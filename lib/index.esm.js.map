{"version":3,"file":"index.esm.js","sources":["../src/core/FocusType.ts","../src/aggregates/ClickHelper.ts","../src/events/Event.ts","../src/events/PointerEvent.ts","../src/events/PointerRelease.ts","../src/events/PointerPress.ts","../src/events/Leave.ts","../src/helpers/measureTextDims.ts","../src/aggregates/TextHelper.ts","../src/aggregates/Variable.ts","../src/core/DefaultTextInputHandler.ts","../src/theme/ThemeProperty.ts","../src/theme/Alignment.ts","../src/theme/Theme.ts","../node_modules/tslib/tslib.es6.js","../src/helpers/roundToPower2.ts","../src/core/Viewport.ts","../src/core/Root.ts","../src/core/DOMRoot.ts","../src/widgets/Widget.ts","../src/widgets/Parent.ts","../src/widgets/SingleParent.ts","../src/widgets/PassthroughWidget.ts","../src/widgets/ArtificialConstraint.ts","../src/widgets/BaseContainer.ts","../src/widgets/Button.ts","../src/widgets/FilledButton.ts","../src/widgets/Container.ts","../src/widgets/TextMargin.ts","../src/widgets/Label.ts","../src/widgets/TextButton.ts","../src/widgets/VirtualKeyboard/GlyphVirtualKey.ts","../src/widgets/MultiParent.ts","../src/widgets/MultiContainer.ts","../src/widgets/Row.ts","../src/widgets/VirtualKeyboard/VirtualKeyRow.ts","../src/widgets/VirtualKeyboard/VirtualKey.ts","../src/widgets/VirtualKeyboard/BasicVirtualKey.ts","../src/widgets/VirtualKeyboard/BackspaceKey.ts","../src/widgets/VirtualKeyboard/EscapeKey.ts","../src/widgets/VirtualKeyboard/EnterKey.ts","../src/widgets/VirtualKeyboard/ShiftKey.ts","../src/widgets/VirtualKeyboard/SpaceKey.ts","../src/widgets/Column.ts","../src/widgets/VirtualKeyboard/VirtualKeyboard.ts","../src/widgets/Margin.ts","../src/core/DOMVirtualKeyboardRoot.ts","../src/core/VirtualKeyboardRoot.ts","../src/events/KeyEvent.ts","../src/events/KeyRelease.ts","../src/events/KeyPress.ts","../src/drivers/KeyboardDriver.ts","../src/drivers/DOMKeyboardDriver.ts","../src/helpers/getPointerEventNormPos.ts","../src/events/PointerMove.ts","../src/drivers/PointerHint.ts","../src/drivers/PointerDriver.ts","../src/drivers/DOMPointerDriver.ts","../src/drivers/RayPointerDriver.ts","../src/theme/DebugTheme.ts","../src/validators/CompositeValidator.ts","../src/validators/DefaultTextValidator.ts","../src/validators/FloatValidator.ts","../src/validators/IntValidator.ts","../src/validators/RangeValidator.ts","../src/widgets/TextInput.ts","../src/widgets/BasicTextInput.ts","../src/widgets/Center.ts","../src/widgets/Checkbox.ts","../src/widgets/Icon.ts","../src/widgets/IconButton.ts","../src/widgets/Spacing.ts","../src/widgets/LabelledCheckbox.ts","../src/widgets/ViewportWidget.ts","../src/widgets/ScrollableViewportWidget.ts","../src/widgets/Slider.ts","../src/widgets/ThemeScope.ts"],"sourcesContent":["/**\n * The focus type of an {@link Event}. Used to categorise events when focusing\n * {@link Widget | widgets} in {@link Root | roots}.\n *\n * @category Core\n */\nexport enum FocusType {\n    /**\n     * Used by {@link Leave}, {@link PointerMove}, {@link PointerPress} and\n     * {@link PointerRelease}\n     */\n    Pointer = 0,\n    /** Used by {@link KeyPress} and {@link KeyRelease} */\n    Keyboard = 1,\n}\n","import { PointerRelease } from '../events/PointerRelease';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\n/**\n * The current state of a {@link ClickHelper}\n *\n * @category Aggregate\n */\nexport enum ClickState {\n    /** No pointer is hovering over this clickable widget */\n    Released,\n    /** A pointer is hovering over this clickable widget */\n    Hover,\n    /** A pointer's button is being held down over this clickable widget */\n    Hold,\n}\n\n/**\n * An aggregate helper class for widgets that can be clicked.\n *\n * Keeps its current click state as well as its last click state, last pointer\n * position and whether the last click state change resulted in an actual click.\n *\n * @category Aggregate\n */\nexport class ClickHelper {\n    /** Last click state */\n    lastClickState: ClickState = ClickState.Released;\n    /** The current click state */\n    clickState: ClickState = ClickState.Released;\n    /** Did the last click event handle result in a click state change? */\n    clickStateChanged = false;\n    /** Did the last click state change result in a click? */\n    wasClick = false;\n    /**\n     * Last pointer position in normalised coordinates ([0,0] to [1,1]). If\n     * there is no last pointer position, such as after a leave event, this will\n     * be null. If pointer position was outside box, it will be beyond the [0,0]\n     * to [1,1] range.\n     */\n    pointerPos: [number, number] | null = null;\n    /**\n     * Like {@link pointerPos}, but only updated when a hold state begins.\n     *\n     * Useful for implementing draggable widgets.\n     */\n    startingPointerPos: [number, number] | null = null;\n\n    /**\n     * Create a new ClickHelper\n     *\n     * @param widget The Widget aggregating this helper\n     */\n    constructor(private widget: Widget) {}\n\n    /**\n     * Normalise pointer coordinates inside a rectangle\n     *\n     * @param pX Pointer X coordinate, in pixels\n     * @param pY Pointer Y coordinate, in pixels\n     * @param rLeft Rectangle's left coordinate, in pixels\n     * @param rRight Rectangle's right coordinate, in pixels\n     * @param rTop Rectangle's top coordinate, in pixels\n     * @param rBottom Rectangle's bottom coordinate, in pixels\n     * @returns Returns normalised coordinates\n     */\n    getNormalInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): [number, number] {\n        return [(pX - rLeft) / (rRight - rLeft), (pY - rTop) / (rBottom - rTop)];\n    }\n\n    /**\n     * Check if a point, in pixels, is inside a rectangle.\n     *\n     * @param pX Pointer X coordinate, in pixels\n     * @param pY Pointer Y coordinate, in pixels\n     * @param rLeft Rectangle's left coordinate, in pixels\n     * @param rRight Rectangle's right coordinate, in pixels\n     * @param rTop Rectangle's top coordinate, in pixels\n     * @param rBottom Rectangle's bottom coordinate, in pixels\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isPointInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): boolean {\n        return pX >= rLeft && pX < rRight && pY >= rTop && pY < rBottom;\n    }\n\n    /**\n     * Check if a normalised point is inside a rectangle.\n     *\n     * Since the coordinates are normalised, you don't have to define the\n     * coordinates of the rectangle, which may seem counterintuitive.\n     *\n     * @param pX Pointer X coordinate, normalised\n     * @param pY Pointer Y coordinate, normalised\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isNormalInRect(pX: number, pY: number): boolean {\n        return pX >= 0 && pX < 1 && pY >= 0 && pY < 1;\n    }\n\n    /**\n     * Set {@link clickState} and update {@link lastClickState} if current one\n     * differs. Updates {@link wasClick} and {@link clickStateChanged} flags.\n     */\n    private setClickState(clickState: ClickState, inside: boolean): void {\n        if(this.clickState !== clickState) {\n            this.lastClickState = this.clickState;\n            this.clickState = clickState;\n\n            // If last state was a hold and pointer is still inside click\n            // area, this was a click\n            this.wasClick = inside && this.lastClickState === ClickState.Hold;\n            this.clickStateChanged = true;\n        }\n        else\n            this.clickStateChanged = false;\n    }\n\n    /**\n     * Updates the current {@link clickState} given an event, as well as\n     * {@link _foci | focus}, {@link pointerStyle}, {@link wasClick} and\n     * {@link clickStateChanged} flags.\n     *\n     * @param clickArea A 4-tuple containing, respectively, left coordinate, right coordinate, top coordinate and bottom coordinate of clickable area, in pixels\n     */\n    handleClickEvent(event: Event, root: Root, clickArea: [number, number, number, number]): void {\n        if(event instanceof Leave) {\n            // Drop focus on this widget if this is a leave event\n            root.dropFocus(FocusType.Pointer, this.widget);\n            this.pointerPos = null;\n            return this.setClickState(ClickState.Released, false);\n        }\n        else if(event instanceof PointerEvent) {\n            // Ignore non-pointer events\n\n            // Normalise pointer coordinates in click area\n            this.pointerPos = this.getNormalInRect(event.x, event.y, ...clickArea);\n\n            // If pointer is over the clickable rectangle, then change the\n            // pointer style, else, if not targetted, drop focus\n            const inside = this.isNormalInRect(...this.pointerPos);\n            if(inside)\n                root.pointerStyle = 'pointer';\n            else if(event.target === null) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Released, false);\n            }\n\n            // If this is a press event, request focus and set starting\n            // pointer coordinates\n            if(event instanceof PointerPress) {\n                this.startingPointerPos = this.pointerPos;\n                root.requestFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Hold, inside);\n            }\n\n            // If this is a release event, drop focus\n            if(event instanceof PointerRelease) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                if(inside)\n                    return this.setClickState(ClickState.Hover, inside);\n                else\n                    return this.setClickState(ClickState.Released, inside);\n            }\n\n            // If event was focused, then it's a hold, else, it's a hover\n            if(event.target === null)\n                return this.setClickState(ClickState.Hover, inside);\n            else\n                return this.setClickState(ClickState.Hold, inside);\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}","import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * A generic event. This is an abstract class and must be implemented in child\n * classes.\n *\n * @category Event\n */\nexport abstract class Event {\n    /** The target of this event. Can be null */\n    readonly target: Widget | null;\n    /**\n     * The focus type of this event. Can be null.\n     *\n     * If null, this event cannot be focused, since events are focused by their\n     * {@link FocusType} as a group.\n     */\n    readonly focusType: FocusType | null;\n    /** Can this event be dispatched without a target? */\n    readonly needsFocus: boolean;\n\n    /**\n     * Create a new Event. Sets {@link target}, {@link focusType} and\n     * {@link needsFocus}\n     */\n    constructor(target: Widget | null, focusType: FocusType | null, needsFocus: boolean) {\n        this.target = target;\n        this.focusType = focusType;\n        this.needsFocus = needsFocus;\n    }\n\n    /**\n     * Create a new Event with the same properties as this, except with a new\n     * given target.\n     */\n    abstract cloneWithTarget(target: Widget | null): Event;\n}","import type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport { Event } from './Event';\n\n/**\n * A pointer {@link Event}. This is an abstract class and is implemented in the\n * child classes {@link PointerMove}, {@link PointerPress} and\n * {@link PointerRelease}.\n *\n * Has a focus type of decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerEvent extends Event {\n    /** Pointer event position's X coordinate in pixels. Not an integer. */\n    readonly x: number;\n    /** Pointer event position's Y coordinate in pixels. Not an integer. */\n    readonly y: number;\n\n    /**\n     * Create a new PointerEvent. Sets {@link x}, {@link y}, {@link target},\n     * {@link focusType} and {@link needsFocus} to false.\n     */\n    constructor(x: number, y: number, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(target, focusType, false);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Create a new PointerEvent event with the same properties as this, except\n     * with new {@link x} and {@link y} values corrected for a given offset.\n     */\n    abstract correctOffset(xOffset: number, yOffset: number): PointerEvent;\n}\n","import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer release {@link PointerEvent} (pointer button up).\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerRelease extends PointerEvent {\n    /**\n     * Create a new PointerRelease. Sets {@link x}, {@link y}, {@link target},\n     * {@link focusType} to {@link FocusType.Pointer} and {@link needsFocus} to\n     * false.\n     */\n    constructor(x: number, y: number, target: Widget | null = null) {\n        super(x, y, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerRelease {\n        return new PointerRelease(this.x - xOffset, this.y - yOffset, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerRelease {\n        return new PointerRelease(this.x, this.y, target);\n    }\n}\n","import { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer press {@link PointerEvent} (pointer button down).\n *\n * Has no focus type and does not need focus.\n *\n * @category Event\n */\nexport class PointerPress extends PointerEvent {\n    /**\n     * Create a new PointerMove. Sets {@link x}, {@link y}, {@link target},\n     * {@link focusType} to null and {@link needsFocus} to false.\n     */\n    constructor(x: number, y: number, target: Widget | null = null) {\n        super(x, y, target);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerPress {\n        return new PointerPress(this.x - xOffset, this.y - yOffset, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerPress {\n        return new PointerPress(this.x, this.y, target);\n    }\n}\n\n","import { FocusType} from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * A leave {@link Event}. Dispatched when the pointer leaves the root or the\n * focus capturer changes to another widget.\n *\n * Has a focus type of {@link FocusType.Pointer} and needs focus.\n *\n * @category Event\n */\nexport class Leave extends Event {\n    /**\n     * Create a new KeyEvent. Sets {@link target}, {@link focusType} to\n     * {@link FocusType.Pointer} and {@link needsFocus} to true.\n     */\n    constructor(target: Widget | null = null) {\n        super(target, FocusType.Pointer, true);\n    }\n\n    cloneWithTarget(target: Widget | null): Leave {\n        return new Leave(target);\n    }\n}\n","let measureContext: CanvasRenderingContext2D | null = null;\nconst measurePadding = new Map();\nconst CIRCUMFIX_CHAR = '-';\n\n/**\n * Measures the dimensions of a given string of text with a given font.\n *\n * Note that the first time calling this function is slower than subsequent\n * calls because a dedicated canvas context must be created.\n *\n * @returns Returns a tuple containing, in this order, the width of the text, the text's ascent length and the text's descent length. The actual height can be found by summing the ascent and descent.\n *\n * @category Helper\n */\nexport function measureTextDims(text: string, font: string): [number, number, number] {\n    // Special case for empty strings. measureText likes to give out some bogus\n    // values on empty strings, which doesn't make much sense\n    if(text === '')\n        return [0, 0, 0];\n\n    // Like ctx.measureText(), but it manages a shared canvas for you and gives\n    // you the correct bounding box\n    if(measureContext === null) {\n        const tempCanvas = document.createElement('canvas');\n        measureContext = tempCanvas.getContext('2d');\n        if(measureContext === null)\n            throw 'Failed to get canvas context';\n    }\n\n    measureContext.font = font;\n\n    // Get circumfix length in pixels with current font\n    let suffixLength;\n    if(measurePadding.has(font))\n        suffixLength = measurePadding.get(font);\n    else {\n        // Circumfix length not cached yet, measure it\n        const suffixDims = measureContext.measureText(CIRCUMFIX_CHAR);\n        suffixLength = Math.abs(suffixDims.actualBoundingBoxLeft) + Math.abs(suffixDims.actualBoundingBoxRight);\n        measurePadding.set(font, suffixLength);\n    }\n\n    // TODO cache a limited amount of text measurements\n\n    // Measure text dimensions with a circumfix character so that whitespaces\n    // are measurable, correcting for circumfix character's length\n    const dims = measureContext.measureText(CIRCUMFIX_CHAR + text + CIRCUMFIX_CHAR);\n    return [\n        Math.abs(dims.actualBoundingBoxLeft) + Math.abs(dims.actualBoundingBoxRight) - suffixLength * 2,\n        Math.abs(dims.actualBoundingBoxAscent),\n        Math.abs(dims.actualBoundingBoxDescent),\n    ];\n}\n","import { measureTextDims } from '../helpers/measureTextDims';\n\n/**\n * An aggregate helper class for widgets that contain text.\n *\n * Contains utilities for measuring text dimensions and converting between\n * offsets in pixels and text indices.\n *\n * @category Aggregate\n */\nexport class TextHelper {\n    /** The current string of text */\n    private _text = '';\n    /** The current font used for rendering text */\n    private _font = '';\n    /** The current minimum text width */\n    private _minWidth = 0;\n    /** The current minimum text ascent height */\n    private _minAscent = 0;\n    /** The current minimum text descent height */\n    private _minDescent = 0;\n\n    /**\n     * The current text width corrected for minimum width. May be outdated.\n     */\n    private _width = 0;\n    /**\n     * The current text ascent height corrected for minimum ascent height. May\n     * be outdated.\n     */\n    private _ascent = 0;\n    /**\n     * The current text descent height corrected for minimum descent height.\n     * May be outdated.\n     */\n    private _descent = 0;\n\n    /** Does the text need to be re-measured? */\n    private measureDirty = true;\n    /** Has the text (or properties associated with it) changed? */\n    private _dirty = false;\n\n    /**\n     * Has the text (or properties associated with it) changed? Resets\n     * {@link _dirty} to false\n     */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Update {@link _width}, {@link _ascent} and {@link _descent}. Sets\n     * {@link measureDirty} to false. Does nothing if measurement is not needed.\n     */\n    private updateTextDims(): void {\n        // Abort if measurement not needed\n        if(!this.measureDirty)\n            return;\n\n        // Measure text dimensions\n        const [ width, ascent, descent ] = measureTextDims(this._text, this._font);\n\n        this._width = Math.max(width, this._minWidth);\n        this._ascent = Math.max(ascent, this._minAscent);\n        this._descent = Math.max(descent, this._minDescent);\n\n        // Mark as clean\n        this.measureDirty = false;\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the beginning of a character at\n     * a given index.\n     *\n     * See {@link findIndexOffsetFromOffset} for the opposite.\n     *\n     * @returns Returns the horizontal offset, in pixels. Note that this is not neccessarily an integer.\n     */\n    findOffsetFromIndex(index: number): number {\n        // If index is 0 or an invalid negative number, it is at the beginning\n        if(index <= 0)\n            return 0;\n\n        // Cut text up to given index and measure its length, this length is the\n        // offset at the given index\n        return measureTextDims(this._text.substring(0, index), this._font)[0];\n    }\n\n    /**\n     * Get the index and horizontal offset, in pixels, of the beginning of a\n     * character at a given offset.\n     *\n     * See {@link findOffsetFromIndex} for the opposite.\n     *\n     * @returns Returns a tuple containing the index of the character at the offset and the horizontal offset, in pixels. Note that this is not neccessarily an integer. Note that the returned offset is not the same as the input offset. The returned offset is exactly at the beginning of the character. This is useful for implementing selectable text.\n     */\n    findIndexOffsetFromOffset(offset: number): [number, number] {\n        // If offset is before first character, default to index 0\n        if(offset <= 0)\n            return [0, 0];\n\n        // TODO This has linear complexity, use a binary search instead\n        // For each character, find index at which offset is smaller than\n        // total length minus half length of current character\n        let index = 0, buffer = '', lastLength = 0;\n        for(const char of this._text) {\n            // Add next character to buffer\n            buffer += char;\n\n            // Measure text buffer length and critical offset, which is text\n            // buffer's length minus length of half character, equivalent to\n            // average between last length and current length\n            const bufferLength = measureTextDims(buffer, this._font)[0];\n            // bl - (bl - ll) / 2 = bl - bl / 2 + ll / 2 = (bl + ll) / 2\n            const criticalOffset = (bufferLength + lastLength) / 2;\n\n            // If offset is before critical offset, this is the index we're\n            // looking for\n            if(offset < criticalOffset)\n                return [index, lastLength];\n\n            // Update index and last length\n            index++;\n            lastLength = bufferLength;\n        }\n\n        // Offset is after full length of text, return index after end\n        return [this._text.length, lastLength];\n    }\n\n    /** Sets {@link _dirty} and {@link measureDirty} to true. */\n    private setDirty(): void {\n        this._dirty = true;\n        this.measureDirty = true;\n    }\n\n    /** The current text width. Re-measures text if neccessary. */\n    get width(): number {\n        this.updateTextDims();\n        return this._width;\n    }\n\n    /** The current text ascent height. Re-measures text if neccessary. */\n    get ascent(): number {\n        this.updateTextDims();\n        return this._ascent;\n    }\n\n    /** The current text descent height. Re-measures text if neccessary. */\n    get descent(): number {\n        this.updateTextDims();\n        return this._descent;\n    }\n\n    /**\n     * The current text height. Re-measures text if neccessary. Equivalent to\n     * adding up {@link ascent} and {@link descent}.\n     */\n    get height(): number {\n        this.updateTextDims();\n        return this._ascent + this._descent;\n    }\n\n    /**\n     * The current string of text.\n     *\n     * Sets {@link _text} and calls {@link setDirty} if changed.\n     */\n    set text(text: string) {\n        if(this._text !== text) {\n            this._text = text;\n            this.setDirty();\n        }\n    }\n\n    get text(): string {\n        return this._text;\n    }\n\n    /**\n     * The current font used for rendering text.\n     *\n     * Sets {@link _font} and calls {@link setDirty} if changed.\n     */\n    set font(font: string) {\n        if(this._font !== font) {\n            this._font = font;\n            this.setDirty();\n        }\n    }\n\n    get font(): string {\n        return this._font;\n    }\n\n    /**\n     * The current minimum text width.\n     *\n     * Sets {@link _minWidth} and calls {@link setDirty} if changed.\n     */\n    set minWidth(minWidth: number) {\n        if(this._minWidth !== minWidth) {\n            this._minWidth = minWidth;\n            this.setDirty();\n        }\n    }\n\n    get minWidth(): number {\n        return this._minWidth;\n    }\n\n    /**\n     * The current minimum text ascent height.\n     *\n     * Sets {@link _minAscent} and calls {@link setDirty} if changed.\n     */\n    set minAscent(minAscent: number) {\n        if(this._minAscent !== minAscent) {\n            this._minAscent = minAscent;\n            this.setDirty();\n        }\n    }\n\n    get minAscent(): number {\n        return this._minAscent;\n    }\n\n    /**\n     * The current minimum text descent height.\n     *\n     * Sets {@link _minDescent} and calls {@link setDirty} if changed.\n     */\n    set minDescent(minDescent: number) {\n        if(this._minDescent !== minDescent) {\n            this._minDescent = minDescent;\n            this.setDirty();\n        }\n    }\n\n    get minDescent(): number {\n        return this._minDescent;\n    }\n}\n","/**\n * A callback for when the value of a {@link Variable} changes.\n *\n * @category Aggregate\n */\nexport type VariableCallback<V> = (value: V) => void;\n\n/**\n * An aggregate helper class for widgets that contain a variable with a\n * specified type which is intended to be controlled by the user.\n *\n * Useful for implementing widgets such as sliders, checkboxes, text input,\n * etc...\n *\n * @template V The type of {@link value}.\n *\n * @category Aggregate\n */\nexport class Variable<V> {\n    /** The current value, for internal use. */\n    private _value: V;\n    /** Has the value changed? */\n    private _dirty = false;\n\n    /**\n     * Create a new Variable.\n     *\n     * @param initialValue The initial value of this variable. Sets {@link _value}.\n     * @param callback The callback for when the value is changed.\n     */\n    constructor(initialValue: V, private callback: VariableCallback<V> | null = null) {\n        this._value = initialValue;\n    }\n\n    /**\n     * The current value.\n     *\n     * If setting, {@link setValue} is called.\n     */\n    get value(): V {\n        return this._value;\n    }\n\n    set value(value: V) {\n        this.setValue(value);\n    }\n\n    /** Has the value changed? Resets {@link _dirty} to false */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Sets {@link _value}. Does nothing if the value is already the one\n     * specified.\n     *\n     * {@link _dirty} is set to true if the value has changed.\n     *\n     * @param doCallback If true, then {@link callback} is called if the value has changed.\n     */\n    setValue(value: V, doCallback = true): void {\n        if(this._value === value)\n            return;\n\n        this._value = value;\n        this._dirty = true;\n        if(doCallback && this.callback !== null) {\n            try {\n                this.callback(value);\n            }\n            catch(e) {\n                console.error('Exception in Variable callback', e);\n            }\n        }\n    }\n}\n","/**\n * The default implementation of {@link TextInputHandler}.\n *\n * Creates a new popup div with a CSS ID of 'textInputHandler' and an overlay\n * div with CSS ID 'textInputHandlerOverlay', adding both to the HTML body.\n * Resolves the promise once user input is finished by clicking the OK or Cancel\n * buttons.\n *\n * @category Core\n */\nexport function DefaultTextInputHandler(initialInput: string): Promise<string> {\n    return new Promise((accept, _reject) => {\n        function closePopup() {\n            // Close text input popup\n            document.body.removeChild(containerElem);\n            document.body.removeChild(overlayElem);\n        }\n\n        function cancelHandler() {\n            // Click cancel; close popup and accept with initial input string\n            closePopup();\n            accept(initialInput);\n        }\n\n        function okHandler() {\n            // Click OK; close popup and accept with new input string\n            closePopup();\n            accept(inElem.value);\n        }\n\n        function enterChecker(event: KeyboardEvent) {\n            // Check if enter key was pressed\n            if(event.key == 'Enter') {\n                event.preventDefault();\n                okHandler();\n            }\n        }\n\n        // Create overlay\n        const overlayElem = document.createElement('div');\n        overlayElem.id = 'textInputHandlerOverlay';\n\n        // Create container\n        const containerElem = document.createElement('div');\n        containerElem.id = 'textInputHandler';\n\n        // Create text element\n        const textElem = document.createElement('p');\n        textElem.textContent = 'Change text:';\n\n        // Create input element\n        const inElem = document.createElement('input');\n        inElem.addEventListener('keyup', enterChecker);\n        inElem.value = initialInput;\n\n        // Create button row element\n        const buttonRowElem = document.createElement('div');\n\n        // Create cancel button element\n        const cancelButtonElem = document.createElement('button');\n        cancelButtonElem.addEventListener('click', cancelHandler);\n        cancelButtonElem.textContent = 'Cancel';\n\n        // Create OK button element\n        const okButtonElem = document.createElement('button');\n        okButtonElem.addEventListener('click', okHandler);\n        okButtonElem.textContent = 'OK';\n\n        // Add to row\n        buttonRowElem.appendChild(cancelButtonElem);\n        buttonRowElem.appendChild(okButtonElem);\n\n        // Add to container\n        containerElem.appendChild(textElem);\n        containerElem.appendChild(inElem);\n        containerElem.appendChild(buttonRowElem);\n\n        // Add overlay and container to body\n        document.body.appendChild(overlayElem);\n        document.body.appendChild(containerElem);\n\n        // Focus input\n        inElem.focus({ preventScroll: false });\n    });\n}\n","/**\n * A type of property in a {@link Theme}. Used as keys.\n *\n * @category Theme\n */\nexport enum ThemeProperty {\n    /**\n     * The canvas background\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}.\n     */\n    CanvasFill,\n    /** The {@link Padding} used in {@link Container}. */\n    ContainerPadding,\n    /** The spacing length between widgets in {@link MultiContainer}. */\n    ContainerSpacing,\n    /** The alignment in {@link Container} for when there is extra space. */\n    ContainerAlignment,\n    /**\n     * The primary\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}.\n     * Usually a saturated colour used for filling boxes that need to stand out.\n     */\n    PrimaryFill,\n    /**\n     * The accent\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}.\n     * Usually a saturated colour more saturated than {@link PrimaryFill} used\n     * for highlighting boxes which use PrimaryFill.\n     */\n    AccentFill,\n    /**\n     * The background\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}.\n     * Used for widgets with a background (as in, a background above the canvas\n     * background).\n     */\n    BackgroundFill,\n    /**\n     * The background glow\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}.\n     * Used for highlighting boxes which use {@link BackgroundFill}.\n     */\n    BackgroundGlowFill,\n    /** The minimum length of a {@link Slider} */\n    SliderMinLength,\n    /** The thickness of a {@link Slider} */\n    SliderThickness,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font | font style}\n     * used for body text (most regular text).\n     */\n    BodyTextFont,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}\n     * used for body text (most regular text).\n     */\n    BodyTextFill,\n    /**\n     * The {@link TextHelper._minLabelWidth | minimum width} used for\n     * {@link Label}.\n     */\n    LabelMinWidth,\n    /**\n     * The {@link TextHelper._minLabelAscent | minimum ascent height} used for\n     * {@link Label}.\n     */\n    LabelMinAscent,\n    /**\n     * The {@link TextHelper._minLabelDescent | minimum descent height} used for\n     * {@link Label}.\n     */\n    LabelMinDescent,\n    /** The length in pixels used for {@link Checkbox}. */\n    CheckboxLength,\n    /**\n     * The {@link Padding} used for {@link Checkbox} between the accent box\n     * shown when ticked and the background box.\n     */\n    CheckboxInnerPadding,\n    /**\n     * The background\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}\n     * used for input widgets like {@link TextInput}.\n     */\n    InputBackgroundFill,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font | font style}\n     * used for text in input widgets like {@link TextInput}.\n     */\n    InputTextFont,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}\n     * used for text in input widgets like {@link TextInput}.\n     */\n    InputTextFill,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}\n     * used for text in input widgets like {@link TextInput} when disabled.\n     */\n    InputTextFillDisabled,\n    /**\n     * The\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle | fill style}\n     * used for text in input widgets like {@link TextInput} when invalid.\n     */\n    InputTextFillInvalid,\n    /**\n     * The {@link TextHelper._minLabelWidth | minimum width} used for text input\n     * widgets like {@link TextInput}.\n     */\n    InputTextMinWidth,\n    /**\n     * The {@link TextHelper._minLabelAscent | minimum ascent height} used for\n     * text input widgets like {@link TextInput}.\n     */\n    InputTextMinAscent,\n    /**\n     * The {@link TextHelper._minLabelDescent | minimum descent height} used for\n     * text input widgets like {@link TextInput}.\n     */\n    InputTextMinDescent,\n    /**\n     * The {@link Padding} between text and border used for text input widgets\n     * like {@link TextInput}.\n     */\n    InputTextInnerPadding,\n    /**\n     * The blink rate of text cursors in text input widgets like\n     * {@link TextInput}. Value in \"blinks\" per second.\n     */\n    BlinkRate,\n    /** The thickness of a text cursor in pixels. */\n    CursorThickness,\n    /** The thickness of a {@link ScrollBar} in pixels. */\n    ScrollBarThickness,\n}\n","/**\n * Alignment of container contents. Used for when {@link Container} has too much\n * space.\n *\n * @category Theme\n */\nexport enum Alignment {\n    /** Give the extra space to the child, potentially stretching it. */\n    Stretch,\n    /**\n     * Align the child to the start of the container, having the extra space at\n     * the end.\n     */\n    Start,\n    /**\n     * Align the child to the center of the container, having the extra space\n     * split equally to both the start and the end.\n     */\n    Center,\n    /**\n     * Align the child to the end of the container, having the extra space at\n     * the start.\n     */\n    End,\n}\n","import type { Alignment2D } from './Alignment2D';\nimport { ThemeProperty } from './ThemeProperty';\nimport type { Padding } from './Padding';\nimport { Alignment } from './Alignment';\n\n// The default theme's properties. This will be cloned and, therefore, can't be\n// modified\nconst defaultThemeProperties = new Map<ThemeProperty, unknown>([\n    [ThemeProperty.CanvasFill, 'rgba(0,0,0,0.5)'], // 50% opaque black\n    [ThemeProperty.ContainerPadding, <Padding>{\n        left: 4,\n        right: 4,\n        top: 4,\n        bottom: 4,\n    }],\n    [ThemeProperty.ContainerAlignment, <Alignment2D>{\n        horizontal: Alignment.Start, vertical: Alignment.Start\n    }],\n    [ThemeProperty.ContainerSpacing, 4],\n    [ThemeProperty.PrimaryFill, 'rgb(0,127,255)'], // Azure blue\n    [ThemeProperty.AccentFill, 'rgb(0,195,255)'], // Greener azure blue\n    [ThemeProperty.BackgroundFill, 'rgb(32,32,32)'], // Dark grey\n    [ThemeProperty.BackgroundGlowFill, 'rgb(48,48,48)'], // Lighter dark grey\n    [ThemeProperty.SliderMinLength, 100],\n    [ThemeProperty.SliderThickness, 10],\n    [ThemeProperty.BodyTextFont, '16px sans'],\n    [ThemeProperty.BodyTextFill, 'white'],\n    [ThemeProperty.LabelMinWidth, 0],\n    [ThemeProperty.LabelMinAscent, 0],\n    [ThemeProperty.LabelMinDescent, 3],\n    [ThemeProperty.CheckboxLength, 12],\n    [ThemeProperty.CheckboxInnerPadding, 2],\n    [ThemeProperty.InputBackgroundFill, 'white'],\n    [ThemeProperty.InputTextFont, '16px mono'],\n    [ThemeProperty.InputTextFill, 'black'],\n    [ThemeProperty.InputTextFillDisabled, 'grey'],\n    [ThemeProperty.InputTextFillInvalid, 'red'],\n    [ThemeProperty.InputTextMinWidth, 100],\n    [ThemeProperty.InputTextMinAscent, 16],\n    [ThemeProperty.InputTextMinDescent, 3],\n    [ThemeProperty.InputTextInnerPadding, 2],\n    [ThemeProperty.BlinkRate, 0.8],\n    [ThemeProperty.CursorThickness, 1],\n    [ThemeProperty.ScrollBarThickness, 10],\n]);\n\n/**\n * A theme. Provides styling for widgets.\n *\n * @category Theme\n */\nexport class Theme {\n    /** The values associated to each {@link ThemeProperty} for this theme. */\n    properties: Map<ThemeProperty, unknown>;\n    /**\n     * The fallback theme. If this theme has a missing property, the fallback\n     * theme's property will be used instead\n     */\n    fallback: Theme | null;\n\n    /**\n     * Creates a new Theme.\n     *\n     * Sets {@link properties} and {@link fallback}.\n     *\n     * @param properties This theme's {@link ThemeProperty} values. If null, the default theme properties are used, which consist of mostly semi-transparent black backgrounds and azure blue accents, inspired by material design colours.\n     */\n    constructor(properties: Map<ThemeProperty, unknown> | null = null, fallback: Theme | null = null) {\n        if(properties === null)\n            this.properties = new Map(defaultThemeProperties);\n        else\n            this.properties = properties;\n\n        this.fallback = fallback;\n    }\n\n    /**\n     * Get the value associated with a given {@link ThemeProperty}.\n     *\n     * If the value is missing, the {@link fallback} is tried. If there is no\n     * fallback, an exception is thrown.\n     *\n     * @returns Returns the value associated with the theme property. This could be any type.\n     */\n    private getProperty(themeProperty: ThemeProperty): unknown {\n        // Get property's value\n        let value = this.properties.get(themeProperty);\n\n        // If property is missing, get property from fallback theme\n        if(value === undefined) {\n            if(this.fallback === null)\n                throw new Error(`Theme property ${themeProperty} is not available`);\n\n            value = this.fallback.getProperty(themeProperty);\n        }\n\n        return value;\n    }\n\n    /**\n     * Same as {@link getProperty}, but with type checking for string.\n     * For internal use only.\n     */\n    private getString(themeProperty: ThemeProperty): string {\n        const value = this.getProperty(themeProperty);\n\n        if(typeof value !== 'string')\n            throw new Error(`Theme property ${themeProperty} is not a string`);\n\n        return value;\n    }\n\n    /** Same as {@link getProperty}, but with type checking for number. */\n    getNumber(themeProperty: ThemeProperty): number {\n        const value = this.getProperty(themeProperty);\n\n        if(typeof value !== 'number')\n            throw new Error(`Theme property ${themeProperty} is not a number`);\n\n        return value;\n    }\n\n    /** Same as {@link getProperty}, but casts value to {@link Padding}. */\n    getPadding(themeProperty: ThemeProperty): Padding {\n        // TODO proper type safety\n        return this.getProperty(themeProperty) as Padding;\n    }\n\n    /** Same as {@link getProperty}, but casts value to {@link Alignment}. */\n    getAlignment(themeProperty: ThemeProperty): Alignment {\n        // TODO proper type safety\n        return this.getProperty(themeProperty) as Alignment;\n    }\n\n    /** Same as {@link getProperty}, but casts value to {@link Alignment2D}. */\n    getAlignment2D(themeProperty: ThemeProperty): Alignment2D {\n        // TODO proper type safety\n        return this.getProperty(themeProperty) as Alignment2D;\n    }\n\n    /** Equivalent to {@link getString} */\n    getFill(themeProperty: ThemeProperty): string {\n        // TODO allow gradients, etc... fill styles are not always strings\n        return this.getString(themeProperty);\n    }\n\n    /** Equivalent to {@link getString} */\n    getFont(themeProperty: ThemeProperty): string {\n        return this.getString(themeProperty);\n    }\n}","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","/**\n * Rounds a given number up or down to a power of 2. Useful for working with\n * textures.\n *\n * @param number The number to round\n * @param roundUp If true, rounds the number to the smallest power of 2 greater\n * or equal to the input, else, rounds the number to the greatest power of 2\n * smaller or equal to the input.\n *\n * @returns Returns the rounded number\n *\n * @category Helper\n */\nexport function roundToPower2(number: number, roundUp = true): number {\n    const roundFun = roundUp ? Math.ceil : Math.floor;\n    return Math.pow(2, roundFun(Math.log2(number)));\n}","import { roundToPower2 } from '../helpers/roundToPower2';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * Viewports are internally used to manage a canvas' size and painting. It is\n * used by {@link Root} and {@link ViewportWidget}.\n *\n * @category Core\n */\nexport class Viewport {\n    /**\n     * Constraints of viewport. For internal use only.\n     *\n     * By default, has no minimum width nor height and unconstrained maximum\n     * width and height.\n     *\n     * See {@link constraints}.\n     */\n    private _constraints: [number, number, number, number] = [0, Infinity, 0, Infinity];\n    /** Have the constraints been changed? */\n    private dirty = true;\n\n    /** The internal canvas. Widgets are painted to this */\n    readonly canvas: HTMLCanvasElement;\n    /** The internal canvas' context. Alpha is enabled. */\n    readonly context: CanvasRenderingContext2D;\n\n    /**\n     * Create a new Viewport.\n     *\n     * Creates a new canvas with a starting width and height, setting\n     * {@link canvas} and {@link context}. Failure to get a canvas context\n     * results in an exception.\n     */\n    constructor(startingWidth = 64, startingHeight = 64) {\n        // Create internal canvas\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = startingWidth;\n        this.canvas.height = startingHeight;\n\n        // Get context out of canvas\n        const context = this.canvas.getContext('2d', { alpha: true });\n        if(context === null)\n            throw 'Failed to get canvas context';\n\n        this.context = context;\n    }\n\n    /** The current dimensions of the {@link canvas | internal canvas} */\n    get canvasDimensions(): [number, number] {\n        return [this.canvas.width, this.canvas.height];\n    }\n\n    /**\n     * Layout constraints of viewport when resolving widget's layout. A 4-tuple\n     * containing, respectively, minimum width, maximum width, minimum height\n     * and maximum height.\n     *\n     * See {@link _constraints}.\n     */\n    set constraints(constraints: [number, number, number, number]) {\n        if(this._constraints[0] !== constraints[0] ||\n           this._constraints[1] !== constraints[1] ||\n           this._constraints[2] !== constraints[2] ||\n           this._constraints[3] !== constraints[3]) {\n            this._constraints[0] = constraints[0];\n            this._constraints[1] = constraints[1];\n            this._constraints[2] = constraints[2];\n            this._constraints[3] = constraints[3];\n            this.dirty = true;\n        }\n    }\n\n    get constraints(): [number, number, number, number] {\n        return [...this._constraints];\n    }\n\n    /**\n     * Resolves the given child's layout by calling {@link Widget.resolveLayout}\n     * with the current {@link constraints}.\n     *\n     * If the child's layout is not dirty, then resolveLayout is not called.\n     *\n     * Expands {@link canvas} if the new layout is too big for the current\n     * canvas. Expansion is done in powers of 2 to avoid issues with external 3D\n     * libraries.\n     *\n     * @returns Returns true if the child was resized, else, false.\n     */\n    resolveChildsLayout(child: Widget): boolean {\n        if(!child.layoutDirty && !this.dirty)\n            return false;\n\n        // Remove constraints' dirty flag\n        this.dirty = false;\n\n        // Resolve child's layout\n        const [oldWidth, oldHeight] = child.dimensions;\n\n        child.resolveLayout(...this.constraints);\n\n        const [newWidth, newHeight] = child.dimensions;\n\n        if(newWidth !== oldWidth || newHeight !== oldHeight) {\n            // Re-scale canvas if neccessary.\n            // Canvas dimensions are rounded to the nearest power of 2, favoring\n            // bigger powers. This is to avoid issues with mipmapping, which\n            // requires texture sizes to be powers of 2.\n            const potentialCWidth = roundToPower2(newWidth);\n            if(potentialCWidth > this.canvas.width)\n                this.canvas.width = potentialCWidth;\n\n            const potentialCHeight = roundToPower2(newHeight);\n            if(potentialCHeight > this.canvas.height)\n                this.canvas.height = potentialCHeight;\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Paint a given child to {@link canvas}.\n     *\n     * Nothing is done if the child was not dirty.\n     *\n     * @returns Returns true if the child was dirty, else, false.\n     */\n    paintToCanvas(child: Widget): boolean {\n        // Paint child\n        const wasDirty = child.dirty;\n        if(wasDirty)\n            child.paint(0, 0, this.context);\n\n        return wasDirty;\n    }\n}","import type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { TextInputHandler } from './TextInputHandler';\nimport type { Widget } from '../widgets/Widget';\nimport type { Event } from '../events/Event';\nimport { FocusType } from './FocusType';\nimport { Leave } from '../events/Leave';\nimport type { Driver } from './Driver';\nimport { Theme } from '../theme/Theme';\nimport { Viewport } from './Viewport';\n\n/**\n * A Root is the parent of all widgets, but not a widget itself. It contains a\n * single child and manages dimensions and input handling\n *\n * @category Core\n */\nexport class Root {\n    /** The Root's child; the parent Widget of all widgets in this Root */\n    readonly child: Widget;\n    /** The internal viewport. Manages drawing */\n    protected viewport: Viewport;\n    /** The list of drivers registered to this root */\n    protected drivers: Set<Driver> = new Set();\n    /**\n     * Is the Root enabled? For internal use only.\n     *\n     * See {@link enabled}\n     */\n    protected _enabled = true;\n    /**\n     * The pointer style this root wants. Will be set on\n     * {@link postLayoutUpdate} by {@link pointerStyleHandler}\n     */\n    pointerStyle = 'default';\n    /**\n     * The actual current pointer style.\n     *\n     * For internal use only.\n     *\n     * See {@link pointerStyle}\n     */\n    protected _currentPointerStyle = 'default';\n    /**\n     * Pointer style handler, decides how to show the given pointer style.\n     * Normally a function which sets the CSS cursor style of the Root's canvas\n     */\n    pointerStyleHandler: PointerStyleHandler | null;\n    /**\n     * Current component foci (event targets for each focus type).\n     *\n     * For internal use only.\n     *\n     * See {@link requestFocus}, {@link dropFocus}, {@link clearFocus} and\n     * {@link getFocus}\n     */\n    protected _foci: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n    ]);\n    /**\n     * Last capturer of each component focus (event targets for each focus\n     * type).\n     *\n     * For internal use only.\n     *\n     * See {@link getFocusCapturer}\n     */\n    protected _fociCapturers: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n    ]);\n    /**\n     * Handler for mobile-friendly text input. If not null, widgets that need\n     * text may call this to get a string.\n     *\n     * See {@link hasMobileTextInput}, {@link usingMobileTextInput} and\n     * {@link getTextInput}\n     */\n    textInputHandler: TextInputHandler | null = null;\n    /**\n     * Is the mobile-friendly text input in use?\n     *\n     * For internal use only.\n     *\n     * See {@link hasMobileTextInput}, {@link usingMobileTextInput} and\n     * {@link getTextInput}\n     */\n    protected _mobileTextInUse = false;\n\n    /**\n     * Creates a new Root.\n     *\n     * Sets {@link child}, {@link pointerStyleHandler} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(child: Widget, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        this.viewport = new Viewport();\n        this.child = child;\n        this.pointerStyleHandler = pointerStyleHandler;\n        this.child.inheritedTheme = theme;\n    }\n\n    /** The {@link viewport}'s {@link Viewport.constraints | constraints} */\n    get constraints(): [number, number, number, number] {\n        return this.viewport.constraints;\n    }\n\n    set constraints(constraints: [number, number, number, number]) {\n        this.viewport.constraints = constraints;\n    }\n\n    /**\n     * The {@link viewport}'s\n     * {@link Viewport.canvasDimensions | canvasDimensions}\n     */\n    get canvasDimensions(): [number, number] {\n        return this.viewport.canvasDimensions;\n    }\n\n    /**\n     * The {@link child}'s {@link Widget.dimensions | dimensions}\n     */\n    get dimensions(): [number, number] {\n        return this.child.dimensions;\n    }\n\n    /**\n     * Is this root enabled? If not enabled, painting, updating or resolving\n     * layout will do nothing. {@link drivers | Drivers} will also be notified\n     * by calling {@link Driver.onEnable} or {@link Driver.onDisable}, pointer\n     * style will be reset ({@link updatePointerStyle} called with 'default')\n     * and all {@link _foci | foci} will be cleared ({@link clearFocus}).\n     *\n     * See {@link _enabled}\n     */\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    set enabled(newEnabled: boolean) {\n        const oldEnabled = this._enabled;\n\n        if(oldEnabled !== newEnabled) {\n            this._enabled = newEnabled;\n\n            // Call driver hooks, reset pointer style and release foci if UI\n            // disabled\n            if(newEnabled) {\n                for(const driver of this.drivers)\n                    driver.onEnable(this);\n            }\n            else {\n                for(const driver of this.drivers)\n                    driver.onDisable(this);\n\n                this.updatePointerStyle('default');\n\n                for(const focus of this._foci.keys())\n                    this.clearFocus(focus);\n            }\n        }\n    }\n\n\n    /**\n     * The {@link viewport}'s {@link Viewport.canvas | canvas}\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.viewport.canvas;\n    }\n\n    /**\n     * Resolve the layout of this root. Does nothing if root is disabled.\n     *\n     * Calls {@link viewport}'s {@link Viewport.populateChildsLayout} and\n     * {@link resolveChildsLayout} with {@link child}\n     *\n     * Call this before calling {@link postLayoutUpdate} and after calling\n     * {@link preLayoutUpdate}\n     */\n    resolveLayout(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.resolveChildsLayout(this.child);\n    }\n\n    /**\n     * Paint this root's next frame if needed. Does nothing if root is disabled.\n     *\n     * Calls {@link viewport}'s {@link Viewport.paintToCanvas} with\n     * {@link child}.\n     *\n     * Call this after calling {@link postLayoutUpdate}.\n     *\n     * @returns Returns whether the child was dirty or not. Use this to tell an external 3D library whether to update a mesh's texture or not.\n     */\n    paint(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.paintToCanvas(this.child);\n    }\n\n    /**\n     * Dispatches an {@link Event} to this root's {@link child} by calling\n     * {@link Widget.dispatchEvent}. Updates\n     * {@link _fociCapturers | foci capturers} and notifies {@link drivers} by\n     * calling {@link Driver.onFocusCapturerChanged} if the capturer changes.\n     * Does nothing if root is disabled.\n     *\n     * Note that if an event with a focus is dispatched and no widget captures\n     * the event due to the widget not existing anymore or being disabled, the\n     * focus type of the event will be cleared in the root with\n     * {@link clearFocus}.\n     */\n    dispatchEvent(event: Event): void {\n        // Ignore event if Root is disabled\n        if(!this.enabled)\n            return;\n\n        // If event is focusable and is missing a target...\n        if(event.focusType !== null && event.target === null) {\n            // Ignore event if it needs a focus but there is no component\n            // focused in the needed focus\n            let focus = this._foci.get(event.focusType);\n            if(typeof focus === 'undefined')\n                focus = null;\n\n            if(event.needsFocus && focus === null) {\n                //console.warn('Dropped event due to lack of target', event);\n                return;\n            }\n\n            // Set event target\n            event = event.cloneWithTarget(focus);\n        }\n\n        // Clear pointer style. This will be set by children if neccessary\n        this.pointerStyle = 'default';\n\n        // Pass event down to internal Container\n        const captured = this.child.dispatchEvent(event, this);\n        if(captured === null) {\n            // If the event wasn't captured but it had a focus, clear the focus\n            // NOTE: This is for preventing a component that is no longer\n            // present in the UI from capturing events\n            if(event.focusType !== null) {\n                //console.warn('Focus cleared due to uncaptured focused event', event);\n                this.clearFocus(event.focusType);\n            }\n        }\n        /*else\n            console.info('Event captured by widget:', captured.constructor.name);*/\n\n        // Update focus capturer if it changed\n        if(event.focusType === null)\n            return;\n\n        const oldCapturer = this._fociCapturers.get(event.focusType) ?? null;\n        if(oldCapturer === captured)\n            return;\n\n        // Special case: when the pointer focus capturer changes, dispatch a\n        // leave event to the last capturer\n        if(event.focusType === FocusType.Pointer && oldCapturer !== null)\n            this.child.dispatchEvent(new Leave(oldCapturer), this);\n\n        this._fociCapturers.set(event.focusType, captured);\n        for(const driver of this.drivers)\n            driver.onFocusCapturerChanged(this, event.focusType, oldCapturer, captured);\n    }\n\n    /**\n     * Do a pre-layout update; calls {@link drivers}' {@link Driver.update} and\n     * {@link child}'s {@link Widget.preLayoutUpdate}. Does nothing if root is\n     * disabled.\n     *\n     * Call this before calling {@link resolveLayout}\n     */\n    preLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Update drivers\n        for(const driver of this.drivers)\n            driver.update(this);\n\n        // Pre-layout update child\n        this.child.preLayoutUpdate(this);\n    }\n\n\n    /**\n     * Do a post-layout update; calls {@link child}'s\n     * {@link Widget.postLayoutUpdate} and {@link updatePointerStyle}. Does\n     * nothing if root is disabled.\n     *\n     * Call this before calling {@link paint} and after calling\n     * {@link resolveLayout}\n     */\n    postLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Post-layout update child\n        this.child.postLayoutUpdate(this);\n\n        // Update pointer style\n        this.updatePointerStyle();\n    }\n\n    /**\n     * Calls {@link pointerStyleHandler} if the {@link pointerStyle} has changed\n     * (checked by comparing with {@link _currentPointerStyle}). Also updates\n     * {@link _currentPointerStyle}. Can also be optionally supplied a new\n     * pointer style.\n     */\n    updatePointerStyle(newStyle: string | null = null): void {\n        if(newStyle !== null)\n            this.pointerStyle = newStyle;\n\n        if(this.pointerStyle !== this._currentPointerStyle) {\n            this._currentPointerStyle = this.pointerStyle;\n            if(this.pointerStyleHandler !== null)\n                this.pointerStyleHandler(this._currentPointerStyle);\n        }\n    }\n\n    /**\n     * Sets the current {@link _foci | focus} of a given type to a given widget.\n     * If the focus changes, {@link clearFocus} is called and {@link drivers}\n     * are notified by calling {@link Driver.onFocusChanged}.\n     */\n    requestFocus(focusType: FocusType, widget: Widget): void {\n        if(widget !== null) {\n            // Replace focus if current focus is not the desired one\n            const currentFocus = this._foci.get(focusType);\n            if(widget !== currentFocus) {\n                this.clearFocus(focusType);\n                //console.log('Set focus type', focusType, 'to widget', widget);\n                this._foci.set(focusType, widget);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, focusType, widget);\n            }\n        }\n    }\n\n    /**\n     * Clears the current {@link _foci | focus} of a given type if it is\n     * currently set to a given widget. Achieved by calling {@link clearFocus}.\n     */\n    dropFocus(focusType: FocusType, widget: Widget): void {\n        // NOTE: Use this instead of clearFocus if your intent is to make sure a\n        // SPECIFIC COMPONENT is no longer focused, NOT ANY COMPONENT\n        const currentFocus = this._foci.get(focusType);\n        if(widget === currentFocus)\n            this.clearFocus(focusType);\n    }\n\n    /**\n     * Clears the current {@link _foci | focus} of a given type. If there was a\n     * focus set, {@link drivers} are notified by calling\n     * {@link Driver.onFocusChanged}.\n     */\n    clearFocus(focusType: FocusType): void {\n        const currentFocus = this._foci.get(focusType);\n        if(currentFocus !== null && typeof currentFocus !== 'undefined') {\n            //console.log('Dropped focus type', focusType, 'from widget', currentFocus);\n            currentFocus.onFocusDropped(focusType, this);\n\n            this._foci.set(focusType, null);\n            for(const driver of this.drivers)\n                driver.onFocusChanged(this, focusType, null);\n        }\n    }\n\n    /**\n     * Gets the current {@link _foci | focus} of a given type.\n     */\n    getFocus(focusType: FocusType): Widget | null {\n        return this._foci.get(focusType) ?? null;\n    }\n\n    /**\n     * Gets the last {@link _fociCapturers | focus capturer} of a given type.\n     */\n    getFocusCapturer(focusType: FocusType): Widget | null {\n        return this._fociCapturers.get(focusType) ?? null;\n    }\n\n    /**\n     * Registers a {@link Driver} to the root, adding it to the {@link drivers}\n     * list and calling {@link Driver.onEnable}. If the driver was already\n     * registered, nothing happens.\n     */\n    registerDriver(driver: Driver): void {\n        // If driver is not registered, register it\n        if(this.drivers.has(driver))\n            return;\n\n        this.drivers.add(driver);\n        if(this._enabled && driver.onEnable)\n            driver.onEnable(this);\n    }\n\n    /**\n     * Unregisters a {@link Driver} from the root, removing it from the\n     * {@link drivers} list and calling {@link Driver.onDisable}. If the driver\n     * was not registered, nothing happens.\n     */\n    unregisterDriver(driver: Driver): void {\n        // If driver is registered, unregister it\n        if(!this.drivers.delete(driver))\n            return;\n\n        if(this._enabled && driver.onDisable)\n            driver.onDisable(this);\n    }\n\n    /**\n     * Unregisters all {@link drivers} from the root, by calling\n     * {@link unregisterDriver}.\n     */\n    clearDrivers(): void {\n        // Unregister all drivers\n        for(const driver of this.drivers)\n            this.unregisterDriver(driver);\n    }\n\n    /**\n     * Can {@link getTextInput} be called? True if {@link textInputHandler} is\n     * not null and {@link usingMobileTextInput} is false.\n     */\n    get hasMobileTextInput(): boolean {\n        return this.textInputHandler !== null && !this._mobileTextInUse;\n    }\n\n    /**\n     * Is {@link getTextInput} in use?\n     *\n     * See {@link _mobileTextInUse}.\n     */\n    get usingMobileTextInput(): boolean {\n        return this._mobileTextInUse;\n    }\n\n    /**\n     * Get text input from the user. Used for mobile where keyboard events are\n     * hard to get.\n     *\n     * @returns If this is already in use ({@link usingMobileTextInput}), returns null, else, returns a string typed by the user.\n     */\n    async getTextInput(initialInput = ''): Promise<string | null> {\n        // Only get if text input is currently available\n        // XXX even though this if statement is equivalent to\n        // hasMobileTextInput, typescript type inference is bad and only works\n        // if its done this way, else it thinks that textInputHandler may be\n        // null and throws an error when compiling\n        if(this.textInputHandler !== null && !this._mobileTextInUse) {\n            // Flag text input as in-use\n            this._mobileTextInUse = true;\n\n            // Get input from handler\n            const newInput = await this.textInputHandler(initialInput);\n\n            // Flag text input as not in-use\n            this._mobileTextInUse = false;\n\n            // Return new value\n            return newInput;\n        }\n\n        return null;\n    }\n}\n","import type { Widget } from '../widgets/Widget';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * Like Root, but for easy use in an HTML page.\n *\n * Instead of calling each individual update method, simply call {@link update}\n * on every animation frame. {@link Driver | Drivers} still need to be manually\n * registered.\n *\n * @category Core\n */\nexport class DOMRoot extends Root {\n    /** This root's canvas element. Add this to the HTML body */\n    readonly domElem: HTMLCanvasElement;\n    /** This root's canvas element's context. Used for painting */\n    private domCanvasContext: CanvasRenderingContext2D;\n\n    /**\n     * Create a new DOMRoot.\n     *\n     * Sets {@link child} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}. Also sets up a\n     * {@link pointerStyleHandler} which simply sets the CSS cursor style of\n     * {@link domElem}. Creates {@link domElem} and {@link domCanvasContext}.\n     *\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(child: Widget, theme: Theme = new Theme()) {\n        super(child, null, theme);\n\n        // Make DOM element, which is a canvas, and get a 2D context for it\n        this.domElem = document.createElement('canvas');\n        this.domElem.tabIndex = 1;\n        [this.domElem.width, this.domElem.height] = this.dimensions;\n\n        const context = this.domElem.getContext('2d', { alpha: true });\n        if(context === null)\n            throw 'Failed to get DOM canvas context';\n\n        this.domCanvasContext = context;\n\n        // Setup pointer style handler\n        this.pointerStyleHandler = (newPointerStyle: string): void => {\n            this.domElem.style.cursor = newPointerStyle;\n        };\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link domElem}'s display style is set to 'none',\n     * hiding it.\n     *\n     * Calls {@link preLayoutUpdate}, {@link resolveLayout},\n     * {@link postLayoutUpdate} and {@link paint}.\n     */\n    update(): void {\n        if(!this.enabled) {\n            this.domElem.style.display = 'none';\n            return;\n        }\n        else\n            this.domElem.style.removeProperty('display');\n\n        this.preLayoutUpdate();\n        if(this.resolveLayout())\n            [this.domElem.width, this.domElem.height] = this.dimensions;\n        this.postLayoutUpdate();\n        if(this.paint()) {\n            this.domCanvasContext.globalCompositeOperation = 'copy';\n            this.domCanvasContext.drawImage(this.canvas, 0, 0);\n        }\n    }\n}","import { ThemeProperty } from '../theme/ThemeProperty';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic widget. All widgets extend this class.\n *\n * @category Widget\n */\nexport abstract class Widget {\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     */\n    private _enabled = true;\n    /** Widget will only be painted if dirty is true. */\n    protected _dirty = true;\n    /**\n     * If this is true, widget needs their layout resolved. If implementing a\n     * container, propagate this up.\n     */\n    protected _layoutDirty = true;\n    /**\n     * Widget will have its background automatically cleared when painting if\n     * needsClear is true. The background fill style used is\n     * {@link ThemeProperty.CanvasFill}.\n     */\n    readonly needsClear: boolean;\n    /**\n     * Widget will get targetted events even if the target is not itself if it\n     * this is true. Useful for implementing container widgets.\n     */\n    readonly propagatesEvents: boolean;\n    /**\n     * The theme override used by the Widget. If this is null, the Widget's\n     * theme will be the inherited theme, else, it will be the theme override\n     * with the inherited theme as the fallback. The fallback of the theme\n     * override will be ignored and replaced.\n     */\n    private _themeOverride: Theme | null;\n    /** The current theme in use by the Widget. */\n    private _theme: Theme | null = null;\n    /** The inherited theme. */\n    private _inheritedTheme: Theme | null = null;\n    /** Width of widget in pixels. */\n    protected width = 0;\n    /** Height of widget in pixels. */\n    protected height = 0;\n    /** {@link flex} but for internal use. */\n    protected _flex = 0;\n\n    /**\n     * How much this widget will expand relative to other widgets in a flexbox\n     * container. If changed, sets {@link _layoutDirty} to true.\n     */\n    get flex(): number {\n        return this._flex;\n    }\n\n    set flex(flex: number) {\n        if(flex !== this._flex) {\n            this._flex = flex;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** Create a new Widget. */\n    constructor(themeOverride: Theme | null, needsClear: boolean, propagatesEvents: boolean) {\n        this.needsClear = needsClear;\n        this.propagatesEvents = propagatesEvents;\n        this._themeOverride = themeOverride;\n    }\n\n    /**\n     * Called when the inherited theme of this Widget is updated. Can be\n     * overridden. Does nothing by default.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected updateInheritedTheme(): void {}\n\n    /** Update this widget's current theme, with theme override set up. */\n    private updateTheme(): void {\n        if(this._themeOverride === null)\n            this._theme = this._inheritedTheme;\n        else {\n            this._themeOverride.fallback = this._inheritedTheme;\n            this._theme = this._themeOverride;\n        }\n    }\n\n    /**\n     * The current theme in use by the Widget. If there is no theme, throws an\n     * exception.\n     */\n    get theme(): Theme {\n        if(this._theme === null)\n            throw 'Widget theme is not ready';\n\n        return this._theme;\n    }\n\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     *\n     * If changed, {@link _enabled} is set, {@link _layoutDirty} is set to true\n     * and {@link _dirty} is set to true if enabled or false if not enabled.\n     *\n     * If getting, {@link _enabled} is returned.\n     */\n    set enabled(enabled: boolean) {\n        if(enabled === this._enabled)\n            return;\n\n        this._enabled = enabled;\n        this._dirty = enabled;\n        this._layoutDirty = true;\n    }\n\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    /**\n     * Set the theme override of this widget. Should not be overridden, but can\n     * be. If overridden, the original method should still be called.\n     *\n     * Calls {@link updateTheme} and sets {@link _layoutDirty} and\n     * {@link _dirty} to true if widget is enabled.\n     */\n    protected setThemeOverride(theme: Theme | null): void {\n        // Abort if theme hasn't changed\n        if(this._themeOverride === theme)\n            return;\n\n        this._themeOverride = theme;\n        this.updateTheme();\n\n        if(this._enabled) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * The theme override used by the Widget. If this is null, the Widget's\n     * theme will be the inherited theme, else, it will be the theme override\n     * with the inherited theme as the fallback. The fallback of the theme\n     * override will be ignored and replaced.\n     *\n     * If setting, calls {@link setThemeOverride}.\n     *\n     * If getting, returns {@link _themeOverride}.\n     */\n    set themeOverride(theme: Theme | null) {\n        this.setThemeOverride(theme);\n    }\n\n    get themeOverride(): Theme | null {\n        return this._themeOverride;\n    }\n\n    /**\n     * Set the inherited theme of this widget. Should not be overridden, but can\n     * be. If overridden, the original method should still be called.\n     *\n     * Theme override has priority over inherited theme. Inherited theme should\n     * be propagated to children so they also have a theme.\n     *\n     * Calls {@link updateInheritedTheme} and {@link updateTheme} and sets\n     * {@link _layoutDirty} and {@link _dirty} to true if widget is enabled.\n     */\n    protected inheritTheme(theme: Theme | null): void {\n        // Abort if theme hasn't changed\n        if(this._inheritedTheme === theme)\n            return;\n\n        this._inheritedTheme = theme;\n        this.updateInheritedTheme();\n        this.updateTheme();\n\n        if(this._enabled) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * The inherited theme of this widget.\n     *\n     * If setting, calls {@link inheritTheme}.\n     *\n     * If getting, returns {@link _inheritedTheme}.\n     */\n    set inheritedTheme(theme: Theme | null) {\n        this.inheritTheme(theme);\n    }\n\n    get inheritedTheme(): Theme | null {\n        return this._inheritedTheme;\n    }\n\n    /**\n     * Get the resolved dimensions. Returns a 2-tuple containing\n     * {@link width} and {@link height}.\n     */\n    get dimensions(): [number, number] {\n        return [this.width, this.height];\n    }\n\n    /**\n     * Check if the widget is dirty. Returns {@link _dirty}, as long as\n     * {@link dimensionless} is not true.\n     */\n    get dirty(): boolean {\n        return this._dirty && !this.dimensionless;\n    }\n\n    /** Check if the widget's layout is dirty. Returns {@link _layoutDirty}. */\n    get layoutDirty(): boolean {\n        return this._layoutDirty;\n    }\n\n    /**\n     * Check if the widget has zero width or height.\n     *\n     * If true, {@link paint} will do nothing and {@link dirty} will be false\n     * even if {@link _dirty} is true.\n     *\n     * Usually becomes true when containers overflow.\n     */\n    get dimensionless(): boolean {\n        return this.width == 0 || this.height == 0;\n    }\n\n    /**\n     * Called when a focus type owned by this Widget has been dropped. Does\n     * nothing by default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusDropped(_focusType: FocusType, _root: Root): void {}\n\n    /**\n     * Widget event handling callback. If the event is to be captured, the\n     * capturer is returned, else, null. By default, this will do nothing and\n     * capture the event if it is targetted at itself or is a\n     * {@link PointerEvent}. Should be overridden.\n     *\n     * If overriding, return the widget that has captured the event (could be\n     * this, for example, or a child widget if implementing a container), or\n     * null if no widget captured the event.\n     */\n    protected handleEvent(event: Event, _root: Root): Widget | null {\n        if(event.target === this ||\n           ((event instanceof PointerEvent) && (event.target === null)))\n            return this;\n        else\n            return null;\n    }\n\n    /**\n     * Called when an event is passed to the Widget. Checks if the target\n     * matches the Widget, unless the Widget propagates events, or if the event\n     * is a {@link PointerEvent} and is in the bounds of the Widget. If neither\n     * of the conditions are true, the event is not captured (null is returned),\n     * else, the {@link handleEvent} method is called and its result is\n     * returned. Must not be overridden.\n     *\n     * @returns Returns the widget that captured the event or null if none captured the event.\n     */\n    dispatchEvent(event: Event, root: Root): Widget | null {\n        if(!this._enabled)\n            return null;\n\n        if(event.target === null) {\n            if(event instanceof PointerEvent) {\n                if(event.x < 0 || event.y < 0 || event.x >= this.width || event.y >= this.height)\n                    return null;\n            }\n        }\n        else if(event.target !== this && !this.propagatesEvents)\n            return null;\n\n        return this.handleEvent(event, root);\n    }\n\n    /**\n     * Generic update method which is called before layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePreLayoutUpdate(_root: Root): void {}\n\n    /**\n     * Generic update method which is called before layout is resolved. Calls\n     * {@link handlePreLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    preLayoutUpdate(root: Root): void {\n        if(this._enabled)\n            this.handlePreLayoutUpdate(root);\n    }\n\n    /**\n     * Resolve layout of this widget. Must be implemented; set {@link width} and\n     * {@link height}.\n     */\n    protected abstract handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void;\n\n    /**\n     * Wrapper for {@link handleResolveLayout}. Does nothing if\n     * {@link _enabled} is false. If the resolved dimensions change,\n     * {@link _dirty} is set to true. {@link _layoutDirty} is set to false. If\n     * the widget is not loose and the layout has non-infinite max constraints,\n     * then the widget is stretched to fit max constraints. Must not be\n     * overridden.\n     */\n    resolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        if(minWidth > maxWidth)\n            throw 'minWidth must not be greater than maxWidth';\n        if(minWidth < 0)\n            throw 'minWidth must not be lesser than 0';\n        if(minWidth == Infinity)\n            throw 'minWidth must not be infinite';\n        if(minHeight > maxHeight)\n            throw 'minHeight must not be greater than maxHeight';\n        if(minHeight < 0)\n            throw 'minHeight must not be lesser than 0';\n        if(minHeight == Infinity)\n            throw 'minHeight must not be infinite';\n\n        if(!this._enabled) {\n            this.width = 0;\n            this.height = 0;\n            this._layoutDirty = false;\n            return;\n        }\n\n        const oldWidth = this.width;\n        const oldHeight = this.height;\n\n        this.handleResolveLayout(minWidth, maxWidth, minHeight, maxHeight);\n\n        if(this.width < minWidth) {\n            this.width = minWidth;\n            console.warn('Horizontal underflow in widget', this.constructor.name);\n        }\n        else if(this.width > maxWidth) {\n            this.width = maxWidth;\n            console.warn('Horizontal overflow in widget', this.constructor.name);\n        }\n\n        if(this.width < 0 || this.width == Infinity)\n            throw new Error(`Disallowed width in widget ${this.constructor.name}: ${this.width}`);\n\n        if(this.height < minHeight) {\n            this.height = minHeight;\n            console.warn('Vertical underflow in widget', this.constructor.name);\n        }\n        else if(this.height > maxHeight) {\n            this.height = maxHeight;\n            console.warn('Vertical overflow in widget', this.constructor.name);\n        }\n\n        if(this.height < 0 || this.height == Infinity)\n            throw new Error(`Disallowed height in widget ${this.constructor.name}: ${this.height}`);\n\n        this._layoutDirty = false;\n\n        if(oldWidth !== this.width || oldHeight !== this.height)\n            this._dirty = true;\n\n        //console.log('Resolved layout of', this.constructor.name);\n    }\n\n    /**\n     * Generic update method which is called after layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePostLayoutUpdate(_root: Root): void {}\n\n    /**\n     * Generic update method which is called after layout is resolved. Calls\n     * {@link handlePostLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    postLayoutUpdate(root: Root): void {\n        if(this._enabled)\n            this.handlePostLayoutUpdate(root);\n    }\n\n    /**\n     * Paiting utility: clears background of widget. Should not be overridden.\n     *\n     * The background fill style used is {@link ThemeProperty.CanvasFill}.\n     */\n    protected clear(x: number, y: number, width: number, height: number, ctx: CanvasRenderingContext2D): void {\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = this.theme.getFill(ThemeProperty.CanvasFill);\n        ctx.beginPath();\n        // These are rounded because clipping and filling doesn't\n        // work properly with decimal points\n        ctx.rect(Math.trunc(x), Math.trunc(y), Math.ceil(width), Math.ceil(height));\n        ctx.clip();\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Widget painting callback. By default does nothing. Do painting logic here\n     * when extending Widget. Should be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePainting(_x: number, _y: number, _ctx: CanvasRenderingContext2D): void {}\n\n    /**\n     * Called when the Widget is dirty and the Root is being rendered. Does\n     * nothing if dirty flag is not set, else, clears the background if\n     * {@link needsClear} is true, calls the {@link handlePainting} method and\n     * unsets the dirty flag. Does nothing if {@link dimensionless} is true.\n     * Must not be overridden.\n     */\n    paint(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        if(this.dimensionless || !this._dirty)\n            return;\n\n        //console.log('Painted', this.constructor.name);\n\n        if(this._enabled) {\n            if(this.needsClear)\n                this.clear(x, y, this.width, this.height, ctx);\n\n            ctx.save();\n            this.handlePainting(x, y, ctx);\n            ctx.restore();\n        }\n\n        this._dirty = false;\n    }\n}","import type { Theme } from '../theme/Theme';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A mixin class for widgets which may have children.\n *\n * Overrides {@link updateInheritedTheme} so that inherited themes are\n * propagated to children, and {@link forceLayoutDirty} so that forcing layout\n * as dirty is propagated to children. Also provides utilities for getting the\n * amount of children, a public iterator for children and a protected child\n * list. This way, widgets that use this mixin can decide if modifying the list\n * of children should be public or not.\n *\n * Can be constrained to a specific type of children.\n *\n * See {@link MultiParent} and {@link SingleParent} for more specialised\n * versions.\n *\n * @category Widget\n */\nexport abstract class Parent<W extends Widget = Widget> extends Widget {\n    /**\n     * This widget's children. Note that this is marked as readonly so that it\n     * cannot be accidentally replaced with a new array. This way, references to\n     * this array are always valid. If you want to clear this array, set the\n     * length to zero instead of creating a new instance. readonly still means\n     * that you can add/remove elements to/from the array.\n     *\n     * See {@link children} for the public iterator getter.\n     */\n    protected readonly _children: Array<W>;\n\n    /**\n     * Create a new Parent. Automatically adds all widgets in the input array\n     * to {@link _children}.\n     */\n    constructor(children: Array<W>, themeOverride: Theme | null, needsClear: boolean, propagatesEvents: boolean) {\n        super(themeOverride, needsClear, propagatesEvents);\n\n        this._children = [...children];\n    }\n\n    protected override updateInheritedTheme(): void {\n        const inheritedTheme = this.inheritedTheme;\n        if(inheritedTheme !== null) {\n            for(const child of this.children)\n                child.inheritedTheme = inheritedTheme;\n        }\n    }\n\n    /** Get amount of children of this parent widget. */\n    get childCount(): number {\n        return this._children.length;\n    }\n\n    /**\n     * Get iterator for children of this parent widget. Cannot modify list of\n     * children via this iterator; for read-only purposes only.\n     */\n    get children(): Iterable<W> {\n        return this._children.values();\n    }\n}","import type { Widget } from '../widgets/Widget';\nimport type { Theme } from '../theme/Theme';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with a\n * single mandatory child.\n *\n * @category Widget\n */\nexport abstract class SingleParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Create a new SingleParent instance.\n     *\n     * @param child The mandatory single child of this widget. Cannot be changed later, unless {@link _children} is changed directly via the widget using this mixin.\n     */\n    constructor(child: W, themeOverride: Theme | null, needsClear: boolean, propagatesEvents: boolean) {\n        super([child], themeOverride, needsClear, propagatesEvents);\n    }\n\n    /** This widget's child. */\n    get child(): W {\n        return this._children[0];\n    }\n}","import { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and does nothing,\n * passing all events through to its child. Useful for widgets that are only\n * used for logic, like {@link ThemeScope}.\n *\n * Can be constrained to a specific type of children.\n *\n * Since this does nothing on its own, it should not be used on its own.\n * Instead, extend this class if you are looking for a way to do wrapper widgets\n * that provide extra logic.\n *\n * @category Widget\n */\nexport class PassthroughWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, themeOverride: Theme | null = null) {\n        // Passthrough widgets dont need a clear background, have a child and\n        // propagate events\n        super(child, themeOverride, false, true);\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve child's layout and set own resolved dimensions to be equal to\n        // the child's\n        const child = this.child;\n        child.resolveLayout(minWidth, maxWidth, minHeight, maxHeight);\n        [this.width, this.height] = child.dimensions;\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Paint child\n        this.child.paint(x, y, ctx);\n    }\n}","import { PassthroughWidget } from './PassthroughWidget';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which imposes further layout constraints onto a\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ArtificialConstraint<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** See {@link constraints}. For internal use only */\n    private _constraints: [number, number, number, number] = [0, Infinity, 0, Infinity];\n\n    /**\n     * The further constraints given to the child. A 4-tuple containing,\n     * respectively, minimum width, maximum width, minimum height and maximum\n     * height. Changing this sets {@link _layoutDirty} to true. Constraints are\n     * only applied if they are more restrictive than the original constraints.\n     */\n    set constraints(constraints: [number, number, number, number]) {\n        if(this._constraints[0] !== constraints[0] ||\n           this._constraints[1] !== constraints[1] ||\n           this._constraints[2] !== constraints[2] ||\n           this._constraints[3] !== constraints[3]) {\n            this._constraints[0] = constraints[0];\n            this._constraints[1] = constraints[1];\n            this._constraints[2] = constraints[2];\n            this._constraints[3] = constraints[3];\n            this._layoutDirty = true;\n        }\n    }\n\n    get constraints(): [number, number, number, number] {\n        return [...this._constraints];\n    }\n\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, constraints: [number, number, number, number] = [0, Infinity, 0, Infinity], themeOverride: Theme | null = null) {\n        super(child, themeOverride);\n\n        this._constraints = [...constraints];\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Further restrict constraints\n        if(this._constraints[0] > minWidth)\n            minWidth = this._constraints[0];\n        if(this._constraints[1] < maxWidth)\n            maxWidth = this._constraints[1];\n        if(this._constraints[2] > minHeight)\n            minHeight = this._constraints[2];\n        if(this._constraints[3] < maxHeight)\n            maxHeight = this._constraints[3];\n\n        // Resolve layout\n        super.handleResolveLayout(minWidth, maxWidth, minHeight, maxHeight);\n    }\n}","import { ThemeProperty } from '../theme/ThemeProperty';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { Alignment } from '../theme/Alignment';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and automatically paints\n * the child, adds padding, propagates events (if enabled) and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class BaseContainer<W extends Widget = Widget> extends SingleParent<W> {\n    /** Horizontal offset of child relative to container. */\n    private offsetX = 0;\n    /** Vertical offset of child relative to container. */\n    private offsetY = 0;\n\n    /** Create a new BaseContainer. */\n    constructor(child: W, propagateEvents: boolean, themeOverride: Theme | null = null) {\n        // Containers need a clear background, have a child and may propagate\n        // events\n        super(child, themeOverride, true, propagateEvents);\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Correct pointer events for padding\n        if(event instanceof PointerEvent)\n            event = event.correctOffset(this.offsetX, this.offsetY);\n\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get padding\n        const padding = this.theme.getPadding(ThemeProperty.ContainerPadding);\n        const hPadding = padding.left + padding.right;\n        const vPadding = padding.top + padding.bottom;\n        let childMaxWidth = maxWidth - hPadding;\n        let childMaxHeight = maxHeight - vPadding;\n\n        // If there isn't enough space for padding, resolve child's layout with\n        // a tight fit of 0 for axis with lack of space\n        if(childMaxWidth < 0)\n            childMaxWidth = 0;\n        if(childMaxHeight < 0)\n            childMaxHeight = 0;\n\n        // Use tight fit if using a stretch alignment\n        const alignment = this.theme.getAlignment2D(ThemeProperty.ContainerAlignment);\n        const childMinWidth = alignment.horizontal == Alignment.Stretch\n                                ? childMaxWidth : 0;\n        const childMinHeight = alignment.vertical == Alignment.Stretch\n                                ? childMaxHeight : 0;\n\n        // Resolve child's layout\n        this.child.resolveLayout(childMinWidth, childMaxWidth, childMinHeight, childMaxHeight);\n        const childDims = this.child.dimensions;\n        const usedWidth = childDims[0] + hPadding;\n        const usedHeight = childDims[1] + vPadding;\n\n        // Resolve own layout\n        this.width = Math.max(minWidth, usedWidth);\n        this.height = Math.max(minHeight, usedHeight);\n\n        // Horizontal offset\n        this.offsetX = padding.left;\n        if(alignment.horizontal !== Alignment.Stretch) {\n            // Get free space for this axis\n            const freeSpace = this.width - usedWidth;\n\n            // Ignore if free space is negative or zero, as in, the child didn't\n            // even get the space they requested or just enough space\n            if(freeSpace > 0) {\n                // Distribute free space according to chosen alignment mode\n                // XXX Couldn't this be simplified by using a ratio instead of\n                // an enum?\n                switch(alignment.horizontal) {\n                    case Alignment.Center:\n                        this.offsetX += freeSpace / 2;\n                        break;\n                    case Alignment.End:\n                        this.offsetX += freeSpace;\n                        break;\n                }\n            }\n        }\n\n        // Vertical offset\n        this.offsetY = padding.top;\n        if(alignment.vertical !== Alignment.Stretch) {\n            // Same logic as above, but for vertical axis\n            const freeSpace = this.height - usedHeight;\n\n            if(freeSpace > 0) {\n                switch(alignment.vertical) {\n                    case Alignment.Center:\n                        this.offsetY += freeSpace / 2;\n                        break;\n                    case Alignment.End:\n                        this.offsetY += freeSpace;\n                        break;\n                }\n            }\n        }\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Paint child\n        this.child.paint(x + this.offsetX, y + this.offsetY, ctx);\n    }\n}\n","import { ClickHelper } from '../aggregates/ClickHelper';\nimport { BaseContainer } from './BaseContainer';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which can be {@link Clickable | clicked} as a button.\n * Since the button grabs all events, no events are propagated to the child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Button<W extends Widget = Widget> extends BaseContainer<W> {\n    /** The helper for handling pointer clicks */\n    protected clickHelper: ClickHelper;\n    /**\n     * The callback for clicking this button. If null, the button is not\n     * clickable but will still absorb events.\n     */\n    callback: (() => void) | null;\n\n    /** Create a new Button. */\n    constructor(child: W, callback: (() => void) | null = null, themeOverride: Theme | null = null) {\n        super(child, false, themeOverride);\n        this.clickHelper = new ClickHelper(this);\n        this.callback = callback;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Abort if no callback, but still absorb events\n        if(this.callback === null) {\n            this.clickHelper.clickStateChanged = false;\n            return this;\n        }\n\n        // Check if button was pressed and call callback if so\n        this.clickHelper.handleClickEvent(event, root, [0, this.width, 0, this.height]);\n        if(this.clickHelper.clickStateChanged && this.clickHelper.wasClick) {\n            try {\n                this.callback();\n            }\n            catch(e) {\n                console.error('Exception in Icon callback', e);\n            }\n        }\n\n        return this;\n    }\n}\n","import { ClickState } from '../aggregates/ClickHelper';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\nimport { Button } from './Button';\n\n/**\n * A {@link Button} which overrides the canvas colour, meaning that it has a\n * filled background. Uses a technique similar to {@link ThemeScope} to achieve\n * this.\n *\n * Can be constrained to a specific type of children.\n *\n * This button version can also be \"forced down\"; the button becomes similar to\n * being pressed, visually. Useful for implementing widgets such as\n * {@link ShiftKey}.\n *\n * @category Widget\n */\nexport class FilledButton<W extends Widget = Widget> extends Button<W> {\n    /** Theme property used for overriding the canvas colour. */\n    private backgroundProperty: ThemeProperty = ThemeProperty.BackgroundFill;\n    /** Is the button currently forced down? */\n    private _forced = false;\n\n    /**\n     * Update the background fill.\n     *\n     * Sets {@link backgroundProperty} depending on {@link _forced} and\n     * {@link clickState}, calls {@link inheritTheme} and sets\n     * {@link _backgroundDirty} to true.\n     */\n    private updateBackground(): void {\n        if(this._forced)\n            this.backgroundProperty = ThemeProperty.PrimaryFill;\n        else {\n            switch(this.clickHelper.clickState) {\n            case ClickState.Hold:\n                this.backgroundProperty = ThemeProperty.AccentFill;\n                break;\n            case ClickState.Hover:\n                this.backgroundProperty = ThemeProperty.BackgroundGlowFill;\n                break;\n            default:\n                this.backgroundProperty = ThemeProperty.BackgroundFill;\n                break;\n            }\n        }\n\n        // Update inherited theme\n        const overrideValue = this.theme.getFill(this.backgroundProperty);\n        const modifiedTheme = new Theme(\n            new Map([\n                [ThemeProperty.CanvasFill, overrideValue],\n            ]),\n            this.inheritedTheme?.fallback,\n        );\n\n        super.inheritTheme(modifiedTheme);\n    }\n\n    set forced(forced: boolean) {\n        if(forced !== this._forced) {\n            this._forced = forced;\n            this.updateBackground();\n        }\n    }\n\n    get forced(): boolean {\n        return this._forced;\n    }\n\n    protected override setThemeOverride(theme: Theme | null): void {\n        if(theme === null)\n            return super.setThemeOverride(null);\n\n        // Create new theme with the canvas colour set to the override's\n        // background and use that as the theme override. If override doesn't\n        // have the wanted property, it will throw an exception.\n        try {\n            const overrideValue = theme.getFill(this.backgroundProperty);\n            const modifiedTheme = new Theme(new Map([\n                [ThemeProperty.CanvasFill, overrideValue],\n            ]));\n\n            super.setThemeOverride(modifiedTheme);\n        }\n        catch(_e) {\n            return super.setThemeOverride(null);\n        }\n    }\n\n    protected override inheritTheme(theme: Theme): void {\n        // Create theme with fallback to new theme with overridden canvas colour\n        const canvasValue = theme.getFill(this.backgroundProperty);\n        const modifiedTheme = new Theme(\n            new Map([\n                [ThemeProperty.CanvasFill, canvasValue],\n            ]),\n            theme,\n        );\n\n        super.inheritTheme(modifiedTheme);\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        const capturer = super.handleEvent(event, root);\n\n        if(this.clickHelper.clickStateChanged)\n            this.updateBackground();\n\n        return capturer;\n    }\n}\n","import { BaseContainer } from './BaseContainer';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which always propagates events. Use this widget if\n * you are not sure what that means.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Container<W extends Widget = Widget> extends BaseContainer<W> {\n    /** Create a new Container. */\n    constructor(child: W, themeOverride: Theme | null = null) {\n        super(child, true, themeOverride);\n    }\n}\n","import type { Alignment2D } from '../theme/Alignment2D';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\n\n/**\n * A {@link Margin} which stretches on the vertical axis. Useful for\n * horizontally centering labels without making them look weird if they are in\n * a row, such as in a {@link VirtualKeyRow}.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class TextMargin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new TextMargin. */\n    constructor(child: W) {\n        const themeOverride = new Theme(new Map<ThemeProperty, unknown>([\n            [\n                ThemeProperty.ContainerAlignment,\n                <Alignment2D>{\n                    horizontal: Alignment.Center, vertical: Alignment.Stretch,\n                },\n            ],\n        ]));\n\n        super(child, themeOverride);\n    }\n}\n","import { ThemeProperty } from '../theme/ThemeProperty';\nimport { TextHelper } from '../aggregates/TextHelper';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A function which returns a string. An alternative to supplying a\n * {@link Label} with a string if you have a text value that constantly changes.\n *\n * @category Widget\n */\nexport type TextGetter = () => string;\n\n// TODO add support for multiline text with wrapping\n/**\n * A widget which displays a line of text.\n *\n * @category Widget\n */\nexport class Label extends Widget {\n    /**\n     * The text getter source. If this is not null, text will be updated with\n     * the return value of this callback, every update.\n     */\n    private textGetter: TextGetter | null = null;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n\n    /**\n     * Create a new Label.\n     *\n     * @param source The text source of the label. Has the same behaviour as setting {@link source}.\n     */\n    constructor(source: string | TextGetter, themeOverride: Theme | null = null) {\n        // Labels need a clear background, have no children and don't propagate\n        // events\n        super(themeOverride, true, false);\n\n        this.textHelper = new TextHelper();\n        this.source = source;\n    }\n\n    /**\n     * This label's text source. If you want to get the current text string,\n     * then use {@link currentText} instead.\n     *\n     * When setting, if text is a {@link TextGetter}, then {@link textGetter} is\n     * set, else, {@link setText} is called.\n     *\n     * When getting, if {@link textGetter} is set, then it is returned, else,\n     * {@link _text} is returned.\n     */\n    set source(source: string | TextGetter) {\n        if(source instanceof Function)\n            this.textGetter = source;\n        else {\n            this.textGetter = null;\n            this.textHelper.text = source;\n        }\n    }\n\n    get source(): string | TextGetter {\n        if(this.textGetter !== null)\n            return this.textGetter;\n        else\n            return this.textHelper.text;\n    }\n\n    /** The current minimum text width. */\n    set minWidth(minWidth: number) {\n        this.textHelper.minWidth = minWidth;\n    }\n\n    get minWidth(): number {\n        return this.textHelper.minWidth;\n    }\n\n    /** The current minimum text ascent height. */\n    set minAscent(minAscent: number) {\n        this.textHelper.minAscent = minAscent;\n    }\n\n    get minAscent(): number {\n        return this.textHelper.minAscent;\n    }\n\n    /** The current minimum text descent height. */\n    set minDescent(minDescent: number) {\n        this.textHelper.minDescent = minDescent;\n    }\n\n    get minDescent(): number {\n        return this.textHelper.minDescent;\n    }\n\n    /**\n     * The current text value. If you want to get the current text source, then\n     * use {@link source} instead.\n     */\n    get text(): string {\n        return this.textHelper.text;\n    }\n\n    protected override handlePreLayoutUpdate(_root: Root): void {\n        // Update text helper variables\n        if(this.textGetter !== null)\n            this.textHelper.text = this.textGetter();\n\n        this.textHelper.font = this.theme.getFont(ThemeProperty.BodyTextFont);\n        this.textHelper.minWidth = this.theme.getNumber(ThemeProperty.LabelMinWidth);\n        this.textHelper.minAscent = this.theme.getNumber(ThemeProperty.LabelMinAscent);\n        this.textHelper.minDescent = this.theme.getNumber(ThemeProperty.LabelMinDescent);\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.width = Math.max(Math.min(this.textHelper.width, maxWidth), minWidth);\n        this.height = Math.max(Math.min(this.textHelper.height, maxHeight), minHeight);\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // TODO clip to prevent drawing outside of widget if you know that the dimensions are too small\n        ctx.font = this.textHelper.font;\n        ctx.fillStyle = this.theme.getFill(ThemeProperty.BodyTextFill);\n        ctx.fillText(this.text, x, y + this.height - this.textHelper.descent);\n    }\n}\n","import { FilledButton } from './FilledButton';\nimport type { Theme } from '../theme/Theme';\nimport type { TextGetter } from './Label';\nimport { TextMargin } from './TextMargin';\nimport { Label } from './Label';\n\n/**\n * A {@link FilledButton} with a {@link Label} inside a {@link TextMargin}.\n *\n * @category Widget\n */\nexport class TextButton extends FilledButton<TextMargin<Label>> {\n    /** Create a new TextButton. */\n    constructor(text: string | TextGetter, callback: (() => void) | null = null, themeOverride: Theme | null = null) {\n        super(\n            new TextMargin(\n                new Label(text, themeOverride),\n            ),\n            callback, themeOverride\n        );\n    }\n\n    /** This button's Label widget */\n    get icon(): Label {\n        return this.child.child;\n    }\n}\n","import { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\nimport { TextButton } from '../TextButton';\n\n/**\n * A {@link VirtualKey} which emits key presses for a given glyph (character),\n * handling alternative versions of the glyph when shift is held down, such as\n * uppercase variants, or exclamation marks for ones.\n *\n * For other specific keys, see {@link BasicVirtualKey}.\n *\n * @category Widget\n */\nexport class GlyphVirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new GlyphVirtualKey.\n     *\n     * @param glyph The glyph to emit/show when shift is not held.\n     * @param altGlyph The alternative glyph to emit/show when shift is held.\n     * @param keyContext The {@link KeyContext} shared by other keys to tell when shift is being held in a virtual keyboard.\n     */\n    constructor(glyph: string, altGlyph: string | null = null, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeOverride: Theme | null = null) {\n        if(altGlyph === null)\n            altGlyph = glyph;\n\n        function getGlyph() {\n            if(keyContext.shift) {\n                if(altGlyph === null)\n                    return glyph;\n                else\n                    return altGlyph;\n            }\n            else\n                return glyph;\n        }\n\n        super(\n            new TextButton(\n                getGlyph, () => keyContext.callback(getGlyph()), themeOverride,\n            ),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeOverride,\n        );\n\n        this.flex = flex;\n    }\n}\n","import type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with any\n * amount of children and public access to modifying this list of children.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport abstract class MultiParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Add child(ren) to this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true and\n     * {@link updateInheritedTheme} is called so that new children inherit this\n     * widget's theme.\n     *\n     * @param children If this is a widget, then it is pushed to {@link _children}. If this is an array of widgets, then each widget is pushed to {@link _children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    add(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            for(const child of children)\n                this._children.push(child);\n        }\n        else\n            this._children.push(children);\n\n        this.updateInheritedTheme();\n\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n\n    /**\n     * Remove child(ren) from this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true and\n     * {@link updateInheritedTheme} is called so that new children inherit this\n     * widget's theme.\n     *\n     * @param children If this is a widget, then it is removed from {@link _children}. If this is an array of widgets, then each widget is removed from {@link _children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    remove(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            for(const child of children) {\n                const pos = this._children.indexOf(child);\n                if(pos !== -1)\n                    this._children.splice(pos, 1);\n            }\n        }\n        else {\n            const pos = this._children.indexOf(children);\n            if(pos !== -1)\n                this._children.splice(pos, 1);\n        }\n\n        this.updateInheritedTheme();\n\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n\n    /**\n     * Remove all children from this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true.\n     *\n     * @returns Returns this so that the method is chainable.\n     */\n    clearChildren(): this {\n        this._children.length = 0;\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n}","import { ThemeProperty } from '../theme/ThemeProperty';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { Event } from '../events/Event';\nimport { MultiParent } from './MultiParent';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link MultiParent} which automatically paints children, adds spacing,\n * propagates events and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * Note that there is no padding. Put this inside a {@link Margin} if padding is\n * needed.\n *\n * @category Widget\n */\nexport class MultiContainer<W extends Widget = Widget> extends MultiParent<W> {\n    /** Is the container's whole background dirty (including spacing)? */\n    private backgroundDirty = true;\n    /** Is this container vertical? */\n    private vertical: boolean;\n\n    /** Create a MultiContainer. */\n    constructor(vertical: boolean, themeOverride: Theme | null = null) {\n        // MultiContainers clear their own background, have children and\n        // propagate events\n        super([], themeOverride, false, true);\n\n        this.vertical = vertical;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Find which widget the event should go to\n        const spacing = this.theme.getNumber(ThemeProperty.ContainerSpacing);\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            const length = this.vertical ? child.dimensions[1] : child.dimensions[0];\n\n            // Stop if event was captured\n            const captured = child.dispatchEvent(event, root);\n            if(captured !== null)\n                return captured;\n\n            // Correct event position and offset for next widget if event has\n            // position\n            if(event instanceof PointerEvent) {\n                if(this.vertical)\n                    event = event.correctOffset(0, length + spacing);\n                else\n                    event = event.correctOffset(length + spacing, 0);\n            }\n        }\n\n        // Event wasn't dispatched to any child\n        return null;\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update children\n        for(const child of this.children) {\n            child.preLayoutUpdate(root);\n\n            // If child's layout is dirty, set own layoutDirty flag\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update children\n        for(const child of this.children) {\n            child.postLayoutUpdate(root);\n\n            // If child is dirty, set own dirty flag\n            if(child.dirty)\n                this._dirty = true;\n        }\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // TODO vertical alignment (non-stretch where min cross length = 0)\n        // Resolve children's layout with loose constraints along the main axis\n        // to get their wanted dimensions and calculate total flex ratio\n        let totalFlex = 0;\n        let crossLength = 0;\n        let minCrossAxis = this.vertical ? maxWidth : maxHeight;\n        const maxLength = this.vertical ? maxHeight : maxWidth;\n\n        if(minCrossAxis == Infinity)\n            minCrossAxis = 0;\n\n        for(const child of this.children) {\n            let childCross: number;\n            if(this.vertical) {\n                child.resolveLayout(minCrossAxis, maxWidth, 0, Infinity);\n                childCross = child.dimensions[0];\n            }\n            else {\n                child.resolveLayout(0, Infinity, minCrossAxis, maxHeight);\n                childCross = child.dimensions[1];\n            }\n\n            totalFlex += child.flex;\n            if(childCross > crossLength)\n                crossLength = childCross;\n        }\n\n        // Clamp cross length\n        const minCrossLength = this.vertical ? minWidth : minHeight;\n        if(crossLength < minCrossLength)\n            crossLength = minCrossLength;\n\n        // Get free space\n        const spacing = this.theme.getNumber(ThemeProperty.ContainerSpacing);\n        let usedSpace = Math.trunc(this.childCount / 2) * spacing;\n        for(const child of this.children)\n            usedSpace += this.vertical ? child.dimensions[1] : child.dimensions[0];\n\n        const freeSpace = maxLength - usedSpace;\n\n        // Don't do flexbox calculations if free space is infinite\n        // (unconstrained main axis) or if there isn't any free space.\n        if(freeSpace == Infinity || freeSpace <= 0) {\n            if(this.vertical) {\n                this.width = crossLength;\n                this.height = Math.min(usedSpace, maxHeight);\n            }\n            else {\n                this.width = Math.min(usedSpace, maxWidth);\n                this.height = crossLength;\n            }\n\n            // Shrink widgets that are in the overflown section of the container\n            // if there is lack of space\n            if(freeSpace >= 0)\n                return;\n\n            let spaceLeft = maxLength;\n            for(const child of this.children) {\n                const childLength = this.vertical ? child.dimensions[1]\n                                                  : child.dimensions[0];\n\n                if(childLength > spaceLeft) {\n                    // Shrink widget\n                    if(this.vertical)\n                        child.resolveLayout(minCrossAxis, maxWidth, 0, spaceLeft);\n                    else\n                        child.resolveLayout(0, spaceLeft, minCrossAxis, maxHeight);\n\n                    spaceLeft = 0;\n                }\n                else\n                    spaceLeft = Math.max(0, spaceLeft - childLength - spacing);\n            }\n\n            return;\n        }\n\n        // Resolve children's layout with constraints restricted to distributed\n        // free space\n        for(const child of this.children) {\n            const maxMainAxis = freeSpace * child.flex / totalFlex;\n            if(this.vertical)\n                child.resolveLayout(minCrossAxis, maxWidth, 0, maxMainAxis);\n            else\n                child.resolveLayout(0, maxMainAxis, minCrossAxis, maxHeight);\n        }\n\n        // Resolve width and height\n        if(this.vertical) {\n            this.width = crossLength;\n            this.height = maxHeight;\n        }\n        else {\n            this.width = maxWidth;\n            this.height = crossLength;\n        }\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Clear background if never cleared before and there is spacing\n        const spacing = this.theme.getNumber(ThemeProperty.ContainerSpacing);\n        if(this.backgroundDirty && spacing > 0)\n            this.clear(x, y, this.width, this.height, ctx);\n\n        this.backgroundDirty = false;\n\n        // Paint children\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Figure out child width and height and clamp if needed\n            const length = this.vertical ? child.dimensions[1] : child.dimensions[0];\n\n            // Paint child\n            child.paint(x, y, ctx);\n\n            // Increment position in growth direction, with spacing\n            if(this.vertical)\n                y += length + spacing;\n            else\n                x += length + spacing;\n        }\n    }\n}\n","import { MultiContainer } from './MultiContainer';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A horizontal {@link MultiContainer}.\n *\n * @category Widget\n */\nexport class Row<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Row. */\n    constructor(themeOverride: Theme | null = null) {\n        super(false, themeOverride);\n    }\n}\n","import { ThemeProperty } from '../../theme/ThemeProperty';\nimport { GlyphVirtualKey } from './GlyphVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { VirtualKey } from './VirtualKey';\nimport { Theme } from '../../theme/Theme';\nimport { Row } from '../Row';\n\n/**\n * A template for a single virtual keyboard key. A function that, when called\n * given a {@link KeyContext} and theme override, returns a {@link VirtualKey}\n * which can be used as a virtual keyboard key widget.\n *\n * Example:\n * const template: VirtualKeyTemplate = (keyContext, themeOverride) => new BackspaceKey(keyContext, themeOverride);\n *\n * @category Widget\n */\nexport type VirtualKeyTemplate = (keyContext: KeyContext, themeOverride: Theme | null) => VirtualKey;\n\n/**\n * A template for multiple {@link GlyphVirtualKey} virtual keyboard keys. A\n * 2-tuple of strings, where each string has the same length. Each character of\n * the string represents a glyph to add to a keyboard row. The first string of\n * the tuple has the regular glyphs, while the second string string of the tuple\n * has the alternative glyphs.\n *\n * Example:\n * ```typescript\n * const template: GlyphVirtualKeysTemplate = ['qwertyuiop', 'QWERTYUIOP'];\n * ```\n *\n * @category Widget\n */\nexport type GlyphVirtualKeysTemplate = [string, string];\n\n/**\n * A template for a single row of virtual keyboard keys. An array of\n * {@link GlyphVirtualKeysTemplate} and {@link VirtualKeyTemplate}.\n *\n * Example:\n * const backspaceTemplate: VirtualKeyTemplate = (keyContext, themeOverride) => new BackspaceKey(keyContext, themeOverride);\n * const rowTemplate: VirtualKeyRowTemplate = [['`1234567890-=', '~!@#$%^&*()_+'], backspaceTemplate];\n *\n * @category Widget\n */\nexport type VirtualKeyRowTemplate = Array<GlyphVirtualKeysTemplate | VirtualKeyTemplate>;\n\n/**\n * A {@link Row} of {@link VirtualKey | virtual keys}. Generates given a\n * template.\n *\n * @category Widget\n */\nexport class VirtualKeyRow extends Row<VirtualKey> {\n    /**\n     * Create a new VirtualKeyRow.\n     *\n     * @param rowTemplate Template for this row of virtual keys.\n     * @param keyContext The {@link KeyContext} to be shared among all virtual keys in this row.\n     * @param flex The flex to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minWidth The minWidth to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minHeight The minHeight to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param themeOverride The themeOverride to pass to each key widget\n     */\n    constructor(rowTemplate: VirtualKeyRowTemplate, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeOverride: Theme | null = null) {\n        super(new Theme(new Map<ThemeProperty, unknown>([\n            [ThemeProperty.ContainerSpacing, 0],\n        ])));\n\n        for(const entry of rowTemplate) {\n            if(typeof entry === 'function') {\n                // Entry is in template function format\n                const templateFunction = entry;\n                this.add(templateFunction(keyContext, themeOverride));\n            }\n            else if(typeof entry[0] === 'string' && typeof entry[1] === 'string') {\n                // Entry is in multiple glyphs format\n                const glyphs = entry[0];\n                const altGlyphs = entry[1];\n                for(let i = 0; i < glyphs.length; i++) {\n                    let altGlyph = null;\n                    if(i < altGlyphs.length)\n                        altGlyph = altGlyphs[i];\n\n                    this.add(new GlyphVirtualKey(\n                        glyphs[i],\n                        altGlyph,\n                        keyContext,\n                        flex,\n                        minWidth,\n                        minHeight,\n                        themeOverride,\n                    ));\n                }\n            }\n            else {\n                throw new Error(`Unknown virtual key row template format for entry: ${entry}`);\n            }\n        }\n    }\n}","import { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { TextGetter } from '../../widgets/Label';\nimport type { Theme } from '../../theme/Theme';\nimport { TextButton } from '../TextButton';\n\n/**\n * An {@link ArtificialConstraint} with a {@link TextButton} which calls a given\n * callback and displays a given text source.\n *\n * For now there's nothing special about this class; it's just a common base\n * class for virtual keyboard key widgets.\n *\n * @category Widget\n */\nexport class VirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new VirtualKey.\n     *\n     * @param text The text to display in the virtual key.\n     * @param callback The callback called when the button is pressed.\n     */\n    constructor(text: string | TextGetter, callback: () => void, flex = 0, minWidth = 24, minHeight = 24, themeOverride: Theme | null = null) {\n        super(\n            new TextButton(text, callback, themeOverride),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeOverride,\n        );\n\n        this.flex = flex;\n    }\n}\n","import type { TextGetter } from '../../widgets/Label';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which emits key presses of a given key code.\n *\n * @category Widget\n */\nexport class BasicVirtualKey extends VirtualKey {\n    /**\n     * Create a new BasicVirtualKey.\n     *\n     * @param text The text to display in the virtual key.\n     * @param keyCode The {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | key code} to emit in the keyContext's callback when the virtual key is pressed\n     * @param keyContext The {@link KeyContext} shared by other virtual keyboard key widgets.\n     */\n    constructor(text: string | TextGetter, keyCode: string, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeOverride: Theme | null = null) {\n        super(\n            text,\n            () => keyContext.callback(keyCode),\n            flex,\n            minWidth,\n            minHeight,\n            themeOverride,\n        );\n    }\n}\n","import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Backspace' key presses.\n *\n * @category Widget\n */\nexport class BackspaceKey extends BasicVirtualKey {\n    /** Create a new BackspaceKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 60, minHeight = 24, themeOverride: Theme | null = null) {\n        super('Backspace', 'Backspace', keyContext, flex, minWidth, minHeight, themeOverride);\n    }\n}\n","import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Escape' key presses.\n *\n * @category Widget\n */\nexport class EscapeKey extends BasicVirtualKey {\n    /** Create a new EscapeKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeOverride: Theme | null = null) {\n        super('Esc', 'Escape', keyContext, flex, minWidth, minHeight, themeOverride);\n    }\n}\n","import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Enter' key presses.\n *\n * @category Widget\n */\nexport class EnterKey extends BasicVirtualKey {\n    /** Create a new EnterKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 72, minHeight = 24, themeOverride: Theme | null = null) {\n        super('Enter', 'Enter', keyContext, flex, minWidth, minHeight, themeOverride);\n    }\n}\n","import type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a shift key; toggles\n * {@link KeyContext.shift} on click.\n *\n * @category Widget\n */\nexport class ShiftKey extends VirtualKey {\n    /** Create a new ShiftKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 84, minHeight = 24, themeOverride: Theme | null = null) {\n        super(\n            'Shift',\n            () => {\n                keyContext.shift = !keyContext.shift;\n                this.child.forced = keyContext.shift;\n                keyContext.callback('Shift');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeOverride,\n        );\n\n        this.child.forced = keyContext.shift;\n    }\n}\n","import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\n\n/**\n * A {@link BasicVirtualKey} which emits ' ' key presses.\n *\n * @category Widget\n */\nexport class SpaceKey extends BasicVirtualKey {\n    /** Create a new SpaceKey. */\n    constructor(keyContext: KeyContext, flex = 1, minWidth = 84, minHeight = 24, themeOverride: Theme | null = null) {\n        super('Space', ' ', keyContext, flex, minWidth, minHeight, themeOverride);\n    }\n}\n","import { MultiContainer } from './MultiContainer';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A vertical {@link MultiContainer}.\n *\n * @category Widget\n */\nexport class Column<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Column. */\n    constructor(themeOverride: Theme | null = null) {\n        super(true, themeOverride);\n    }\n}\n","import type { KeyboardDriver } from '../../drivers/KeyboardDriver';\nimport type { VirtualKeyRowTemplate } from './VirtualKeyRow';\nimport { VirtualKeyRow } from './VirtualKeyRow';\nimport type { KeyContext } from './KeyContext';\nimport type { Theme } from '../../theme/Theme';\nimport { BackspaceKey } from './BackspaceKey';\nimport { EscapeKey } from './EscapeKey';\nimport { EnterKey } from './EnterKey';\nimport { ShiftKey } from './ShiftKey';\nimport { SpaceKey } from './SpaceKey';\nimport { Column } from '../Column';\n\n/**\n * A template for the keys in a {@link VirtualKeyboard}. Each member of the\n * array contains the template for a row of keys, from top to bottom.\n *\n * @category Widget\n */\nexport type VirtualKeyboardTemplate = Array<VirtualKeyRowTemplate>;\n\nfunction EnterKeyTemplate(keyContext: KeyContext, themeOverride: Theme | null): EnterKey {\n    return new EnterKey(\n        keyContext, undefined, undefined, undefined, themeOverride,\n    );\n}\n\nfunction ShiftKeyTemplate(keyContext: KeyContext, themeOverride: Theme | null): ShiftKey {\n    return new ShiftKey(\n        keyContext, undefined, undefined, undefined, themeOverride,\n    );\n}\n\nfunction BackspaceKeyTemplate(keyContext: KeyContext, themeOverride: Theme | null): BackspaceKey {\n    return new BackspaceKey(\n        keyContext, undefined, undefined, undefined, themeOverride,\n    );\n}\n\nfunction SpaceKeyTemplate(keyContext: KeyContext, themeOverride: Theme | null): SpaceKey {\n    return new SpaceKey(\n        keyContext, undefined, undefined, undefined, themeOverride,\n    );\n}\n\nfunction EscapeKeyTemplate(keyContext: KeyContext, themeOverride: Theme | null): EscapeKey {\n    return new EscapeKey(\n        keyContext, undefined, undefined, undefined, themeOverride,\n    );\n}\n\n/**\n * The default template for the keys in a {@link VirtualKeyboard}; A QWERTY\n * keyboard with US layout.\n *\n * @category Widget\n */\nexport const defaultVirtualKeyboardTemplate: VirtualKeyboardTemplate = [\n    // First row\n    [['`1234567890-=', '~!@#$%^&*()_+']],\n    // Second row\n    [['qwertyuiop[]\\\\', 'QWERTYUIOP{}|']],\n    // Third row\n    [['asdfghjkl;\\'', 'ASDFGHJKL:\"'], EnterKeyTemplate],\n    // Fourth row\n    [ShiftKeyTemplate, ['zxcvbnm,./', 'ZXCVBNM<>?']],\n    // Fifth row\n    [BackspaceKeyTemplate, SpaceKeyTemplate, EscapeKeyTemplate],\n];\n\n/**\n * A virtual keyboard widget.\n *\n * Needs a {@link KeyboardDriver} so that key events can be queued.\n *\n * Equivalent to creating a {@link Column} of {@link VirtualKeyRow} with a shared\n * {@link KeyContext}.\n *\n * @category Widget\n */\nexport class VirtualKeyboard extends Column {\n    /**\n     * Create a new VirtualKeyboard.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param flexRatio The flexRatio to use when creating {@link Glyph | Glyphs}\n     * @param mainBasis The mainBasis to use when creating {@link Glyph | Glyphs}\n     * @param crossBasis The crossBasis to use when creating {@link Glyph | Glyphs}\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, flexRatio = 0, mainBasis = 24, crossBasis = 24, themeOverride: Theme | null = null) {\n        super(themeOverride);\n\n        // Make context\n        const keyContext = <KeyContext>{\n            callback: (key: string) => {\n                keyboardDriver.keyPress(key);\n            },\n            shift: false,\n        };\n\n        for(const rowTemplate of keyboardTemplate) {\n            this.add(new VirtualKeyRow(\n                rowTemplate, keyContext, flexRatio, mainBasis, crossBasis,\n                themeOverride,\n            ));\n        }\n    }\n}\n","import type { Alignment2D } from '../theme/Alignment2D';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\n\n/**\n * A {@link Container} with center alignment on both axes and default padding,\n * similar to {@link Center}.\n *\n * Can be constrained to a specific type of children.\n *\n * Alignment settings are applied via theme overrides, so no theme override can\n * be passed to this widget. If you want to override additional theme properties\n * other than the one overridden here, then use {@link Container} instead.\n *\n * @category Widget\n */\nexport class Margin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Margin. */\n    constructor(child: W) {\n        const themeOverride = new Theme(new Map<ThemeProperty, unknown>([\n            [\n                ThemeProperty.ContainerAlignment,\n                <Alignment2D>{\n                    horizontal: Alignment.Center, vertical: Alignment.Center,\n                },\n            ],\n        ]));\n\n        super(child, themeOverride);\n    }\n}\n","import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { DOMRoot } from './DOMRoot';\n\n/**\n * A {@link DOMRoot} with similar functionality to {@link VirtualKeyboardRoot}.\n * In this version\n * {@link VirtualKeyboardRoot.updateVisibility | updateVisibility} doesn't\n * exist. Instead, just call {@link update} like in DOMRoot.\n *\n * @category Core\n */\nexport class DOMVirtualKeyboardRoot extends DOMRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}. Also sets up a\n     * {@link pointerStyleHandler} which simply sets the CSS cursor style of\n     * {@link domElem}. Creates {@link domElem} and {@link domCanvasContext}.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link domElem}'s display style is set to 'none',\n     * hiding it.\n     *\n     * Calls {@link preLayoutUpdate}, {@link resolveLayout},\n     * {@link postLayoutUpdate} and {@link paint}.\n     *\n     * Also updates the visibility of this root; if the keyboard driver has no\n     * focused root, then the root is disabled, else, it is enabled.\n     */\n    override update(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n\n        // Update normally\n        super.update();\n    }\n}","import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * A {@link Root} containing a single {@link VirtualKeyboard} widget inside a\n * {@link Margin}. Automatically disables itself if not needed, but\n * {@link updateVisibility} must be called every frame for this behaviour to\n * occur.\n *\n * @category Core\n */\nexport class VirtualKeyboardRoot extends Root {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link pointerStyleHandler} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            pointerStyleHandler, theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n    }\n}","import type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport { Event } from './Event';\n\n/**\n * A keyboard {@link Event}. This is an abstract class and is implemented in the\n * child classes {@link KeyPress} and {@link KeyRelease}.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport abstract class KeyEvent extends Event {\n    /**\n     * This event's key. Uses the same values as the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key}\n     * Web API.\n     */\n    readonly key: string;\n\n    /**\n     * Create a new KeyEvent. Sets {@link key}, {@link target},\n     * {@link focusType} to {@link FocusType.Keyboard} and {@link needsFocus} to\n     * true.\n     */\n    constructor(key: string, target: Widget | null) {\n        super(target, FocusType.Keyboard, true);\n        this.key = key;\n    }\n}\n","import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key release {@link KeyEvent} (key up).\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyRelease extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyRelease {\n        return new KeyRelease(this.key, target);\n    }\n}\n","import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key press {@link KeyEvent} (key down).\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyPress extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyPress {\n        return new KeyPress(this.key, target);\n    }\n}\n","import type { KeyEvent } from '../events/KeyEvent';\nimport { KeyRelease } from '../events/KeyRelease';\nimport type { Widget } from '../widgets/Widget';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic keyboard {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending keyboard events to\n * registered roots.\n *\n * @category Driver\n */\nexport class KeyboardDriver implements Driver {\n    /** The list of key down/up events that haven't been dispatched yet. */\n    private eventQueues: Map<Root, Array<KeyEvent>> = new Map();\n    /** A set containing the keys currently down. */\n    private keysDown: Set<string> = new Set();\n    /** The currently focused root. New keyboard events will go to this root */\n    private focus: Root | null = null;\n\n    /**\n     * Get the {@link eventQueues | event queue} of a given root. If this driver\n     * is not registered to the given root or the given root is disabled, making\n     * it not present in eventQueues, then null is returned.\n     */\n    private getEventQueue(root: Root | null): Array<KeyEvent> | null {\n        if(root === null)\n            return null;\n\n        const eventQueue = this.eventQueues.get(root);\n        if(typeof eventQueue === 'undefined')\n            return null;\n\n        return eventQueue;\n    }\n\n    /**\n     * Changes the current {@link focus | root focus}.\n     *\n     * If there was a previous root focus, that root's {@link Root.clearFocus}\n     * is called with {@link FocusType.Keyboard}.\n     *\n     * {@link keysDown} is cleared.\n     */\n    protected changeFocusedRoot(root: Root | null): void {\n        if(this.focus !== null)\n            this.focus.clearFocus(FocusType.Keyboard);\n\n        this.focus = root;\n        this.keysDown.clear();\n    }\n\n    /**\n     * Get the current {@link focus | root focus}.\n     *\n     * @returns Returns {@link focus}\n     */\n    getFocusedRoot(): Root | null {\n        return this.focus;\n    }\n\n    /**\n     * Clear the current {@link focus | root focus}. Calls\n     * {@link changeFocusedRoot} with null.\n     */\n    clearFocus(): void {\n        this.changeFocusedRoot(null);\n    }\n\n    /**\n     * Push a new {@link KeyPress} event to {@link eventQueues}.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     */\n    keyDown(key: string): void {\n        this.keysDown.add(key);\n        const eventQueue = this.getEventQueue(this.focus);\n        if(eventQueue !== null)\n            eventQueue.push(new KeyPress(key, null));\n    }\n\n    /**\n     * Push a new {@link KeyRelease} event to {@link eventQueues}.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     */\n    keyUp(key: string): void {\n        if(this.keysDown.delete(key)) {\n            const eventQueue = this.getEventQueue(this.focus);\n            if(eventQueue !== null)\n                eventQueue.push(new KeyRelease(key, null));\n        }\n    }\n\n    /**\n     * Calls {@link keyDown} followed by {@link keyUp}. If the key was already\n     * down before calling ({@link isKeyDown}), keyUp is not called.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     */\n    keyPress(key: string): void {\n        const wasDown = this.isKeyDown(key);\n        this.keyDown(key);\n        if(!wasDown)\n            this.keyUp(key);\n    }\n\n    /**\n     * Check if a key is pressed.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     *\n     * @returns Returns true if key was in {@link keysDown}\n     */\n    isKeyDown(key: string): boolean {\n        return this.keysDown.has(key);\n    }\n\n    /**\n     * Adds enabled root to {@link eventQueues}.\n     */\n    onEnable(root: Root): void {\n        if(!this.eventQueues.has(root))\n            this.eventQueues.set(root, []);\n    }\n\n    /**\n     * Removes disabled root from {@link eventQueues}. If the root was the\n     * {@link focus}, then {@link clearFocus | the focus is cleared }.\n     */\n    onDisable(root: Root): void {\n        if(this.eventQueues.has(root)) {\n            this.eventQueues.delete(root);\n            if(root === this.focus)\n                this.clearFocus();\n        }\n    }\n\n    /**\n     * Dispatches all {@link eventQueue | queued events } for the root and\n     * clears its event queue\n     */\n    update(root: Root): void {\n        const eventQueue = this.getEventQueue(root);\n        if(eventQueue === null)\n            return;\n\n        // Dispatch queued keyboard events\n        for(const event of eventQueue)\n            root.dispatchEvent(event);\n\n        // Clear event queue\n        eventQueue.length = 0;\n    }\n\n    /**\n     * Does nothing if the new focus type is not a {@link FocusType.Keyboard}.\n     * If the focus comes from a root which is not the\n     * {@link focus | root focus}, then the root focus is\n     * {@link changeFocusedRoot | changed to the new root}. If it comes from the\n     * current root focus and there is no new focused widget (the root's\n     * keyboard focus was cleared), then the root focus is\n     * {@link clearFocus | cleared}.\n     */\n    onFocusChanged(root: Root, focusType: FocusType, newFocus: Widget | null): void {\n        if(focusType !== FocusType.Keyboard)\n            return;\n\n        if(root == this.focus) {\n            if(newFocus === null)\n                this.clearFocus();\n        }\n        else if(newFocus !== null)\n            this.changeFocusedRoot(root);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n","import { KeyboardDriver } from './KeyboardDriver';\n\n/**\n * A {@link KeyboardDriver} which listens for key events from HTML DOM elements.\n *\n * Note that if a DOM element is unfocused in the DOM to an unbound DOM element,\n * the root focus is cleared. If this creates issues, other DOM elements can be\n * bound without listening for key events.\n *\n * @category Driver\n */\nexport class DOMKeyboardDriver extends KeyboardDriver {\n    /** The list of HTML DOM elements bound to this keyboard driver */\n    private domElems: Set<EventTarget> = new Set();\n\n    /**\n     * Bind an HTML DOM element to this keyboard driver.\n     *\n     * @param listenToKeys If true, event listeners will be added to listen for keys. blur event listeners are always added no matter what.\n     */\n    bindDOMElem(domElem: HTMLElement, listenToKeys = true): void {\n        // Add to set. If it was already in set, abort\n        if(this.domElems.has(domElem))\n            return;\n\n        this.domElems.add(domElem);\n\n        // Listen for keyboard events, filling event queue, and blur event for\n        // clearing keyboard focus\n        if(listenToKeys) {\n            domElem.addEventListener('keydown', (event) => {\n                this.keyDown(event.key);\n            });\n\n            domElem.addEventListener('keyup', (event) => {\n                this.keyUp(event.key);\n            });\n        }\n\n        domElem.addEventListener('blur', (event) => {\n            if(this.shouldClearFocus(event.relatedTarget))\n                this.clearFocus();\n        });\n\n    }\n\n    /**\n     * Check if the {@link focus | root focus} should be cleared given that the\n     * HTML DOM focus has been lost to another HTML DOM element\n     *\n     * @param newTarget The HTML DOM element to which the focus has been lost to\n     */\n    shouldClearFocus(newTarget: EventTarget | null): boolean {\n        return newTarget === null || !this.domElems.has(newTarget);\n    }\n}\n","/**\n * Extracts the position of a DOM PointerEvent and normalises it. Useful for\n * implementing mouse input.\n *\n * @returns Returns a 2-tuple containing the normalised coordinates; the first\n * element contains the normalised x axis, and the second element contains the\n * normalised y axis\n *\n * @category Helper\n */\nexport function getPointerEventNormPos(event: PointerEvent, domElem: HTMLElement): [number, number] {\n    const rect = domElem.getBoundingClientRect();\n    return [\n        (event.clientX - rect.left) / rect.width,\n        (event.clientY - rect.top) / rect.height,\n    ];\n}","import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer move {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerMove extends PointerEvent {\n    /**\n     * Create a new PointerMove. Sets {@link x}, {@link y}, {@link target},\n     * {@link focusType} to {@link FocusType.Pointer} and {@link needsFocus} to\n     * false.\n     */\n    constructor(x: number, y: number, target: Widget | null = null) {\n        super(x, y, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerMove {\n        return new PointerMove(this.x - xOffset, this.y - yOffset, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerMove {\n        return new PointerMove(this.x, this.y, target);\n    }\n}\n","/**\n * A {@link PointerDriver}'s pointer hint; each registered pointer has a pointer\n * hint which tracks whether the pointer is not in use, hovering a root or\n * pressing a root. Useful for styling pointers depending on if they are\n * hovering/pressing a root or not.\n *\n * @category Driver\n */\nexport enum PointerHint {\n    /** The pointer is currently not hovering any root. */\n    None,\n    /** The pointer is currently hovering a root. */\n    Hovering,\n    /** The pointer is currently hovering and pressing a root. */\n    Pressing,\n}","import { PointerRelease } from '../events/PointerRelease';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerMove } from '../events/PointerMove';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Event } from '../events/Event';\nimport { PointerHint } from './PointerHint';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\ninterface PointerDriverState {\n    eventQueue: Array<Event>;\n    pointer: number | null;\n    pressing: boolean;\n    hovering: boolean;\n}\n\n/**\n * A generic pointer {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending pointer events to\n * registered roots and (un)registering pointers.\n *\n * @category Driver\n */\nexport class PointerDriver implements Driver {\n    /**\n     * The current state for each registered and enabled root. Contains whether\n     * each root is pressing, hovering, which pointer is bound to it and its\n     * event queue\n     */\n    protected states: Map<Root, PointerDriverState> = new Map();\n    /** The next available pointer ID. See {@link registerPointer} */\n    private nextPointerID = 0;\n    /**\n     * The {@link PointerHint | hints} for each pointer. The keys are pointer\n     * IDs, while the values are that pointer's hint.\n     *\n     * See {@link getPointerHint}\n     */\n    protected hints: Map<number, PointerHint> = new Map();\n\n    /** Unassign a pointer from a given root and its state. */\n    private unassignPointer(root: Root, state: PointerDriverState) {\n        // Clear pointer state\n        if(state.pointer !== null)\n            this.setPointerHint(state.pointer, PointerHint.None);\n\n        // Clear state\n        state.pointer = null;\n        if(state.hovering) {\n            // Queue up Leave event if hovering\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n        }\n        state.hovering = false;\n        state.pressing = false;\n    }\n\n    /**\n     * Register a new pointer.\n     *\n     * @returns Returns {@link nextPointerID} and increments it\n     */\n    registerPointer(): number {\n        const newID = this.nextPointerID++;\n        this.setPointerHint(newID, PointerHint.None);\n        return newID;\n    }\n\n    /**\n     * Unregister a pointer.\n     *\n     * If a root has this pointer bound to it, the pointer is unbound from the\n     * root, a Leave event is queued to the root and the hovering and pressing\n     * state of the root is set to false.\n     */\n    unregisterPointer(pointer: number): void {\n        for(const [root, state] of this.states) {\n            // Unassign pointer if unregistered pointer was assigned to root\n            if(state.pointer === pointer)\n                this.unassignPointer(root, state);\n        }\n\n        this.hints.delete(pointer);\n    }\n\n    /**\n     * Queue up a pointer event to a given root. The type of\n     * {@link PointerEvent} is decided automatically based on the root's state\n     * and whether its pressing or not.\n     *\n     * @param pointer The registered pointer ID\n     * @param xNorm The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param pressing Is the pointer pressed?\n     *\n     * If null, the last pressing state is used, meaning that the pressing state\n     * has not changed. Useful if getting pointer movement in an event based\n     * environment where you only know when a pointer press occurs, but not if\n     * the pointer is pressed or not\n     */\n    movePointer(root: Root, pointer: number, xNorm: number, yNorm: number, pressing: boolean | null = null): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // If there is no pointer assigned, assign this one\n        const firstAssign = state.pointer === null;\n        if(firstAssign)\n            state.pointer = pointer;\n\n        // If press state was not supplied, then it hasn't changed. Use the last\n        // state\n        if(pressing === null)\n            pressing = state.pressing;\n\n        // If pointer is entering this root for the first time, then find which\n        // root the pointer was assigned to and queue a leave event\n        const pointerMatches = state.pointer === pointer;\n        if(!pointerMatches || firstAssign) {\n            for(const [otherRoot, otherState] of this.states) {\n                // Ignore if its this root\n                if(otherRoot === root)\n                    continue;\n\n                // If other root has this pointer assigned, unassign it\n                if(otherState.pointer === pointer)\n                    this.unassignPointer(otherRoot, otherState);\n            }\n        }\n\n        // Ignore if pointer is not the assigned one and not pressing or being\n        // pressed by the assigned pointer\n        if(!pointerMatches && (!pressing || state.pressing))\n            return;\n\n        // Translate to canvas coordinates\n        const [width, height] = root.dimensions;\n        const x = xNorm * width;\n        const y = yNorm * height;\n\n        // Get event type\n        let e;\n        if(pressing !== state.pressing) {\n            if(pressing)\n                e = new PointerPress(x, y);\n            else\n                e = new PointerRelease(x, y);\n\n            state.pressing = pressing;\n\n            if(pressing) {\n                // Replace assigned pointer and clear old assigned pointer's\n                // hint\n                if(state.pointer !== pointer && state.pointer !== null) {\n                    state.eventQueue.push(\n                        new Leave(root.getFocusCapturer(FocusType.Pointer))\n                    );\n                    this.setPointerHint(state.pointer, PointerHint.None);\n                    state.pointer = pointer;\n                }\n            }\n        }\n        else\n            e = new PointerMove(x, y);\n\n        // Queue event and update hovering flag\n        state.eventQueue.push(e);\n        state.hovering = true;\n\n        // Update pointer's hint\n        if(state.pressing)\n            this.setPointerHint(pointer, PointerHint.Pressing);\n        else\n            this.setPointerHint(pointer, PointerHint.Hovering);\n    }\n\n    /**\n     * Queue up a {@link Leave} event to a given root. Event will only be queued\n     * if the root was being hovered.\n     *\n     * @param pointer The registered pointer ID\n     */\n    leavePointer(root: Root, pointer: number): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Queue leave event if this is the assigned pointer and if hovering\n        if(state.hovering && state.pointer == pointer) {\n            state.hovering = false;\n            state.pressing = false;\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n            this.setPointerHint(pointer, PointerHint.None);\n        }\n    }\n\n    /**\n     * Queue up a {@link Leave} event to any root with the given pointer\n     * assigned. Event will only be queued if the root was being hovered.\n     * Pointer will also be unassigned from root.\n     *\n     * @param pointer The registered pointer ID\n     */\n    leaveAnyPointer(pointer: number): void {\n        for(const root of this.states.keys())\n            this.leavePointer(root, pointer);\n    }\n\n    /**\n     * Set a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer The registered pointer ID\n     * @param hint The new pointer hint\n     * @returns Returns true if the pointer hint changed, else, false\n     */\n    protected setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const oldHint = this.hints.get(pointer);\n\n        if(oldHint !== hint) {\n            this.hints.set(pointer, hint);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Get a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer The registered pointer ID\n     *\n     * @returns Returns the given pointer ID's hint. If the pointer ID is not registered, {@link PointerHint.None} is returned.\n     */\n    getPointerHint(pointer: number): PointerHint {\n        return this.hints.get(pointer) ?? PointerHint.None;\n    }\n\n    /**\n     * Creates a state for the enabled root in {@link states}.\n     */\n    onEnable(root: Root): void {\n        // Create new state for UI that just got enabled\n        this.states.set(root, <PointerDriverState>{\n            eventQueue: [],\n            pointer: null,\n            pressing: false,\n            hovering: false,\n        });\n    }\n\n    /**\n     * Dispatches a leave event for the disabled root and deletes the state of\n     * the disabled root from {@link states}.\n     */\n    onDisable(root: Root): void {\n        // Dispatch leave event\n        root.dispatchEvent(new Leave());\n\n        // Reset hint for assigned pointer\n        const state = this.states.get(root);\n        if(typeof state !== 'undefined' && state.pointer !== null)\n            this.setPointerHint(state.pointer, PointerHint.None);\n\n\n        // Delete state for UI thats about to get disabled\n        this.states.delete(root);\n    }\n\n    /**\n     * Dispatches all queued events (found in {@link states}) for the root and\n     * clears its event queue\n     */\n    update(root: Root): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Dispatch all queued events for this root\n        for(const event of state.eventQueue)\n            root.dispatchEvent(event);\n\n        // Clear queue\n        state.eventQueue.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusChanged(_root: Root, _focusType: FocusType, _newFocus: Widget | null): void {}\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n","import { getPointerEventNormPos } from '../helpers/getPointerEventNormPos';\nimport { PointerDriver } from './PointerDriver';\nimport type { Root } from '../core/Root';\n\ninterface RootDOMBind {\n    domElem: HTMLElement,\n    pointermoveListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerdownListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerupListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerleaveListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n}\n\n/**\n * A {@link PointerDriver} which listens for pointer events from HTML DOM\n * elements. Each HTML DOM element is bound to a specific root, which synergizes\n * well with DOMRoot.\n *\n * @category Driver\n */\nexport class DOMPointerDriver extends PointerDriver {\n    /** The HTML DOM element and listeners that each root is bound to */\n    // XXX using weakmap so it auto-unbinds once a root stops existing\n    private domElems: WeakMap<Root, RootDOMBind> = new WeakMap();\n    /** The pointer ID of the mouse. Registered in constructor */\n    private mousePointerID: number; // TODO support multiple \"mouse\" pointers for multitouch\n\n    /**\n     * Create a new DOMPointerDriver.\n     *\n     * Automatically registers a pointer to be used by the mouse.\n     */\n    constructor() {\n        super();\n\n        this.mousePointerID = this.registerPointer();\n    }\n\n    /**\n     * Bind an HTML DOM element to a specific root.\n     *\n     * If the root was already registered, {@link removeListeners} is called.\n     * Populates {@link domElems} with the new bind. Calls {@link addListeners}\n     * if root is enabled.\n     */\n    bindDOMElem(root: Root, domElem: HTMLElement): void {\n        let rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.removeListeners(rootBind);\n        else {\n            rootBind = <RootDOMBind>{\n                domElem,\n                pointermoveListen: null,\n                pointerdownListen: null,\n                pointerupListen: null,\n                pointerleaveListen: null,\n            };\n            this.domElems.set(root, rootBind);\n        }\n\n        if(root.enabled)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Add pointer event listeners to root's DOM element.\n     */\n    private addListeners(root: Root, rootBind: RootDOMBind) {\n        // Make listeners for mouse events, queueing events. Add them to the\n        // root DOM bind so they can be removed later when needed\n        const domElem = rootBind.domElem;\n        rootBind.pointermoveListen = (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.movePointer(root, this.mousePointerID, ...getPointerEventNormPos(event, domElem));\n        }\n        rootBind.pointerdownListen = (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.movePointer(root, this.mousePointerID, ...getPointerEventNormPos(event, domElem), true);\n        }\n        rootBind.pointerupListen = (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.movePointer(root, this.mousePointerID, ...getPointerEventNormPos(event, domElem), false);\n        }\n        rootBind.pointerleaveListen = (event: PointerEvent) => {\n            if(event.isPrimary)\n                this.leavePointer(root, this.mousePointerID);\n        }\n\n        // Add listeners to DOM element\n        domElem.addEventListener('pointermove', rootBind.pointermoveListen);\n        domElem.addEventListener('pointerdown', rootBind.pointerdownListen);\n        domElem.addEventListener('pointerup', rootBind.pointerupListen);\n        domElem.addEventListener('pointerleave', rootBind.pointerleaveListen);\n    }\n\n    /**\n     * Remove pointer event listeners from root's DOM element and unset tracked\n     * listeners in root's bind.\n     */\n    private removeListeners(rootBind: RootDOMBind) {\n        if(rootBind.pointermoveListen !== null) {\n            rootBind.domElem.removeEventListener('pointermove', rootBind.pointermoveListen);\n            rootBind.pointermoveListen = null;\n        }\n        if(rootBind.pointerdownListen !== null) {\n            rootBind.domElem.removeEventListener('pointerdown', rootBind.pointerdownListen);\n            rootBind.pointerdownListen = null;\n        }\n        if(rootBind.pointerupListen !== null) {\n            rootBind.domElem.removeEventListener('pointerup', rootBind.pointerupListen);\n            rootBind.pointerupListen = null;\n        }\n        if(rootBind.pointerleaveListen !== null) {\n            rootBind.domElem.removeEventListener('pointerleave', rootBind.pointerleaveListen);\n            rootBind.pointerleaveListen = null;\n        }\n    }\n\n    /**\n     * Calls {@link PointerDriver.onEnable} and {@link addListeners} to each\n     * bound root.\n     */\n    override onEnable(root: Root): void {\n        super.onEnable(root);\n\n        // Add event listeners for pointer when root is enabled, if the root is\n        // bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Calls {@link PointerDriver.onDisable} and {@link removeListeners} to each\n     * bound root.\n     */\n    override onDisable(root: Root): void {\n        super.onDisable(root);\n\n        // Remove event listeners for pointer when root is disabled, if the root\n        // is bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.removeListeners(rootBind);\n    }\n}","import type { RayPointerSource } from './RayPointerSource';\nimport type { PointerHint } from './PointerHint';\nimport { PointerDriver } from './PointerDriver';\nimport { Root } from '../core/Root';\n\n/**\n * A {@link PointerDriver} which gets pointer events from raycasts in a 3D\n * engine's world. This is an abstract class and must be implemented. For an\n * example, see\n * [canvas-ui-three](https://github.com/playkostudios/canvas-ui-three)'s\n * ThreeRayPointerDriver implementation.\n *\n * @category Driver\n */\nexport abstract class RayPointerDriver extends PointerDriver {\n    /** The sources which this is assigned to */\n    protected readonly sources: Set<RayPointerSource> = new Set();\n\n    /**\n     * Cast a ray in the world and get which root was intersected and where.\n     *\n     * @param origin The world position where the ray is starting\n     * @param direction A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @returns Returns a 3-tuple containing, in this order, the intersected root or null if none intersected, the normalised x axis of the intersection and the normalised y axis of the intersection. If no root was intersected, use bogus values for x and y\n     */\n    protected abstract castRay(origin: [number, number, number], direction: [number, number, number]): [Root | null, number, number];\n\n    /**\n     * Receive a ray from a {@link RayPointerSource}.\n     *\n     * @param pointer The source's pointer ID, given when setting the source's sink\n     * @param pressing Is the pointer being pressed? If null, the previous pressing state is used\n     * @param origin The world position where the ray is starting\n     * @param direction A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     */\n    handlePointerRay(pointer: number, pressing: boolean | null, origin: [number, number, number], direction: [number, number, number]): void {\n        // Cast a ray and get the root that intersects with the ray and the\n        // intersection coordinates\n        const [root, xNorm, yNorm] = this.castRay(origin, direction);\n\n        // Queue a leave event if no root intersected, else, queue a move event\n        if(root === null)\n            this.leaveAnyPointer(pointer);\n        else\n            this.movePointer(root, pointer, xNorm, yNorm, pressing);\n    }\n\n    /** Add a source. Assigns itself to the given source. */\n    addSource(source: RayPointerSource): void {\n        if(!this.sources.has(source)) {\n            source.setRayPointerDriver(this);\n            this.sources.add(source);\n        }\n    }\n\n    protected override setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const changed = super.setPointerHint(pointer, hint);\n\n        // Call onPointerHintChanged handler for each source\n        for(const source of this.sources)\n            source.onPointerHintChanged(pointer, hint);\n\n        return changed;\n\n    }\n}\n","import type { ThemeProperty } from './ThemeProperty';\nimport { Theme } from './Theme';\n\n/**\n * A theme which always gives out a random fill colour. Used for debugging when\n * painting occurs. Has no properties but always has a fallback theme.\n *\n * @category Theme\n */\nexport class DebugTheme extends Theme {\n    /**\n     * Create a new DebugTheme instance.\n     *\n     * @param fallback The actual theme to use. Fill colors will be ignored as they are randomly generated. If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(fallback: Theme = new Theme()) {\n        super(new Map(), fallback);\n    }\n\n    override getFill(themeProperty: ThemeProperty): string {\n        // Always return a random fill color if the original method didn't throw\n        // an exception\n        void super.getFill(themeProperty);\n\n        return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n    }\n}\n","import type { Validator, UnknownValidator } from './Validator';\nimport { VariableCallback } from '../aggregates/Variable';\n\n/**\n * Creates a new {@link Validator} which is a list of validators merged into\n * one.\n *\n * @param validators The list of validators to be merged. The validators will be run in the order of the array.\n * @param defaultValue The bogus value that will be returned if the input is invalid\n * @param callback A callback which is called if validation succeeds. If null, no such callback will be called.\n * @template U The type of the input.\n * @template V The type of the output (the transformed input).\n *\n * @category Validator\n */\nexport function MakeCompositeValidator<U, V>(validators: Array<UnknownValidator>, defaultValue: V, callback: VariableCallback<V> | null = null): Validator<U, V> {\n    // TODO there must be a better way to do this which preserves type checking.\n    // maybe make Validator a class which can be chained with other validators?\n    return (value: U): [boolean, V] => {\n        let valid = true;\n        let nextValue: unknown = value;\n\n        for(const validator of validators) {\n            [valid, nextValue] = validator(nextValue);\n            if(!valid)\n                return [false, defaultValue];\n        }\n\n        if(callback !== null) {\n            try {\n                callback(nextValue as V);\n            }\n            catch(e) {\n                console.warn('Exception in CompositeValidator callback:', e);\n            }\n        }\n\n        return [true, nextValue as V];\n    };\n}","import type { VariableCallback } from '../aggregates/Variable';\nimport type { TextValidator } from './Validator';\n\n/**\n * A {@link TextValidator} which does nothing. Always reports a string as valid\n * and returns the input as the transformed input.\n *\n * @category Validator\n */\nexport function DefaultTextValidator(text: string): [boolean, string] {\n    return [true, text];\n}\n\n/**\n * Create a new {@link TextValidator} which calls a given callback. Always\n * reports a string as valid and returns the input as the transformed input,\n * like {@link DefaultTextValidator}.\n *\n * Note that this is only useful if a callback is supplied. If null is given as\n * the callback, then this will simply return {@link DefaultTextValidator}.\n *\n * @category Validator\n */\nexport function MakeDefaultTextValidatorWithCallback(callback: VariableCallback<string> | null = null): TextValidator<string> {\n    if(callback === null)\n        return DefaultTextValidator;\n\n    return (text: string): [boolean, string] => {\n        callback(text);\n        return [true, text];\n    }\n}","const floatRegex = /^-?(\\.\\d+|\\d+(\\.(\\d+)?)?)(e\\d+)?$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * number. If valid, then it transforms the input string into a float.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function FloatValidator(text: string): [boolean, number] {\n    if(!floatRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseFloat(text)];\n}","const intRegex = /^-?\\d+$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * integer. If valid, then it transforms the input string into an integer.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function IntValidator(text: string): [boolean, number] {\n    if(!intRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseInt(text)];\n}","import type { Validator } from './Validator';\n\n/**\n * Creates a {@link Validator} which checks whether an input value is within a\n * specified exclusive range (can't be an inclusive range), always returning the\n * original input value.\n *\n * @template V The type of the input (and output, since it is unchanged).\n *\n * @category Validator\n */\nexport function MakeRangeValidator<V>(min: V, max: V): Validator<V, V> {\n    // TODO make a system for inclusive ranges\n    return (value: V): [boolean, V] => {\n        if(value < min)\n            return [false, value];\n\n        if(value > max)\n            return [false, value];\n\n        return [true, value];\n    };\n}","import type { TextValidator } from '../validators/Validator';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport { TextHelper } from '../aggregates/TextHelper';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { Variable } from '../aggregates/Variable';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A flexbox widget that allows for a single line of text input.\n *\n * Supports obscuring the text with {@link hideText}, which shows all characters\n * as black circles like in password fields, text validation and toggling\n * editing.\n *\n * If a {@link TextInputHandler} is set, then that will be used instead of\n * keyboard input for mobile compatibility.\n *\n * @template V The type of {@link value}; the type of the transformed value returned by the validator.\n *\n * @category Widget\n */\nexport class TextInput<V> extends Widget {\n    /**\n     * At what timestamp did the blinking start. If 0, then the text cursor is\n     * not blinking.\n     */\n    private blinkStart = 0;\n    /**\n     * Was the cursor shown last frame due to blinking? If null, then the text\n     * cursor is not blinking.\n     */\n    private blinkWasOn: boolean | null = null;\n    /** Current cursor position (index, not offset). */\n    private cursorPos = 0;\n    /** Current cursor offset in pixels. */\n    private cursorOffset = 0;\n    /** Does the cursor offset need to be updated? */\n    private cursorOffsetDirty = false;\n    /** Is editing enabled? */\n    private _editingEnabled = true;\n    /** Is the text hidden? */\n    private _hideText = false;\n    /** Is the text valid? */\n    private _valid;\n    /** Last valid value. */\n    private _validValue;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /** The helper for keeping track of the input value */\n    protected variable: Variable<string>;\n\n    /** Create a new TextInput. */\n    constructor(validator: TextValidator<V>, initialValue = '', themeOverride: Theme | null = null) {\n        // TextInputs clear their own background, have no children and don't\n        // propagate events\n        super(themeOverride, false, false);\n\n        this.textHelper = new TextHelper();\n        this.variable = new Variable<string>(initialValue, (text: string) => {\n            const [valid, validatedValue] = validator(text);\n\n            if(valid)\n                this._validValue = validatedValue;\n\n            if(valid !== this._valid) {\n                this._valid = valid;\n                this._dirty = true;\n            }\n        });\n        [this._valid, this._validValue] = validator(initialValue);\n    }\n\n    /**\n     * Is the text cursor shown?\n     *\n     * @returns Returns true if the text cursor is shown, false if not shown but the text input is in use, or null if the text cursor is not shown due to the text input not being in use.\n     */\n    get blinkOn(): boolean | null {\n        if(this.blinkStart === 0)\n            return null;\n\n        const blinkRate = this.theme.getNumber(ThemeProperty.BlinkRate);\n        return Math.trunc(((Date.now() - this.blinkStart) / (500 * blinkRate)) % 2) === 0;\n    }\n\n    /**\n     * Is editing enabled?\n     *\n     * Tied to {@link _editingEnabled}. If changed, {@link _dirty} is set to\n     * true. If disabled, blinking stops and the cursor position is reset to the\n     * beginning.\n     */\n    get editingEnabled(): boolean {\n        return this._editingEnabled;\n    }\n\n    set editingEnabled(editingEnabled: boolean) {\n        if(this._editingEnabled !== editingEnabled) {\n            this._editingEnabled = editingEnabled;\n\n            // Disable blinking and reset cursor position if disabled\n            if(!editingEnabled) {\n                this.blinkStart = 0;\n                this.moveCursorTo(0);\n            }\n\n            // Mark as dirty; the text color changes\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Is the text hidden?\n     *\n     * Tied to {@link _hideText}. If changed, {@link _dirty} and\n     * {@link cursorOffsetDirty} are set to true.\n     */\n    get hideText(): boolean {\n        return this._hideText;\n    }\n\n    set hideText(hideText: boolean) {\n        if(this._hideText !== hideText) {\n            this._hideText = hideText;\n\n            // Mark as dirty and cursor offset as dirty; the text is\n            // (de)obfuscated\n            this.cursorOffsetDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /** The current text value. */\n    set text(text: string) {\n        this.variable.value = text;\n    }\n\n    get text(): string {\n        return this.variable.value;\n    }\n\n    /**\n     * Get the text as it is shown. If the text is hidden, all characters are\n     * replaced with a black circle.\n     */\n    get displayedText(): string {\n        if(this._hideText)\n            return ''.repeat(this.variable.value.length);\n        else\n            return this.variable.value;\n    }\n\n    /** Is the current value in the text input valid? */\n    get valid(): boolean {\n        return this._valid;\n    }\n\n    /** The last valid value, transformed by the validator. */\n    get validValue(): V {\n        return this._validValue;\n    }\n\n    /** The current minimum text width. */\n    set minWidth(minWidth: number) {\n        this.textHelper.minWidth = minWidth;\n    }\n\n    get minWidth(): number {\n        return this.textHelper.minWidth;\n    }\n\n    /** The current minimum text ascent height. */\n    set minAscent(minAscent: number) {\n        this.textHelper.minAscent = minAscent;\n    }\n\n    get minAscent(): number {\n        return this.textHelper.minAscent;\n    }\n\n    /** The current minimum text descent height. */\n    set minDescent(minDescent: number) {\n        this.textHelper.minDescent = minDescent;\n    }\n\n    get minDescent(): number {\n        return this.textHelper.minDescent;\n    }\n\n    /**\n     * Move the cursor to a given index.\n     *\n     * Sets {@link _dirty} and {@link cursorOffsetDirty} to true.\n     */\n    moveCursorTo(index: number): void {\n        // Update cursor position, checking for boundaries\n        this.cursorPos = Math.min(Math.max(index, 0), this.text.length);\n\n        // Update cursor offset\n        this.cursorOffsetDirty = true;\n        this._dirty = true;\n    }\n\n    /**\n     * Move the cursor by a given index delta. Calls {@link moveCursorTo}\n     *\n     * @param delta The change in index; if a positive number, the cursor will be moved right by that amount, else, the cursor will be moved left by that amount.\n     */\n    moveCursor(delta: number): void {\n        this.moveCursorTo(this.cursorPos + delta);\n    }\n\n    /**\n     * Insert text at the current cursor index. Calls {@link moveCursorTo}\n     * afterwards.\n     */\n    insertText(str: string): void {\n        // Insert string in current cursor position\n        this.text = this.text.substring(0, this.cursorPos) + str + this.text.substring(this.cursorPos);\n        // Move cursor neccessary amount forward\n        this.moveCursor(str.length);\n    }\n\n    /**\n     * Deletes a certain amount of characters in a given direction from the\n     * current cursor index. Calls {@link moveCursorTo} afterwards if\n     * neccessary.\n     *\n     * @param delta The amount and direction of the deletion. For example, if 5, then 5 characters are deleted after the cursor. If -5, then 5 characters are deleted before the cursor and the cursor is moved 5 indices left.\n     */\n    deleteText(delta: number): void {\n        // Delete characters forwards if delta is positive, backwards if delta\n        // is negative. Deleting characters backwards results in moving the\n        // cursor\n        if(delta > 0)\n            this.text = this.text.substring(0, this.cursorPos) + this.text.substring(this.cursorPos + delta);\n        else if(delta < 0) {\n            // NOTE, still checking if delta < 0 so that nothing is done if\n            // delta is 0\n            this.text = this.text.substring(0, this.cursorPos + delta) + this.text.substring(this.cursorPos);\n            this.moveCursor(delta);\n        }\n    }\n\n    override onFocusDropped(focusType: FocusType, _root: Root): void {\n        // Stop blinking cursor if keyboard focus lost\n        if(focusType === FocusType.Keyboard)\n            this.blinkStart = 0;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this {\n        // If editing is disabled, abort\n        if(!this._editingEnabled)\n            return this;\n\n        if(event instanceof PointerEvent) {\n            // If this is a pointer event, set pointer style and handle clicks\n            root.pointerStyle = 'text';\n\n            // Request keyboard focus if this is a pointer press\n            if(event instanceof PointerPress) {\n                // Update cursor position (and offset) from click position\n                const padding = this.theme.getNumber(ThemeProperty.InputTextInnerPadding);\n                [this.cursorPos, this.cursorOffset] = this.textHelper.findIndexOffsetFromOffset(event.x - padding);\n\n                // Start blinking cursor and mark component as dirty, to\n                // make sure that cursor blink always resets for better\n                // feedback\n                this.blinkStart = Date.now();\n                this._dirty = true;\n\n                // Request focus\n                root.requestFocus(FocusType.Keyboard, this);\n            }\n            // Get mobile-friendly text input if available\n            else if(event instanceof PointerRelease && root.hasMobileTextInput) {\n                root.getTextInput(this.text).then((newValue: string | null) => {\n                    if(newValue === null)\n                        return;\n\n                    if(this.text !== newValue) {\n                        this.text = newValue;\n                        this.moveCursorTo(newValue.length);\n                    }\n                });\n            }\n\n            return this;\n        }\n        else if(event instanceof KeyPress) {\n            // If this is a key press, do the key's action\n            if(event.key.length === 1)\n                this.insertText(event.key); // Insert character\n            else if(event.key === 'Backspace')\n                this.deleteText(-1); // Delete backwards\n            else if(event.key === 'Delete')\n                this.deleteText(1); // Delete forwards\n            else if(event.key === 'ArrowLeft')\n                this.moveCursor(-1); // Move cursor left\n            else if(event.key === 'ArrowRight')\n                this.moveCursor(1); // Move cursor right\n            else if(event.key === 'Home')\n                this.moveCursorTo(0); // Move cursor to beginning\n            else if(event.key === 'End')\n                this.moveCursorTo(this.text.length); // Move cursor to end\n            else if(event.key === 'Escape') {\n                root.dropFocus(FocusType.Keyboard, this); // Drop focus\n                return this;\n            }\n            else\n                return this; // Ignore key if it is unknown\n\n            // Reset blink time for better feedback\n            this.blinkStart = Date.now();\n        }\n\n        return this;\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Drop focus if editing is disabled\n        if(!this.editingEnabled)\n            root.dropFocus(FocusType.Keyboard, this);\n\n        // Mark as dirty when a blink needs to occur\n        if(this.blinkOn !== this.blinkWasOn)\n            this._dirty = true;\n\n        // Update TextHelper variables\n        this.textHelper.text = this.displayedText;\n        this.textHelper.font = this.theme.getFont(ThemeProperty.InputTextFont);\n        this.textHelper.minWidth = this.theme.getNumber(ThemeProperty.InputTextMinWidth);\n        this.textHelper.minAscent = this.theme.getNumber(ThemeProperty.InputTextMinAscent);\n        this.textHelper.minDescent = this.theme.getNumber(ThemeProperty.InputTextMinDescent);\n\n        if(this.cursorOffsetDirty) {\n            this.cursorOffset = this.textHelper.findOffsetFromIndex(this.cursorPos);\n            this.cursorOffsetDirty = false;\n        }\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Expand as much as possible if constrained, else, only expand to the\n        // needed dimensions\n        const padding = 2 * this.theme.getNumber(ThemeProperty.InputTextInnerPadding);\n        if(maxWidth !== Infinity)\n            this.width = maxWidth;\n        else\n            this.width = Math.max(minWidth, this.textHelper.width + padding);\n\n        if(maxHeight !== Infinity)\n            this.height = maxHeight;\n        else\n            this.height = Math.max(minHeight, this.textHelper.height + padding);\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // TODO scrolling\n        // Paint background\n        ctx.fillStyle = this.theme.getFill(ThemeProperty.InputBackgroundFill);\n        ctx.fillRect(x, y, this.width, this.height);\n\n        // Paint current text value\n        ctx.font = this.theme.getFont(ThemeProperty.InputTextFont);\n        if(this._editingEnabled) {\n            if(this._valid)\n                ctx.fillStyle = this.theme.getFill(ThemeProperty.InputTextFill);\n            else\n                ctx.fillStyle = this.theme.getFill(ThemeProperty.InputTextFillInvalid);\n        }\n        else\n            ctx.fillStyle = this.theme.getFill(ThemeProperty.InputTextFillDisabled);\n\n        const padding = this.theme.getNumber(ThemeProperty.InputTextInnerPadding);\n        ctx.fillText(this.displayedText, x + padding, y + this.height - this.textHelper.descent - padding);\n\n        // Paint blink\n        const blinkOn = this.blinkOn;\n        this.blinkWasOn = blinkOn;\n        if(!blinkOn)\n            return;\n\n        const cursorThickness = this.theme.getNumber(ThemeProperty.CursorThickness);\n        ctx.fillRect(\n            x + this.cursorOffset,\n            y + padding,\n            cursorThickness,\n            this.height - padding * 2,\n        );\n    }\n}\n","import { MakeDefaultTextValidatorWithCallback } from '../validators/DefaultTextValidator';\nimport type { VariableCallback } from '../aggregates/Variable';\nimport type { Theme } from \"../theme/Theme\";\nimport { TextInput } from \"./TextInput\";\n\n/**\n * A {@link TextInput} with an optional callback and no validation.\n *\n * @category Widget\n */\nexport class BasicTextInput extends TextInput<string> {\n    /**\n     * Create a new BasicTextInput.\n     *\n     * Equivalent to creating a new {@link TextInput} instance with a validator\n     * created by {@link MakeDefaultTextValidatorWithCallback}.\n     *\n     * @param callback An optional callback called when the text changes. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<string> | null = null, initialValue = '', themeOverride: Theme | null = null) {\n        const validator = MakeDefaultTextValidatorWithCallback(callback);\n        super(validator, initialValue, themeOverride);\n    }\n}\n","import { ThemeProperty } from '../theme/ThemeProperty';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport type { Padding } from '../theme/Padding';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\n\n/**\n * A {@link Container} with center alignment on both axes and no padding.\n *\n * Can be constrained to a specific type of children.\n *\n * Padding and alignment settings are applied via theme overrides, so no theme\n * override can be passed to this widget. If you want to override additional\n * theme properties other than the ones overridden here, then use\n * {@link Container} instead.\n *\n * @category Widget\n */\nexport class Center<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Center. */\n    constructor(child: W) {\n        const themeOverride = new Theme(new Map<ThemeProperty, unknown>([\n            [\n                ThemeProperty.ContainerAlignment,\n                <Alignment2D>{\n                    horizontal: Alignment.Center, vertical: Alignment.Center,\n                },\n            ],\n            [\n                ThemeProperty.ContainerPadding,\n                <Padding>{\n                    left: 0, right: 0, top: 0, bottom: 0,\n                },\n            ],\n        ]));\n\n        super(child, themeOverride);\n    }\n}\n","import { Variable, VariableCallback } from '../aggregates/Variable';\nimport { ClickHelper, ClickState } from '../aggregates/ClickHelper';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A checkbox widget; can be ticked or unticked.\n *\n * @category Widget\n */\nexport class Checkbox extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper for handling pointer clicks */\n    protected clickHelper: ClickHelper;\n    /** The helper for keeping track of the checkbox value */\n    protected variable: Variable<boolean>;\n\n    /**\n     * Create a new Checkbox.\n     *\n     * @param callback An optional callback called when the checkbox is ticked or unticked. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<boolean> | null = null, initialValue = false, themeOverride: Theme | null = null) {\n        // Checkboxes need a clear background, have no children and don't\n        // propagate events\n        super(themeOverride, true, false);\n\n        // Save callback and initial value\n        this.variable = new Variable<boolean>(initialValue, callback);\n\n        // Setup click helper\n        this.clickHelper = new ClickHelper(this);\n    }\n\n    /** Is the checkbox checked? */\n    set checked(checked: boolean) {\n        this.variable.value = checked;\n    }\n\n    get checked(): boolean {\n        return this.variable.value;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this {\n        // Check if checkbox rectangle was pressed and swap value if so\n        this.clickHelper.handleClickEvent(\n            event,\n            root,\n            [this.offsetX, this.actualLength, this.offsetY, this.actualLength],\n        );\n\n        if(this.clickHelper.clickStateChanged && this.clickHelper.wasClick)\n            this.checked = !this.checked;\n\n        return this;\n    }\n\n    protected override handlePreLayoutUpdate(_root: Root): void {\n        // Mark as dirty if variable is dirty\n        if(this.variable.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find actual length\n        const length = this.theme.getNumber(ThemeProperty.CheckboxLength);\n        this.actualLength = Math.min(length, maxWidth, maxHeight);\n\n        // Resolve width and height\n        this.width = this.actualLength;\n        this.height = this.actualLength;\n\n        if(this.width < minWidth)\n            this.width = minWidth;\n        if(this.height < minHeight)\n            this.height = minHeight;\n\n        // Center checkbox\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of checkbox\n        if(useGlow)\n            ctx.fillStyle = this.theme.getFill(ThemeProperty.BackgroundGlowFill);\n        else\n            ctx.fillStyle = this.theme.getFill(ThemeProperty.BackgroundFill);\n\n        ctx.fillRect(\n            this.offsetX, this.offsetY, this.actualLength, this.actualLength,\n        );\n\n        // Draw checked part of checkbox\n        if(this.checked) {\n            if(useGlow)\n                ctx.fillStyle = this.theme.getFill(ThemeProperty.AccentFill);\n            else\n                ctx.fillStyle = this.theme.getFill(ThemeProperty.PrimaryFill);\n\n            const innerPadding = this.theme.getNumber(ThemeProperty.CheckboxInnerPadding);\n            const innerLength = this.actualLength - innerPadding * 2;\n\n            // Fall back to filling entire checkbox if there isn't enougn space\n            // for padding\n            if(innerLength <= 0) {\n                ctx.fillRect(\n                    x + this.offsetX,\n                    y + this.offsetY,\n                    this.actualLength,\n                    this.actualLength,\n                );\n            }\n            else {\n                ctx.fillRect(\n                    x + this.offsetX + innerPadding,\n                    y + this.offsetY + innerPadding,\n                    innerLength,\n                    innerLength,\n                );\n            }\n        }\n    }\n}\n","import type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A widget which displays a given image.\n *\n * @category Widget\n */\nexport class Icon extends Widget {\n    /** The current image used by the icon. */\n    private _image: HTMLImageElement;\n    /**\n     * The last source that the current image was using. Used for tracking if\n     * the image source changed and if the image is fully loaded.\n     */\n    private lastSrc: string | null = null;\n    /** The current image rotation in radians. */\n    private _rotation = 0;\n    /**\n     * The view box of this Icon, useful if the image used for the icon is a\n     * spritesheet. If null, the entire image will be used.\n     */\n    viewBox: [number, number, number, number] | null;\n    /** See {@link imageWidth}. For internal use only */\n    private _imageWidth: number | null;\n    /** See {@link imageHeight}. For internal use only */\n    private _imageHeight: number | null;\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual image width */\n    private actualWidth = 0;\n    /** Actual image height */\n    private actualHeight = 0;\n\n    /** Create a new Icon. */\n    constructor(image: HTMLImageElement, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, themeOverride: Theme | null = null) {\n        // Icons need a clear background, have no children and don't propagate\n        // events\n        super(themeOverride, true, false);\n\n        this._image = image;\n        this._imageWidth = width;\n        this._imageHeight = height;\n        this.viewBox = viewBox;\n    }\n\n    /**\n     * The image used by this Icon.\n     *\n     * Sets {@link _image} if changed and sets {@link lastSrc} to null to mark\n     * the image as loading so that flickers are minimised.\n     *\n     * If getting, returns {@link _image}.\n     */\n    set image(image: HTMLImageElement) {\n        if(image !== this._image) {\n            this._image = image;\n            this.lastSrc = null;\n        }\n    }\n\n    get image(): HTMLImageElement {\n        return this._image;\n    }\n\n    /**\n     * The wanted width. If null, the image's width will be used, taking\n     * {@link viewBox} into account.\n     */\n    get imageWidth(): number | null {\n        return this._imageWidth;\n    }\n\n    set imageWidth(imageWidth: number | null) {\n        if(this._imageWidth !== imageWidth) {\n            this._imageWidth = imageWidth;\n            this._layoutDirty = true;\n        }\n    }\n\n    /**\n     * The wanted height. If null, the image's height will be used, taking\n     * {@link viewBox} into account.\n     */\n    get imageHeight(): number | null {\n        return this._imageHeight;\n    }\n\n    set imageHeight(imageHeight: number | null) {\n        if(this._imageHeight !== imageHeight) {\n            this._imageHeight = imageHeight;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePreLayoutUpdate(_root: Root): void {\n        // Icons only needs to be re-drawn if image changed, which is tracked by\n        // the image setter, or if the source changed, but not if the icon isn't\n        // loaded yet\n        if(this._image?.src !== this.lastSrc && this._image?.complete)\n            this._dirty = true;\n\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find dimensions\n        let wantedWidth = this._imageWidth;\n        if(wantedWidth === null) {\n            if(this.viewBox === null)\n                wantedWidth = this._image.width;\n            else\n                wantedWidth = this.viewBox[2];\n        }\n\n        this.width = Math.max(Math.min(wantedWidth, maxWidth), minWidth);\n\n        let wantedHeight = this._imageHeight;\n        if(wantedHeight === null) {\n            if(this.viewBox === null)\n                wantedHeight = this._image.height;\n            else\n                wantedHeight = this.viewBox[3];\n        }\n\n        this.height = Math.max(Math.min(wantedHeight, maxHeight), minHeight);\n\n        // Find offset and actual image dimensions (preserving aspect ratio)\n        const widthRatio = this.width / wantedWidth;\n        const heightRatio = this.height / wantedHeight;\n        const scale = Math.min(widthRatio, heightRatio);\n        this.actualWidth = wantedWidth * scale;\n        this.actualHeight = wantedHeight * scale;\n        this.offsetX = (this.width - this.actualWidth) / 2;\n        this.offsetY = (this.height - this.actualHeight) / 2;\n    }\n\n    /**\n     * This icon's rotation. Useful for implementing spinners.\n     *\n     * Sets {@link _rotation} if changed and sets {@link _dirty} to true.\n     *\n     * If getting, returns {@link _rotation}.\n     */\n    set rotation(rotation: number) {\n        if(rotation !== this._rotation) {\n            this._rotation = rotation;\n            this._dirty = true;\n        }\n    }\n\n    get rotation(): number {\n        return this._rotation;\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Abort if icon isn't ready yet\n        if(!this._image?.complete) {\n            this.lastSrc = null;\n            return;\n        }\n\n        // Mark as not needing to be drawn by setting the source\n        this.lastSrc = this._image.src;\n\n        // Translate and rotate if rotation is not 0\n        let tdx = this.offsetX, tdy = this.offsetY;\n        if(this.rotation !== 0) {\n            ctx.save();\n            ctx.translate(\n                x + this.offsetX + this.actualWidth / 2,\n                y + this.offsetY + this.actualHeight / 2,\n            );\n            tdx = -this.actualWidth / 2;\n            tdy = -this.actualHeight / 2;\n            ctx.rotate(this.rotation);\n        }\n\n        // Draw image, with viewBox if it is not null\n        if(this.viewBox === null) {\n            ctx.drawImage(\n                this._image,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n        else {\n            ctx.drawImage(\n                this._image, ...this.viewBox,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n\n        // Revert transformation\n        if(this.rotation !== 0)\n            ctx.restore();\n    }\n}\n","import type { Theme } from '../theme/Theme';\nimport { Button } from './Button';\nimport { Margin } from './Margin';\nimport { Icon } from './Icon';\n\n/**\n * A {@link Button} with an {@link Icon} inside a {@link Margin}.\n *\n * @category Widget\n */\nexport class IconButton extends Button<Margin<Icon>> {\n    /** Create a new IconButton. */\n    constructor(image: HTMLImageElement, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, callback: (() => void) | null = null, themeOverride: Theme | null = null) {\n        super(\n            new Margin(\n                new Icon(image, width, height, viewBox, themeOverride),\n            ),\n            callback, themeOverride\n        );\n    }\n\n    /** This button's Icon widget */\n    get icon(): Icon {\n        return this.child.child;\n    }\n}\n","import type { Theme } from '../theme/Theme';\nimport { Widget } from './Widget';\n\n/**\n * A widget with empty space.\n *\n * Will always try to expand if the layout is constrained, so make sure to set\n * flex or pass it along the constructor\n *\n * @category Widget\n */\nexport class Spacing extends Widget {\n    /** The minimum width this will try to expand */\n    minWidth: number;\n    /** The minimum height this will try to expand */\n    minHeight: number;\n\n    /** Create a new Spacing. */\n    constructor(flex = 1, minWidth = 0, minHeight = 0, themeOverride: Theme | null = null) {\n        // Spacing needs clear, never has children and doesn't propagate events\n        super(themeOverride, true, false);\n\n        this.flex = flex;\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Try to expand each axis. If axis is not constrained (can't expand),\n        // then try to use the biggest minimum length\n        if(maxWidth !== Infinity)\n            this.width = maxWidth;\n        else\n            this.width = Math.max(minWidth, this.minWidth);\n\n        if(maxHeight !== Infinity)\n            this.height = maxHeight;\n        else\n            this.height = Math.max(minHeight, this.minHeight);\n    }\n}\n","import type { VariableCallback } from '../aggregates/Variable';\nimport type { Theme } from '../theme/Theme';\nimport type { TextGetter } from './Label';\nimport { Checkbox } from './Checkbox';\nimport { Spacing } from './Spacing';\nimport { Label } from './Label';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a {@link Checkbox}.\n *\n * @category Widget\n */\nexport class LabelledCheckbox extends Row {\n    constructor(text: string | TextGetter, callback: VariableCallback<boolean> | null = null, initialValue = false, themeOverride: Theme | null = null) {\n        super(themeOverride);\n\n        this.add([\n            new Label(text, themeOverride),\n            new Spacing(1, 0, 0, themeOverride),\n            new Checkbox(callback, initialValue, themeOverride),\n        ]);\n    }\n}\n","import { ThemeProperty } from '../theme/ThemeProperty';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport { Viewport } from '../core/Viewport';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\n\n/**\n * A type of container widget which is allowed to be bigger or smaller than its\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * Allows setting the offset of the child, automatically clips it if neccessary.\n * Otherwise acts like a {@link Container}. Implemented by using a\n * {@link Viewport}; effectively, the child widget is painted to a dedicated\n * canvas.\n *\n * @category Widget\n */\nexport class ViewportWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** See {@link widthTied}. For internal use only */\n    private _widthTied: boolean;\n    /** See {@link heightTied}. For internal use only */\n    private _heightTied: boolean;\n    /** See {@link minWidth}. For internal use only */\n    private _minWidth = 0;\n    /** See {@link minHeight}. For internal use only */\n    private _minHeight = 0;\n    /** The actual viewport object. */\n    private viewport: Viewport;\n    /** See {@link offset}. For internal use only */\n    private _offset: [number, number] = [0, 0];\n\n    /** Create a new ViewportWidget. */\n    constructor(child: W, widthTied = false, heightTied = false, themeOverride: Theme | null = null) {\n        // Viewport clears its own background, has a single child and propagates\n        // events\n        super(child, themeOverride, false, true);\n\n        this.viewport = new Viewport();\n        this._widthTied = widthTied;\n        this._heightTied = heightTied;\n    }\n\n    /**\n     * Get {@link viewport}'s\n     * {@link Viewport.canvasDimensions | canvasDimensions}.\n     */\n    get canvasDimensions(): [number, number] {\n        return this.viewport.canvasDimensions;\n    }\n\n    /**\n     * Offset of {@link child}. Positional events will take this into account,\n     * as well as rendering. Useful for implementing scrolling.\n     */\n    get offset(): [number, number] {\n        return [...this._offset];\n    }\n\n    set offset(offset: [number, number]) {\n        if(this._offset[0] !== offset[0] || this._offset[1] !== offset[1]) {\n            this._offset[0] = offset[0];\n            this._offset[1] = offset[1];\n            this._dirty = true;\n        }\n    }\n\n    /** The {@link Viewport.constraints | Viewport's constraints}. */\n    set constraints(constraints: [number, number, number, number]) {\n        this.viewport.constraints = constraints;\n    }\n\n    get constraints(): [number, number, number, number] {\n        return this.viewport.constraints;\n    }\n\n    /**\n     * Is the width tied to the child's? If true, width constraints will be\n     * overridden.\n     */\n    get widthTied(): boolean {\n        return this._widthTied;\n    }\n\n    set widthTied(widthTied: boolean) {\n        if(this._widthTied !== widthTied) {\n            this._widthTied = widthTied;\n            this._layoutDirty = true;\n        }\n    }\n\n    /**\n     * Is the height tied to the child's? If true, height constraints will be\n     * overridden.\n     */\n    get heightTied(): boolean {\n        return this._heightTied;\n    }\n\n    set heightTied(heightTied: boolean) {\n        if(this._heightTied !== heightTied) {\n            this._heightTied = heightTied;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** The minimum width that this widget will try to expand to. */\n    get minWidth(): number {\n        return this._minWidth;\n    }\n\n    set minWidth(minWidth: number) {\n        if(this._minWidth !== minWidth) {\n            this._minWidth = minWidth;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** The minimum height that this widget will try to expand to. */\n    get minHeight(): number {\n        return this._minHeight;\n    }\n\n    set minHeight(minHeight: number) {\n        if(this._minHeight !== minHeight) {\n            this._minHeight = minHeight;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Ignore events with no position and no target\n        if(event.target === null && !(event instanceof PointerEvent))\n            return null;\n\n        // Drop event if it is a positional event with no target outside the\n        // child's viewport\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const vpl = this.offset[0];\n        const vpr = vpl + innerWidth;\n        const vpt = this.offset[1];\n        const vpb = vpt + innerHeight;\n        if(event instanceof PointerEvent) {\n            if(event.target === null) {\n                if(event.x < vpl)\n                    return null;\n                if(event.x >= vpr)\n                    return null;\n                if(event.y < vpt)\n                    return null;\n                if(event.y >= vpb)\n                    return null;\n            }\n\n            event = event.correctOffset(vpl, vpt);\n        }\n\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        const child = this.child;\n\n        // Pre-layout update child\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        const child = this.child;\n\n        // Post-layout update child\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n\n        // If child's layout is dirty and at least one of the axes are tied,\n        // propagate layout dirtiness. Try to resolve layout if no axis is tied.\n        const tied = this._widthTied || this._heightTied;\n        if(child.layoutDirty && tied)\n            this._layoutDirty = true;\n        else if(!tied)\n            this.viewport.resolveChildsLayout(child);\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        let normalWidth = true, normalHeight = true;\n        const actualMinWidth = Math.min(Math.max(minWidth, this._minWidth), maxWidth);\n        const actualMinHeight = Math.min(Math.max(minHeight, this._minHeight), maxHeight);\n\n        if(this._widthTied || this._heightTied) {\n            // Resolve child's layout\n            const constraints = this.viewport.constraints;\n\n            if(this._widthTied) {\n                constraints[0] = minWidth;\n                constraints[1] = maxWidth;\n            }\n\n            if(this._heightTied) {\n                constraints[2] = minHeight;\n                constraints[3] = maxHeight;\n            }\n\n            const child = this.child;\n            this.viewport.constraints = constraints;\n            this.viewport.resolveChildsLayout(child);\n\n            // Tie wanted axes. Do regular layout for non-tied axes.\n            if(this._widthTied) {\n                this.width = child.dimensions[0];\n                normalWidth = false;\n            }\n\n            if(this._heightTied) {\n                this.height = child.dimensions[1];\n                normalHeight = false;\n            }\n        }\n\n        // Expand as much as possible if constrained, else, only expand to the\n        // needed dimensions\n        if(normalWidth)\n            this.width = (maxWidth !== Infinity) ? maxWidth : actualMinWidth;\n\n        if(normalHeight)\n            this.height = (maxHeight !== Infinity) ? maxHeight : actualMinHeight;\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Paint child to viewport's canvas\n        this.viewport.paintToCanvas(this.child);\n\n        // Save context\n        ctx.save();\n\n        // Clip to drawing area\n        // These are rounded because clipping and filling doesn't work properly\n        // with decimal points\n        const drawAreaClip = new Path2D();\n        drawAreaClip.rect(Math.trunc(x), Math.trunc(y), Math.ceil(this.width), Math.ceil(this.height));\n        ctx.clip(drawAreaClip);\n\n        // Clear background\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = this.theme.getFill(ThemeProperty.CanvasFill);\n        ctx.fill(drawAreaClip);\n\n        // Draw canvas with offset in passed context\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const [xOffset, yOffset] = this.offset;\n        const xDst = x + xOffset;\n        const yDst = y + yOffset;\n        const offsetClip = new Path2D();\n        offsetClip.rect(Math.trunc(xDst), Math.trunc(yDst), Math.ceil(innerWidth), Math.ceil(innerHeight));\n        ctx.clip(offsetClip);\n        ctx.drawImage(\n            this.viewport.canvas,\n            0,\n            0,\n            innerWidth,\n            innerHeight,\n            xDst,\n            yDst,\n            innerWidth,\n            innerHeight,\n        );\n\n        // Restore context\n        ctx.restore();\n    }\n}","import { ViewportWidget } from './ViewportWidget';\nimport type { Widget } from './Widget';\n\n/**\n * A wrapper for a {@link ViewportWidget} which can be scrolled with\n * {@link ScrollBar}.\n *\n * Can be constrained to a specific type of children.\n *\n * To avoid an ugly looking layout, scrollbars are automatically hidden if they\n * are not needed. However, you can only tell if a scrollbar is needed after\n * layout is resolved. This creates problems, because scrollbars also contribute\n * to the layout, resulting in scrollbar hiding/showing being one frame late and\n * potentially introducing flickering. An alternative will be provided in the\n * future, but for now, use {@link vScrollHide} and {@link hScrollHide} to\n * force-hide each scrollbar if you know they aren't needed to avoid flickering\n * or other layout issues.\n *\n * @category Widget\n */\nexport class ScrollableViewportWidget<W extends Widget = Widget> extends ViewportWidget<W> {\n    // TODO\n}","import { Variable, VariableCallback } from '../aggregates/Variable';\nimport { ClickHelper, ClickState } from '../aggregates/ClickHelper';\nimport { ThemeProperty } from '../theme/ThemeProperty';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A slider flexbox widget; can slide a numeric value from an inclusive minimum\n * value to an inclusive maximum value, with optional snapping along set\n * increments.\n *\n * Note that sliders can only be horizontal.\n *\n * @category Widget\n */\nexport class Slider extends Widget {\n    /** The slider's minimum value. */\n    private minValue: number;\n    /** The slider's maximum value. */\n    private maxValue: number;\n    /**\n     * The increments in which the slider changes value. If 0, there are no\n     * fixed increments.\n     */\n    private snapIncrement: number;\n    /** The helper for handling pointer clicks/drags */\n    protected clickHelper: ClickHelper;\n    /** The helper for keeping track of the slider's value */\n    protected variable: Variable<number>;\n    /** Is this a vertical slider? */\n    protected readonly vertical: boolean;\n    /** The horizontal offset of the slider */\n    private offsetX = 0;\n    /** The vertical offset of the slider */\n    private offsetY = 0;\n    /** The actual width of the slider */\n    private actualWidth = 0;\n    /** The actual height of the slider */\n    private actualHeight = 0;\n\n    /** Create a new Slider */\n    constructor(callback: VariableCallback<number> | null = null, minValue = 0, maxValue = 1, snapIncrement = 0, initialValue = 0, vertical = false, themeOverride: Theme | null = null) {\n        // Sliders need a clear background, have no children and don't propagate\n        // events\n        super(themeOverride, true, false);\n\n        this.clickHelper = new ClickHelper(this);\n        this.variable = new Variable(initialValue, callback);\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n        this.snapIncrement = snapIncrement;\n        this.vertical = vertical;\n    }\n\n    /** The slider's value */\n    set value(value: number) {\n        // Snap to increments if needed\n        if(this.snapIncrement > 0)\n            value = Math.round(value / this.snapIncrement) * this.snapIncrement;\n\n        // Clamp value\n        if(value < this.minValue)\n            value = this.minValue;\n        else if(value > this.maxValue)\n            value = this.maxValue;\n\n        // Update value in variable\n        this.variable.value = value;\n    }\n\n    get value(): number {\n        return this.variable.value;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this {\n        // Handle click event\n        const clickArea: [number, number, number, number] = [\n            this.offsetX, this.offsetX + this.actualWidth,\n            this.offsetY, this.offsetY + this.actualHeight,\n        ];\n\n        this.clickHelper.handleClickEvent(event, root, clickArea);\n\n        // If this was a click or the slider is currently being held, update\n        // value\n        if(((this.clickHelper.clickStateChanged && this.clickHelper.wasClick) || this.clickHelper.clickState == ClickState.Hold)\n            && this.clickHelper.pointerPos !== null) {\n            // Interpolate value\n            const percent = this.clickHelper.pointerPos[0];\n            this.value = this.minValue + percent * (this.maxValue - this.minValue);\n        }\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect)\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return this;\n    }\n\n    protected override handleResolveLayout(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get theme properties\n        const thickness = this.theme.getNumber(ThemeProperty.SliderThickness);\n        const minLength = this.theme.getNumber(ThemeProperty.SliderMinLength);\n\n        // Fully expand along main axis if constrained and center along cross\n        // axis\n        if(this.vertical) {\n            // Main axis\n            if(maxHeight != Infinity)\n                this.height = maxHeight;\n            else\n                this.height = Math.max(minLength, minHeight);\n\n            this.actualHeight = this.height;\n            this.offsetY = 0;\n\n            // Cross axis\n            this.width = Math.min(Math.max(thickness, minWidth), maxWidth);\n\n            this.actualWidth = Math.min(this.width, thickness);\n            this.offsetX = (this.width - this.actualWidth) / 2;\n        }\n        else {\n            // Main axis\n            if(maxWidth != Infinity)\n                this.width = maxWidth;\n            else\n                this.width = Math.max(minLength, minWidth);\n\n            this.actualWidth = this.width;\n            this.offsetY = 0;\n\n            // Cross axis\n            this.height = Math.min(Math.max(thickness, minHeight), maxHeight);\n\n            this.actualHeight = Math.min(this.height, thickness);\n            this.offsetX = (this.height - this.actualHeight) / 2;\n        }\n    }\n\n    protected override handlePainting(x: number, y: number, ctx: CanvasRenderingContext2D): void {\n        // Correct position with offset\n        x += this.offsetX;\n        y += this.offsetY;\n\n        // Draw filled part of slider\n        // Use accent colour if hovering or holding\n        const accentStates = [ClickState.Hover, ClickState.Hold];\n        if(accentStates.includes(this.clickHelper.clickState))\n            ctx.fillStyle = this.theme.getFill(ThemeProperty.AccentFill);\n        else\n            ctx.fillStyle = this.theme.getFill(ThemeProperty.PrimaryFill);\n        const fullWidth = this.actualWidth * (this.value - this.minValue) / (this.maxValue - this.minValue);\n        ctx.fillRect(x, y, fullWidth, this.actualHeight);\n\n        // Draw empty part of slider\n        ctx.fillStyle = this.theme.getFill(ThemeProperty.BackgroundFill);\n        const emptyWidth = this.actualWidth - fullWidth;\n        ctx.fillRect(x + fullWidth, y, emptyWidth, this.actualHeight);\n    }\n}\n","import { PassthroughWidget } from './PassthroughWidget';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which changes the theme of its child and\n * completely ignores inherited themes.\n *\n * Can be constrained to a specific type of children.\n *\n * Since the new theme replaces the inherited theme, children of the child will\n * also inherit this theme since inherited themes are propagated down the widget\n * tree.\n *\n * @category Widget\n */\nexport class ThemeScope<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** The theme used for the child. */\n    private scopeTheme: Theme;\n\n    /** Create a new ThemeScope. */\n    constructor(child: W, themeOverride: Theme) {\n        super(child, null);\n        this.scopeTheme = themeOverride;\n    }\n\n    override setThemeOverride(scopeTheme: Theme): void {\n        this.scopeTheme = scopeTheme;\n        super.inheritTheme(this.scopeTheme);\n    }\n\n    override inheritTheme(_theme: Theme): void {\n        // Ignore theme and use scope theme instead\n        super.inheritTheme(this.scopeTheme);\n    }\n}"],"names":["FocusType","ClickState","Event","constructor","target","focusType","needsFocus","this","PointerEvent","x","y","super","PointerRelease","Pointer","correctOffset","xOffset","yOffset","cloneWithTarget","PointerPress","Leave","ClickHelper","widget","Released","getNormalInRect","pX","pY","rLeft","rRight","rTop","rBottom","isPointInRect","isNormalInRect","setClickState","clickState","inside","lastClickState","wasClick","Hold","clickStateChanged","handleClickEvent","event","root","clickArea","dropFocus","pointerPos","pointerStyle","startingPointerPos","requestFocus","Hover","measureContext","measurePadding","Map","measureTextDims","text","font","tempCanvas","document","createElement","getContext","suffixLength","has","get","suffixDims","measureText","Math","abs","actualBoundingBoxLeft","actualBoundingBoxRight","set","dims","actualBoundingBoxAscent","actualBoundingBoxDescent","TextHelper","dirty","wasDirty","_dirty","updateTextDims","measureDirty","width","ascent","descent","_text","_font","_width","max","_minWidth","_ascent","_minAscent","_descent","_minDescent","findOffsetFromIndex","index","substring","findIndexOffsetFromOffset","offset","buffer","lastLength","char","bufferLength","length","setDirty","height","minWidth","minAscent","minDescent","Variable","initialValue","callback","_value","value","setValue","doCallback","e","console","error","DefaultTextInputHandler","initialInput","Promise","accept","_reject","closePopup","body","removeChild","containerElem","overlayElem","okHandler","inElem","id","textElem","textContent","addEventListener","key","preventDefault","buttonRowElem","cancelButtonElem","okButtonElem","appendChild","focus","preventScroll","ThemeProperty","Alignment","defaultThemeProperties","CanvasFill","ContainerPadding","left","right","top","bottom","ContainerAlignment","horizontal","Start","vertical","ContainerSpacing","PrimaryFill","AccentFill","BackgroundFill","BackgroundGlowFill","SliderMinLength","SliderThickness","BodyTextFont","BodyTextFill","LabelMinWidth","LabelMinAscent","LabelMinDescent","CheckboxLength","CheckboxInnerPadding","InputBackgroundFill","InputTextFont","InputTextFill","InputTextFillDisabled","InputTextFillInvalid","InputTextMinWidth","InputTextMinAscent","InputTextMinDescent","InputTextInnerPadding","BlinkRate","CursorThickness","ScrollBarThickness","Theme","properties","fallback","getProperty","themeProperty","undefined","Error","getString","getNumber","getPadding","getAlignment","getAlignment2D","getFill","getFont","__awaiter","thisArg","_arguments","P","generator","resolve","reject","fulfilled","step","next","rejected","result","done","then","apply","roundToPower2","number","roundUp","roundFun","ceil","floor","pow","log2","Viewport","startingWidth","startingHeight","Infinity","canvas","context","alpha","canvasDimensions","constraints","_constraints","resolveChildsLayout","child","layoutDirty","oldWidth","oldHeight","dimensions","resolveLayout","newWidth","newHeight","potentialCWidth","potentialCHeight","paintToCanvas","paint","Root","pointerStyleHandler","theme","Set","Keyboard","viewport","inheritedTheme","enabled","_enabled","newEnabled","driver","drivers","onEnable","onDisable","updatePointerStyle","_foci","keys","clearFocus","dispatchEvent","captured","oldCapturer","_fociCapturers","onFocusCapturerChanged","preLayoutUpdate","update","postLayoutUpdate","newStyle","_currentPointerStyle","onFocusChanged","currentFocus","onFocusDropped","getFocus","getFocusCapturer","registerDriver","add","unregisterDriver","delete","clearDrivers","hasMobileTextInput","textInputHandler","_mobileTextInUse","usingMobileTextInput","getTextInput","newInput","DOMRoot","domElem","tabIndex","domCanvasContext","newPointerStyle","style","cursor","removeProperty","globalCompositeOperation","drawImage","display","Widget","themeOverride","needsClear","propagatesEvents","_themeOverride","flex","_flex","_layoutDirty","updateInheritedTheme","updateTheme","_theme","_inheritedTheme","setThemeOverride","inheritTheme","dimensionless","_focusType","_root","handleEvent","handlePreLayoutUpdate","maxWidth","minHeight","maxHeight","handleResolveLayout","warn","name","handlePostLayoutUpdate","clear","ctx","save","fillStyle","beginPath","rect","trunc","clip","fill","restore","handlePainting","_x","_y","_ctx","Parent","children","_children","childCount","values","SingleParent","PassthroughWidget","ArtificialConstraint","BaseContainer","propagateEvents","offsetX","offsetY","padding","hPadding","vPadding","childMaxWidth","childMaxHeight","alignment","childMinWidth","Stretch","childMinHeight","childDims","usedWidth","usedHeight","freeSpace","Center","End","Button","clickHelper","FilledButton","updateBackground","_forced","backgroundProperty","overrideValue","modifiedTheme","forced","_e","canvasValue","capturer","Container","TextMargin","Label","source","textHelper","Function","textGetter","min","fillText","TextButton","icon","GlyphVirtualKey","glyph","altGlyph","keyContext","getGlyph","shift","MultiParent","Array","isArray","push","remove","pos","indexOf","splice","clearChildren","MultiContainer","spacing","totalFlex","crossLength","minCrossAxis","maxLength","childCross","minCrossLength","usedSpace","spaceLeft","childLength","maxMainAxis","backgroundDirty","Row","VirtualKeyRow","rowTemplate","entry","templateFunction","glyphs","altGlyphs","i","VirtualKey","BasicVirtualKey","keyCode","BackspaceKey","EscapeKey","EnterKey","ShiftKey","SpaceKey","Column","defaultVirtualKeyboardTemplate","VirtualKeyboard","keyboardDriver","keyboardTemplate","flexRatio","mainBasis","crossBasis","keyPress","Margin","DOMVirtualKeyboardRoot","getFocusedRoot","VirtualKeyboardRoot","updateVisibility","KeyEvent","KeyRelease","KeyPress","KeyboardDriver","getEventQueue","eventQueue","eventQueues","changeFocusedRoot","keysDown","keyDown","keyUp","wasDown","isKeyDown","newFocus","_oldCapturer","_newCapturer","DOMKeyboardDriver","bindDOMElem","listenToKeys","domElems","shouldClearFocus","relatedTarget","newTarget","getPointerEventNormPos","getBoundingClientRect","clientX","clientY","PointerMove","PointerHint","PointerDriver","unassignPointer","state","pointer","setPointerHint","None","hovering","pressing","registerPointer","newID","nextPointerID","unregisterPointer","states","hints","movePointer","xNorm","yNorm","firstAssign","pointerMatches","otherRoot","otherState","Pressing","Hovering","leavePointer","leaveAnyPointer","hint","getPointerHint","_newFocus","DOMPointerDriver","WeakMap","mousePointerID","rootBind","removeListeners","pointermoveListen","pointerdownListen","pointerupListen","pointerleaveListen","addListeners","isPrimary","removeEventListener","RayPointerDriver","handlePointerRay","origin","direction","castRay","addSource","sources","setRayPointerDriver","changed","onPointerHintChanged","DebugTheme","random","toString","MakeCompositeValidator","validators","defaultValue","valid","nextValue","validator","DefaultTextValidator","MakeDefaultTextValidatorWithCallback","floatRegex","FloatValidator","test","parseFloat","NaN","intRegex","IntValidator","parseInt","MakeRangeValidator","TextInput","variable","validatedValue","_validValue","_valid","blinkOn","blinkStart","blinkRate","Date","now","editingEnabled","_editingEnabled","moveCursorTo","hideText","_hideText","cursorOffsetDirty","displayedText","repeat","validValue","cursorPos","moveCursor","delta","insertText","str","deleteText","cursorOffset","newValue","blinkWasOn","fillRect","cursorThickness","BasicTextInput","Checkbox","checked","actualLength","useGlow","innerPadding","innerLength","Icon","image","viewBox","_image","_imageWidth","_imageHeight","lastSrc","imageWidth","imageHeight","src","complete","wantedWidth","wantedHeight","widthRatio","heightRatio","scale","actualWidth","actualHeight","rotation","_rotation","tdx","tdy","translate","rotate","IconButton","Spacing","LabelledCheckbox","ViewportWidget","widthTied","heightTied","_widthTied","_heightTied","_offset","_minHeight","innerWidth","innerHeight","vpl","vpr","vpt","vpb","tied","normalWidth","normalHeight","actualMinWidth","actualMinHeight","drawAreaClip","Path2D","xDst","yDst","offsetClip","ScrollableViewportWidget","Slider","minValue","maxValue","snapIncrement","round","percent","thickness","minLength","includes","fullWidth","emptyWidth","ThemeScope","scopeTheme"],"mappings":"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"}