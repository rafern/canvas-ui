{
  "version": 3,
  "sources": ["../src/core/DefaultTextInputHandler.ts", "../src/core/FocusType.ts", "../src/events/Event.ts", "../src/events/TextPasteEvent.ts", "../src/theme/FlexAlignment.ts", "../src/theme/Alignment.ts", "../src/theme/BaseTheme.ts", "../src/theme/Theme.ts", "../src/events/Leave.ts", "../src/decorators/FlagFields.ts", "../src/helpers/roundToPower2.ts", "../src/core/Viewport.ts", "../src/core/Root.ts", "../src/core/DOMRoot.ts", "../src/events/ModifierEvent.ts", "../src/events/PointerEvent.ts", "../src/widgets/Widget.ts", "../src/widgets/Parent.ts", "../src/widgets/SingleParent.ts", "../src/widgets/PassthroughWidget.ts", "../src/widgets/ArtificialConstraint.ts", "../src/events/PointerButtonEvent.ts", "../src/events/PointerRelease.ts", "../src/events/PointerPress.ts", "../src/helpers/ClickHelper.ts", "../src/events/PointerWheel.ts", "../src/widgets/BaseContainer.ts", "../src/widgets/Button.ts", "../src/widgets/FilledButton.ts", "../src/helpers/measureTextDims.ts", "../src/helpers/TextHelper.ts", "../src/widgets/Label.ts", "../src/widgets/TextButton.ts", "../src/widgets/VirtualKeyboard/GlyphVirtualKey.ts", "../src/widgets/MultiParent.ts", "../src/widgets/MultiContainer.ts", "../src/widgets/Row.ts", "../src/widgets/VirtualKeyboard/VirtualKeyRow.ts", "../src/widgets/VirtualKeyboard/VirtualKey.ts", "../src/widgets/VirtualKeyboard/BasicVirtualKey.ts", "../src/widgets/VirtualKeyboard/BackspaceKey.ts", "../src/widgets/VirtualKeyboard/EscapeKey.ts", "../src/widgets/VirtualKeyboard/EnterKey.ts", "../src/widgets/VirtualKeyboard/ShiftKey.ts", "../src/widgets/VirtualKeyboard/SpaceKey.ts", "../src/widgets/Column.ts", "../src/widgets/VirtualKeyboard/VirtualKeyboard.ts", "../src/widgets/Container.ts", "../src/widgets/Margin.ts", "../src/core/DOMVirtualKeyboardRoot.ts", "../src/core/VirtualKeyboardRoot.ts", "../src/events/KeyEvent.ts", "../src/events/KeyRelease.ts", "../src/events/KeyPress.ts", "../src/drivers/KeyboardDriver.ts", "../src/drivers/DOMKeyboardDriver.ts", "../src/helpers/getPointerEventNormPos.ts", "../src/events/PointerMove.ts", "../src/drivers/PointerHint.ts", "../src/drivers/PointerDriver.ts", "../src/drivers/DOMPointerDriver.ts", "../src/drivers/RayPointerDriver.ts", "../src/helpers/Variable.ts", "../src/theme/DebugTheme.ts", "../src/validators/CompositeValidator.ts", "../src/validators/DefaultTextValidator.ts", "../src/validators/FloatValidator.ts", "../src/validators/IntValidator.ts", "../src/validators/RangeValidator.ts", "../src/widgets/VirtualKeyboard/AltKey.ts", "../src/widgets/VirtualKeyboard/ControlKey.ts", "../src/widgets/TextInput.ts", "../src/widgets/BasicTextInput.ts", "../src/widgets/Center.ts", "../src/widgets/Checkbox.ts", "../src/widgets/Icon.ts", "../src/widgets/IconButton.ts", "../src/widgets/Spacing.ts", "../src/widgets/LabelledCheckbox.ts", "../src/widgets/ViewportWidget.ts", "../src/widgets/ScrollableViewportWidget.ts", "../src/widgets/Slider.ts", "../src/widgets/TextMargin.ts", "../src/widgets/ThemeScope.ts"],
  "sourcesContent": ["/**\n * The default implementation of {@link TextInputHandler}.\n *\n * Creates a new popup div with a CSS ID of 'textInputHandler' and an overlay\n * div with CSS ID 'textInputHandlerOverlay', adding both to the HTML body.\n * Resolves the promise once user input is finished by clicking the OK or Cancel\n * buttons.\n *\n * @category Core\n */\nexport function DefaultTextInputHandler(initialInput: string): Promise<string> {\n    return new Promise((accept, _reject) => {\n        function closePopup() {\n            // Close text input popup\n            document.body.removeChild(containerElem);\n            document.body.removeChild(overlayElem);\n        }\n\n        function cancelHandler() {\n            // Click cancel; close popup and accept with initial input string\n            closePopup();\n            accept(initialInput);\n        }\n\n        function okHandler() {\n            // Click OK; close popup and accept with new input string\n            closePopup();\n            accept(inElem.value);\n        }\n\n        function enterChecker(event: KeyboardEvent) {\n            // Check if enter key was pressed\n            if(event.key == 'Enter') {\n                event.preventDefault();\n                okHandler();\n            }\n        }\n\n        // Create overlay\n        const overlayElem = document.createElement('div');\n        overlayElem.id = 'textInputHandlerOverlay';\n\n        // Create container\n        const containerElem = document.createElement('div');\n        containerElem.id = 'textInputHandler';\n\n        // Create text element\n        const textElem = document.createElement('p');\n        textElem.textContent = 'Change text:';\n\n        // Create input element\n        const inElem = document.createElement('input');\n        inElem.addEventListener('keyup', enterChecker);\n        inElem.value = initialInput;\n\n        // Create button row element\n        const buttonRowElem = document.createElement('div');\n\n        // Create cancel button element\n        const cancelButtonElem = document.createElement('button');\n        cancelButtonElem.addEventListener('click', cancelHandler);\n        cancelButtonElem.textContent = 'Cancel';\n\n        // Create OK button element\n        const okButtonElem = document.createElement('button');\n        okButtonElem.addEventListener('click', okHandler);\n        okButtonElem.textContent = 'OK';\n\n        // Add to row\n        buttonRowElem.appendChild(cancelButtonElem);\n        buttonRowElem.appendChild(okButtonElem);\n\n        // Add to container\n        containerElem.appendChild(textElem);\n        containerElem.appendChild(inElem);\n        containerElem.appendChild(buttonRowElem);\n\n        // Add overlay and container to body\n        document.body.appendChild(overlayElem);\n        document.body.appendChild(containerElem);\n\n        // Focus input\n        inElem.focus({ preventScroll: false });\n    });\n}\n", "/**\n * The focus type of an {@link Event}. Used to categorise events when focusing\n * {@link Widget | widgets} in {@link Root | roots}.\n *\n * @category Core\n */\nexport enum FocusType {\n    /** Used for widgets that need pointer input, such as {@link Button} */\n    Pointer = 0,\n    /** Used for widgets that need text input, such as {@link TextInput} */\n    Keyboard = 1,\n}\n", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * A generic event. This is an abstract class and must be implemented in child\n * classes.\n *\n * @category Event\n */\nexport abstract class Event {\n    /** The target of this event. Can be null */\n    readonly target: Widget | null;\n    /**\n     * The focus type of this event. Can be null.\n     *\n     * If null, this event cannot be focused, since events are focused by their\n     * {@link FocusType} as a group.\n     */\n    readonly focusType: FocusType | null;\n    /** Can this event be dispatched without a target? */\n    readonly needsFocus: boolean;\n\n    /** Create a new Event. */\n    constructor(target: Widget | null, focusType: FocusType | null, needsFocus: boolean) {\n        this.target = target;\n        this.focusType = focusType;\n        this.needsFocus = needsFocus;\n    }\n\n    /**\n     * Create a new Event with the same properties as this, except with a new\n     * given target.\n     */\n    abstract cloneWithTarget(target: Widget | null): Event;\n}", "import type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport { Event } from './Event';\n\n/**\n * An event which contains text pasted by the clipboard.\n *\n * Has a focus type of {@link FocusType.Keyboard} and does not need focus.\n *\n * @category Event\n */\nexport class TextPasteEvent extends Event {\n    /** The pasted text */\n    readonly text: string;\n\n    /** Create a new Event. */\n    constructor(text: string, target: Widget | null = null) {\n        super(target, FocusType.Keyboard, false);\n        this.text = text;\n    }\n\n    cloneWithTarget(target: Widget | null): TextPasteEvent {\n        return new TextPasteEvent(this.text, target);\n    }\n}", "/**\n * Alignment of multi-container contents along the main axis. Used for when\n * {@link MultiContainer} has unused space, even after distribution. Similar to\n * {@link Alignment}.\n *\n * @category Theme\n */\nexport const enum FlexAlignment {\n    /** Distribute unused space between each child. */\n    SpaceBetween = 'between',\n    /** Distribute unused space between each child and at start and end. */\n    SpaceAround = 'around',\n    /**\n     * Align the children to the start of the container, having the extra space\n     * at the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the children to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the children to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "/**\n * Alignment of container contents. Used for when {@link Container} has too much\n * space.\n *\n * @category Theme\n */\nexport const enum Alignment {\n    /** Give the extra space to the child, potentially stretching it. */\n    Stretch = 'stretch',\n    /**\n     * Align the child to the start of the container, having the extra space at\n     * the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the child to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the child to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "import type { FlexAlignment2D } from './FlexAlignment2D';\nimport type { ThemeProperties } from './ThemeProperties';\nimport type { Alignment2D } from './Alignment2D';\nimport { FlexAlignment } from './FlexAlignment';\nimport type { FillStyle } from './FillStyle';\nimport type { Padding } from './Padding';\nimport { Alignment } from './Alignment';\nimport type { Theme } from './Theme';\n\n/**\n * The base class for {@link Widget} and {@link Theme}. The backbone of the\n * theming system.\n *\n * @category Theme\n */\nexport class BaseTheme implements ThemeProperties {\n    /** See {@link fallbackTheme} */\n    private _fallbackTheme?: Theme;\n    /** Listener for theme fallback */\n    private listener: ((property: string | null) => void) | null = null;\n\n    /**\n     * The fallback theme. If this theme has a missing property, the fallback\n     * theme's property will be used instead. This will automatically\n     * (un)subscribe to/from the fallback theme.\n     */\n    protected get fallbackTheme(): Theme | undefined {\n        return this._fallbackTheme;\n    }\n\n    protected set fallbackTheme(newTheme: Theme | undefined) {\n        if(this._fallbackTheme === newTheme)\n            return;\n\n        // Unsubscribe from old theme\n        const oldTheme = this._fallbackTheme;\n        if(typeof oldTheme !== 'undefined' && this.listener !== null)\n            oldTheme.unsubscribe(this.listener);\n\n        // Subscribe to new theme\n        if(typeof newTheme !== 'undefined') {\n            this.listener = (property: string | null) => this.onThemeUpdated(property);\n            newTheme.subscribe(this.listener);\n        }\n\n        // Set theme\n        this._fallbackTheme = newTheme;\n\n        // Notify that the fallback theme has changed\n        this.onThemeUpdated();\n    }\n\n    /** Called when the fallback theme changes. Does nothing by default. */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected onThemeUpdated(_property: string | null = null): void {}\n\n    /** Create a new BaseTheme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        this._fallbackTheme = fallbackTheme;\n\n        if(typeof properties === 'undefined')\n            return;\n\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE START\n        this._canvasFill = properties.canvasFill;\n        this._containerPadding = properties.containerPadding;\n        this._containerAlignment = properties.containerAlignment;\n        this._multiContainerSpacing = properties.multiContainerSpacing;\n        this._multiContainerAlignment = properties.multiContainerAlignment;\n        this._primaryFill = properties.primaryFill;\n        this._accentFill = properties.accentFill;\n        this._backgroundFill = properties.backgroundFill;\n        this._backgroundGlowFill = properties.backgroundGlowFill;\n        this._sliderMinLength = properties.sliderMinLength;\n        this._sliderThickness = properties.sliderThickness;\n        this._bodyTextFont = properties.bodyTextFont;\n        this._bodyTextFill = properties.bodyTextFill;\n        this._bodyTextHeight = properties.bodyTextHeight;\n        this._bodyTextSpacing = properties.bodyTextSpacing;\n        this._checkboxLength = properties.checkboxLength;\n        this._checkboxInnerPadding = properties.checkboxInnerPadding;\n        this._inputBackgroundFill = properties.inputBackgroundFill;\n        this._inputSelectBackgroundFill = properties.inputSelectBackgroundFill;\n        this._inputTextFont = properties.inputTextFont;\n        this._inputTextFill = properties.inputTextFill;\n        this._inputTextFillDisabled = properties.inputTextFillDisabled;\n        this._inputTextFillInvalid = properties.inputTextFillInvalid;\n        this._inputTextHeight = properties.inputTextHeight;\n        this._inputTextSpacing = properties.inputTextSpacing;\n        this._inputTextInnerPadding = properties.inputTextInnerPadding;\n        this._inputTextMinWidth = properties.inputTextMinWidth;\n        this._blinkRate = properties.blinkRate;\n        this._cursorThickness = properties.cursorThickness;\n        this._scrollBarThickness = properties.scrollBarThickness;\n        this._scrollBarMinPercent = properties.scrollBarMinPercent;\n        this._scrollBarMinPixels = properties.scrollBarMinPixels;\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE END\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE START\n    /** See {@link canvasFill}. For internal use only. */\n    private _canvasFill?: FillStyle;\n\n    get canvasFill(): FillStyle {\n        return this._canvasFill ?? this._fallbackTheme?.canvasFill ?? 'rgba(0,0,0,0.5)';\n    }\n\n    set canvasFill(value: FillStyle | undefined) {\n        if(this._canvasFill !== value) {\n            this._canvasFill = value;\n            this.onThemeUpdated('canvasFill');\n        }\n    }\n\n    /** See {@link containerPadding}. For internal use only. */\n    private _containerPadding?: Padding;\n\n    get containerPadding(): Padding {\n        return this._containerPadding ?? this._fallbackTheme?.containerPadding ?? <Padding>{left: 4, right: 4, top: 4, bottom: 4};\n    }\n\n    set containerPadding(value: Padding | undefined) {\n        if(this._containerPadding !== value) {\n            this._containerPadding = value;\n            this.onThemeUpdated('containerPadding');\n        }\n    }\n\n    /** See {@link containerAlignment}. For internal use only. */\n    private _containerAlignment?: Alignment2D;\n\n    get containerAlignment(): Alignment2D {\n        return this._containerAlignment ?? this._fallbackTheme?.containerAlignment ?? <Alignment2D>{horizontal: Alignment.Start, vertical: Alignment.Start};\n    }\n\n    set containerAlignment(value: Alignment2D | undefined) {\n        if(this._containerAlignment !== value) {\n            this._containerAlignment = value;\n            this.onThemeUpdated('containerAlignment');\n        }\n    }\n\n    /** See {@link multiContainerSpacing}. For internal use only. */\n    private _multiContainerSpacing?: number;\n\n    get multiContainerSpacing(): number {\n        return this._multiContainerSpacing ?? this._fallbackTheme?.multiContainerSpacing ?? 4;\n    }\n\n    set multiContainerSpacing(value: number | undefined) {\n        if(this._multiContainerSpacing !== value) {\n            this._multiContainerSpacing = value;\n            this.onThemeUpdated('multiContainerSpacing');\n        }\n    }\n\n    /** See {@link multiContainerAlignment}. For internal use only. */\n    private _multiContainerAlignment?: FlexAlignment2D;\n\n    get multiContainerAlignment(): FlexAlignment2D {\n        return this._multiContainerAlignment ?? this._fallbackTheme?.multiContainerAlignment ?? <FlexAlignment2D>{main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch};\n    }\n\n    set multiContainerAlignment(value: FlexAlignment2D | undefined) {\n        if(this._multiContainerAlignment !== value) {\n            this._multiContainerAlignment = value;\n            this.onThemeUpdated('multiContainerAlignment');\n        }\n    }\n\n    /** See {@link primaryFill}. For internal use only. */\n    private _primaryFill?: FillStyle;\n\n    get primaryFill(): FillStyle {\n        return this._primaryFill ?? this._fallbackTheme?.primaryFill ?? 'rgb(0,127,255)';\n    }\n\n    set primaryFill(value: FillStyle | undefined) {\n        if(this._primaryFill !== value) {\n            this._primaryFill = value;\n            this.onThemeUpdated('primaryFill');\n        }\n    }\n\n    /** See {@link accentFill}. For internal use only. */\n    private _accentFill?: FillStyle;\n\n    get accentFill(): FillStyle {\n        return this._accentFill ?? this._fallbackTheme?.accentFill ?? 'rgb(0,195,255)';\n    }\n\n    set accentFill(value: FillStyle | undefined) {\n        if(this._accentFill !== value) {\n            this._accentFill = value;\n            this.onThemeUpdated('accentFill');\n        }\n    }\n\n    /** See {@link backgroundFill}. For internal use only. */\n    private _backgroundFill?: FillStyle;\n\n    get backgroundFill(): FillStyle {\n        return this._backgroundFill ?? this._fallbackTheme?.backgroundFill ?? 'rgb(32,32,32)';\n    }\n\n    set backgroundFill(value: FillStyle | undefined) {\n        if(this._backgroundFill !== value) {\n            this._backgroundFill = value;\n            this.onThemeUpdated('backgroundFill');\n        }\n    }\n\n    /** See {@link backgroundGlowFill}. For internal use only. */\n    private _backgroundGlowFill?: FillStyle;\n\n    get backgroundGlowFill(): FillStyle {\n        return this._backgroundGlowFill ?? this._fallbackTheme?.backgroundGlowFill ?? 'rgb(48,48,48)';\n    }\n\n    set backgroundGlowFill(value: FillStyle | undefined) {\n        if(this._backgroundGlowFill !== value) {\n            this._backgroundGlowFill = value;\n            this.onThemeUpdated('backgroundGlowFill');\n        }\n    }\n\n    /** See {@link sliderMinLength}. For internal use only. */\n    private _sliderMinLength?: number;\n\n    get sliderMinLength(): number {\n        return this._sliderMinLength ?? this._fallbackTheme?.sliderMinLength ?? 100;\n    }\n\n    set sliderMinLength(value: number | undefined) {\n        if(this._sliderMinLength !== value) {\n            this._sliderMinLength = value;\n            this.onThemeUpdated('sliderMinLength');\n        }\n    }\n\n    /** See {@link sliderThickness}. For internal use only. */\n    private _sliderThickness?: number;\n\n    get sliderThickness(): number {\n        return this._sliderThickness ?? this._fallbackTheme?.sliderThickness ?? 10;\n    }\n\n    set sliderThickness(value: number | undefined) {\n        if(this._sliderThickness !== value) {\n            this._sliderThickness = value;\n            this.onThemeUpdated('sliderThickness');\n        }\n    }\n\n    /** See {@link bodyTextFont}. For internal use only. */\n    private _bodyTextFont?: string;\n\n    get bodyTextFont(): string {\n        return this._bodyTextFont ?? this._fallbackTheme?.bodyTextFont ?? '16px sans';\n    }\n\n    set bodyTextFont(value: string | undefined) {\n        if(this._bodyTextFont !== value) {\n            this._bodyTextFont = value;\n            this.onThemeUpdated('bodyTextFont');\n        }\n    }\n\n    /** See {@link bodyTextFill}. For internal use only. */\n    private _bodyTextFill?: FillStyle;\n\n    get bodyTextFill(): FillStyle {\n        return this._bodyTextFill ?? this._fallbackTheme?.bodyTextFill ?? 'white';\n    }\n\n    set bodyTextFill(value: FillStyle | undefined) {\n        if(this._bodyTextFill !== value) {\n            this._bodyTextFill = value;\n            this.onThemeUpdated('bodyTextFill');\n        }\n    }\n\n    /** See {@link bodyTextHeight}. For internal use only. */\n    private _bodyTextHeight?: number | null;\n\n    get bodyTextHeight(): number | null {\n        return this._bodyTextHeight ?? this._fallbackTheme?.bodyTextHeight ?? null;\n    }\n\n    set bodyTextHeight(value: number | null | undefined) {\n        if(this._bodyTextHeight !== value) {\n            this._bodyTextHeight = value;\n            this.onThemeUpdated('bodyTextHeight');\n        }\n    }\n\n    /** See {@link bodyTextSpacing}. For internal use only. */\n    private _bodyTextSpacing?: number | null;\n\n    get bodyTextSpacing(): number | null {\n        return this._bodyTextSpacing ?? this._fallbackTheme?.bodyTextSpacing ?? null;\n    }\n\n    set bodyTextSpacing(value: number | null | undefined) {\n        if(this._bodyTextSpacing !== value) {\n            this._bodyTextSpacing = value;\n            this.onThemeUpdated('bodyTextSpacing');\n        }\n    }\n\n    /** See {@link checkboxLength}. For internal use only. */\n    private _checkboxLength?: number;\n\n    get checkboxLength(): number {\n        return this._checkboxLength ?? this._fallbackTheme?.checkboxLength ?? 12;\n    }\n\n    set checkboxLength(value: number | undefined) {\n        if(this._checkboxLength !== value) {\n            this._checkboxLength = value;\n            this.onThemeUpdated('checkboxLength');\n        }\n    }\n\n    /** See {@link checkboxInnerPadding}. For internal use only. */\n    private _checkboxInnerPadding?: number;\n\n    get checkboxInnerPadding(): number {\n        return this._checkboxInnerPadding ?? this._fallbackTheme?.checkboxInnerPadding ?? 2;\n    }\n\n    set checkboxInnerPadding(value: number | undefined) {\n        if(this._checkboxInnerPadding !== value) {\n            this._checkboxInnerPadding = value;\n            this.onThemeUpdated('checkboxInnerPadding');\n        }\n    }\n\n    /** See {@link inputBackgroundFill}. For internal use only. */\n    private _inputBackgroundFill?: FillStyle;\n\n    get inputBackgroundFill(): FillStyle {\n        return this._inputBackgroundFill ?? this._fallbackTheme?.inputBackgroundFill ?? 'white';\n    }\n\n    set inputBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputBackgroundFill !== value) {\n            this._inputBackgroundFill = value;\n            this.onThemeUpdated('inputBackgroundFill');\n        }\n    }\n\n    /** See {@link inputSelectBackgroundFill}. For internal use only. */\n    private _inputSelectBackgroundFill?: FillStyle;\n\n    get inputSelectBackgroundFill(): FillStyle {\n        return this._inputSelectBackgroundFill ?? this._fallbackTheme?.inputSelectBackgroundFill ?? 'rgb(0,195,255)';\n    }\n\n    set inputSelectBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputSelectBackgroundFill !== value) {\n            this._inputSelectBackgroundFill = value;\n            this.onThemeUpdated('inputSelectBackgroundFill');\n        }\n    }\n\n    /** See {@link inputTextFont}. For internal use only. */\n    private _inputTextFont?: string;\n\n    get inputTextFont(): string {\n        return this._inputTextFont ?? this._fallbackTheme?.inputTextFont ?? '16px mono';\n    }\n\n    set inputTextFont(value: string | undefined) {\n        if(this._inputTextFont !== value) {\n            this._inputTextFont = value;\n            this.onThemeUpdated('inputTextFont');\n        }\n    }\n\n    /** See {@link inputTextFill}. For internal use only. */\n    private _inputTextFill?: FillStyle;\n\n    get inputTextFill(): FillStyle {\n        return this._inputTextFill ?? this._fallbackTheme?.inputTextFill ?? 'black';\n    }\n\n    set inputTextFill(value: FillStyle | undefined) {\n        if(this._inputTextFill !== value) {\n            this._inputTextFill = value;\n            this.onThemeUpdated('inputTextFill');\n        }\n    }\n\n    /** See {@link inputTextFillDisabled}. For internal use only. */\n    private _inputTextFillDisabled?: FillStyle;\n\n    get inputTextFillDisabled(): FillStyle {\n        return this._inputTextFillDisabled ?? this._fallbackTheme?.inputTextFillDisabled ?? 'grey';\n    }\n\n    set inputTextFillDisabled(value: FillStyle | undefined) {\n        if(this._inputTextFillDisabled !== value) {\n            this._inputTextFillDisabled = value;\n            this.onThemeUpdated('inputTextFillDisabled');\n        }\n    }\n\n    /** See {@link inputTextFillInvalid}. For internal use only. */\n    private _inputTextFillInvalid?: FillStyle;\n\n    get inputTextFillInvalid(): FillStyle {\n        return this._inputTextFillInvalid ?? this._fallbackTheme?.inputTextFillInvalid ?? 'red';\n    }\n\n    set inputTextFillInvalid(value: FillStyle | undefined) {\n        if(this._inputTextFillInvalid !== value) {\n            this._inputTextFillInvalid = value;\n            this.onThemeUpdated('inputTextFillInvalid');\n        }\n    }\n\n    /** See {@link inputTextHeight}. For internal use only. */\n    private _inputTextHeight?: number | null;\n\n    get inputTextHeight(): number | null {\n        return this._inputTextHeight ?? this._fallbackTheme?.inputTextHeight ?? null;\n    }\n\n    set inputTextHeight(value: number | null | undefined) {\n        if(this._inputTextHeight !== value) {\n            this._inputTextHeight = value;\n            this.onThemeUpdated('inputTextHeight');\n        }\n    }\n\n    /** See {@link inputTextSpacing}. For internal use only. */\n    private _inputTextSpacing?: number | null;\n\n    get inputTextSpacing(): number | null {\n        return this._inputTextSpacing ?? this._fallbackTheme?.inputTextSpacing ?? null;\n    }\n\n    set inputTextSpacing(value: number | null | undefined) {\n        if(this._inputTextSpacing !== value) {\n            this._inputTextSpacing = value;\n            this.onThemeUpdated('inputTextSpacing');\n        }\n    }\n\n    /** See {@link inputTextInnerPadding}. For internal use only. */\n    private _inputTextInnerPadding?: number;\n\n    get inputTextInnerPadding(): number {\n        return this._inputTextInnerPadding ?? this._fallbackTheme?.inputTextInnerPadding ?? 2;\n    }\n\n    set inputTextInnerPadding(value: number | undefined) {\n        if(this._inputTextInnerPadding !== value) {\n            this._inputTextInnerPadding = value;\n            this.onThemeUpdated('inputTextInnerPadding');\n        }\n    }\n\n    /** See {@link inputTextMinWidth}. For internal use only. */\n    private _inputTextMinWidth?: number;\n\n    get inputTextMinWidth(): number {\n        return this._inputTextMinWidth ?? this._fallbackTheme?.inputTextMinWidth ?? 100;\n    }\n\n    set inputTextMinWidth(value: number | undefined) {\n        if(this._inputTextMinWidth !== value) {\n            this._inputTextMinWidth = value;\n            this.onThemeUpdated('inputTextMinWidth');\n        }\n    }\n\n    /** See {@link blinkRate}. For internal use only. */\n    private _blinkRate?: number;\n\n    get blinkRate(): number {\n        return this._blinkRate ?? this._fallbackTheme?.blinkRate ?? 0.8;\n    }\n\n    set blinkRate(value: number | undefined) {\n        if(this._blinkRate !== value) {\n            this._blinkRate = value;\n            this.onThemeUpdated('blinkRate');\n        }\n    }\n\n    /** See {@link cursorThickness}. For internal use only. */\n    private _cursorThickness?: number;\n\n    get cursorThickness(): number {\n        return this._cursorThickness ?? this._fallbackTheme?.cursorThickness ?? 1;\n    }\n\n    set cursorThickness(value: number | undefined) {\n        if(this._cursorThickness !== value) {\n            this._cursorThickness = value;\n            this.onThemeUpdated('cursorThickness');\n        }\n    }\n\n    /** See {@link scrollBarThickness}. For internal use only. */\n    private _scrollBarThickness?: number;\n\n    get scrollBarThickness(): number {\n        return this._scrollBarThickness ?? this._fallbackTheme?.scrollBarThickness ?? 8;\n    }\n\n    set scrollBarThickness(value: number | undefined) {\n        if(this._scrollBarThickness !== value) {\n            this._scrollBarThickness = value;\n            this.onThemeUpdated('scrollBarThickness');\n        }\n    }\n\n    /** See {@link scrollBarMinPercent}. For internal use only. */\n    private _scrollBarMinPercent?: number;\n\n    get scrollBarMinPercent(): number {\n        return this._scrollBarMinPercent ?? this._fallbackTheme?.scrollBarMinPercent ?? 0.1;\n    }\n\n    set scrollBarMinPercent(value: number | undefined) {\n        if(this._scrollBarMinPercent !== value) {\n            this._scrollBarMinPercent = value;\n            this.onThemeUpdated('scrollBarMinPercent');\n        }\n    }\n\n    /** See {@link scrollBarMinPixels}. For internal use only. */\n    private _scrollBarMinPixels?: number;\n\n    get scrollBarMinPixels(): number {\n        return this._scrollBarMinPixels ?? this._fallbackTheme?.scrollBarMinPixels ?? 20;\n    }\n\n    set scrollBarMinPixels(value: number | undefined) {\n        if(this._scrollBarMinPixels !== value) {\n            this._scrollBarMinPixels = value;\n            this.onThemeUpdated('scrollBarMinPixels');\n        }\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE END\n}\n", "import type { ThemeProperties } from './ThemeProperties';\nimport { BaseTheme } from './BaseTheme';\n\n/**\n * Provides styling for {@link Widget | Widgets}.\n *\n * @category Theme\n */\nexport class Theme extends BaseTheme {\n    /** Listeners that are listening for changes in this theme (or fallback) */\n    protected subscribers: Set<(property: string | null) => void>;\n\n    /** Create a new Theme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        super(properties, fallbackTheme);\n        this.subscribers = new Set();\n    }\n\n    override get fallbackTheme(): Theme | undefined {\n        return super.fallbackTheme;\n    }\n\n    override set fallbackTheme(newTheme: Theme | undefined) {\n        super.fallbackTheme = newTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        // Notify all subscribers\n        for(const listener of this.subscribers)\n            listener(property);\n    }\n\n    /**\n     * Subscribe to this theme. When a change occurs in the theme, the passed\n     * listener callback will be called. The argument used for the callback will\n     * be null if the theme's fallback has changed and therefore all properties\n     * are to be assumed as changed, else, the argument will be a string\n     * containing the name of the theme property that changed.\n     */\n    subscribe(listener: (property: string | null) => void): void {\n        this.subscribers.add(listener);\n    }\n\n    /**\n     * Unsubscribe from this theme; removes the listener callback from the list\n     * of subscribers.\n     */\n    unsubscribe(listener: (property: string | null) => void): void {\n        this.subscribers.delete(listener);\n    }\n}", "import { FocusType} from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * A leave {@link Event}. Dispatched when the pointer leaves the root or the\n * focus capturer changes to another widget.\n *\n * Has a focus type of {@link FocusType.Pointer} and needs focus.\n *\n * @category Event\n */\nexport class Leave extends Event {\n    /**\n     * Create a new KeyEvent. Sets {@link target}, {@link focusType} to\n     * {@link FocusType.Pointer} and {@link needsFocus} to true.\n     */\n    constructor(target: Widget | null = null) {\n        super(target, FocusType.Pointer, true);\n    }\n\n    cloneWithTarget(target: Widget | null): Leave {\n        return new Leave(target);\n    }\n}\n", "/**\n * A decorator for a public field which sets calls a callback if the property's\n * value is changed.\n *\n * @param callback The callback to call if the value changes. `this` is bound.\n * @category Decorator\n */\nexport function watchField(callback: (oldValue: any) => void) {\n    return function(target: any, propertyKey: string): void {\n        const curValues = new WeakMap();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value) {\n                const oldValue = curValues.get(this);\n                if(value !== oldValue) {\n                    curValues.set(this, value);\n                    callback.call(this, oldValue);\n                }\n            },\n            get: function() {\n                return curValues.get(this);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchField} which sets a given flag to true.\n *\n * @param flagKey The key of the flag property to set to true\n * @category Decorator\n */\nexport function flagField(flagKey: string): (target: any, propertyKey: string) => void {\n    return watchField(function(this: any) {\n        this[flagKey] = true;\n    });\n}\n\n/**\n * A {@link flagField} where the flag key is `_dirty`.\n *\n * @category Decorator\n */\nexport const paintField = flagField('_dirty');\n\n/**\n * A {@link flagField} where the flag key is `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const layoutField = flagField('_layoutDirty');\n\n/**\n * A {@link watchField} which sets a given array of flags to true.\n *\n * @param flagKeys An array containing the keys of each flag property to set to true\n * @category Decorator\n */\nexport function multiFlagField(flagKeys: Array<string>): (target: any, propertyKey: string) => void {\n    return watchField(function(this: any) {\n        for(const flagKey of flagKeys)\n            this[flagKey] = true;\n    });\n}\n\n/**\n * A {@link multiFlagField} where the flag keys are `_dirty` and `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const paintLayoutField = multiFlagField(['_dirty', '_layoutDirty']);\n\n/**\n * Similar to {@link watchField}, but for array fields, like tuples. Getting the\n * property returns a shallow copy of the tuple, setting the value uses a\n * shallow copy of the input value if the current value is not an array. If both\n * the new value and the current value are arrays, then the current value's\n * members are updated; no shallow copy is created.\n *\n * @param callback The callback to call if the value changes. `this` is bound.\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function watchArrayField(callback: () => void, allowNonArrays = false) {\n    return function(target: any, propertyKey: string): void {\n        const curValues = new WeakMap<any, Array<any>>();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value: any) {\n                if(Array.isArray(value)) {\n                    const curTuple = curValues.get(this);\n                    if(Array.isArray(curTuple)) {\n                        if(value.length !== curTuple.length) {\n                            curTuple.length = value.length;\n                            for(let i = 0; i < value.length; i++)\n                                curTuple[i] = value[i];\n\n                            callback.call(this);\n                        }\n                        else {\n                            for(let i = 0; i < value.length; i++) {\n                                if(curTuple[i] !== value[i]) {\n                                    for(let j = 0; j < value.length; j++)\n                                        curTuple[j] = value[j];\n\n                                    callback.call(this);\n\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        curValues.set(this, [...value]);\n                        callback.call(this);\n                    }\n                }\n                else {\n                    if(allowNonArrays) {\n                        curValues.set(this, value);\n                        callback.call(this);\n                    }\n                    else\n                        throw new Error('Value must be an array');\n                }\n            },\n            get: function() {\n                const curTuple = curValues.get(this);\n                if(!Array.isArray(curTuple))\n                    return curTuple;\n\n                return [...curTuple];\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchArrayField} which sets a given flag to true.\n *\n * @param flagKey The key of the flag property to set to true\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function flagArrayField(flagKey: string, allowNonArrays = false): (target: any, propertyKey: string) => void {\n    return watchArrayField(function(this: any) {\n        this[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_dirty`.\n *\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintArrayField(allowNonArrays = false): (target: any, propertyKey: string) => void {\n    return flagArrayField('_dirty', allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_layoutDirty`.\n *\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function layoutArrayField(allowNonArrays = false): (target: any, propertyKey: string) => void {\n    return flagArrayField('_layoutDirty', allowNonArrays);\n}\n\n/**\n * A {@link watchArrayField} which sets a given array of flags to true.\n *\n * @param flagKeys An array containing the keys of each flag property to set to true\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function multiFlagArrayField(flagKeys: Array<string>, allowNonArrays = false): (target: any, propertyKey: string) => void {\n    return watchArrayField(function(this: any) {\n        for(const flagKey of flagKeys)\n            this[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link multiFlagArrayField} where the flag keys are `_dirty` and\n * `_layoutDirty`.\n *\n * @param allowNonArrays Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintLayoutArrayField(allowNonArrays = false): (target: any, propertyKey: string) => void {\n    return multiFlagArrayField(['_dirty', '_layoutDirty'], allowNonArrays);\n}\n", "/**\n * Rounds a given number up or down to a power of 2. Useful for working with\n * textures.\n *\n * @param number The number to round\n * @param roundUp If true, rounds the number to the smallest power of 2 greater\n * or equal to the input, else, rounds the number to the greatest power of 2\n * smaller or equal to the input.\n *\n * @returns Returns the rounded number\n *\n * @category Helper\n */\nexport function roundToPower2(number: number, roundUp = true): number {\n    const roundFun = roundUp ? Math.ceil : Math.floor;\n    return Math.pow(2, roundFun(Math.log2(number)));\n}", "import type { LayoutConstraints } from './LayoutConstraints';\nimport { paintArrayField } from '../decorators/FlagFields';\nimport { roundToPower2 } from '../helpers/roundToPower2';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * Viewports are internally used to manage a canvas' size and painting. It is\n * used by {@link Root} and {@link ViewportWidget}.\n *\n * @category Core\n */\nexport class Viewport {\n    /**\n     * Layout constraints of viewport when resolving widget's layout. A 4-tuple\n     * containing, respectively, minimum width, maximum width, minimum height\n     * and maximum height.\n     *\n     * By default, has no minimum width nor height and unconstrained maximum\n     * width and height.\n     *\n     * @decorator `@paintArrayField()`\n     */\n    @paintArrayField()\n    constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n    /** Have the constraints been changed? */\n    private dirty = true;\n\n    /** The internal canvas. Widgets are painted to this */\n    readonly canvas: HTMLCanvasElement;\n    /** The internal canvas' context. Alpha is enabled. */\n    readonly context: CanvasRenderingContext2D;\n\n    /**\n     * Create a new Viewport.\n     *\n     * Creates a new canvas with a starting width and height, setting\n     * {@link canvas} and {@link context}. Failure to get a canvas context\n     * results in an exception.\n     */\n    constructor(startingWidth = 64, startingHeight = 64) {\n        // Create internal canvas\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = startingWidth;\n        this.canvas.height = startingHeight;\n\n        // Get context out of canvas\n        const context = this.canvas.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error('Failed to get canvas context');\n\n        this.context = context;\n    }\n\n    /** The current dimensions of the {@link canvas | internal canvas} */\n    get canvasDimensions(): [number, number] {\n        return [this.canvas.width, this.canvas.height];\n    }\n\n    /**\n     * Resolves the given child's layout by calling\n     * {@link Widget.resolveDimensions} with the current {@link constraints},\n     * and {@link Widget.resolvePosition}.\n     *\n     * If the child's layout is not dirty, then nothing is done.\n     *\n     * Expands {@link canvas} if the new layout is too big for the current\n     * canvas. Expansion is done in powers of 2 to avoid issues with external 3D\n     * libraries.\n     *\n     * @returns Returns true if the child was resized, else, false.\n     */\n    resolveChildsLayout(child: Widget): boolean {\n        if(!child.layoutDirty && !this.dirty)\n            return false;\n\n        // Remove constraints' dirty flag\n        this.dirty = false;\n\n        // Resolve child's layout\n        const [oldWidth, oldHeight] = child.dimensions;\n        const [minWidth, maxWidth, minHeight, maxHeight] = this.constraints;\n\n        child.resolveDimensionsAsTop(minWidth, maxWidth, minHeight, maxHeight);\n        child.resolvePosition(0, 0);\n\n        const [newWidth, newHeight] = child.dimensions;\n\n        if(newWidth !== oldWidth || newHeight !== oldHeight) {\n            // Re-scale canvas if neccessary.\n            // Canvas dimensions are rounded to the nearest power of 2, favoring\n            // bigger powers. This is to avoid issues with mipmapping, which\n            // requires texture sizes to be powers of 2.\n            const newCanvasWidth = Math.max(roundToPower2(newWidth), this.canvas.width);\n            const newCanvasHeight = Math.max(roundToPower2(newHeight), this.canvas.height);\n\n            if(newCanvasWidth !== this.canvas.width || newCanvasHeight !== this.canvas.height) {\n                // Resizing a canvas clears its contents. To mitigate this, copy\n                // the canvas contents to a new canvas, resize the canvas and\n                // copy the contents back. To avoid unnecessary copying, the\n                // canvas will not be copied if the old dimensions of the child\n                // were 0x0\n                // TODO resizing is kinda expensive. maybe find a better way?\n\n                let copyCanvas = null;\n                if(oldWidth !== 0 && oldHeight !== 0) {\n                    copyCanvas = document.createElement('canvas');\n                    copyCanvas.width = oldWidth;\n                    copyCanvas.height = oldHeight;\n\n                    const copyCtx = copyCanvas.getContext('2d');\n                    if(copyCtx === null)\n                        throw new Error('Failed to get context of temporary canvas for resizing original canvas');\n\n                    copyCtx.globalCompositeOperation = 'copy';\n                    copyCtx.drawImage(\n                        this.canvas,\n                        0, 0, newWidth, newHeight,\n                        0, 0, newWidth, newHeight,\n                    );\n                }\n\n                this.canvas.width = newCanvasWidth;\n                this.canvas.height = newCanvasHeight;\n\n                if(copyCanvas !== null) {\n                    this.context.globalCompositeOperation = 'copy';\n                    this.context.drawImage(\n                        copyCanvas,\n                        0, 0, copyCanvas.width, copyCanvas.height,\n                        0, 0, copyCanvas.width, copyCanvas.height,\n                    );\n                    this.context.globalCompositeOperation = 'source-over';\n                }\n            }\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Paint a given child to {@link canvas}.\n     *\n     * Nothing is done if the child was not dirty.\n     *\n     * @param force Force re-paint even if {@link dirty} is false\n     * @returns Returns true if the child was dirty, else, false.\n     */\n    paintToCanvas(child: Widget, force: boolean): boolean {\n        // Paint child\n        const wasDirty = child.dirty;\n        child.paint(this.context, force);\n        return wasDirty;\n    }\n}", "import type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { TextInputHandler } from './TextInputHandler';\nimport type { Widget } from '../widgets/Widget';\nimport type { Event } from '../events/Event';\nimport { FocusType } from './FocusType';\nimport { Leave } from '../events/Leave';\nimport type { Driver } from './Driver';\nimport { Theme } from '../theme/Theme';\nimport { Viewport } from './Viewport';\n\n/**\n * A Root is the parent of all widgets, but not a widget itself. It contains a\n * single child and manages dimensions and input handling\n *\n * @category Core\n */\nexport class Root {\n    /** The Root's child; the parent Widget of all widgets in this Root */\n    readonly child: Widget;\n    /** The internal viewport. Manages drawing */\n    protected viewport: Viewport;\n    /** The list of drivers registered to this root */\n    protected drivers: Set<Driver> = new Set();\n    /**\n     * Is the Root enabled? For internal use only.\n     *\n     * See {@link enabled}\n     */\n    protected _enabled = true;\n    /**\n     * The pointer style this root wants. Will be set on\n     * {@link postLayoutUpdate} by {@link pointerStyleHandler}\n     */\n    pointerStyle = 'default';\n    /**\n     * The actual current pointer style.\n     *\n     * For internal use only.\n     *\n     * See {@link pointerStyle}\n     */\n    protected _currentPointerStyle = 'default';\n    /**\n     * Pointer style handler, decides how to show the given pointer style.\n     * Normally a function which sets the CSS cursor style of the Root's canvas\n     */\n    pointerStyleHandler: PointerStyleHandler | null;\n    /**\n     * Current component foci (event targets for each focus type).\n     *\n     * For internal use only.\n     *\n     * See {@link requestFocus}, {@link dropFocus}, {@link clearFocus} and\n     * {@link getFocus}\n     */\n    protected _foci: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n    ]);\n    /**\n     * Last capturer of each component focus (event targets for each focus\n     * type).\n     *\n     * For internal use only.\n     *\n     * See {@link getFocusCapturer}\n     */\n    protected _fociCapturers: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n    ]);\n    /**\n     * Handler for mobile-friendly text input. If not null, widgets that need\n     * text may call this to get a string.\n     *\n     * See {@link hasMobileTextInput}, {@link usingMobileTextInput} and\n     * {@link getTextInput}\n     */\n    textInputHandler: TextInputHandler | null = null;\n    /**\n     * Is the mobile-friendly text input in use?\n     *\n     * For internal use only.\n     *\n     * See {@link hasMobileTextInput}, {@link usingMobileTextInput} and\n     * {@link getTextInput}\n     */\n    protected _mobileTextInUse = false;\n\n    /**\n     * Creates a new Root.\n     *\n     * Sets {@link child}, {@link pointerStyleHandler} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(child: Widget, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        this.viewport = new Viewport();\n        this.child = child;\n        this.pointerStyleHandler = pointerStyleHandler;\n        this.child.inheritedTheme = theme;\n    }\n\n    /** The {@link viewport}'s {@link Viewport.constraints | constraints} */\n    get constraints(): [number, number, number, number] {\n        return this.viewport.constraints;\n    }\n\n    set constraints(constraints: [number, number, number, number]) {\n        this.viewport.constraints = constraints;\n    }\n\n    /**\n     * The {@link viewport}'s\n     * {@link Viewport.canvasDimensions | canvasDimensions}\n     */\n    get canvasDimensions(): [number, number] {\n        return this.viewport.canvasDimensions;\n    }\n\n    /**\n     * The {@link child}'s {@link Widget.dimensions | dimensions}\n     */\n    get dimensions(): [number, number] {\n        return this.child.dimensions;\n    }\n\n    /**\n     * Is this root enabled? If not enabled, painting, updating or resolving\n     * layout will do nothing. {@link drivers | Drivers} will also be notified\n     * by calling {@link Driver.onEnable} or {@link Driver.onDisable}, pointer\n     * style will be reset ({@link updatePointerStyle} called with 'default')\n     * and all {@link _foci | foci} will be cleared ({@link clearFocus}).\n     *\n     * See {@link _enabled}\n     */\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    set enabled(newEnabled: boolean) {\n        const oldEnabled = this._enabled;\n\n        if(oldEnabled !== newEnabled) {\n            this._enabled = newEnabled;\n\n            // Call driver hooks, reset pointer style and release foci if UI\n            // disabled\n            if(newEnabled) {\n                for(const driver of this.drivers)\n                    driver.onEnable(this);\n            }\n            else {\n                for(const driver of this.drivers)\n                    driver.onDisable(this);\n\n                this.updatePointerStyle('default');\n\n                for(const focus of this._foci.keys())\n                    this.clearFocus(focus);\n            }\n        }\n    }\n\n\n    /**\n     * The {@link viewport}'s {@link Viewport.canvas | canvas}\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.viewport.canvas;\n    }\n\n    /**\n     * Resolve the layout of this root. Does nothing if root is disabled.\n     *\n     * Calls {@link viewport}'s {@link resolveChildsLayout} with {@link child}\n     *\n     * Call this before calling {@link postLayoutUpdate} and after calling\n     * {@link preLayoutUpdate}\n     *\n     * @returns Returns true if viewport was resized\n     */\n    resolveLayout(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.resolveChildsLayout(this.child);\n    }\n\n    /**\n     * Paint this root's next frame if needed. Does nothing if root is disabled.\n     *\n     * Calls {@link viewport}'s {@link Viewport.paintToCanvas} with\n     * {@link child}.\n     *\n     * Call this after calling {@link postLayoutUpdate}.\n     *\n     * @returns Returns whether the child was dirty or not. Use this to tell an external 3D library whether to update a mesh's texture or not.\n     */\n    paint(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.paintToCanvas(this.child, false);\n    }\n\n    /**\n     * Dispatches an {@link Event} to this root's {@link child} by calling\n     * {@link Widget.dispatchEvent}. Updates\n     * {@link _fociCapturers | foci capturers} and notifies {@link drivers} by\n     * calling {@link Driver.onFocusCapturerChanged} if the capturer changes.\n     * Does nothing if root is disabled.\n     *\n     * Note that if an event with a focus is dispatched and no widget captures\n     * the event due to the widget not existing anymore or being disabled, the\n     * focus type of the event will be cleared in the root with\n     * {@link clearFocus}.\n     *\n     * @returns Returns true if the event was captured\n     */\n    dispatchEvent(event: Event): boolean {\n        // Ignore event if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        // If event is focusable and is missing a target...\n        if(event.focusType !== null && event.target === null) {\n            // Ignore event if it needs a focus but there is no component\n            // focused in the needed focus\n            let focus = this._foci.get(event.focusType);\n            if(typeof focus === 'undefined')\n                focus = null;\n\n            if(event.needsFocus && focus === null) {\n                //console.warn('Dropped event due to lack of target', event);\n                return false;\n            }\n\n            // Set event target\n            event = event.cloneWithTarget(focus);\n        }\n\n        // Clear pointer style. This will be set by children if neccessary\n        this.pointerStyle = 'default';\n\n        // Pass event down to internal Container\n        const captured = this.child.dispatchEvent(event, this);\n        if(captured === null) {\n            // If the event wasn't captured but it had a focus, clear the focus\n            // NOTE: This is for preventing a component that is no longer\n            // present in the UI from capturing events\n            if(event.focusType !== null) {\n                //console.warn('Focus cleared due to uncaptured focused event', event);\n                this.clearFocus(event.focusType);\n            }\n        }\n        /*else\n            console.info('Event captured by widget:', captured.constructor.name);*/\n\n        // Update focus capturer if it changed\n        if(event.focusType === null)\n            return captured !== null;\n\n        const oldCapturer = this._fociCapturers.get(event.focusType) ?? null;\n        if(oldCapturer === captured)\n            return captured !== null;\n\n        // Special case: when the pointer focus capturer changes, dispatch a\n        // leave event to the last capturer\n        if(event.focusType === FocusType.Pointer && oldCapturer !== null)\n            this.child.dispatchEvent(new Leave(oldCapturer), this);\n\n        this._fociCapturers.set(event.focusType, captured);\n        for(const driver of this.drivers)\n            driver.onFocusCapturerChanged(this, event.focusType, oldCapturer, captured);\n\n        return captured !== null;\n    }\n\n    /**\n     * Do a pre-layout update; calls {@link drivers}' {@link Driver.update} and\n     * {@link child}'s {@link Widget.preLayoutUpdate}. Does nothing if root is\n     * disabled.\n     *\n     * Call this before calling {@link resolveLayout}\n     */\n    preLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Update drivers\n        for(const driver of this.drivers)\n            driver.update(this);\n\n        // Pre-layout update child\n        this.child.preLayoutUpdate(this);\n    }\n\n\n    /**\n     * Do a post-layout update; calls {@link child}'s\n     * {@link Widget.postLayoutUpdate} and {@link updatePointerStyle}. Does\n     * nothing if root is disabled.\n     *\n     * Call this before calling {@link paint} and after calling\n     * {@link resolveLayout}\n     */\n    postLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Post-layout update child\n        this.child.postLayoutUpdate(this);\n\n        // Update pointer style\n        this.updatePointerStyle();\n    }\n\n    /**\n     * Calls {@link pointerStyleHandler} if the {@link pointerStyle} has changed\n     * (checked by comparing with {@link _currentPointerStyle}). Also updates\n     * {@link _currentPointerStyle}. Can also be optionally supplied a new\n     * pointer style.\n     */\n    updatePointerStyle(newStyle: string | null = null): void {\n        if(newStyle !== null)\n            this.pointerStyle = newStyle;\n\n        if(this.pointerStyle !== this._currentPointerStyle) {\n            this._currentPointerStyle = this.pointerStyle;\n            if(this.pointerStyleHandler !== null)\n                this.pointerStyleHandler(this._currentPointerStyle);\n        }\n    }\n\n    /**\n     * Sets the current {@link _foci | focus} of a given type to a given widget.\n     * If the focus changes, {@link clearFocus} is called and {@link drivers}\n     * are notified by calling {@link Driver.onFocusChanged}.\n     */\n    requestFocus(focusType: FocusType, widget: Widget): void {\n        if(widget !== null) {\n            // Replace focus if current focus is not the desired one\n            const currentFocus = this._foci.get(focusType);\n            if(widget !== currentFocus) {\n                this.clearFocus(focusType);\n                //console.log('Set focus type', focusType, 'to widget', widget);\n                this._foci.set(focusType, widget);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, focusType, widget);\n            }\n        }\n    }\n\n    /**\n     * Clears the current {@link _foci | focus} of a given type if it is\n     * currently set to a given widget. Achieved by calling {@link clearFocus}.\n     */\n    dropFocus(focusType: FocusType, widget: Widget): void {\n        // NOTE: Use this instead of clearFocus if your intent is to make sure a\n        // SPECIFIC COMPONENT is no longer focused, NOT ANY COMPONENT\n        const currentFocus = this._foci.get(focusType);\n        if(widget === currentFocus)\n            this.clearFocus(focusType);\n    }\n\n    /**\n     * Clears the current {@link _foci | focus} of a given type. If there was a\n     * focus set, {@link drivers} are notified by calling\n     * {@link Driver.onFocusChanged}.\n     */\n    clearFocus(focusType: FocusType): void {\n        const currentFocus = this._foci.get(focusType);\n        if(currentFocus !== null && typeof currentFocus !== 'undefined') {\n            //console.log('Dropped focus type', focusType, 'from widget', currentFocus);\n            currentFocus.onFocusDropped(focusType, this);\n\n            this._foci.set(focusType, null);\n            for(const driver of this.drivers)\n                driver.onFocusChanged(this, focusType, null);\n        }\n    }\n\n    /**\n     * Gets the current {@link _foci | focus} of a given type.\n     */\n    getFocus(focusType: FocusType): Widget | null {\n        return this._foci.get(focusType) ?? null;\n    }\n\n    /**\n     * Gets the last {@link _fociCapturers | focus capturer} of a given type.\n     */\n    getFocusCapturer(focusType: FocusType): Widget | null {\n        return this._fociCapturers.get(focusType) ?? null;\n    }\n\n    /**\n     * Registers a {@link Driver} to the root, adding it to the {@link drivers}\n     * list and calling {@link Driver.onEnable}. If the driver was already\n     * registered, nothing happens.\n     */\n    registerDriver(driver: Driver): void {\n        // If driver is not registered, register it\n        if(this.drivers.has(driver))\n            return;\n\n        this.drivers.add(driver);\n        if(this._enabled && driver.onEnable)\n            driver.onEnable(this);\n    }\n\n    /**\n     * Unregisters a {@link Driver} from the root, removing it from the\n     * {@link drivers} list and calling {@link Driver.onDisable}. If the driver\n     * was not registered, nothing happens.\n     */\n    unregisterDriver(driver: Driver): void {\n        // If driver is registered, unregister it\n        if(!this.drivers.delete(driver))\n            return;\n\n        if(this._enabled && driver.onDisable)\n            driver.onDisable(this);\n    }\n\n    /**\n     * Unregisters all {@link drivers} from the root, by calling\n     * {@link unregisterDriver}.\n     */\n    clearDrivers(): void {\n        // Unregister all drivers\n        for(const driver of this.drivers)\n            this.unregisterDriver(driver);\n    }\n\n    /**\n     * Can {@link getTextInput} be called? True if {@link textInputHandler} is\n     * not null and {@link usingMobileTextInput} is false.\n     */\n    get hasMobileTextInput(): boolean {\n        return this.textInputHandler !== null && !this._mobileTextInUse;\n    }\n\n    /**\n     * Is {@link getTextInput} in use?\n     *\n     * See {@link _mobileTextInUse}.\n     */\n    get usingMobileTextInput(): boolean {\n        return this._mobileTextInUse;\n    }\n\n    /**\n     * Get text input from the user. Used for mobile where keyboard events are\n     * hard to get.\n     *\n     * @returns If this is already in use ({@link usingMobileTextInput}), returns null, else, returns a string typed by the user.\n     */\n    async getTextInput(initialInput = ''): Promise<string | null> {\n        // Only get if text input is currently available\n        // XXX even though this if statement is equivalent to\n        // hasMobileTextInput, typescript type inference is bad and only works\n        // if its done this way, else it thinks that textInputHandler may be\n        // null and throws an error when compiling\n        if(this.textInputHandler !== null && !this._mobileTextInUse) {\n            // Flag text input as in-use\n            this._mobileTextInUse = true;\n\n            // Get input from handler\n            const newInput = await this.textInputHandler(initialInput);\n\n            // Flag text input as not in-use\n            this._mobileTextInUse = false;\n\n            // Return new value\n            return newInput;\n        }\n\n        return null;\n    }\n}\n", "import { TextPasteEvent } from '../events/TextPasteEvent';\nimport type { Widget } from '../widgets/Widget';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * Like Root, but for easy use in an HTML page.\n *\n * Instead of calling each individual update method, simply call {@link update}\n * on every animation frame. {@link Driver | Drivers} still need to be manually\n * registered.\n *\n * @category Core\n */\nexport class DOMRoot extends Root {\n    /** This root's canvas element. Add this to the HTML body */\n    readonly domElem: HTMLCanvasElement;\n    /** This root's canvas element's context. Used for painting */\n    private domCanvasContext: CanvasRenderingContext2D;\n\n    /**\n     * Create a new DOMRoot.\n     *\n     * Sets {@link child} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}. Also sets up a\n     * {@link pointerStyleHandler} which simply sets the CSS cursor style of\n     * {@link domElem}. Creates {@link domElem} and {@link domCanvasContext}.\n     *\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(child: Widget, theme: Theme = new Theme()) {\n        super(child, null, theme);\n\n        // Make DOM element, which is a canvas, and get a 2D context for it\n        this.domElem = document.createElement('canvas');\n        this.domElem.tabIndex = 1;\n        [this.domElem.width, this.domElem.height] = this.dimensions;\n\n        const context = this.domElem.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error('Failed to get DOM canvas context');\n\n        this.domCanvasContext = context;\n\n        // Setup pointer style handler\n        this.pointerStyleHandler = (newPointerStyle: string): void => {\n            this.domElem.style.cursor = newPointerStyle;\n        };\n\n        // Listen to paste events\n        this.domElem.addEventListener('paste', event => {\n            event.preventDefault();\n            if(event.clipboardData !== null)\n                this.dispatchEvent(new TextPasteEvent(event.clipboardData.getData('text')));\n        });\n        this.domElem.contentEditable = 'true';\n\n        // Remove styling added by contenteditable\n        this.domElem.style.outline = '0px solid transparent';\n        this.domElem.style.cursor = 'default';\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link domElem}'s display style is set to 'none',\n     * hiding it.\n     *\n     * Calls {@link preLayoutUpdate}, {@link resolveLayout},\n     * {@link postLayoutUpdate} and {@link paint}.\n     */\n    update(): void {\n        if(!this.enabled) {\n            this.domElem.style.display = 'none';\n            return;\n        }\n        else\n            this.domElem.style.removeProperty('display');\n\n        this.preLayoutUpdate();\n        if(this.resolveLayout())\n            [this.domElem.width, this.domElem.height] = this.dimensions;\n        this.postLayoutUpdate();\n        if(this.paint()) {\n            this.domCanvasContext.globalCompositeOperation = 'copy';\n            this.domCanvasContext.drawImage(this.canvas, 0, 0);\n        }\n    }\n}", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * An event which contains the state of modifier keys. This is an abstract class\n * and must be implemented in child classes.\n *\n * @category Event\n */\nexport abstract class ModifierEvent extends Event {\n    /** Is shift being pressed? */\n    readonly shift: boolean;\n    /** Is control being pressed? */\n    readonly ctrl: boolean;\n    /** Is alt being pressed? */\n    readonly alt: boolean;\n\n    /** Create a new ModifierEvent. */\n    constructor(shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null, focusType: FocusType | null, needsFocus: boolean) {\n        super(target, focusType, needsFocus);\n        this.shift = shift;\n        this.ctrl = ctrl;\n        this.alt = alt;\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A pointer {@link Event}.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerEvent extends ModifierEvent {\n    /** Pointer event position's X coordinate in pixels. Not an integer. */\n    readonly x: number;\n    /** Pointer event position's Y coordinate in pixels. Not an integer. */\n    readonly y: number;\n\n    /** Create a new PointerEvent. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(shift, ctrl, alt, target, focusType, false);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Create a new PointerEvent event with the same properties as this, except\n     * with new {@link x} and {@link y} values corrected for a given offset.\n     */\n    abstract correctOffset(xOffset: number, yOffset: number): PointerEvent;\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { FocusType } from '../core/FocusType';\nimport { BaseTheme } from '../theme/BaseTheme';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic widget. All widgets extend this class. All widgets extend\n * {@link BaseTheme} so that the theme in use can be overridden.\n *\n * @category Widget\n */\nexport abstract class Widget extends BaseTheme {\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     */\n    private _enabled = true;\n    /** Widget will only be painted if dirty is true. */\n    protected _dirty = true;\n    /**\n     * If this is true, widget needs their layout resolved. If implementing a\n     * container, propagate this up.\n     */\n    protected _layoutDirty = true;\n    /**\n     * Widget will have its background automatically cleared when painting if\n     * needsClear is true. The background fill style used is\n     * {@link canvasFill}.\n     */\n    readonly needsClear: boolean;\n    /**\n     * Widget will get targetted events even if the target is not itself if it\n     * this is true. Useful for implementing container widgets.\n     */\n    readonly propagatesEvents: boolean;\n    /** Width of widget in pixels. */\n    protected width = 0;\n    /** Height of widget in pixels. */\n    protected height = 0;\n    /** Absolute horizontal offset of widget in pixels. */\n    protected x = 0;\n    /** Absolute vertical offset of widget in pixels. */\n    protected y = 0;\n    /** {@link flex} but for internal use. */\n    protected _flex = 0;\n\n    /**\n     * How much this widget will expand relative to other widgets in a flexbox\n     * container. If changed, sets {@link _layoutDirty} to true.\n     */\n    get flex(): number {\n        return this._flex;\n    }\n\n    set flex(flex: number) {\n        if(flex !== this._flex) {\n            this._flex = flex;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** Create a new Widget. */\n    constructor(needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        this.needsClear = needsClear;\n        this.propagatesEvents = propagatesEvents;\n    }\n\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     *\n     * If changed, {@link _enabled} is set, {@link _layoutDirty} is set to true\n     * and {@link _dirty} is set to true if enabled or false if not enabled.\n     *\n     * If getting, {@link _enabled} is returned.\n     */\n    set enabled(enabled: boolean) {\n        if(enabled === this._enabled)\n            return;\n\n        this._enabled = enabled;\n        this._dirty = enabled;\n        this._layoutDirty = true;\n    }\n\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    /** The inherited theme of this widget. Sets {@link fallbackTheme}. */\n    set inheritedTheme(theme: Theme | undefined) {\n        this.fallbackTheme = theme;\n    }\n\n    get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(this.needsClear && (property === null || property === 'canvasFill'))\n            this._dirty = true;\n    }\n\n    /**\n     * Get the resolved dimensions. Returns a 2-tuple containing\n     * {@link width} and {@link height}.\n     */\n    get dimensions(): [number, number] {\n        return [this.width, this.height];\n    }\n\n    /**\n     * Get the resolved position. Returns a 2-tuple containing {@link x} and\n     * {@link y}.\n     */\n    get position(): [number, number] {\n        return [this.x, this.y];\n    }\n\n    /**\n     * Check if the widget is dirty. Returns {@link _dirty}, as long as\n     * {@link dimensionless} is not true.\n     */\n    get dirty(): boolean {\n        return this._dirty && !this.dimensionless;\n    }\n\n    /** Check if the widget's layout is dirty. Returns {@link _layoutDirty}. */\n    get layoutDirty(): boolean {\n        return this._layoutDirty;\n    }\n\n    /**\n     * Check if the widget has zero width or height.\n     *\n     * If true, {@link paint} will do nothing and {@link dirty} will be false\n     * even if {@link _dirty} is true.\n     *\n     * Usually becomes true when containers overflow.\n     */\n    get dimensionless(): boolean {\n        return this.width == 0 || this.height == 0;\n    }\n\n    /**\n     * Called when a focus type owned by this Widget has been dropped. Does\n     * nothing by default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusDropped(_focusType: FocusType, _root: Root): void {}\n\n    /**\n     * Widget event handling callback. If the event is to be captured, the\n     * capturer is returned, else, null.\n     *\n     * By default, this will do nothing and capture the event if it is targetted\n     * at itself.\n     *\n     * If overriding, return the widget that has captured the event (could be\n     * this, for example, or a child widget if implementing a container), or\n     * null if no widget captured the event.\n     */\n    protected handleEvent(event: Event, _root: Root): Widget | null {\n        if(event.target === this)\n            return this;\n        else\n            return null;\n    }\n\n    /**\n     * Called when an event is passed to the Widget. Checks if the target\n     * matches the Widget, unless the Widget propagates events, or if the event\n     * is a {@link PointerEvent} and is in the bounds of the Widget. If neither\n     * of the conditions are true, the event is not captured (null is returned),\n     * else, the {@link handleEvent} method is called and its result is\n     * returned. Must not be overridden.\n     *\n     * @returns Returns the widget that captured the event or null if none captured the event.\n     */\n    dispatchEvent(event: Event, root: Root): Widget | null {\n        if(!this._enabled)\n            return null;\n\n        if(event.target === null) {\n            if(event instanceof PointerEvent) {\n                if(event.x < this.x || event.y < this.y || event.x >= this.x + this.width || event.y >= this.y + this.height)\n                    return null;\n            }\n        }\n        else if(event.target !== this && !this.propagatesEvents)\n            return null;\n\n        return this.handleEvent(event, root);\n    }\n\n    /**\n     * Generic update method which is called before layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePreLayoutUpdate(_root: Root): void {}\n\n    /**\n     * Generic update method which is called before layout is resolved. Calls\n     * {@link handlePreLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    preLayoutUpdate(root: Root): void {\n        if(this._enabled)\n            this.handlePreLayoutUpdate(root);\n    }\n\n    /**\n     * Resolve dimensions of this widget. Must be implemented; set {@link width}\n     * and {@link height}.\n     */\n    protected abstract handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void;\n\n    /**\n     * Wrapper for {@link handleResolveDimensions}. Does nothing if\n     * {@link _enabled} is false. If the resolved dimensions change,\n     * {@link _dirty} is set to true. {@link _layoutDirty} is set to false. If\n     * the widget is not loose and the layout has non-infinite max constraints,\n     * then the widget is stretched to fit max constraints. Must not be\n     * overridden.\n     */\n    resolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Do nothing if disabled\n        if(!this._enabled) {\n            this.width = 0;\n            this.height = 0;\n            this._layoutDirty = false;\n            return;\n        }\n\n        // Validate constraints\n        if(minWidth == Infinity)\n            throw new Error('minWidth must not be infinite');\n        if(minWidth > maxWidth) {\n            // Not throwing here because floating pointer precision errors\n            // sometimes trigger this due to tight constraints\n            console.warn(`minWidth (${minWidth}) must not be greater than maxWidth (${maxWidth}). Set minWidth to maxWidth. This may be caused by floating pointer precision errors`);\n            minWidth = maxWidth;\n        }\n        if(minWidth < 0) {\n            console.warn(`minWidth (${minWidth}) must not be lesser than 0. Set minWidth to 0. This may be caused by floating pointer precision errors`);\n            minWidth = 0;\n        }\n\n        if(minHeight == Infinity)\n            throw new Error('minHeight must not be infinite');\n        if(minHeight > maxHeight) {\n            console.warn(`minHeight (${minHeight}) must not be greater than maxHeight (${maxHeight}). Set minHeight to maxHeight. This may be caused by floating pointer precision errors`);\n            minHeight = maxHeight;\n        }\n        if(minHeight < 0) {\n            console.warn(`minHeight (${minHeight}) must not be lesser than 0. Set minHeight to 0. This may be caused by floating pointer precision errors`);\n            minHeight = 0;\n        }\n\n        // Keep track of old dimensions to compare later\n        const oldWidth = this.width;\n        const oldHeight = this.height;\n\n        // Resolve dimensions\n        this.handleResolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Validate resolved dimensions, handling overflows, underflows and\n        // invalid dimensions\n        if(this.width < minWidth) {\n            this.width = minWidth;\n            console.error('Horizontal underflow in widget');\n        }\n        else if(this.width > maxWidth) {\n            this.width = maxWidth;\n            console.error('Horizontal overflow in widget');\n        }\n\n        if(this.width < 0 || !isFinite(this.width) || isNaN(this.width))\n            throw new Error(`Disallowed width (${this.width}) in widget`);\n\n        if(this.height < minHeight) {\n            this.height = minHeight;\n            console.error('Vertical underflow in widget');\n        }\n        else if(this.height > maxHeight) {\n            this.height = maxHeight;\n            console.error('Vertical overflow in widget');\n        }\n\n        if(this.height < 0 || !isFinite(this.height) || isNaN(this.height))\n            throw new Error(`Disallowed height (${this.height}) in widget`);\n\n        // Clear layout dirty flag\n        this._layoutDirty = false;\n\n        // If dimensions changed (compare with tracked old dimensions), then set\n        // dirty flag\n        if(oldWidth !== this.width || oldHeight !== this.height)\n            this._dirty = true;\n\n        //console.log('Resolved layout of', this.constructor.name);\n    }\n\n    /**\n     * Like {@link resolveDimensions} but for widgets at the top of the widget\n     * tree (the child of the {@link Root}). This retries dimension resolving if\n     * there is at least one unconstrained axis so that flex layout works even\n     * in infinite layout.\n     */\n    resolveDimensionsAsTop(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Resolve dimensions again, now with maximum constraints. This is so\n        // that widgets that depend on max constraints, such as containers that\n        // handle flexbox layout, work properly. Only do this if constraints\n        // don't already have maximum dimensions.\n        if(maxWidth === Infinity || maxHeight === Infinity) {\n            this.resolveDimensions(\n                minWidth,\n                maxWidth === Infinity ? this.width : maxWidth,\n                minHeight,\n                maxHeight === Infinity ? this.height : maxHeight,\n            );\n        }\n    }\n\n    /**\n     * Called after resolving position of this widget. Should be implemented if\n     * widget is a container; call resolvePosition of children. Does nothing by\n     * default.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected afterPositionResolved(): void {}\n\n    /**\n     * Set the position of this widget and calls {@link afterPositionResolved}.\n     * If the resolved position changes, sets {@link _dirty} to true. Does\n     * nothing if {@link _enabled} is false. Must not be overridden.\n     */\n    resolvePosition(x: number, y: number): void {\n        // Mark as dirty if position changed\n        if(x !== this.x || y !== this.y)\n            this._dirty = true;\n\n        // Set position\n        this.x = x;\n        this.y = y;\n\n        // Call hook\n        this.afterPositionResolved();\n    }\n\n    /**\n     * Generic update method which is called after layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePostLayoutUpdate(_root: Root): void {}\n\n    /**\n     * Generic update method which is called after layout is resolved. Calls\n     * {@link handlePostLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    postLayoutUpdate(root: Root): void {\n        if(this._enabled)\n            this.handlePostLayoutUpdate(root);\n    }\n\n    /**\n     * Paiting utility: clears background of widget. Should not be overridden.\n     *\n     * Rounds to nearest pixels; no subpixel clearing.\n     *\n     * The background fill style used is {@link ThemeProperty.CanvasFill}.\n     *\n     * @param fillStyle The fill style to use for clearing. If null (default), then the value of {@link canvasFill} is used\n     */\n    protected clear(x: number, y: number, width: number, height: number, ctx: CanvasRenderingContext2D, fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n        // These are rounded because clipping and filling doesn't\n        // work properly with decimal points\n        ctx.rect(Math.trunc(x), Math.trunc(y), Math.ceil(width), Math.ceil(height));\n        ctx.clip();\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Paiting utility: start a clear operation with no clipping path, the user\n     * has to add their own paths to the context. Should not be overridden.\n     *\n     * The background fill style used is {@link ThemeProperty.CanvasFill}.\n     *\n     * @param fillStyle The fill style to use for clearing. If null (default), then the value of {@link canvasFill} is used\n     */\n    protected clearStart(ctx: CanvasRenderingContext2D, fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n    }\n\n    /**\n     * Paiting utility: end a clear operation (from {@link clearStart}). Should\n     * not be overridden.\n     *\n     * @param fillRule The canvas fill rule for clipping. See the {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip#parameters | canvas clip documentation}\n     */\n    protected clearEnd(ctx: CanvasRenderingContext2D, fillRule: CanvasFillRule = 'nonzero'): void {\n        ctx.clip(fillRule);\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Paiting/layout utility: rounds the bounds of a rectangle to the nearest\n     * pixels.\n     *\n     * @param roundInwards Should the rectangle be rounded inwards (shrunk instead of expanded)? False by default\n     * @returns Returns a 4-tuple containing rounded x, y, width and height respectively\n     */\n    protected roundRect(x: number, y: number, width: number, height: number, roundInwards = false): [number, number, number, number] {\n        // Decide rounding functions\n        const roundDown = roundInwards ? Math.ceil : Math.floor;\n        const roundUp = roundInwards ? Math.floor : Math.ceil;\n\n        // Round rectangle\n        x = roundDown(x);\n        y = roundDown(y);\n        return [x, y, roundUp(x + width) - x, roundUp(y + height) - y];\n    }\n\n    /**\n     * Widget painting callback. By default does nothing. Do painting logic here\n     * when extending Widget. Even if {@link dirty} is false, if this method is\n     * called, then the widget must still be painted. Should be overridden.\n     *\n     * @param forced Was this widget force-painted? If calling a child's paint method, propagate this value\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePainting(_ctx: CanvasRenderingContext2D, _forced: boolean): void {}\n\n    /**\n     * Called when the Widget is dirty and the Root is being rendered. Does\n     * nothing if dirty flag is not set, else, clears the background if\n     * {@link needsClear} is true, calls the {@link handlePainting} method and\n     * unsets the dirty flag. Automatically calls {@link dryPaint} if\n     * {@link dimensionless} is true. Must not be overridden.\n     *\n     * @param force Force re-paint even if {@link dirty} is false\n     */\n    paint(ctx: CanvasRenderingContext2D, force = false): void {\n        if(this.dimensionless)\n            return this.dryPaint();\n\n        if(!this._dirty && !force)\n            return;\n\n        //console.log('Painted', this.constructor.name);\n\n        if(this._enabled) {\n            if(this.needsClear)\n                this.clear(this.x, this.y, this.width, this.height, ctx);\n\n            ctx.save();\n            this.handlePainting(ctx, force);\n            ctx.restore();\n        }\n\n        this._dirty = false;\n    }\n\n    /**\n     * Unset this widget's dirty flag. Call this when painting a child that you\n     * know will not be visible, such as if clipping and the child is out of\n     * bounds. If implementing a container widget, override this so that each\n     * child widget's dryPaint method is called.\n     */\n    dryPaint(): void {\n        this._dirty = false;\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Theme } from '../theme/Theme';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A mixin class for widgets which may have children.\n *\n * Overrides the {@link inheritedTheme} accessor so that inherited themes are\n * propagated to children, and {@link dryPaint} so that dry painting this parent\n * also dry paints the children. Also provides utilities for getting the amount\n * of children, a public iterator for children and a protected child list. This\n * way, widgets that extend this class can decide if modifying the list of\n * children should be public or not.\n *\n * Can be constrained to a specific type of children.\n *\n * See {@link MultiParent} and {@link SingleParent} for more specialised\n * versions.\n *\n * @category Widget\n */\nexport abstract class Parent<W extends Widget = Widget> extends Widget {\n    /**\n     * This widget's children. Note that this is marked as readonly so that it\n     * cannot be accidentally replaced with a new array. This way, references to\n     * this array are always valid. If you want to clear this array, set the\n     * length to zero instead of creating a new instance. readonly still means\n     * that you can add/remove elements to/from the array.\n     *\n     * See {@link children} for the public iterator getter.\n     */\n    protected readonly _children: Array<W>;\n\n    /**\n     * Create a new Parent. Automatically adds all widgets in the input array\n     * to {@link _children}.\n     */\n    constructor(children: Array<W>, needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super(needsClear, propagatesEvents, themeProperties);\n\n        this._children = [...children];\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        super.inheritedTheme = theme;\n        for(const child of this.children)\n            child.inheritedTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return super.inheritedTheme;\n    }\n\n    override dryPaint(): void {\n        super.dryPaint();\n\n        for(const child of this.children)\n            child.dryPaint();\n    }\n\n    /** Get amount of children of this parent widget. */\n    get childCount(): number {\n        return this._children.length;\n    }\n\n    /**\n     * Get iterator for children of this parent widget. Cannot modify list of\n     * children via this iterator; for read-only purposes only.\n     */\n    get children(): Iterable<W> {\n        return this._children.values();\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with a\n * single mandatory child.\n *\n * @category Widget\n */\nexport abstract class SingleParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Create a new SingleParent instance.\n     *\n     * @param child The mandatory single child of this widget. Cannot be changed later, unless {@link _children} is changed directly via the widget using this mixin.\n     */\n    constructor(child: W, needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super([child], needsClear, propagatesEvents, themeProperties);\n    }\n\n    /** This widget's child. */\n    get child(): W {\n        return this._children[0];\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and does nothing,\n * passing all events through to its child. Useful for widgets that are only\n * used for logic, like {@link ThemeScope}.\n *\n * Can be constrained to a specific type of children.\n *\n * Since this does nothing on its own, it should not be used on its own.\n * Instead, extend this class if you are looking for a way to do wrapper widgets\n * that provide extra logic.\n *\n * @category Widget\n */\nexport class PassthroughWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        // Passthrough widgets dont need a clear background, have a child and\n        // propagate events\n        super(child, false, true, themeProperties);\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve child's dimensions and set own resolved dimensions to be\n        // equal to the child's\n        const child = this.child;\n        child.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n        [this.width, this.height] = child.dimensions;\n    }\n\n    protected override afterPositionResolved(): void {\n        // Resolve child's position to be the same as this widget's position\n        this.child.resolvePosition(this.x, this.y);\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        // Paint child\n        this.child.paint(ctx, forced);\n    }\n}", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { layoutArrayField } from '../decorators/FlagFields';\nimport { PassthroughWidget } from './PassthroughWidget';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which imposes further layout constraints onto a\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ArtificialConstraint<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** See {@link constraints}. For internal use only */\n    private _constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n\n    /**\n     * The further constraints given to the child. A 4-tuple containing,\n     * respectively, minimum width, maximum width, minimum height and maximum\n     * height. Changing this sets {@link _layoutDirty} to true. Constraints are\n     * only applied if they are more restrictive than the original constraints.\n     *\n     * @decorator `@layoutArrayField()`\n     */\n    @layoutArrayField()\n    constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, constraints: LayoutConstraints = [0, Infinity, 0, Infinity], themeProperties?: ThemeProperties) {\n        super(child, themeProperties);\n\n        this._constraints = [...constraints];\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Further restrict constraints if possible.\n        let newMinWidth = Math.min(Math.max(this._constraints[0], minWidth), maxWidth);\n        let newMinHeight = Math.min(Math.max(this._constraints[2], minHeight), maxHeight);\n        const newMaxWidth = Math.min(Math.max(this._constraints[1], minWidth), maxWidth);\n        const newMaxHeight = Math.min(Math.max(this._constraints[3], minHeight), maxHeight);\n\n        if(newMinWidth > newMaxWidth)\n            newMinWidth = newMaxWidth;\n\n        if(newMinHeight > newMaxHeight)\n            newMinHeight = newMaxHeight;\n\n        // Resolve dimensions\n        super.handleResolveDimensions(newMinWidth, newMaxWidth, newMinHeight, newMaxHeight);\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { PointerEvent } from './PointerEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A {@link PointerEvent} for button presses/releases, containing helpers for\n * checking whether it was the left/primary button, right/secondary button or\n * middle/tertiary button. Always take the button ID into account when handling\n * this event as you get a pair of {@link PointerPress} and\n * {@link PointerRelease} events per button ID.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerButtonEvent extends PointerEvent {\n    /**\n     * The ID of the button affected.\n     *\n     * 0: left/primary button.\n     * 1: right/secondary button.\n     * 2: middle/tertiary button.\n     * etc...\n     */\n    readonly button: number;\n\n    /** Create a new PointerButtonEvent. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(x, y, shift, ctrl, alt, target, focusType);\n        this.button = button;\n    }\n\n    /** Is the button affected the left/primary button? */\n    get isLeft(): boolean {\n        return this.button === 0;\n    }\n\n    /** Alias for {@link isLeft} */\n    get isPrimary(): boolean {\n        return this.isLeft;\n    }\n\n    /** Is the button affected the right/secondary button? */\n    get isRight(): boolean {\n        return this.button === 1;\n    }\n\n    /** Alias for {@link isRight} */\n    get isSecondary(): boolean {\n        return this.isRight;\n    }\n\n    /** Is the button affected the middle/tertiary button? */\n    get isMiddle(): boolean {\n        return this.button === 2;\n    }\n\n    /** Alias for {@link isMiddle} */\n    get isTertiary(): boolean {\n        return this.isMiddle;\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { FocusType } from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer release {@link PointerButtonEvent} (pointer button up).\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerRelease extends PointerButtonEvent {\n    /** Create a new PointerRelease. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerRelease {\n        return new PointerRelease(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerRelease {\n        return new PointerRelease(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer press {@link PointerButtonEvent} (pointer button down).\n *\n * Has no focus type and does not need focus.\n *\n * @category Event\n */\nexport class PointerPress extends PointerButtonEvent {\n    /** Create a new PointerPress. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerPress {\n        return new PointerPress(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerPress {\n        return new PointerPress(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n\n", "import { PointerRelease } from '../events/PointerRelease';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\n/**\n * The current state of a {@link ClickHelper}\n *\n * @category Helper\n */\nexport enum ClickState {\n    /** No pointer is hovering over this clickable widget */\n    Released,\n    /** A pointer is hovering over this clickable widget */\n    Hover,\n    /** A pointer's button is being held down over this clickable widget */\n    Hold,\n}\n\n/**\n * An aggregate helper class for widgets that can be clicked.\n *\n * Keeps its current click state as well as its last click state, last pointer\n * position and whether the last click state change resulted in an actual click.\n *\n * @category Helper\n */\nexport class ClickHelper {\n    /** Last click state */\n    lastClickState: ClickState = ClickState.Released;\n    /** The current click state */\n    clickState: ClickState = ClickState.Released;\n    /** Did the last click event handle result in a click state change? */\n    clickStateChanged = false;\n    /** Did the last click state change result in a click? */\n    wasClick = false;\n    /**\n     * Last pointer position in normalised coordinates ([0,0] to [1,1]). If\n     * there is no last pointer position, such as after a leave event, this will\n     * be null. If pointer position was outside box, it will be beyond the [0,0]\n     * to [1,1] range.\n     */\n    pointerPos: [number, number] | null = null;\n    /**\n     * Like {@link pointerPos}, but only updated when a hold state begins.\n     *\n     * Useful for implementing draggable widgets.\n     */\n    startingPointerPos: [number, number] | null = null;\n    /** Which pointer button should count as a click? Left button by default */\n    pointerButton = 0;\n    /** The Widget aggregating this helper */\n    private widget: Widget;\n\n    /**\n     * Create a new ClickHelper\n     *\n     * @param widget The Widget aggregating this helper\n     */\n    constructor(widget: Widget) {\n        this.widget = widget;\n    }\n\n    /**\n     * Normalise pointer coordinates inside a rectangle\n     *\n     * @param pX Pointer X coordinate, in pixels\n     * @param pY Pointer Y coordinate, in pixels\n     * @param rLeft Rectangle's left coordinate, in pixels\n     * @param rRight Rectangle's right coordinate, in pixels\n     * @param rTop Rectangle's top coordinate, in pixels\n     * @param rBottom Rectangle's bottom coordinate, in pixels\n     * @returns Returns normalised coordinates\n     */\n    getNormalInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): [number, number] {\n        return [(pX - rLeft) / (rRight - rLeft), (pY - rTop) / (rBottom - rTop)];\n    }\n\n    /**\n     * Check if a point, in pixels, is inside a rectangle.\n     *\n     * @param pX Pointer X coordinate, in pixels\n     * @param pY Pointer Y coordinate, in pixels\n     * @param rLeft Rectangle's left coordinate, in pixels\n     * @param rRight Rectangle's right coordinate, in pixels\n     * @param rTop Rectangle's top coordinate, in pixels\n     * @param rBottom Rectangle's bottom coordinate, in pixels\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isPointInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): boolean {\n        return pX >= rLeft && pX < rRight && pY >= rTop && pY < rBottom;\n    }\n\n    /**\n     * Check if a normalised point is inside a rectangle.\n     *\n     * Since the coordinates are normalised, you don't have to define the\n     * coordinates of the rectangle, which may seem counterintuitive.\n     *\n     * @param pX Pointer X coordinate, normalised\n     * @param pY Pointer Y coordinate, normalised\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isNormalInRect(pX: number, pY: number): boolean {\n        return pX >= 0 && pX < 1 && pY >= 0 && pY < 1;\n    }\n\n    /**\n     * Set {@link clickState} and update {@link lastClickState} if current one\n     * differs. Updates {@link wasClick} and {@link clickStateChanged} flags.\n     */\n    private setClickState(clickState: ClickState, inside: boolean): void {\n        if(this.clickState !== clickState) {\n            this.lastClickState = this.clickState;\n            this.clickState = clickState;\n\n            // If last state was a hold and pointer is still inside click\n            // area, this was a click\n            this.wasClick = inside && this.lastClickState === ClickState.Hold;\n            this.clickStateChanged = true;\n        }\n        else\n            this.clickStateChanged = false;\n    }\n\n    /**\n     * Updates the current {@link clickState} given an event, as well as\n     * {@link _foci | focus}, {@link pointerStyle}, {@link wasClick} and\n     * {@link clickStateChanged} flags.\n     *\n     * @param clickArea A 4-tuple containing, respectively, left coordinate, right coordinate, top coordinate and bottom coordinate of clickable area, in pixels\n     */\n    handleClickEvent(event: Event, root: Root, clickArea: [number, number, number, number]): void {\n        if(event instanceof Leave) {\n            // Drop focus on this widget if this is a leave event\n            root.dropFocus(FocusType.Pointer, this.widget);\n            this.pointerPos = null;\n            return this.setClickState(ClickState.Released, false);\n        }\n        else if(event instanceof PointerEvent) {\n            // Normalise pointer coordinates in click area\n            this.pointerPos = this.getNormalInRect(event.x, event.y, ...clickArea);\n\n            // If pointer is over the clickable rectangle, then change the\n            // pointer style, else, if not targetted, drop focus\n            const inside = this.isNormalInRect(...this.pointerPos);\n            if(inside)\n                root.pointerStyle = 'pointer';\n            else if(event.target === null) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Released, false);\n            }\n\n            // If this is a press event, request focus and set starting\n            // pointer coordinates. Ignore if wrong button\n            if(event instanceof PointerPress && event.button === this.pointerButton) {\n                this.startingPointerPos = this.pointerPos;\n                root.requestFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Hold, inside);\n            }\n\n            // If this is a release event, drop focus. Ignore if wrong button\n            if(event instanceof PointerRelease && event.button === this.pointerButton) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                if(inside)\n                    return this.setClickState(ClickState.Hover, inside);\n                else\n                    return this.setClickState(ClickState.Released, inside);\n            }\n\n            // If event was focused, then it's a hold, else, it's a hover\n            if(event.target === null)\n                return this.setClickState(ClickState.Hover, inside);\n            else\n                return this.setClickState(ClickState.Hold, inside);\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer wheel {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerWheel extends PointerEvent {\n    /** Wheel event horizontal scroll amount in pixels. Not an integer. */\n    readonly deltaX: number;\n    /** Wheel event vertical scroll amount in pixels. Not an integer. */\n    readonly deltaY: number;\n    /** Was this wheel event created from a pointer drag? */\n    readonly fromDrag: boolean;\n\n    /** Create a new PointerWheel. */\n    constructor(x: number, y: number, deltaX: number, deltaY: number, fromDrag: boolean, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n        this.deltaX = deltaX;\n        this.deltaY = deltaY;\n        this.fromDrag = fromDrag;\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerWheel {\n        return new PointerWheel(this.x - xOffset, this.y - yOffset, this.deltaX, this.deltaY, this.fromDrag, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerWheel {\n        return new PointerWheel(this.x, this.y, this.deltaX, this.deltaY, this.fromDrag, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { FillStyle } from '../theme/FillStyle';\nimport { Alignment } from '../theme/Alignment';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and automatically paints\n * the child, adds padding, propagates events (if enabled) and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class BaseContainer<W extends Widget = Widget> extends SingleParent<W> {\n    /** Does the background need to be cleared? */\n    protected backgroundDirty = true;\n\n    /** Create a new BaseContainer. */\n    constructor(child: W, propagateEvents: boolean, themeProperties?: ThemeProperties) {\n        // Containers clear their own background, have a child and may propagate\n        // events\n        super(child, false, propagateEvents, themeProperties);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n\n        // If background is dirty, set self as dirty\n        if(this.backgroundDirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get padding\n        const padding = this.containerPadding;\n        const hPadding = padding.left + padding.right;\n        const vPadding = padding.top + padding.bottom;\n        let childMaxWidth = maxWidth - hPadding;\n        let childMaxHeight = maxHeight - vPadding;\n\n        // If there isn't enough space for padding, resolve child's layout with\n        // a tight fit of 0 for axis with lack of space\n        if(childMaxWidth < 0)\n            childMaxWidth = 0;\n        if(childMaxHeight < 0)\n            childMaxHeight = 0;\n\n        // Provide minimum constraints if using stretch alignment, correcting\n        // for padding. If maximum constraints are available (not infinite), use\n        // those instead\n        const alignment = this.containerAlignment;\n        let childMinWidth = 0;\n        if(alignment.horizontal === Alignment.Stretch) {\n            if(childMaxWidth !== Infinity)\n                childMinWidth = childMaxWidth;\n            else\n                childMinWidth = Math.max(minWidth - hPadding, 0);\n        }\n\n        let childMinHeight = 0;\n        if(alignment.vertical === Alignment.Stretch) {\n            if(childMaxHeight !== Infinity)\n                childMinHeight = childMaxHeight;\n            else\n                childMinHeight = Math.max(minHeight - vPadding, 0);\n        }\n\n        // Resolve child's dimensions\n        const [oldChildWidth, oldChildHeight] = this.child.dimensions;\n        this.child.resolveDimensions(childMinWidth, childMaxWidth, childMinHeight, childMaxHeight);\n        const [childWidth, childHeight] = this.child.dimensions;\n\n        // Resolve own dimensions\n        const [oldWidth, oldHeight] = [this.width, this.height];\n        this.width = Math.max(minWidth, childWidth + hPadding);\n        this.height = Math.max(minHeight, childHeight + vPadding);\n\n        // Mark background as dirty if own size or child's size changed\n        if(this.width !== oldWidth || this.height !== oldHeight ||\n           childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n            this.backgroundDirty = true;\n    }\n\n    protected override afterPositionResolved(): void {\n        // Get padding and alignment\n        const padding = this.containerPadding;\n        const alignment = this.containerAlignment;\n\n        // Calculate used space\n        const [childWidth, childHeight] = this.child.dimensions;\n        const usedWidth = childWidth + padding.left + padding.right;\n        const usedHeight = childHeight + padding.top + padding.bottom;\n\n        // Horizontal offset\n        let childX = this.x + padding.left;\n        if(alignment.horizontal !== Alignment.Stretch) {\n            // Get free space for this axis\n            const freeSpace = this.width - usedWidth;\n\n            // Ignore if free space is negative or zero, as in, the child didn't\n            // even get the space they requested or just enough space. If there\n            // is free space, distribute free space according to chosen\n            // alignment ratio\n            if(freeSpace > 0)\n                childX += freeSpace * alignment.horizontal;\n        }\n\n        // Vertical offset\n        let childY = this.y + padding.top;\n        if(alignment.vertical !== Alignment.Stretch) {\n            // Same logic as above, but for vertical axis\n            const freeSpace = this.height - usedHeight;\n\n            if(freeSpace > 0)\n                childY += freeSpace * alignment.vertical;\n        }\n\n        // Resolve child's position\n        const [oldChildX, oldChildY] = this.child.position;\n        this.child.resolvePosition(childX, childY);\n\n        // If child's position changed, mark background as dirty\n        if(oldChildX !== childX || oldChildY !== childY)\n            this.backgroundDirty = true;\n    }\n\n    /**\n     * Implementation of handlePainting; separate from handlePainting so that\n     * the fillStyle for the background clear can be overridden.\n     */\n    protected handleBaseContainerPainting(ctx: CanvasRenderingContext2D, forced: boolean, fillStyle: FillStyle | null = null): void {\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart(ctx, fillStyle);\n            ctx.rect(...this.roundRect(this.x, this.y, this.width, this.height));\n            ctx.rect(...this.roundRect(...this.child.position, ...this.child.dimensions, true));\n            this.clearEnd(ctx, 'evenodd');\n\n            this.backgroundDirty = false;\n        }\n\n        // Paint child\n        this.child.paint(ctx, forced);\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        this.handleBaseContainerPainting(ctx, forced);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { ClickHelper } from '../helpers/ClickHelper';\nimport { BaseContainer } from './BaseContainer';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which can be {@link ClickHelper | clicked} as a\n * button. Since the button grabs all events, no events are propagated to the\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Button<W extends Widget = Widget> extends BaseContainer<W> {\n    /** The helper for handling pointer clicks */\n    protected clickHelper: ClickHelper;\n    /**\n     * The callback for clicking this button. If null, the button is not\n     * clickable but will still absorb events.\n     */\n    callback: (() => void) | null;\n\n    /** Create a new Button. */\n    constructor(child: W, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(child, false, themeProperties);\n        this.clickHelper = new ClickHelper(this);\n        this.callback = callback;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Ignore wheel events\n        if(event instanceof PointerWheel)\n            return null;\n\n        // Abort if no callback, but still absorb events\n        if(this.callback === null) {\n            this.clickHelper.clickStateChanged = false;\n            return this;\n        }\n\n        // Check if button was pressed and call callback if so\n        this.clickHelper.handleClickEvent(event, root, [this.x, this.x + this.width, this.y, this.y + this.height]);\n        if(this.clickHelper.clickStateChanged && this.clickHelper.wasClick) {\n            try {\n                this.callback();\n            }\n            catch(e) {\n                console.error('Exception in Icon callback', e);\n            }\n        }\n\n        return this;\n    }\n}\n", "import { ThemeProperties } from '../theme/ThemeProperties';\nimport { watchField } from '../decorators/FlagFields';\nimport { ClickState } from '../helpers/ClickHelper';\nimport { FillStyle } from '../theme/FillStyle';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\nimport { Button } from './Button';\n\n/**\n * A {@link Button} which overrides the canvas colour, meaning that it has a\n * filled background.\n *\n * Can be constrained to a specific type of children.\n *\n * This button version can also be \"forced down\"; the button becomes similar to\n * being pressed, visually. Useful for implementing widgets such as\n * {@link ShiftKey}.\n *\n * @category Widget\n */\nexport class FilledButton<W extends Widget = Widget> extends Button<W> {\n    /** Theme property used for overriding the canvas colour. */\n    private backgroundProperty = 'backgroundFill';\n    // TODO I'm not a big fan of using a prototype's method as a callback :|\n    /**\n     * Is the button currently forced down?\n     *\n     * @decorator `@watchField(FilledButton.prototype.updateBackground)`\n     */\n    @watchField(FilledButton.prototype.updateBackground)\n    forced = false;\n    /** The inherited theme for the child */\n    private childTheme: Theme;\n\n    /** Create a new FilledButton. */\n    constructor(child: W, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(child, callback, themeProperties);\n\n        // Make theme that will be inherited by child. Later, this theme's\n        // canvasFill property will be changed, notifying the child. Make the\n        // child inherit the theme. fallbackTheme is also later set when this\n        // widget inherits a theme\n        this.childTheme = new Theme(<ThemeProperties>{\n            canvasFill: this.getBackgroundFill(),\n        });\n        this.child.inheritedTheme = this.childTheme;\n    }\n\n    /**\n     * Update the background fill.\n     *\n     * Sets {@link backgroundProperty} depending on {@link _forced} and\n     * {@link clickState}, calls {@link inheritTheme} and sets\n     * {@link _backgroundDirty} to true.\n     */\n    private updateBackground(): void {\n        const oldProperty = this.backgroundProperty;\n\n        if(this.forced)\n            this.backgroundProperty = 'primaryFill';\n        else {\n            switch(this.clickHelper.clickState) {\n            case ClickState.Hold:\n                this.backgroundProperty = 'accentFill';\n                break;\n            case ClickState.Hover:\n                this.backgroundProperty = 'backgroundGlowFill';\n                break;\n            default:\n                this.backgroundProperty = 'backgroundFill';\n                break;\n            }\n        }\n\n        // Update canvasFill property of child's theme\n        if(oldProperty !== this.backgroundProperty) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n    }\n\n    private getBackgroundFill(): FillStyle {\n        switch(this.backgroundProperty) {\n            case 'primaryFill':\n                return this.primaryFill;\n            case 'accentFill':\n                return this.accentFill;\n            case 'backgroundGlowFill':\n                return this.backgroundGlowFill;\n            case 'backgroundFill':\n                return this.backgroundFill;\n            default:\n                throw new Error(`Unknown theme property: ${this.backgroundProperty}`);\n        }\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        if(theme === this.fallbackTheme)\n            return;\n\n        this.fallbackTheme = theme;\n        this.childTheme.fallbackTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === this.backgroundFill) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        const capturer = super.handleEvent(event, root);\n\n        if(this.clickHelper.clickStateChanged)\n            this.updateBackground();\n\n        return capturer;\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        this.handleBaseContainerPainting(ctx, forced, this.getBackgroundFill());\n    }\n}\n", "let measureContext: CanvasRenderingContext2D | null = null;\n\n/**\n * Measures the dimensions of a given string of text with a given font.\n *\n * Note that the first time calling this function is slower than subsequent\n * calls because a dedicated canvas context must be created.\n *\n * @returns Returns a the TextMetrics of the measured text.\n *\n * @category Helper\n */\nexport function measureTextDims(text: string, font: string): TextMetrics {\n    // Get canvas context if not yet got\n    if(measureContext === null) {\n        const tempCanvas = document.createElement('canvas');\n        measureContext = tempCanvas.getContext('2d');\n        if(measureContext === null)\n            throw new Error('Failed to get canvas context');\n    }\n\n    // Set font\n    measureContext.font = font;\n\n    // Measure text\n    // TODO cache a limited amount of text measurements\n    return measureContext.measureText(text);\n}\n", "import { measureTextDims } from '../helpers/measureTextDims';\nimport { multiFlagField } from '../decorators/FlagFields';\nimport { FillStyle } from '../theme/FillStyle';\n\nconst WIDTH_OVERRIDING_CHARS = new Set(['\\n', '\\t']);\n\n/**\n * A text render group. Contains all neccessary information to position a piece\n * of text.\n *\n * A 4-tuple containing, respectively, the inclusive index where the piece of\n * text starts, the exclusive index where the piece of text ends (including\n * characters that aren't rendered, such as newlines), the right horizontal\n * offset of the piece of text and whether the piece of text overrides width or\n * not.\n *\n * For characters that override width, the text range should have a length of 1\n * and will not be merged with other text render groups, else, it is a hint\n * containing the pre-measured size, for optimisation reasons, and may be merged\n * with other text render groups. Width-overidding groups where the text range\n * length is greater than 1 will have the length of each individual character as\n * an interpolation of the total length, where each character has equal width,\n * which is cheap, but innacurate; this is the reason why it is preferred to\n * have length 1 text range for width-overriding groups although you may still\n * want this for specific reasons (such as trailing space removal).\n * Width-overriding groups are also only meant to be used for whitespaces and\n * will therefore not be painted.\n *\n * Note that 0-width text render groups are valid and used for empty lines.\n *\n * @category Helper\n */\nexport type TextRenderGroup = [rangeStart: number, rangeEnd: number, right: number, overridesWidth: boolean];\n\n/**\n * A line range. Contains all neccessary information to render a line of text.\n * An array of text render groups.\n *\n * @category Helper\n */\nexport type LineRange = Array<TextRenderGroup>;\n\n/**\n * The mode to use for text wrapping in {@link TextHelper}.\n *\n * @category Helper\n */\nexport enum WrapMode {\n    /**\n     * Whitespaces always have width. The default wrapping mode for input\n     * widgets\n     */\n    Normal,\n    /**\n     * Whitespaces at the end of a line which result in an overflow have no\n     * width. The default wrapping mode for widgets that display text, since\n     * spaces at the beginning of a line due to wrapping looks weird in\n     * {@link Label | labels}. Whitespaces at the beginning of a new line are\n     * still kept, as they are deliberate.\n     */\n    Shrink,\n}\n\n/**\n * An aggregate helper class for widgets that contain text.\n *\n * Contains utilities for measuring text dimensions, converting between offsets\n * in pixels and text indices and painting.\n *\n * @category Helper\n */\nexport class TextHelper {\n    /**\n     * The current string of text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    text = '';\n    /**\n     * The current font used for rendering text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])\n    font = '';\n    /**\n     * The current maximum text width. If not Infinite, then text will be\n     * wrapped.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    maxWidth = Infinity;\n    /**\n     * The height of each line of text when wrapped. If null, then the helper\n     * will try to automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineHeight: number | null = null;\n    /**\n     * The amount of spacing between lines. If null, then the helper will try to\n     * automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineSpacing: number | null = null;\n    /**\n     * The amount of spaces that each tab character is equivalent to. By\n     * default, it is equivalent to 4 spaces.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])\n    tabWidth = 4;\n    /**\n     * The mode for text wrapping\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    wrapMode: WrapMode = WrapMode.Normal;\n\n    /** The current largest text width. May be outdated. */\n    private _width = 0;\n    /** The current total text height. May be outdated. */\n    private _height = 0;\n    /** The current {@link lineHeight}. May be outdated */\n    private _lineHeight = 0;\n    /** The current {@link lineSpacing}. May be outdated */\n    private _lineSpacing = 0;\n    /** The actual {@link tabWidth} in pixels. May be outdated */\n    private _tabWidth = 0;\n\n    /** Does the text need to be re-measured? */\n    private measureDirty = true;\n    /** Does the line height or spacing need to be re-measured? */\n    private lineHeightSpacingDirty = true;\n    /** Does the tab width need to be re-measured? */\n    private tabWidthDirty = true;\n    /** Has the text (or properties associated with it) changed? */\n    private _dirty = false;\n    /** See {@link lineRanges}. For internal use only. */\n    private _lineRanges: Array<LineRange> = [];\n\n    /**\n     * Has the text (or properties associated with it) changed? Resets\n     * {@link _dirty} to false\n     */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Measure a slice of text taking left offset into account. If left offset\n     * is 0, then this will also add the left bounding box overhang. If not,\n     * then it will just return the width.\n     *\n     * Only for slices of text which have no width-overriding characters, else,\n     * you will get wrong measurements.\n     *\n     * @returns Returns the new horizontal offset\n     */\n    private measureTextSlice(left: number, start: number, end: number): number {\n        const metrics = measureTextDims(this.text.slice(start, end), this.font);\n        if(left === 0)\n            return metrics.width + Math.max(0, metrics.actualBoundingBoxLeft);\n        else\n            return left + metrics.width;\n    }\n\n    /**\n     * Get width from line range start to index. Handles out of bounds indices,\n     * but keeps them in the same line\n     */\n    private getLineRangeWidthUntil(range: LineRange, index: number): number {\n        // If before or at first group's start index, 0 width\n        if(index <= range[0][0])\n            return 0;\n\n        // Find text render group that this index belongs to\n        let groupIndex = 0;\n        for(; groupIndex < range.length; groupIndex++) {\n            // If index is at this group's end, return group's right value.\n            // Most width-overriding groups have a length of 1 and therefore\n            // just stop here\n            const group = range[groupIndex];\n            const groupEnd = group[1];\n            if(index == groupEnd)\n                return group[2];\n            else if(index >= group[0] && index < groupEnd)\n                break;\n        }\n\n        // If index was after line end, pick end of last group\n        if(groupIndex === range.length)\n            return range[groupIndex - 1][2];\n\n        // Find left value\n        let left = 0;\n        if(groupIndex > 0)\n            left = range[groupIndex - 1][2];\n\n        // Measure the slice of text. Interpolate if it's a width-overidding\n        // group\n        const group = range[groupIndex];\n        if(group[3])\n            return left + group[2] * (index - group[0]) / (group[1] - group[0]);\n        else\n            return this.measureTextSlice(left, group[0], index);\n    }\n\n    /**\n     * Similar to {@link measureTextDims}, but uses text render groups for\n     * optimisation purposes and for the ability of individual characters to\n     * override their natively measured size; tabs having a dynamic size that\n     * aligns them to multiples of a value and newlines having no length.\n     *\n     * @param start The inclusive index to start measuring at. If there are render groups and unmeasured text before this index, then this value will be overridden to include the unmeasured text. Render groups will also be merged if they don't override width.\n     * @param end The exclusive index to stop measuring at.\n     * @param lineRange The current text render groups for this line of text. This will be updated in place.\n     * @param maxWidth The maximum width of a line of text. If the line contains a single character, this will be ignored.\n     * @returns Returns true if the line range was modified and it fit into the maximum width\n     */\n    private measureText(start: number, end: number, maxWidth: number, lineRange: LineRange): boolean {\n        // Remove render groups that intersect the range that will be measured.\n        // Removing a group means that the group will have to be re-measured and\n        // therefore start is overridden\n        let wantedGroups = 0;\n        for(; wantedGroups < lineRange.length; wantedGroups++) {\n            const group: TextRenderGroup = lineRange[wantedGroups];\n            if(start >= group[0] && start < group[1]) {\n                start = group[0];\n                break;\n            }\n        }\n\n        // Correct start value; attempt to merge with previous groups or expand\n        // the measurement to include previous parts of text that haven't been\n        // measured yet\n        if(wantedGroups > 0) {\n            let lastGroup: TextRenderGroup | null = lineRange[wantedGroups - 1];\n            if(lastGroup[1] !== start) {\n                start = lastGroup[1];\n\n                if(--wantedGroups > 0)\n                    lastGroup = lineRange[wantedGroups];\n                else\n                    lastGroup = null;\n            }\n\n            if(lastGroup !== null && !lastGroup[3] && !WIDTH_OVERRIDING_CHARS.has(this.text[start])) {\n                start = lastGroup[0];\n                wantedGroups--;\n            }\n        }\n\n        // Find left horizontal offset\n        let left = 0;\n        if(wantedGroups > 0)\n            left = lineRange[wantedGroups - 1][2];\n\n        // Measure range of text, potentially splitting it into render groups\n        let groupStart = start;\n        const addedGroups: Array<TextRenderGroup> = [];\n        while(groupStart < end) {\n            if(this.text[groupStart] === '\\t') {\n                // Align to tab width\n                const tabWidth = this.actualTabWidth;\n                left = (Math.floor(left / tabWidth) + 1) * tabWidth;\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n            }\n            else if(this.text[groupStart] === '\\n') {\n                // Make it 0-width and ignore all other text\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n\n                if(groupStart < end)\n                    console.warn('measureText called with text range where newline was at the middle of the range instead of at the end. Some text was ignored');\n\n                break;\n            }\n            else {\n                // Find group end index; at next width-overriding character or\n                // at end\n                let nextNewline = this.text.indexOf('\\n', groupStart + 1);\n                if(nextNewline === -1)\n                    nextNewline = Infinity;\n\n                let nextTab = this.text.indexOf('\\t', groupStart + 1);\n                if(nextTab === -1)\n                    nextTab = Infinity;\n\n                const groupEnd = Math.min(nextNewline, nextTab, end);\n\n                // Measure group\n                left = this.measureTextSlice(left, groupStart, groupEnd);\n                addedGroups.push([groupStart, groupEnd, left, false]);\n\n                groupStart = groupEnd;\n            }\n        }\n\n        // Check if this fits in maximum width\n        const groupCount = wantedGroups + addedGroups.length;\n        const lastGroup = addedGroups[addedGroups.length - 1]\n                            ?? lineRange[wantedGroups - 1]\n                            ?? null;\n\n        if(lastGroup === null) {\n            // Lines ranges must have at least one group\n            lineRange.length = 0;\n            lineRange.push([start, start, 0, false]);\n            return true;\n        }\n        else if((groupCount === 1 && (lastGroup[1] - lastGroup[0]) <= 1) ||\n                lastGroup[2] <= maxWidth) {\n            lineRange.length = wantedGroups;\n            lineRange.push(...addedGroups);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Update {@link _width}, {@link _ascent} and {@link _descent}. Sets\n     * {@link measureDirty} to false. Does nothing if measurement is not needed.\n     */\n    private updateTextDims(): void {\n        // Update line height or line spacing if needed\n        if(this.lineHeightSpacingDirty) {\n            this.lineHeightSpacingDirty = false;\n\n            const oldLineHeight = this._lineHeight;\n            const oldLineSpacing = this._lineSpacing;\n\n            if(this.lineHeight === null || this.lineSpacing === null) {\n                const metrics = measureTextDims(\n                    '~!@#$%^&*()_+`1234567890-=qwertyuiop[]\\\\QWERTYUIOP{}|asdfghjkl;\\'ASDFGHJKL:\"zxcvbnm,./ZXCVBNM<>?',\n                    this.font,\n                );\n\n                if(this.lineHeight === null)\n                    this._lineHeight = metrics.actualBoundingBoxAscent;\n                else\n                    this._lineHeight = this.lineHeight;\n\n                if(this.lineSpacing === null)\n                    this._lineSpacing = metrics.actualBoundingBoxDescent;\n                else\n                    this._lineSpacing = this.lineSpacing;\n            }\n            else {\n                this._lineHeight = this.lineHeight;\n                this._lineSpacing = this.lineSpacing;\n            }\n\n            // If line height or spacing changed, text needs to be re-measured\n            if(oldLineHeight !== this._lineHeight || oldLineSpacing !== this._lineSpacing)\n                this.measureDirty = true;\n        }\n\n        // Update tab width if needed\n        if(this.tabWidthDirty) {\n            this.tabWidthDirty = false;\n            this._tabWidth = measureTextDims(' ', this.font).width * this.tabWidth;\n        }\n\n        // Abort if measurement not needed\n        if(!this.measureDirty)\n            return;\n\n        // Mark as clean\n        this.measureDirty = false;\n\n        const fullLineHeight = this._lineHeight + this._lineSpacing;\n\n        if(this.text.length === 0) {\n            // Special case for empty string; set height to height of single\n            // line and width to 0 if maxWidth is not set or maxWidth if set\n            this._height = fullLineHeight;\n            this._width = this.maxWidth === Infinity ? 0 : this.maxWidth;\n            this._lineRanges.length = 1;\n            this._lineRanges[0] = [[0, 0, 0, false]];\n        }\n        else if(this.maxWidth === Infinity) {\n            // Don't wrap text, but split lines when there's a newline character\n            this._lineRanges.length = 0;\n            let lineStart = 0;\n            this._height = 0;\n            this._width = 0;\n\n            const text = this.text;\n            // eslint-disable-next-line no-constant-condition\n            while(true) {\n                // Where is the next newline?\n                const newline = this.text.indexOf('\\n', lineStart);\n                const atEnd = newline === -1;\n                const end = atEnd ? text.length : (newline + 1);\n\n                // Measure this block of text and add it to the line ranges\n                const range: LineRange = [];\n                this.measureText(lineStart, end, Infinity, range);\n                this._lineRanges.push(range);\n\n                this._height += fullLineHeight;\n                const width = range[range.length - 1][2];\n                if(width > this._width)\n                    this._width = width;\n\n                // At end, abort\n                if(atEnd)\n                    break;\n\n                // Set start of next line\n                lineStart = end;\n            }\n        }\n        else {\n            // Wrap text\n            this._lineRanges.length = 0;\n            let range: LineRange = [];\n            const text = this.text;\n            const spaceRegex = /\\s/;\n            let wordStart = -1;\n\n            for(let i = 0; i <= text.length;) {\n                const isSpace = spaceRegex.test(text[i]);\n                const atEnd = i === text.length;\n\n                // If this is a whitespace, wrap the previous word and check\n                // where this character fits\n                if(isSpace || atEnd) {\n                    // Try fitting word if any\n                    if(wordStart >= 0 && !this.measureText(wordStart, i, this.maxWidth, range)) {\n                        // Overflow, check if word fits in new line\n                        const newRange: LineRange = [];\n                        if(this.measureText(wordStart, i, this.maxWidth, newRange)) {\n                            // Fits in new line. Push old line to line ranges if\n                            // it had any text render groups\n                            if(range.length === 0)\n                                throw new Error('Unexpected line range without any render groups');\n                            this._lineRanges.push(range);\n                            range = newRange;\n                        }\n                        else {\n                            // Doesn't fit in new line. Fit as much as possible\n                            // in current line and move rest to new line by\n                            // backtracking to where the split occurs. Don't\n                            // reverse this loop; although it may seem more\n                            // efficient, it breaks when the word is broken\n                            // across more than 2 lines\n                            let j = wordStart;\n                            for(; j < i - 1; j++) {\n                                if(!this.measureText(j, j + 1, this.maxWidth, range))\n                                    break;\n                            }\n                            this._lineRanges.push(range);\n                            range = newRange;\n\n                            i = j;\n                            wordStart = j;\n                            continue;\n                        }\n                    }\n\n                    wordStart = -1;\n\n                    // End line\n                    if(atEnd) {\n                        // If there isn't a render group in the line range yet,\n                        // add it. Use last group's position. If there isn't a\n                        // last group, default to the very beginning\n                        if(range.length === 0) {\n                            const lastLineRange = this._lineRanges[this._lineRanges.length - 1];\n                            if(lastLineRange === undefined)\n                                range.push([0, 0, 0, false]);\n                            else {\n                                const lastGroup = lastLineRange[lastLineRange.length - 1];\n                                if(lastGroup === undefined)\n                                    range.push([0, 0, 0, false]);\n                                else\n                                    range.push([lastGroup[1], lastGroup[1], 0, false]);\n                            }\n                        }\n\n                        this._lineRanges.push(range);\n                        break;\n                    }\n\n                    // Try fitting whitespace character\n                    if(text[i] === '\\n') {\n                        // Newline character. Break line, but measure text\n                        // anyways to update line range\n                        this.measureText(i, i + 1, Infinity, range);\n                        this._lineRanges.push(range);\n                        range = [];\n                    }\n                    else if(!this.measureText(i, i + 1, this.maxWidth, range)) {\n                        // Regular whitespace character overflow: put whitespace\n                        // in next line but measure it anyways to update line\n                        // range. If in the shrink wrap mode, then group up as\n                        // many whitespaces as possible and make a zero-width\n                        // group out of them\n                        if(this.wrapMode === WrapMode.Shrink) {\n                            const spaceGroupStart = i;\n                            do {\n                                i++;\n                            } while(text[i] !== '\\n' && spaceRegex.test(text[i]));\n\n                            const lastGroup = range[range.length - 1];\n                            range.push([\n                                spaceGroupStart,\n                                i,\n                                lastGroup !== undefined ? lastGroup[2] : 0,\n                                true,\n                            ]);\n                            this._lineRanges.push(range);\n                            range = [];\n                            continue;\n                        }\n                        else {\n                            this._lineRanges.push(range);\n                            range = [];\n                            this.measureText(i, i + 1, Infinity, range);\n                        }\n                    }\n                }\n                else if(wordStart === -1)\n                    wordStart = i;\n\n                // Incrementing down here so that we don't have to do i = j - 1\n                // when splitting words\n                i++;\n            }\n\n            // Calculate dimensions\n            this._width = this.maxWidth;\n            this._height = fullLineHeight * this._lineRanges.length;\n        }\n    }\n\n    paint(ctx: CanvasRenderingContext2D, fillStyle: FillStyle, x: number, y: number): void {\n        // Clip\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, this.width, this.height);\n        ctx.clip();\n\n        // Apply fill style and font\n        ctx.font = this.font;\n        ctx.fillStyle = fillStyle;\n        ctx.textBaseline = 'alphabetic';\n\n        // Paint line (or lines) of text\n        const fullLineHeight = this.fullLineHeight;\n        let yOffset = y + this._lineHeight;\n        //let toggle = false;\n        for(const range of this._lineRanges) {\n            let left = 0;\n            for(const group of range) {\n                // Skip width-overidding or zero-width render groups\n                if(!group[3] && group[2] > left) {\n                    /*ctx.fillStyle = toggle ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 255, 0, 0.5)';\n                    ctx.fillRect(x + left, yOffset - this._lineHeight, group[2] - left, fullLineHeight);\n                    toggle = !toggle;\n                    ctx.fillStyle = fillStyle;*/\n                    ctx.fillText(this.text.slice(group[0], group[1]), x + left, yOffset);\n                }\n                /*else {\n                    let debugWidth = group[2] - left;\n                    ctx.fillStyle = debugWidth > 0 ? 'rgba(0, 0, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';\n                    if(debugWidth == 0)\n                        debugWidth = 4;\n                    else if(debugWidth < 0)\n                        throw new Error('Unexpected group with negative width');\n                    ctx.fillRect(x + left, yOffset - this._lineHeight, debugWidth, fullLineHeight);\n                }*/\n\n                left = group[2];\n            }\n            yOffset += fullLineHeight;\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the beginning of a character at\n     * a given index.\n     *\n     * See {@link findIndexOffsetFromOffset} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the offset, in pixels. Vertical offset in the tuple is at the top of the character. Note that this is not neccessarily an integer.\n     */\n    findOffsetFromIndex(index: number): [x: number, yTop: number] {\n        // If index is 0, an invalid negative number or there are no lines, it\n        // is at the beginning\n        const lineRanges = this.lineRanges;\n        if(index <= 0 || lineRanges.length === 0)\n            return [0, 0];\n\n        // Check which line the index is in\n        let line = 0;\n        for(const range of lineRanges) {\n            if(index < range[range.length - 1][1])\n                break;\n\n            line++;\n        }\n\n        // Special case; the index is after the end, pick the end of the text\n        if(line >= lineRanges.length) {\n            line = lineRanges.length - 1;\n            index = this.text.length;\n        }\n\n        // Get horizontal offset\n        return [\n            this.getLineRangeWidthUntil(lineRanges[line], index),\n            line * this.fullLineHeight,\n        ];\n    }\n\n    /**\n     * Get the index and horizontal offset, in pixels, of the beginning of a\n     * character at a given offset.\n     *\n     * See {@link findOffsetFromIndex} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the index of the character at the offset and a 2-tuple containing the offset, in pixels. Note that this is not neccessarily an integer. Note that the returned offset is not the same as the input offset. The returned offset is exactly at the beginning of the character. This is useful for implementing selectable text.\n     */\n    findIndexOffsetFromOffset(offset: [number, number]): [number, [number, number]] {\n        // If offset is before or at first character, text is empty or there are\n        // no lines, default to index 0\n        const fullLineHeight = this.fullLineHeight;\n        if(this.text === '' || (offset[0] <= 0 && offset[1] < fullLineHeight) || offset[1] < 0)\n            return [0, [0, 0]];\n\n        // Find line being selected\n        const line = Math.floor(offset[1] / fullLineHeight);\n\n        // If this is beyond the last line, pick the last character\n        const ranges = this.lineRanges;\n        if(line >= ranges.length) {\n            const index = this.text.length;\n            return [index, this.findOffsetFromIndex(index)];\n        }\n\n        // If this is an empty line, stop\n        const yOffset = line * fullLineHeight;\n        const range = ranges[line];\n        if(range.length === 1 && range[0][0] === range[0][1])\n            return [range[0][0], [range[0][2], yOffset]];\n\n        // TODO This has linear complexity, use binary search instead if possible\n        // For each character, find index at which offset is smaller than\n        // total length minus half length of current character\n        let lastLength = 0;\n        const lineStart = range[0][0];\n\n        // Special case; if line range ends with a newline, ignore last\n        // character\n        let lineEnd = range[range.length - 1][1];\n        if(this.text[lineEnd - 1] === '\\n')\n            lineEnd--;\n\n        for(let i = lineStart; i < lineEnd; i++) {\n            // Measure length from this index to the next\n            const length = this.getLineRangeWidthUntil(range, i + 1);\n            const criticalOffset = (length + lastLength) / 2;\n\n            // If offset is before critical offset, this is the index we're\n            // looking for\n            if(offset[0] < criticalOffset)\n                return [i, [lastLength, yOffset]];\n\n            // Update last length\n            lastLength = length;\n        }\n\n        // Offset is after full length of text, return index after end\n        return [lineEnd, [lastLength, yOffset]];\n    }\n\n    /**\n     * Get a line number from a given cursor index. If out of bounds, returns\n     * nearest in-bounds line. Line numbers start at 0.\n     */\n    getLine(index: number): number {\n        if(index <= 0)\n            return 0;\n\n        const lineRanges = this.lineRanges;\n        for(let line = 0; line < lineRanges.length; line++) {\n            const lineRange = lineRanges[line];\n            const lastGroup = lineRange[lineRange.length - 1];\n            if(index < lastGroup[1])\n                return line;\n        }\n\n        return lineRanges.length - 1;\n    }\n\n    /**\n     * Get the index of the start of a line. If out of bounds, returns the\n     * nearest in-bounds index\n     */\n    getLineStart(line: number): number {\n        if(line <= 0)\n            return 0;\n\n        const lineRanges = this.lineRanges;\n        if(line >= lineRanges.length) {\n            const lastLine = lineRanges[lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        return lineRanges[line][0][0];\n    }\n\n    /**\n     * Get the index of the end of a line.\n     *\n     * @param includeNewlines If false, newline characters will be ignored and the end will be at their index, instead of after their index\n     */\n    getLineEnd(line: number, includeNewlines = true): number {\n        if(line < 0)\n            return 0;\n\n        const lineRanges = this.lineRanges;\n        if(line >= lineRanges.length) {\n            const lastLine = lineRanges[lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        const lineRange = lineRanges[line];\n        const lastGroup = lineRange[lineRange.length - 1];\n        const lastIndex = lastGroup[1];\n        if(!includeNewlines && lastIndex > 0 &&\n           this.text[lastIndex - 1] === '\\n' && lastGroup[0] !== lastGroup[1])\n            return lastIndex - 1;\n        else\n            return lastIndex;\n    }\n\n    /** The current text width. Re-measures text if neccessary. */\n    get width(): number {\n        this.updateTextDims();\n        return this._width;\n    }\n\n    /** The current total text height. Re-measures text if neccessary. */\n    get height(): number {\n        this.updateTextDims();\n        return this._height;\n    }\n\n    /**\n     * Which range of text indices are used for each line.\n     *\n     * If there is no text wrapping (maxWidth is Infinity), then this will\n     * contain a single tuple containing [0, (text length)].\n     *\n     * If there is text wrapping, then this will be an array where each member\n     * is a tuple containing the starting index of a line of text and the ending\n     * index (exclusive) of a line of text.\n     */\n    get lineRanges(): Array<LineRange> {\n        this.updateTextDims();\n        return [...this._lineRanges];\n    }\n\n    /**\n     * Get the current line height, even if {@link lineHeight} is null.\n     * Re-measures line height if neccessary.\n     */\n    get actualLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight;\n    }\n\n    /**\n     * Get the current line spacing, even if {@link lineSpacing} is null.\n     * Re-measures line spacing if neccessary.\n     */\n    get actualLineSpacing(): number {\n        this.updateTextDims();\n        return this._lineSpacing;\n    }\n\n    /** Get the current tab width in pixels. Re-measures if neccessary */\n    get actualTabWidth(): number {\n        this.updateTextDims();\n        return this._tabWidth;\n    }\n\n    /**\n     * Get the height between the start of each line; the full line height.\n     *\n     * Equivalent to the sum of {@link actualLineHeight} and\n     * {@link actualLineSpacing}\n     */\n    get fullLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight + this._lineSpacing;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { TextHelper, WrapMode } from '../helpers/TextHelper';\nimport { layoutField } from '../decorators/FlagFields';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A function which returns a string. An alternative to supplying a\n * {@link Label} with a string if you have a text value that constantly changes.\n *\n * @category Widget\n */\nexport type TextGetter = () => string;\n\n// TODO add support for multiline text with wrapping\n/**\n * A widget which displays a line of text.\n *\n * @category Widget\n */\nexport class Label extends Widget {\n    /**\n     * The text getter source. If this is not null, text will be updated with\n     * the return value of this callback, every update.\n     */\n    private textGetter: TextGetter | null = null;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /**\n     * Is text wrapping enabled? If not, text will clipped on overflow\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText = true;\n\n    /**\n     * Create a new Label.\n     *\n     * @param source The text source of the label. Has the same behaviour as setting {@link source}.\n     */\n    constructor(source: string | TextGetter, themeProperties?: ThemeProperties) {\n        // Labels need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        this.textHelper = new TextHelper();\n        this.textHelper.wrapMode = WrapMode.Shrink;\n        this.source = source;\n    }\n\n    /**\n     * This label's text source. If you want to get the current text string,\n     * then use {@link text} instead.\n     *\n     * When setting, if source is a {@link TextGetter}, then {@link textGetter}\n     * is set, else, {@link textGetter} is set to null and and the\n     * {@link textHelper}'s {@link TextHelper.text | text} is set.\n     *\n     * When getting, if {@link textGetter} is set, then it is returned, else,\n     * {@link textHelper}.{@link TextHelper.text | text} is returned.\n     */\n    set source(source: string | TextGetter) {\n        if(source instanceof Function)\n            this.textGetter = source;\n        else {\n            this.textGetter = null;\n            this.textHelper.text = source;\n        }\n    }\n\n    get source(): string | TextGetter {\n        if(this.textGetter !== null)\n            return this.textGetter;\n        else\n            return this.textHelper.text;\n    }\n\n    /**\n     * The current text value. If you want to get the current text source, then\n     * use {@link source} instead.\n     */\n    get text(): string {\n        return this.textHelper.text;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFont' ||\n                property === 'labelMinWidth' ||\n                property === 'labelMinAscent' ||\n                property === 'labelMinDescent')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFill')\n            this._dirty = true;\n    }\n\n    protected override handlePreLayoutUpdate(_root: Root): void {\n        // Update text helper variables\n        if(this.textGetter !== null)\n            this.textHelper.text = this.textGetter();\n\n        this.textHelper.font = this.bodyTextFont;\n        this.textHelper.lineHeight = this.bodyTextHeight;\n        this.textHelper.lineSpacing = this.bodyTextSpacing;\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.textHelper.maxWidth = this.wrapText ? maxWidth : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        this.width = Math.max(Math.min(this.textHelper.width, maxWidth), minWidth);\n        this.height = Math.max(Math.min(this.textHelper.height, maxHeight), minHeight);\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, _forced: boolean): void {\n        // Start clipping if text wrapping is disabled\n        if(!this.wrapText) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n        }\n\n        // Paint text\n        this.textHelper.paint(ctx, this.bodyTextFill, this.x, this.y);\n\n        // Stop clipping if text wrapping is disabled\n        if(!this.wrapText)\n            ctx.restore();\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { FilledButton } from './FilledButton';\nimport type { TextGetter } from './Label';\nimport { Label } from './Label';\n\n/**\n * A {@link FilledButton} with a {@link Label}. Alignment is forced to be\n * horizontally centered and vertically stretching like in {@link TextMargin}.\n * Text-wrapping is disabled so that text is centered properly.\n *\n * @category Widget\n */\nexport class TextButton extends FilledButton<Label> {\n    /** Create a new TextButton. */\n    constructor(text: string | TextGetter, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Stretch,\n        };\n\n        const label = new Label(text, themeProperties);\n        label.wrapText = false;\n        super(label, callback, themePropertiesClone);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { KeyContext } from './KeyContext';\nimport { TextButton } from '../TextButton';\n\n/**\n * A {@link VirtualKey} which emits key presses for a given glyph (character),\n * handling alternative versions of the glyph when shift is held down, such as\n * uppercase variants, or exclamation marks for ones.\n *\n * For other specific keys, see {@link BasicVirtualKey}.\n *\n * @category Widget\n */\nexport class GlyphVirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new GlyphVirtualKey.\n     *\n     * @param glyph The glyph to emit/show when shift is not held.\n     * @param altGlyph The alternative glyph to emit/show when shift is held.\n     * @param keyContext The {@link KeyContext} shared by other keys to tell when shift is being held in a virtual keyboard.\n     */\n    constructor(glyph: string, altGlyph: string | null = null, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        if(altGlyph === null)\n            altGlyph = glyph;\n\n        function getGlyph() {\n            if(keyContext.shift) {\n                if(altGlyph === null)\n                    return glyph;\n                else\n                    return altGlyph;\n            }\n            else\n                return glyph;\n        }\n\n        super(\n            new TextButton(\n                getGlyph, () => keyContext.callback(getGlyph()), themeProperties,\n            ),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeProperties,\n        );\n\n        this.flex = flex;\n    }\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with any\n * amount of children and public access to modifying this list of children.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport abstract class MultiParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Add child(ren) to this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true and each child's\n     * {@link inheritedTheme} is set so that new children inherit this widget's\n     * theme.\n     *\n     * @param children If this is a widget, then it is pushed to {@link _children}. If this is an array of widgets, then each widget is pushed to {@link _children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    add(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            for(const child of children) {\n                this._children.push(child);\n                child.inheritedTheme = this.inheritedTheme;\n            }\n        }\n        else {\n            this._children.push(children);\n            children.inheritedTheme = this.inheritedTheme;\n        }\n\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n\n    /**\n     * Remove child(ren) from this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true.\n     *\n     * @param children If this is a widget, then it is removed from {@link _children}. If this is an array of widgets, then each widget is removed from {@link _children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    remove(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            for(const child of children) {\n                const pos = this._children.indexOf(child);\n                if(pos !== -1)\n                    this._children.splice(pos, 1);\n            }\n        }\n        else {\n            const pos = this._children.indexOf(children);\n            if(pos !== -1)\n                this._children.splice(pos, 1);\n        }\n\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n\n    /**\n     * Remove all children from this widget.\n     *\n     * {@link _layoutDirty} and {@link _dirty} are set to true.\n     *\n     * @returns Returns this so that the method is chainable.\n     */\n    clearChildren(): this {\n        this._children.length = 0;\n        this._layoutDirty = true;\n        this._dirty = true;\n        return this;\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { FlexAlignment } from '../theme/FlexAlignment';\nimport { Alignment } from '../theme/Alignment';\nimport type { Event } from '../events/Event';\nimport { MultiParent } from './MultiParent';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A {@link MultiParent} which automatically paints children, adds spacing,\n * propagates events and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * Note that there is no padding. Put this inside a {@link Margin} if padding is\n * needed.\n *\n * @category Widget\n */\nexport class MultiContainer<W extends Widget = Widget> extends MultiParent<W> {\n    /** Is the container's background dirty? */\n    private backgroundDirty = true;\n    /** Is this container vertical? */\n    private vertical: boolean;\n    /** The unused space along the main axis after resolving dimensions */\n    private unusedSpace = 0;\n    /** The number of enabled children in this container */\n    private enabledChildCount = 0;\n\n    /** Create a MultiContainer. */\n    constructor(vertical: boolean, themeProperties?: ThemeProperties) {\n        // MultiContainers clear their own background, have children and\n        // propagate events\n        super([], false, true, themeProperties);\n\n        this.vertical = vertical;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'multiContainerAlignment')\n            this._layoutDirty = true;\n        else if(property === 'multiContainerSpacing')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Find which widget the event should go to\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Stop if event was captured\n            const captured = child.dispatchEvent(event, root);\n            if(captured !== null)\n                return captured;\n        }\n\n        // Event wasn't dispatched to any child\n        return null;\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Pre-layout update children\n        for(const child of this.children) {\n            child.preLayoutUpdate(root);\n\n            // If child's layout is dirty, set own layoutDirty flag\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        // Post-layout update children\n        for(const child of this.children) {\n            child.postLayoutUpdate(root);\n\n            // If child is dirty, set own dirty flag\n            if(child.dirty)\n                this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve children's layout with loose constraints along the main axis\n        // to get their wanted dimensions and calculate total flex ratio\n        let totalFlex = 0, crossLength = 0, minCrossAxis = 0;\n        const maxLength = this.vertical ? maxHeight : maxWidth;\n\n        const alignment = this.multiContainerAlignment;\n        if(alignment.cross === Alignment.Stretch) {\n            minCrossAxis = this.vertical ? maxWidth : maxHeight;\n            if(minCrossAxis == Infinity)\n                minCrossAxis = this.vertical ? minWidth : minHeight;\n        }\n\n        this.enabledChildCount = 0;\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            this.enabledChildCount++;\n\n            const [oldChildWidth, oldChildHeight] = child.dimensions;\n\n            if(this.vertical)\n                child.resolveDimensions(minCrossAxis, maxWidth, 0, Infinity);\n            else\n                child.resolveDimensions(0, Infinity, minCrossAxis, maxHeight);\n\n            const [childWidth, childHeight] = child.dimensions;\n\n            totalFlex += child.flex;\n            crossLength = Math.max(this.vertical ? childWidth : childHeight, crossLength);\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Clamp cross length\n        const minCrossLength = this.vertical ? minWidth : minHeight;\n        if(crossLength < minCrossLength)\n            crossLength = minCrossLength;\n\n        // Get free space\n        const spacing = this.multiContainerSpacing;\n        let usedSpace = Math.max(this.enabledChildCount - 1, 0) * spacing;\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            usedSpace += this.vertical ? child.dimensions[1] : child.dimensions[0];\n        }\n\n        const freeSpace = maxLength - usedSpace;\n\n        // Don't do flexbox calculations if free space is infinite\n        // (unconstrained main axis) or if there isn't any free space.\n        if(freeSpace == Infinity || freeSpace <= 0) {\n            const oldWidth = this.width;\n            const oldHeight = this.height;\n\n            if(this.vertical) {\n                this.width = crossLength;\n                this.height = Math.min(usedSpace, maxHeight);\n            }\n            else {\n                this.width = Math.min(usedSpace, maxWidth);\n                this.height = crossLength;\n            }\n\n            // Mark background as dirty if dimensions changed\n            if(this.width !== oldWidth || this.height !== oldHeight)\n                this.backgroundDirty = true;\n\n            // Set unused space to 0; no alignment should be done\n            this.unusedSpace = 0;\n\n            // Resolve children's layout, but now with strict constraints so\n            // that they stretch properly and shrink children if neccessary (on\n            // overflow)\n            let spaceLeft = maxLength;\n            for(const child of this.children) {\n                // Ignore disabled children\n                if(!child.enabled)\n                    continue;\n\n                const [oldChildWidth, oldChildHeight] = child.dimensions;\n\n                if(this.vertical) {\n                    const wantedLength = Math.min(spaceLeft, oldChildHeight);\n                    child.resolveDimensions(minCrossAxis, maxWidth, wantedLength, wantedLength);\n                }\n                else {\n                    const wantedLength = Math.min(spaceLeft, oldChildWidth);\n                    child.resolveDimensions(wantedLength, wantedLength, minCrossAxis, maxHeight);\n                }\n\n                const [childWidth, childHeight] = child.dimensions;\n\n                // Mark background as dirty if child's dimensions changed\n                if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                    this.backgroundDirty = true;\n\n                const childLength = this.vertical ? oldChildHeight\n                                                  : oldChildWidth;\n                spaceLeft = Math.max(0, spaceLeft - childLength - spacing);\n            }\n\n            return;\n        }\n\n        // Resolve children's layout with constraints restricted to distributed\n        // free space. Calculate used space after flexbox calculations.\n        let usedSpaceAfter = 0;\n        let freeSpacePerFlex = 0;\n        if(totalFlex > 0)\n            freeSpacePerFlex = freeSpace / totalFlex;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Add spacing to used space if this is not the first widget\n            if(usedSpaceAfter !== 0)\n                usedSpaceAfter += spacing;\n\n            const dedicatedSpace = freeSpacePerFlex * child.flex;\n            const [oldChildWidth, oldChildHeight] = child.dimensions;\n            if(this.vertical) {\n                const wantedLength = dedicatedSpace + oldChildHeight;\n                child.resolveDimensions(\n                    minCrossAxis, maxWidth,\n                    wantedLength, wantedLength,\n                );\n            }\n            else {\n                const wantedLength = dedicatedSpace + oldChildWidth;\n                child.resolveDimensions(\n                    wantedLength, wantedLength,\n                    minCrossAxis, maxHeight,\n                );\n            }\n\n            const [childWidth, childHeight] = child.dimensions;\n            usedSpaceAfter += this.vertical ? childHeight : childWidth;\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Resolve width and height\n        const oldWidth = this.width;\n        const oldHeight = this.height;\n\n        let length;\n        if(this.vertical) {\n            length = maxHeight;\n            this.width = crossLength;\n            this.height = length;\n        }\n        else {\n            length = maxWidth;\n            this.width = length;\n            this.height = crossLength;\n        }\n\n        // Mark background as dirty if dimensions changed\n        if(this.width !== oldWidth || this.height !== oldHeight)\n            this.backgroundDirty = true;\n\n        // Calculate final unused space; used for alignment. Clamp to zero just\n        // in case XXX is that neccessary?\n        this.unusedSpace = Math.max(length - usedSpaceAfter, 0);\n    }\n\n    protected override afterPositionResolved(): void {\n        // Align children\n        const alignment = this.multiContainerAlignment;\n        const around = alignment.main === FlexAlignment.SpaceAround;\n        const between = alignment.main === FlexAlignment.SpaceBetween || around;\n        // TODO remove as number once typescript 4.4 releases\n        const mainRatio = (between ? 0 : alignment.main as number);\n        const crossRatio = (alignment.cross === Alignment.Stretch ? 0 : alignment.cross);\n        const effectiveChildren = this.enabledChildCount - 1 + (around ? 2 : 0);\n        let extraSpacing;\n        if(effectiveChildren <= 0)\n            extraSpacing = 0;\n        else\n            extraSpacing = this.unusedSpace / effectiveChildren;\n\n        let spacing = this.multiContainerSpacing;\n        if(between)\n            spacing += extraSpacing;\n\n        let mainOffset = (this.vertical ? this.y : this.x) + mainRatio * this.unusedSpace;\n        if(around)\n            mainOffset += extraSpacing;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            const [oldChildX, oldChildY] = child.position;\n            const [childWidth, childHeight] = child.dimensions;\n\n            if(this.vertical) {\n                child.resolvePosition(this.x + crossRatio * (this.width - childWidth), mainOffset);\n                mainOffset += childHeight + spacing;\n            }\n            else {\n                child.resolvePosition(mainOffset, this.y + crossRatio * (this.height - childHeight));\n                mainOffset += childWidth + spacing;\n            }\n\n            const [childX, childY] = child.position;\n\n            // Mark background as dirty if child's position changed\n            if(childX !== oldChildX || childY !== oldChildY)\n                this.backgroundDirty = true;\n        }\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        // Paint children and build clipping region if background is dirty\n        const clipRects: [number, number, number, number][] = [];\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Paint child\n            child.paint(ctx, forced);\n\n            // Add to clipping region if needed\n            if(this.backgroundDirty || forced)\n                clipRects.push(this.roundRect(...child.position, ...child.dimensions));\n        }\n\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart(ctx);\n            ctx.rect(...this.roundRect(this.x, this.y, this.width, this.height));\n            for(const clipRect of clipRects)\n                ctx.rect(...clipRect);\n            this.clearEnd(ctx, 'evenodd');\n        }\n\n        this.backgroundDirty = false;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { MultiContainer } from './MultiContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A horizontal {@link MultiContainer}.\n *\n * @category Widget\n */\nexport class Row<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Row. */\n    constructor(themeProperties?: ThemeProperties) {\n        super(false, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { GlyphVirtualKey } from './GlyphVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { VirtualKey } from './VirtualKey';\nimport { Row } from '../Row';\n\n/**\n * A template for a single virtual keyboard key. A function that, when called\n * given a {@link KeyContext} and theme override, returns a {@link VirtualKey}\n * which can be used as a virtual keyboard key widget.\n *\n * Example:\n * ```typescript\n * const template: VirtualKeyTemplate = (keyContext, themeProperties) => new BackspaceKey(keyContext, themeProperties);\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyTemplate = (keyContext: KeyContext, themeProperties?: ThemeProperties) => VirtualKey;\n\n/**\n * A template for multiple {@link GlyphVirtualKey} virtual keyboard keys. A\n * 2-tuple of strings, where each string has the same length. Each character of\n * the string represents a glyph to add to a keyboard row. The first string of\n * the tuple has the regular glyphs, while the second string string of the tuple\n * has the alternative glyphs.\n *\n * Example:\n * ```typescript\n * const template: GlyphVirtualKeysTemplate = ['qwertyuiop', 'QWERTYUIOP'];\n * ```\n *\n * @category Widget\n */\nexport type GlyphVirtualKeysTemplate = [string, string];\n\n/**\n * A template for a single row of virtual keyboard keys. An array of\n * {@link GlyphVirtualKeysTemplate} and {@link VirtualKeyTemplate}.\n *\n * Example:\n * ```typescript\n * const backspaceTemplate: VirtualKeyTemplate = (keyContext, themeProperties) => new BackspaceKey(keyContext, themeProperties);\n * const rowTemplate: VirtualKeyRowTemplate = [['`1234567890-=', '~!@#$%^&*()_+'], backspaceTemplate];\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyRowTemplate = Array<GlyphVirtualKeysTemplate | VirtualKeyTemplate>;\n\n/**\n * A {@link Row} of {@link VirtualKey | virtual keys}. Generates given a\n * template.\n *\n * @category Widget\n */\nexport class VirtualKeyRow extends Row<VirtualKey> {\n    /**\n     * Create a new VirtualKeyRow.\n     *\n     * @param rowTemplate Template for this row of virtual keys.\n     * @param keyContext The {@link KeyContext} to be shared among all virtual keys in this row.\n     * @param flex The flex to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minWidth The minWidth to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minHeight The minHeight to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param themeProperties The themeProperties to pass to each key widget and this row\n     */\n    constructor(rowTemplate: VirtualKeyRowTemplate, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        for(const entry of rowTemplate) {\n            if(typeof entry === 'function') {\n                // Entry is in template function format\n                const templateFunction = entry;\n                this.add(templateFunction(keyContext, themeProperties));\n            }\n            else if(typeof entry[0] === 'string' && typeof entry[1] === 'string') {\n                // Entry is in multiple glyphs format\n                const glyphs = entry[0];\n                const altGlyphs = entry[1];\n                for(let i = 0; i < glyphs.length; i++) {\n                    let altGlyph = null;\n                    if(i < altGlyphs.length)\n                        altGlyph = altGlyphs[i];\n\n                    this.add(new GlyphVirtualKey(\n                        glyphs[i],\n                        altGlyph,\n                        keyContext,\n                        flex,\n                        minWidth,\n                        minHeight,\n                        themeProperties,\n                    ));\n                }\n            }\n            else {\n                throw new Error(`Unknown virtual key row template format for entry: ${entry}`);\n            }\n        }\n    }\n}", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { TextGetter } from '../../widgets/Label';\nimport { TextButton } from '../TextButton';\n\n/**\n * An {@link ArtificialConstraint} with a {@link TextButton} which calls a given\n * callback and displays a given text source.\n *\n * For now there's nothing special about this class; it's just a common base\n * class for virtual keyboard key widgets.\n *\n * @category Widget\n */\nexport class VirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new VirtualKey.\n     *\n     * @param text The text to display in the virtual key.\n     * @param callback The callback called when the button is pressed.\n     */\n    constructor(text: string | TextGetter, callback: () => void, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            new TextButton(text, callback, themeProperties),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeProperties,\n        );\n\n        this.flex = flex;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { TextGetter } from '../../widgets/Label';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which emits key presses of a given key code.\n *\n * @category Widget\n */\nexport class BasicVirtualKey extends VirtualKey {\n    /**\n     * Create a new BasicVirtualKey.\n     *\n     * @param text The text to display in the virtual key.\n     * @param keyCode The {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | key code} to emit in the keyContext's callback when the virtual key is pressed\n     * @param keyContext The {@link KeyContext} shared by other virtual keyboard key widgets.\n     */\n    constructor(text: string | TextGetter, keyCode: string, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            text,\n            () => keyContext.callback(keyCode),\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Backspace' key presses.\n *\n * @category Widget\n */\nexport class BackspaceKey extends BasicVirtualKey {\n    /** Create a new BackspaceKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 60, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Backspace', 'Backspace', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Escape' key presses.\n *\n * @category Widget\n */\nexport class EscapeKey extends BasicVirtualKey {\n    /** Create a new EscapeKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Esc', 'Escape', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Enter' key presses.\n *\n * @category Widget\n */\nexport class EnterKey extends BasicVirtualKey {\n    /** Create a new EnterKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 72, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Enter', 'Enter', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a shift key; toggles\n * {@link KeyContext.shift} on click.\n *\n * @category Widget\n */\nexport class ShiftKey extends VirtualKey {\n    /** Create a new ShiftKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 84, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Shift',\n            () => {\n                keyContext.shift = !keyContext.shift;\n                this.child.forced = keyContext.shift;\n                keyContext.callback('Shift');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.shift;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits ' ' key presses.\n *\n * @category Widget\n */\nexport class SpaceKey extends BasicVirtualKey {\n    /** Create a new SpaceKey. */\n    constructor(keyContext: KeyContext, flex = 1, minWidth = 84, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Space', ' ', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { MultiContainer } from './MultiContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A vertical {@link MultiContainer}.\n *\n * @category Widget\n */\nexport class Column<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Column. */\n    constructor(themeProperties?: ThemeProperties) {\n        super(true, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyboardDriver } from '../../drivers/KeyboardDriver';\nimport type { FlexAlignment2D } from '../../theme/FlexAlignment2D';\nimport type { VirtualKeyRowTemplate } from './VirtualKeyRow';\nimport { FlexAlignment } from '../../theme/FlexAlignment';\nimport { Alignment } from '../../theme/Alignment';\nimport { VirtualKeyRow } from './VirtualKeyRow';\nimport type { KeyContext } from './KeyContext';\nimport { BackspaceKey } from './BackspaceKey';\nimport { EscapeKey } from './EscapeKey';\nimport { EnterKey } from './EnterKey';\nimport { ShiftKey } from './ShiftKey';\nimport { SpaceKey } from './SpaceKey';\nimport { Column } from '../Column';\n\n/**\n * A template for the keys in a {@link VirtualKeyboard}. Each member of the\n * array contains the template for a row of keys, from top to bottom.\n *\n * @category Widget\n */\nexport type VirtualKeyboardTemplate = Array<VirtualKeyRowTemplate>;\n\nfunction EnterKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): EnterKey {\n    return new EnterKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction ShiftKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): ShiftKey {\n    return new ShiftKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction BackspaceKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): BackspaceKey {\n    return new BackspaceKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction SpaceKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): SpaceKey {\n    return new SpaceKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction EscapeKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): EscapeKey {\n    return new EscapeKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\n/**\n * The default template for the keys in a {@link VirtualKeyboard}; A QWERTY\n * keyboard with US layout.\n *\n * @category Widget\n */\nexport const defaultVirtualKeyboardTemplate: VirtualKeyboardTemplate = [\n    // First row\n    [['`1234567890-=', '~!@#$%^&*()_+']],\n    // Second row\n    [['qwertyuiop[]\\\\', 'QWERTYUIOP{}|']],\n    // Third row\n    [['asdfghjkl;\\'', 'ASDFGHJKL:\"'], EnterKeyTemplate],\n    // Fourth row\n    [ShiftKeyTemplate, ['zxcvbnm,./', 'ZXCVBNM<>?']],\n    // Fifth row\n    [BackspaceKeyTemplate, SpaceKeyTemplate, EscapeKeyTemplate],\n];\n\n/**\n * A virtual keyboard widget.\n *\n * Needs a {@link KeyboardDriver} so that key events can be queued.\n *\n * Equivalent to creating a {@link Column} of {@link VirtualKeyRow} with a shared\n * {@link KeyContext}. Key rows will be created with SpaceBetween main alignment\n * and Stretch cross alignment.\n *\n * @category Widget\n */\nexport class VirtualKeyboard extends Column {\n    /**\n     * Create a new VirtualKeyboard.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param flexRatio The flexRatio to use when creating {@link Glyph | Glyphs}\n     * @param mainBasis The mainBasis to use when creating {@link Glyph | Glyphs}\n     * @param crossBasis The crossBasis to use when creating {@link Glyph | Glyphs}\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, flexRatio = 0, mainBasis = 24, crossBasis = 24, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.multiContainerAlignment = <FlexAlignment2D>{\n            main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch,\n        };\n\n        super(themePropertiesClone);\n\n        // Make context\n        const keyContext = <KeyContext>{\n            callback: (key: string) => {\n                keyboardDriver.keyPress(\n                    key,\n                    keyContext.shift,\n                    keyContext.ctrl,\n                    keyContext.alt,\n                );\n            },\n            shift: false,\n            ctrl: false,\n            alt: false,\n        };\n\n        for(const rowTemplate of keyboardTemplate) {\n            this.add(new VirtualKeyRow(\n                rowTemplate, keyContext, flexRatio, mainBasis, crossBasis,\n                themePropertiesClone,\n            ));\n        }\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { BaseContainer } from './BaseContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which always propagates events. Use this widget if\n * you are not sure what that means.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Container<W extends Widget = Widget> extends BaseContainer<W> {\n    /** Create a new Container. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        super(child, true, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Container} with center alignment on both axes and default padding,\n * similar to {@link Center}.\n *\n * Can be constrained to a specific type of children.\n *\n * Alignment settings are applied via theme properties; if you pass this\n * property, it will be ignored in a clone of the theme properties. If you want\n * to override this theme property property, then use {@link Container} instead.\n *\n * @category Widget\n */\nexport class Margin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Margin. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Center,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { DOMRoot } from './DOMRoot';\n\n/**\n * A {@link DOMRoot} with similar functionality to {@link VirtualKeyboardRoot}.\n * In this version\n * {@link VirtualKeyboardRoot.updateVisibility | updateVisibility} doesn't\n * exist. Instead, just call {@link update} like in DOMRoot.\n *\n * @category Core\n */\nexport class DOMVirtualKeyboardRoot extends DOMRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}. Also sets up a\n     * {@link pointerStyleHandler} which simply sets the CSS cursor style of\n     * {@link domElem}. Creates {@link domElem} and {@link domCanvasContext}.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link domElem}'s display style is set to 'none',\n     * hiding it.\n     *\n     * Calls {@link preLayoutUpdate}, {@link resolveLayout},\n     * {@link postLayoutUpdate} and {@link paint}.\n     *\n     * Also updates the visibility of this root; if the keyboard driver has no\n     * focused root, then the root is disabled, else, it is enabled.\n     */\n    override update(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n\n        // Update normally\n        super.update();\n    }\n}", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * A {@link Root} containing a single {@link VirtualKeyboard} widget inside a\n * {@link Margin}. Automatically disables itself if not needed, but\n * {@link updateVisibility} must be called every frame for this behaviour to\n * occur.\n *\n * @category Core\n */\nexport class VirtualKeyboardRoot extends Root {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link pointerStyleHandler} and {@link child}'s\n     * {@link Widget.inheritedTheme | inherited theme}.\n     *\n     * @param keyboardTemplate By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            pointerStyleHandler, theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.getFocusedRoot() !== null;\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A keyboard {@link ModifierEvent}. This is an abstract class and is\n * implemented in the child classes {@link KeyPress} and {@link KeyRelease}.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport abstract class KeyEvent extends ModifierEvent {\n    /**\n     * This event's key. Uses the same values as the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key}\n     * Web API.\n     */\n    readonly key: string;\n\n    /** Create a new KeyEvent. */\n    constructor(key: string, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null) {\n        super(shift, ctrl, alt, target, FocusType.Keyboard, true);\n        this.key = key;\n    }\n}\n", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key release {@link KeyEvent} (key up).\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyRelease extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyRelease {\n        return new KeyRelease(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key press {@link KeyEvent} (key down). Also dispatched on key repeats.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyPress extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyPress {\n        return new KeyPress(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import type { KeyEvent } from '../events/KeyEvent';\nimport { KeyRelease } from '../events/KeyRelease';\nimport type { Widget } from '../widgets/Widget';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic keyboard {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending keyboard events to\n * registered roots.\n *\n * @category Driver\n */\nexport class KeyboardDriver implements Driver {\n    /** The list of key down/up events that haven't been dispatched yet. */\n    private eventQueues: Map<Root, Array<KeyEvent>> = new Map();\n    /** A set containing the keys currently down. */\n    private keysDown: Set<string> = new Set();\n    /** The currently focused root. New keyboard events will go to this root */\n    private focus: Root | null = null;\n\n    /**\n     * Get the {@link eventQueues | event queue} of a given root. If this driver\n     * is not registered to the given root or the given root is disabled, making\n     * it not present in eventQueues, then null is returned.\n     */\n    private getEventQueue(root: Root | null): Array<KeyEvent> | null {\n        if(root === null)\n            return null;\n\n        const eventQueue = this.eventQueues.get(root);\n        if(typeof eventQueue === 'undefined')\n            return null;\n\n        return eventQueue;\n    }\n\n    /**\n     * Changes the current {@link focus | root focus}.\n     *\n     * If there was a previous root focus, that root's {@link Root.clearFocus}\n     * is called with {@link FocusType.Keyboard}.\n     *\n     * {@link keysDown} is cleared.\n     */\n    protected changeFocusedRoot(root: Root | null): void {\n        if(this.focus !== null)\n            this.focus.clearFocus(FocusType.Keyboard);\n\n        this.focus = root;\n        this.keysDown.clear();\n    }\n\n    /**\n     * Get the current {@link focus | root focus}.\n     *\n     * @returns Returns {@link focus}\n     */\n    getFocusedRoot(): Root | null {\n        return this.focus;\n    }\n\n    /**\n     * Clear the current {@link focus | root focus}. Calls\n     * {@link changeFocusedRoot} with null.\n     */\n    clearFocus(): void {\n        this.changeFocusedRoot(null);\n    }\n\n    /**\n     * Push a new {@link KeyPress} event to {@link eventQueues}.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     */\n    keyDown(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        this.keysDown.add(key);\n        const eventQueue = this.getEventQueue(this.focus);\n        if(eventQueue !== null)\n            eventQueue.push(new KeyPress(key, shift, ctrl, alt, null));\n    }\n\n    /**\n     * Push a new {@link KeyRelease} event to {@link eventQueues}.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     */\n    keyUp(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        if(this.keysDown.delete(key)) {\n            const eventQueue = this.getEventQueue(this.focus);\n            if(eventQueue !== null)\n                eventQueue.push(new KeyRelease(key, shift, ctrl, alt, null));\n        }\n    }\n\n    /**\n     * Calls {@link keyDown} followed by {@link keyUp}. If the key was already\n     * down before calling ({@link isKeyDown}), keyUp is not called.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     */\n    keyPress(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const wasDown = this.isKeyDown(key);\n        this.keyDown(key, shift, ctrl, alt);\n        if(!wasDown)\n            this.keyUp(key, shift, ctrl, alt);\n    }\n\n    /**\n     * Check if a key is pressed.\n     *\n     * @param key Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     *\n     * @returns Returns true if key was in {@link keysDown}\n     */\n    isKeyDown(key: string): boolean {\n        return this.keysDown.has(key);\n    }\n\n    /**\n     * Adds enabled root to {@link eventQueues}.\n     */\n    onEnable(root: Root): void {\n        if(!this.eventQueues.has(root))\n            this.eventQueues.set(root, []);\n    }\n\n    /**\n     * Removes disabled root from {@link eventQueues}. If the root was the\n     * {@link focus}, then {@link clearFocus | the focus is cleared }.\n     */\n    onDisable(root: Root): void {\n        if(this.eventQueues.has(root)) {\n            this.eventQueues.delete(root);\n            if(root === this.focus)\n                this.clearFocus();\n        }\n    }\n\n    /**\n     * Dispatches all {@link eventQueues | queued events } for the root and\n     * clears its event queue\n     */\n    update(root: Root): void {\n        const eventQueue = this.getEventQueue(root);\n        if(eventQueue === null)\n            return;\n\n        // Dispatch queued keyboard events\n        for(const event of eventQueue)\n            root.dispatchEvent(event);\n\n        // Clear event queue\n        eventQueue.length = 0;\n    }\n\n    /**\n     * Does nothing if the new focus type is not a {@link FocusType.Keyboard}.\n     * If the focus comes from a root which is not the\n     * {@link focus | root focus}, then the root focus is\n     * {@link changeFocusedRoot | changed to the new root}. If it comes from the\n     * current root focus and there is no new focused widget (the root's\n     * keyboard focus was cleared), then the root focus is\n     * {@link clearFocus | cleared}.\n     */\n    onFocusChanged(root: Root, focusType: FocusType, newFocus: Widget | null): void {\n        if(focusType !== FocusType.Keyboard)\n            return;\n\n        if(root == this.focus) {\n            if(newFocus === null)\n                this.clearFocus();\n        }\n        else if(newFocus !== null)\n            this.changeFocusedRoot(root);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n", "import { KeyboardDriver } from './KeyboardDriver';\nimport { FocusType } from '../core/FocusType';\n\nconst PREVENT_DEFAULT_KEYS = new Set([\n    'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Home',\n    'PageDown', 'PageUp', 'Tab', ' ',\n]);\n\nfunction unpackKeyboardEvent(event: KeyboardEvent): [key: string, shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.key, event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A {@link KeyboardDriver} which listens for key events from HTML DOM elements.\n *\n * Note that if a DOM element is unfocused in the DOM to an unbound DOM element,\n * the root focus is cleared. If this creates issues, other DOM elements can be\n * bound without listening for key events.\n *\n * @category Driver\n */\nexport class DOMKeyboardDriver extends KeyboardDriver {\n    /** The list of HTML DOM elements bound to this keyboard driver */\n    private domElems: Set<EventTarget> = new Set();\n\n    /**\n     * Bind an HTML DOM element to this keyboard driver.\n     *\n     * @param listenToKeys If true, event listeners will be added to listen for keys. blur event listeners are always added no matter what.\n     */\n    bindDOMElem(domElem: HTMLElement, listenToKeys = true): void {\n        // Add to set. If it was already in set, abort\n        if(this.domElems.has(domElem))\n            return;\n\n        this.domElems.add(domElem);\n\n        // Listen for keyboard events, filling event queue, and blur event for\n        // clearing keyboard focus\n        if(listenToKeys) {\n            domElem.addEventListener('keydown', (event) => {\n                if(PREVENT_DEFAULT_KEYS.has(event.key)) {\n                    const currentFocus = this.getFocusedRoot()?.getFocus(FocusType.Keyboard) ?? null;\n                    if(currentFocus !== null)\n                        event.preventDefault();\n                }\n\n                this.keyDown(...unpackKeyboardEvent(event));\n            });\n\n            domElem.addEventListener('keyup', (event) => {\n                this.keyUp(...unpackKeyboardEvent(event));\n            });\n        }\n\n        domElem.addEventListener('blur', (event) => {\n            if(this.shouldClearFocus(event.relatedTarget))\n                this.clearFocus();\n        });\n\n    }\n\n    /**\n     * Check if the {@link focus | root focus} should be cleared given that the\n     * HTML DOM focus has been lost to another HTML DOM element\n     *\n     * @param newTarget The HTML DOM element to which the focus has been lost to\n     */\n    shouldClearFocus(newTarget: EventTarget | null): boolean {\n        return newTarget === null || !this.domElems.has(newTarget);\n    }\n}\n", "/**\n * Extracts the position of a DOM MouseEvent and normalises it. Useful for\n * implementing mouse input.\n *\n * @returns Returns a 2-tuple containing the normalised coordinates; the first\n * element contains the normalised x axis, and the second element contains the\n * normalised y axis\n *\n * @category Helper\n */\nexport function getPointerEventNormPos(event: MouseEvent, domElem: HTMLElement): [number, number] {\n    const rect = domElem.getBoundingClientRect();\n    return [\n        (event.clientX - rect.left) / rect.width,\n        (event.clientY - rect.top) / rect.height,\n    ];\n}", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer move {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerMove extends PointerEvent {\n    /** Create a new PointerMove. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerMove {\n        return new PointerMove(this.x - xOffset, this.y - yOffset, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerMove {\n        return new PointerMove(this.x, this.y, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "/**\n * A {@link PointerDriver}'s pointer hint; each registered pointer has a pointer\n * hint which tracks whether the pointer is not in use, hovering a root or\n * pressing a root. Useful for styling pointers depending on if they are\n * hovering/pressing a root or not.\n *\n * @category Driver\n */\nexport enum PointerHint {\n    /** The pointer is currently not hovering any root. */\n    None,\n    /** The pointer is currently hovering a root. */\n    Hovering,\n    /** The pointer is currently hovering and pressing a root. */\n    Pressing,\n}", "import { PointerRelease } from '../events/PointerRelease';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { PointerMove } from '../events/PointerMove';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Event } from '../events/Event';\nimport { PointerHint } from './PointerHint';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\ninterface PointerDriverState {\n    eventQueue: Array<Event>;\n    pointer: number | null;\n    pressing: number;\n    hovering: boolean;\n    dragLast: [number, number] | null;\n    dragOrigin: [number, number];\n}\n\n/**\n * A generic pointer {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending pointer events to\n * registered roots and (un)registering pointers.\n *\n * @category Driver\n */\nexport class PointerDriver implements Driver {\n    /**\n     * The current state for each registered and enabled root. Contains whether\n     * each root is pressing, hovering, which pointer is bound to it and its\n     * event queue\n     */\n    protected states: Map<Root, PointerDriverState> = new Map();\n    /** The next available pointer ID. See {@link registerPointer} */\n    private nextPointerID = 0;\n    /**\n     * The {@link PointerHint | hints} for each pointer. The keys are pointer\n     * IDs, while the values are that pointer's hint.\n     *\n     * See {@link getPointerHint}\n     */\n    protected hints: Map<number, PointerHint> = new Map();\n    /**\n     * The dragToScroll value of every pointer ID. See {@link registerPointer}.\n     */\n    private dragToScroll: Map<number, boolean> = new Map();\n\n    /** Unassign a pointer from a given root and its state. */\n    private unassignPointer(root: Root, state: PointerDriverState) {\n        // Clear pointer state\n        if(state.pointer !== null)\n            this.setPointerHint(state.pointer, PointerHint.None);\n\n        // Clear state\n        state.pointer = null;\n        if(state.hovering) {\n            // Queue up Leave event if hovering\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n        }\n        state.hovering = false;\n        state.pressing = 0;\n        state.dragLast = null;\n    }\n\n    /**\n     * Register a new pointer.\n     *\n     * @param dragToScroll If true, then dragging will result in PointerWheel events if no widget captures the events.\n     * @returns Returns {@link nextPointerID} and increments it\n     */\n    registerPointer(dragToScroll = false): number {\n        const newID = this.nextPointerID++;\n        this.setPointerHint(newID, PointerHint.None);\n        this.dragToScroll.set(newID, dragToScroll);\n        return newID;\n    }\n\n    /**\n     * Unregister a pointer.\n     *\n     * If a root has this pointer bound to it, the pointer is unbound from the\n     * root, a Leave event is queued to the root and the hovering and pressing\n     * state of the root is set to false.\n     */\n    unregisterPointer(pointer: number): void {\n        for(const [root, state] of this.states) {\n            // Unassign pointer if unregistered pointer was assigned to root\n            if(state.pointer === pointer)\n                this.unassignPointer(root, state);\n        }\n\n        this.hints.delete(pointer);\n        this.dragToScroll.delete(pointer);\n    }\n\n    /**\n     * Check if a given pointer can queue an event to a given root. Also\n     * automatically assigns pointer to root if possible. For internal use only.\n     *\n     * @param state The root's state. Although the function could technically get the state itself, it's passed to avoid repetition since you will need the state yourself\n     * @param givingActiveInput Is the pointer giving active input (pressing button or scrolling)? If so, then it can auto-assign if the root is not being pressed by another pointer\n     */\n    private canQueueEvent(root: Root, pointer: number, state: PointerDriverState, givingActiveInput: boolean): boolean {\n        // If there is no pointer assigned, assign this one\n        const firstAssign = state.pointer === null;\n        if(firstAssign)\n            state.pointer = pointer;\n\n        // If pointer is entering this root for the first time, then find which\n        // root the pointer was assigned to and queue a leave event\n        const pointerMatches = state.pointer === pointer;\n        if(!pointerMatches || firstAssign) {\n            for(const [otherRoot, otherState] of this.states) {\n                // Ignore if its this root\n                if(otherRoot === root)\n                    continue;\n\n                // If other root has this pointer assigned, unassign it\n                if(otherState.pointer === pointer)\n                    this.unassignPointer(otherRoot, otherState);\n            }\n        }\n\n        // Ignore if pointer is not the assigned one and not giving active input\n        // or being pressed by the assigned pointer\n        if(!pointerMatches && (!givingActiveInput || state.pressing > 0))\n            return false;\n        else {\n            // Replace assigned pointer and clear old assigned pointer's hint if\n            // pointer changed and giving active input\n            if(givingActiveInput && state.pointer !== pointer) {\n                this.unassignPointer(root, state);\n                state.pointer = pointer;\n            }\n\n            return true;\n        }\n    }\n\n    /** Denormalise normalised pointer coordinates. Internal use only. */\n    private denormaliseCoords(root: Root, xNorm: number, yNorm: number): [number, number] {\n        const [width, height] = root.dimensions;\n        return [xNorm * width, yNorm * height];\n    }\n\n    /**\n     * Queue up a pointer event to a given root. The type of\n     * {@link PointerEvent} is decided automatically based on the root's state\n     * and whether its pressing or not.\n     *\n     * @param pointer The registered pointer ID\n     * @param xNorm The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param pressing Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     *\n     * If null, the last pressing state is used, meaning that the pressing state\n     * has not changed. Useful if getting pointer movement in an event based\n     * environment where you only know when a pointer press occurs, but not if\n     * the pointer is pressed or not\n     */\n    movePointer(root: Root, pointer: number, xNorm: number, yNorm: number, pressing: number | null, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // If press state was not supplied, then it hasn't changed. Use the last\n        // state\n        if(pressing === null)\n            pressing = state.pressing;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, pressing > 0))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        if(pressing !== state.pressing) {\n            // Get how many bits in the bitmask you need to check\n            const bits = Math.floor(Math.log2(Math.max(pressing, state.pressing)));\n\n            // Check which buttons changed and generate an event for each\n            for(let bit = 0; bit <= bits; bit++) {\n                const wasPressed = ((state.pressing >> bit) & 0x1) === 1;\n                const isPressed = ((pressing >> bit) & 0x1) === 1;\n\n                if(wasPressed === isPressed)\n                    continue;\n\n                if(isPressed)\n                    state.eventQueue.push(new PointerPress(x, y, bit, shift, ctrl, alt));\n                else\n                    state.eventQueue.push(new PointerRelease(x, y, bit, shift, ctrl, alt));\n            }\n\n            state.pressing = pressing;\n        }\n        else\n            state.eventQueue.push(new PointerMove(x, y, shift, ctrl, alt));\n\n        // Update pointer's hint\n        if(state.pressing > 0)\n            this.setPointerHint(pointer, PointerHint.Pressing);\n        else\n            this.setPointerHint(pointer, PointerHint.Hovering);\n    }\n\n    /**\n     * Queue up a {@link Leave} event to a given root. Event will only be queued\n     * if the root was being hovered.\n     *\n     * @param pointer The registered pointer ID\n     */\n    leavePointer(root: Root, pointer: number): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Queue leave event if this is the assigned pointer and if hovering\n        if(state.hovering && state.pointer == pointer) {\n            state.hovering = false;\n            state.pressing = 0;\n            state.dragLast = null;\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n            this.setPointerHint(pointer, PointerHint.None);\n        }\n    }\n\n    /**\n     * Queue up a {@link Leave} event to any root with the given pointer\n     * assigned. Event will only be queued if the root was being hovered.\n     * Pointer will also be unassigned from root.\n     *\n     * @param pointer The registered pointer ID\n     */\n    leaveAnyPointer(pointer: number): void {\n        for(const root of this.states.keys())\n            this.leavePointer(root, pointer);\n    }\n\n    /**\n     * Queue up a mouse wheel event in a given 2D direction. Event will only be\n     * queued if the root was being hovered.\n     *\n     * @param pointer The registered pointer ID\n     * @param xNorm The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param deltaX How much was scrolled horizontally, in pixels\n     * @param deltaY How much was scrolled vertically, in pixels\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     */\n    wheelPointer(root: Root, pointer: number, xNorm: number, yNorm: number, deltaX: number, deltaY: number, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, true))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        state.eventQueue.push(new PointerWheel(x, y, deltaX, deltaY, false, shift, ctrl, alt));\n    }\n\n    /**\n     * Set a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer The registered pointer ID\n     * @param hint The new pointer hint\n     * @returns Returns true if the pointer hint changed, else, false\n     */\n    protected setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const oldHint = this.hints.get(pointer);\n\n        if(oldHint !== hint) {\n            this.hints.set(pointer, hint);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Get a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer The registered pointer ID\n     *\n     * @returns Returns the given pointer ID's hint. If the pointer ID is not registered, {@link PointerHint.None} is returned.\n     */\n    getPointerHint(pointer: number): PointerHint {\n        return this.hints.get(pointer) ?? PointerHint.None;\n    }\n\n    /**\n     * Creates a state for the enabled root in {@link states}.\n     */\n    onEnable(root: Root): void {\n        // Create new state for UI that just got enabled\n        this.states.set(root, <PointerDriverState>{\n            eventQueue: [],\n            pointer: null,\n            pressing: 0,\n            hovering: false,\n            dragLast: null,\n            dragOrigin: [0, 0],\n        });\n    }\n\n    /**\n     * Dispatches a leave event for the disabled root and deletes the state of\n     * the disabled root from {@link states}.\n     */\n    onDisable(root: Root): void {\n        // Dispatch leave event\n        root.dispatchEvent(new Leave());\n\n        // Reset hint for assigned pointer and stop dragging\n        const state = this.states.get(root);\n        if(typeof state !== 'undefined' && state.pointer !== null) {\n            this.setPointerHint(state.pointer, PointerHint.None);\n            state.dragLast = null;\n        }\n\n        // Delete state for UI thats about to get disabled\n        this.states.delete(root);\n    }\n\n    /**\n     * Dispatches all queued events (found in {@link states}) for the root and\n     * clears its event queue\n     */\n    update(root: Root): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Check if drag to scroll is enabled for this root\n        const dragToScroll = state.pointer === null\n                                ? false\n                                : this.dragToScroll.get(state.pointer);\n\n        // Dispatch all queued events for this root\n        for(const event of state.eventQueue) {\n            // If this is a pointer event and pointer is dragging, continue\n            // doing dragging logic\n            if(event instanceof PointerEvent && state.dragLast !== null) {\n                const [startX, startY] = state.dragLast;\n                root.dispatchEvent(new PointerWheel(\n                    ...state.dragOrigin,\n                    startX - event.x, startY - event.y,\n                    false, false, false, true,\n                ));\n\n                if(event instanceof PointerRelease)\n                    state.dragLast = null;\n                else {\n                    state.dragLast[0] = event.x;\n                    state.dragLast[1] = event.y;\n                }\n\n                continue;\n            }\n\n            // Dispatch event. If nobody captures the event, dragToScroll is\n            // enabled and this is a pointer press, then start dragging\n            if(root.dispatchEvent(event))\n                state.dragLast = null;\n            else if(dragToScroll && event instanceof PointerPress) {\n                state.dragLast = [event.x, event.y];\n                state.dragOrigin[0] = event.x;\n                state.dragOrigin[1] = event.y;\n            }\n        }\n\n        // Clear queue\n        state.eventQueue.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusChanged(_root: Root, _focusType: FocusType, _newFocus: Widget | null): void {}\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n", "import { getPointerEventNormPos } from '../helpers/getPointerEventNormPos';\nimport { PointerDriver } from './PointerDriver';\nimport type { Root } from '../core/Root';\n\ninterface RootDOMBind {\n    domElem: HTMLElement,\n    pointerListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerleaveListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    wheelListen: ((this: HTMLElement, event: WheelEvent) => void) | null,\n    contextMenuListen: ((this: HTMLElement, event: MouseEvent) => void) | null\n}\n\nfunction unpackModifiers(event: MouseEvent): [shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A {@link PointerDriver} which listens for pointer events from HTML DOM\n * elements. Each HTML DOM element is bound to a specific root, which synergizes\n * well with DOMRoot.\n *\n * @category Driver\n */\nexport class DOMPointerDriver extends PointerDriver {\n    /** The HTML DOM element and listeners that each root is bound to */\n    // XXX using weakmap so it auto-unbinds once a root stops existing\n    private domElems: WeakMap<Root, RootDOMBind> = new WeakMap();\n    /** The mapping between each DOM pointer ID and canvas-ui pointer ID */\n    private pointers: Map<number, number> = new Map();\n    /**\n     * The pointer ID of the mouse. Registered in constructor. This is needed\n     * due to wheel events not being part of the DOM PointerEvent interface and\n     * therefore not having a pointerID field. This is also safe because there\n     * can only be one mouse.\n     */\n    private mousePointerID: number;\n\n    /**\n     * Create a new DOMPointerDriver.\n     *\n     * Automatically registers a pointer to be used by the mouse.\n     */\n    constructor() {\n        super();\n\n        this.mousePointerID = this.registerPointer(false);\n    }\n\n    /**\n     * Bind an HTML DOM element to a specific root.\n     *\n     * If the root was already registered, {@link removeListeners} is called.\n     * Populates {@link domElems} with the new bind. Calls {@link addListeners}\n     * if root is enabled.\n     */\n    bindDOMElem(root: Root, domElem: HTMLElement): void {\n        let rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.removeListeners(rootBind);\n        else {\n            rootBind = <RootDOMBind>{\n                domElem,\n                pointerListen: null,\n                pointerleaveListen: null,\n                wheelListen: null,\n                contextMenuListen: null,\n            };\n            this.domElems.set(root, rootBind);\n            domElem.style.touchAction = 'none';\n        }\n\n        if(root.enabled)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Get the canvas-ui pointer ID of a given event. If the event has a pointer\n     * which hasn't been registered yet, then it is registered automatically\n     */\n    private getPointerID(event: PointerEvent): number {\n        let pointerID = this.pointers.get(event.pointerId);\n\n        if(typeof pointerID === 'undefined') {\n            const isMouse = event.pointerType === 'mouse';\n            if(isMouse)\n                pointerID = this.mousePointerID;\n            else\n                pointerID = this.registerPointer(true);\n\n            this.pointers.set(event.pointerId, pointerID);\n        }\n\n        return pointerID;\n    }\n\n    /**\n     * Add pointer event listeners to root's DOM element.\n     */\n    private addListeners(root: Root, rootBind: RootDOMBind) {\n        // Make listeners for mouse events, queueing events. Add them to the\n        // root DOM bind so they can be removed later when needed\n        const domElem = rootBind.domElem;\n        rootBind.pointerListen = (event: PointerEvent) => {\n            this.movePointer(\n                root, this.getPointerID(event),\n                ...getPointerEventNormPos(event, domElem),\n                event.buttons,\n                ...unpackModifiers(event),\n            );\n        }\n        rootBind.pointerleaveListen = (event: PointerEvent) => {\n            this.leavePointer(root, this.getPointerID(event));\n        }\n        rootBind.wheelListen = (event: WheelEvent) => {\n            let deltaX = event.deltaX;\n            let deltaY = event.deltaY;\n            if(deltaX === 0 && event.getModifierState('Shift')) {\n                deltaX = deltaY;\n                deltaY = 0;\n            }\n\n            this.wheelPointer(\n                root, this.mousePointerID,\n                ...getPointerEventNormPos(event, domElem),\n                event.deltaX, event.deltaY,\n                ...unpackModifiers(event),\n            );\n        }\n        rootBind.contextMenuListen = (event: MouseEvent) => {\n            // Prevent right-click from opening context menu\n            event.preventDefault();\n        }\n\n        // Add listeners to DOM element\n        domElem.addEventListener('pointermove', rootBind.pointerListen);\n        domElem.addEventListener('pointerdown', rootBind.pointerListen);\n        domElem.addEventListener('pointerup', rootBind.pointerListen);\n        domElem.addEventListener('pointerleave', rootBind.pointerleaveListen);\n        domElem.addEventListener('wheel', rootBind.wheelListen);\n        domElem.addEventListener('contextmenu', rootBind.contextMenuListen);\n    }\n\n    /**\n     * Remove pointer event listeners from root's DOM element and unset tracked\n     * listeners in root's bind.\n     */\n    private removeListeners(rootBind: RootDOMBind) {\n        if(rootBind.pointerListen !== null) {\n            rootBind.domElem.removeEventListener('pointermove', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerdown', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerup', rootBind.pointerListen);\n            rootBind.pointerListen = null;\n        }\n        if(rootBind.pointerleaveListen !== null) {\n            rootBind.domElem.removeEventListener('pointerleave', rootBind.pointerleaveListen);\n            rootBind.pointerleaveListen = null;\n        }\n        if(rootBind.wheelListen !== null) {\n            rootBind.domElem.removeEventListener('wheel', rootBind.wheelListen);\n            rootBind.wheelListen = null;\n        }\n        if(rootBind.contextMenuListen !== null) {\n            rootBind.domElem.removeEventListener('contextmenu', rootBind.contextMenuListen);\n            rootBind.contextMenuListen = null;\n        }\n    }\n\n    /**\n     * Calls {@link PointerDriver.onEnable} and {@link addListeners} to each\n     * bound root.\n     */\n    override onEnable(root: Root): void {\n        super.onEnable(root);\n\n        // Add event listeners for pointer when root is enabled, if the root is\n        // bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Calls {@link PointerDriver.onDisable} and {@link removeListeners} to each\n     * bound root.\n     */\n    override onDisable(root: Root): void {\n        super.onDisable(root);\n\n        // Remove event listeners for pointer when root is disabled, if the root\n        // is bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(typeof rootBind !== 'undefined')\n            this.removeListeners(rootBind);\n    }\n}", "import type { RayPointerSource } from './RayPointerSource';\nimport type { PointerHint } from './PointerHint';\nimport { PointerDriver } from './PointerDriver';\nimport { Root } from '../core/Root';\n\n/**\n * A {@link PointerDriver} which gets pointer events from raycasts in a 3D\n * engine's world. This is an abstract class and must be implemented. For an\n * example, see\n * [canvas-ui-three](https://github.com/rafern/canvas-ui-three)'s\n * ThreeRayPointerDriver implementation.\n *\n * @category Driver\n */\nexport abstract class RayPointerDriver extends PointerDriver {\n    /** The sources which this is assigned to */\n    protected readonly sources: Set<RayPointerSource> = new Set();\n\n    /**\n     * Cast a ray in the world and get which root was intersected and where.\n     *\n     * @param origin The world position where the ray is starting\n     * @param direction A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @returns Returns a 3-tuple containing, in this order, the intersected root or null if none intersected, the normalised x axis of the intersection and the normalised y axis of the intersection. If no root was intersected, use bogus values for x and y\n     */\n    protected abstract castRay(origin: [number, number, number], direction: [number, number, number]): [Root | null, number, number];\n\n    /**\n     * Receive a ray from a {@link RayPointerSource}.\n     *\n     * @param pointer The source's pointer ID, given when setting the source's sink\n     * @param pressing Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param origin The world position where the ray is starting\n     * @param direction A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @param shift Is shift being pressed?\n     * @param ctrl Is control being pressed?\n     * @param alt Is alt being pressed?\n     */\n    handlePointerRay(pointer: number, pressing: number | null, origin: [number, number, number], direction: [number, number, number], shift: boolean, ctrl: boolean, alt: boolean): void {\n        // Cast a ray and get the root that intersects with the ray and the\n        // intersection coordinates\n        const [root, xNorm, yNorm] = this.castRay(origin, direction);\n\n        // Queue a leave event if no root intersected, else, queue a move event\n        if(root === null)\n            this.leaveAnyPointer(pointer);\n        else\n            this.movePointer(root, pointer, xNorm, yNorm, pressing, shift, ctrl, alt);\n    }\n\n    /** Add a source. Assigns itself to the given source. */\n    addSource(source: RayPointerSource): void {\n        if(!this.sources.has(source)) {\n            source.setRayPointerDriver(this);\n            this.sources.add(source);\n        }\n    }\n\n    protected override setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const changed = super.setPointerHint(pointer, hint);\n\n        // Call onPointerHintChanged handler for each source\n        for(const source of this.sources)\n            source.onPointerHintChanged(pointer, hint);\n\n        return changed;\n\n    }\n}\n", "/**\n * A callback for when the value of a {@link Variable} changes.\n *\n * @category Helper\n */\nexport type VariableCallback<V> = (value: V) => void;\n\n/**\n * An aggregate helper class for widgets that contain a variable with a\n * specified type which is intended to be controlled by the user.\n *\n * Useful for implementing widgets such as sliders, checkboxes, text input,\n * etc...\n *\n * @template V The type of {@link value}.\n *\n * @category Helper\n */\nexport class Variable<V> {\n    /** The current value, for internal use. */\n    private _value: V;\n    /** Has the value changed? */\n    private _dirty = false;\n    /** The callback function called when the value is changed */\n    private callback: VariableCallback<V> | null;\n\n    /**\n     * Create a new Variable.\n     *\n     * @param initialValue The initial value of this variable. Sets {@link _value}.\n     * @param callback The callback for when the value is changed.\n     */\n    constructor(initialValue: V, callback: VariableCallback<V> | null = null) {\n        this._value = initialValue;\n        this.callback = callback;\n    }\n\n    /**\n     * The current value.\n     *\n     * If setting, {@link setValue} is called.\n     */\n    get value(): V {\n        return this._value;\n    }\n\n    set value(value: V) {\n        this.setValue(value);\n    }\n\n    /** Has the value changed? Resets {@link _dirty} to false */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Sets {@link _value}. Does nothing if the value is already the one\n     * specified.\n     *\n     * {@link _dirty} is set to true if the value has changed.\n     *\n     * @param doCallback If true, then {@link callback} is called if the value has changed.\n     */\n    setValue(value: V, doCallback = true): void {\n        if(this._value === value)\n            return;\n\n        this._value = value;\n        this._dirty = true;\n        if(doCallback && this.callback !== null) {\n            try {\n                this.callback(value);\n            }\n            catch(e) {\n                console.error('Exception in Variable callback', e);\n            }\n        }\n    }\n}\n", "import { FillStyle } from './FillStyle';\nimport { Theme } from './Theme';\n\n/**\n * A theme which always gives out a random canvas fill colour. Used for\n * debugging when painting occurs. Has no properties but always has a fallback\n * theme.\n *\n * @category Theme\n */\nexport class DebugTheme extends Theme {\n    /**\n     * Create a new DebugTheme instance.\n     *\n     * @param fallback The actual theme to use. Canvas fill color will be ignored as it is randomly generated. If none supplied, then the default theme found in {@link Theme.constructor} is used\n     */\n    constructor(fallback: Theme = new Theme()) {\n        super(undefined, fallback);\n    }\n\n    override get canvasFill(): FillStyle {\n        return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n    }\n\n    override set canvasFill(value: FillStyle | undefined) {\n        super.canvasFill = value;\n    }\n}\n", "import type { Validator, UnknownValidator } from './Validator';\nimport { VariableCallback } from '../helpers/Variable';\n\n/**\n * Creates a new {@link Validator} which is a list of validators merged into\n * one.\n *\n * @param validators The list of validators to be merged. The validators will be run in the order of the array.\n * @param defaultValue The bogus value that will be returned if the input is invalid\n * @param callback A callback which is called if validation succeeds. If null, no such callback will be called.\n * @template U The type of the input.\n * @template V The type of the output (the transformed input).\n *\n * @category Validator\n */\nexport function MakeCompositeValidator<U, V>(validators: Array<UnknownValidator>, defaultValue: V, callback: VariableCallback<V> | null = null): Validator<U, V> {\n    // TODO there must be a better way to do this which preserves type checking.\n    // maybe make Validator a class which can be chained with other validators?\n    return (value: U): [boolean, V] => {\n        let valid = true;\n        let nextValue: unknown = value;\n\n        for(const validator of validators) {\n            [valid, nextValue] = validator(nextValue);\n            if(!valid)\n                return [false, defaultValue];\n        }\n\n        if(callback !== null) {\n            try {\n                callback(nextValue as V);\n            }\n            catch(e) {\n                console.warn('Exception in CompositeValidator callback:', e);\n            }\n        }\n\n        return [true, nextValue as V];\n    };\n}", "import type { VariableCallback } from '../helpers/Variable';\nimport type { TextValidator } from './Validator';\n\n/**\n * A {@link TextValidator} which does nothing. Always reports a string as valid\n * and returns the input as the transformed input.\n *\n * @category Validator\n */\nexport function DefaultTextValidator(text: string): [boolean, string] {\n    return [true, text];\n}\n\n/**\n * Create a new {@link TextValidator} which calls a given callback. Always\n * reports a string as valid and returns the input as the transformed input,\n * like {@link DefaultTextValidator}.\n *\n * Note that this is only useful if a callback is supplied. If null is given as\n * the callback, then this will simply return {@link DefaultTextValidator}.\n *\n * @category Validator\n */\nexport function MakeDefaultTextValidatorWithCallback(callback: VariableCallback<string> | null = null): TextValidator<string> {\n    if(callback === null)\n        return DefaultTextValidator;\n\n    return (text: string): [boolean, string] => {\n        callback(text);\n        return [true, text];\n    }\n}", "const floatRegex = /^-?(\\.\\d+|\\d+(\\.(\\d+)?)?)(e\\d+)?$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * number. If valid, then it transforms the input string into a float.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function FloatValidator(text: string): [boolean, number] {\n    if(!floatRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseFloat(text)];\n}", "const intRegex = /^-?\\d+$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * integer. If valid, then it transforms the input string into an integer.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function IntValidator(text: string): [boolean, number] {\n    if(!intRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseInt(text)];\n}", "import type { Validator } from './Validator';\n\n/**\n * Creates a {@link Validator} which checks whether an input value is within a\n * specified exclusive range (can't be an inclusive range), always returning the\n * original input value.\n *\n * @template V The type of the input (and output, since it is unchanged).\n *\n * @category Validator\n */\nexport function MakeRangeValidator<V>(min: V, max: V): Validator<V, V> {\n    // TODO make a system for inclusive ranges\n    return (value: V): [boolean, V] => {\n        if(value < min)\n            return [false, value];\n\n        if(value > max)\n            return [false, value];\n\n        return [true, value];\n    };\n}", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as an alt key; toggles\n * {@link KeyContext.alt} on click.\n *\n * @category Widget\n */\nexport class AltKey extends VirtualKey {\n    /** Create a new AltKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 42, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Alt',\n            () => {\n                keyContext.alt = !keyContext.alt;\n                this.child.forced = keyContext.alt;\n                keyContext.callback('Alt');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.alt;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a control key; toggles\n * {@link KeyContext.ctrl} on click.\n *\n * @category Widget\n */\nexport class ControlKey extends VirtualKey {\n    /** Create a new ControlKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 42, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Ctrl',\n            () => {\n                keyContext.ctrl = !keyContext.ctrl;\n                this.child.forced = keyContext.ctrl;\n                keyContext.callback('Control');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.ctrl;\n    }\n}\n", "import { layoutField, multiFlagField, paintArrayField } from '../decorators/FlagFields';\nimport type { TextValidator } from '../validators/Validator';\nimport { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { TextPasteEvent } from '../events/TextPasteEvent';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { PointerMove } from '../events/PointerMove';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { Variable } from '../helpers/Variable';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\nimport { Widget } from './Widget';\n\n/**\n * A flexbox widget that allows for a single line of text input.\n *\n * Supports obscuring the text with {@link hideText}, which shows all characters\n * as black circles like in password fields, text validation and toggling\n * editing.\n *\n * If a {@link TextInputHandler} is set, then that will be used instead of\n * keyboard input for mobile compatibility.\n *\n * @template V The type of {@link validValue}; the type of the transformed value returned by the validator.\n *\n * @category Widget\n */\nexport class TextInput<V> extends Widget {\n    /**\n     * At what timestamp did the blinking start. If 0, then the text cursor is\n     * not blinking.\n     */\n    private blinkStart = 0;\n    /**\n     * Was the cursor shown last frame due to blinking? If null, then the text\n     * cursor is not blinking.\n     */\n    private blinkWasOn: boolean | null = null;\n    /** Current cursor position (index, not offset). */\n    private cursorPos = 0;\n    /** Current cursor offset in pixels. */\n    private cursorOffset: [number, number] = [0, 0];\n    /** Current cursor selection start position (index, not offset). */\n    private selectPos = 0;\n    /** Current cursor selection start offset in pixels. */\n    private selectOffset: [number, number] = [0, 0];\n    /** Does the cursor offset need to be updated? */\n    private cursorOffsetDirty = false;\n    /** Is editing enabled? */\n    private _editingEnabled = true;\n    /**\n     * Is the text hidden?\n     *\n     * @decorator `@multiFlagField(['cursorOffsetDirty', '_dirty'])`\n     */\n    @multiFlagField(['cursorOffsetDirty', '_dirty'])\n    hideText = false;\n    /** Is the text valid? */\n    private _valid;\n    /** Last valid value. */\n    private _validValue;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /** The helper for keeping track of the input value */\n    protected variable: Variable<string>;\n    /**\n     * Current offset of the text in the text box. Used on overflow.\n     *\n     * @decorator `@paintArrayField()`\n     */\n    @paintArrayField()\n    private offset = [0, 0];\n    /**\n     * Is text wrapping enabled? If not, text will be panned if needed\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText = true;\n    /**\n     * An input filter; a function which dictates whether a certain input can be\n     * inserted in the text. If the function returns false given the input,\n     * then the input will not be inserted in the text. Useful for preventing\n     * newlines or forcing numeric input. Note that the input is not\n     * neccessarily a character; it can be a whole sentence.\n     */\n    inputFilter: ((input: string) => boolean) | null = null;\n    /** Is the pointer dragging? */\n    private dragging = false;\n    /** When was the last pointer click? For detecting double/triple-clicks */\n    private lastClick = 0;\n    /**\n     * The cursor position when dragging was started. Used for\n     * double/triple-click dragging.\n     */\n    private dragStart = -1;\n    /**\n     * How many clicks have there been after a first click where the time\n     * between each click is less than 500 ms. Used for detecting double/triple\n     * clicks\n     */\n    private successiveClickCount: 0 | 1 | 2 = 0;\n\n    /** Create a new TextInput. */\n    constructor(validator: TextValidator<V>, inputFilter: ((input: string) => boolean) | null = null, initialValue = '', themeProperties?: ThemeProperties) {\n        // TextInputs clear their own background, have no children and don't\n        // propagate events\n        super(false, false, themeProperties);\n\n        this.textHelper = new TextHelper();\n        this.variable = new Variable<string>(initialValue, (text: string) => {\n            const [valid, validatedValue] = validator(text);\n\n            if(valid)\n                this._validValue = validatedValue;\n\n            if(valid !== this._valid) {\n                this._valid = valid;\n                this._dirty = true;\n            }\n        });\n        [this._valid, this._validValue] = validator(initialValue);\n        this.inputFilter = inputFilter;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'inputTextInnerPadding' ||\n                property === 'inputTextFont' ||\n                property === 'inputTextMinAscent' ||\n                property === 'inputTextMinDescent')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'inputBackgroundFill' ||\n                property === 'inputTextFill' ||\n                property === 'inputTextFillInvalid' ||\n                property === 'inputTextFillDisabled' ||\n                property === 'cursorThickness')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Is the text cursor shown?\n     *\n     * @returns Returns true if the text cursor is shown, false if not shown but the text input is in use, or null if the text cursor is not shown due to the text input not being in use.\n     */\n    get blinkOn(): boolean | null {\n        if(this.blinkStart === 0)\n            return null;\n\n        const blinkRate = this.blinkRate;\n        return Math.trunc(((Date.now() - this.blinkStart) / (500 * blinkRate)) % 2) === 0;\n    }\n\n    /**\n     * Is editing enabled?\n     *\n     * Tied to {@link _editingEnabled}. If changed, {@link _dirty} is set to\n     * true. If disabled, blinking stops and the cursor position is reset to the\n     * beginning.\n     */\n    get editingEnabled(): boolean {\n        return this._editingEnabled;\n    }\n\n    set editingEnabled(editingEnabled: boolean) {\n        if(this._editingEnabled !== editingEnabled) {\n            this._editingEnabled = editingEnabled;\n\n            // Disable blinking and reset cursor position if disabled\n            if(!editingEnabled) {\n                this.blinkStart = 0;\n                this.moveCursorTo(0, false);\n            }\n\n            // Mark as dirty; the text color changes\n            this._dirty = true;\n        }\n    }\n\n    /** The current text value. */\n    set text(text: string) {\n        this.variable.value = text;\n    }\n\n    get text(): string {\n        return this.variable.value;\n    }\n\n    /**\n     * Get the text as it is shown. If the text is hidden, all characters are\n     * replaced with a black circle.\n     */\n    get displayedText(): string {\n        if(this.hideText)\n            return '\u25CF'.repeat(this.variable.value.length);\n        else\n            return this.variable.value;\n    }\n\n    /** Is the current value in the text input valid? */\n    get valid(): boolean {\n        return this._valid;\n    }\n\n    /** The last valid value, transformed by the validator. */\n    get validValue(): V {\n        return this._validValue;\n    }\n\n    /** The current line number, starting from 0. */\n    get line(): number {\n        return this.textHelper.getLine(this.cursorPos);\n    }\n\n    /**\n     * Move the cursor to a given index.\n     *\n     * Sets {@link _dirty} and {@link cursorOffsetDirty} to true.\n     *\n     * @param select Should this do text selection?\n     */\n    moveCursorTo(index: number, select: boolean): void {\n        // Update cursor position, checking for boundaries\n        this.cursorPos = Math.min(Math.max(index, 0), this.text.length);\n\n        if(!select)\n            this.selectPos = this.cursorPos;\n\n        // Update cursor offset\n        this.cursorOffsetDirty = true;\n        this._dirty = true;\n    }\n\n    /**\n     * Move the cursor by a given index delta. Calls {@link moveCursorTo}\n     *\n     * @param delta The change in index; if a positive number, the cursor will be moved right by that amount, else, the cursor will be moved left by that amount.\n     */\n    moveCursor(delta: number, select: boolean): void {\n        this.moveCursorTo(this.cursorPos + delta, select);\n    }\n\n    /**\n     * Move the cursor given a given pointer offset.\n     *\n     * @param offsetX The horizontal offset in pixels, relative to the text area with padding removed\n     * @param offsetY The vertical offset in pixels, relative to the text area with padding removed\n     * @param select Should this do text selection?\n     */\n    moveCursorFromOffset(offsetX: number, offsetY: number, select: boolean): void {\n        [this.cursorPos, this.cursorOffset] = this.textHelper.findIndexOffsetFromOffset(\n            [ offsetX, offsetY ],\n        );\n\n        if(!select) {\n            this.selectPos = this.cursorPos;\n            this.selectOffset = this.cursorOffset;\n        }\n\n        // Start blinking cursor and mark component as dirty, to\n        // make sure that cursor blink always resets for better\n        // feedback\n        this.blinkStart = Date.now();\n        this._dirty = true;\n    }\n\n    /**\n     * Move the cursor by a given line delta. Calls {@link moveCursorFromOffset}\n     *\n     * @param delta The change in line; if a positive number, the cursor will be moved down by that amount, else, the cursor will be moved up by that amount.\n     */\n    moveCursorLine(delta: number, select: boolean): void {\n        this.moveCursorFromOffset(\n            this.cursorOffset[0],\n            this.cursorOffset[1] + (0.5 + delta) * this.textHelper.fullLineHeight,\n            select,\n        );\n    }\n\n    /**\n     * Move the cursor to the start of the line. Calls {@link moveCursorTo}\n     */\n    moveCursorStart(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineStart(this.line), select);\n    }\n\n    /**\n     * Move the cursor to the end of the line. Calls {@link moveCursorTo}\n     */\n    moveCursorEnd(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineEnd(this.line, false), select);\n    }\n\n    /**\n     * Move the cursor by skipping over a number of words. Calls\n     * {@link moveCursorTo}\n     *\n     * @param delta The change in words; if a positive number, the cursor skip this amount of words, else, it will do the same, but backwards.\n     */\n    moveCursorWord(delta: number, select: boolean): void {\n        if(delta == 0)\n            return;\n\n        const wordRegex = /\\w/;\n        const text = this.text;\n        let targetPos = this.cursorPos;\n\n        if(delta > 0) {\n            while(delta > 0) {\n                let insideWord = false;\n                for(; targetPos <= text.length; targetPos++) {\n                    if(targetPos < text.length && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                delta--;\n            }\n        }\n        else {\n            while(delta < 0) {\n                targetPos--;\n                let insideWord = false;\n                for(; targetPos >= 0; targetPos--) {\n                    if(targetPos >= 0 && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                targetPos++;\n                delta++;\n            }\n        }\n\n        this.moveCursorTo(targetPos, select);\n    }\n\n    /**\n     * Deletes a range of text and moves the cursor to the start of the range.\n     *\n     * @param start The inclusive index of the start of the text range\n     * @param end The exclusive index of the end of the text range\n     */\n    deleteRange(start: number, end: number): void {\n        if(start === end)\n            return;\n\n        // Delete text\n        this.text = this.text.substring(0, start) + this.text.substring(end);\n\n        // Update cursor position\n        this.cursorPos = this.selectPos = start;\n        this.cursorOffsetDirty = true;\n    }\n\n    /**\n     * Like {@link moveCursorWord}, but for deleting words. Calls\n     * {@link moveCursorWord} and {@link deleteRange}. If text is being\n     * selected, delta is ignored and the selection is deleted instead. Note\n     * that a delta of zero doesn't delete anything.\n     */\n    deleteWord(delta: number): void {\n        if(delta === 0)\n            return;\n\n        // Delete selection\n        if(this.cursorPos !== this.selectPos) {\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n            return;\n        }\n\n        // Move cursor by wanted words\n        const oldPos = this.cursorPos;\n        this.moveCursorWord(delta, false);\n\n        // If cursor position is different, delete\n        if(oldPos !== this.cursorPos) {\n            this.deleteRange(\n                Math.min(oldPos, this.cursorPos),\n                Math.max(oldPos, this.cursorPos),\n            );\n        }\n    }\n\n    /**\n     * Insert text at the current cursor index. Calls {@link moveCursorTo}\n     * afterwards.\n     */\n    insertText(str: string): void {\n        // Abort if input can't be inserted\n        if(this.inputFilter !== null && !this.inputFilter(str))\n            return;\n\n        if(this.selectPos === this.cursorPos) {\n            // Insert string in current cursor position\n            this.text = this.text.substring(0, this.cursorPos) + str + this.text.substring(this.cursorPos);\n            // Move cursor neccessary amount forward\n            this.moveCursor(str.length, false);\n        }\n        else {\n            const start = Math.min(this.cursorPos, this.selectPos);\n            const end = Math.max(this.cursorPos, this.selectPos);\n\n            // Replace text in selection with the one being inserted\n            this.text = this.text.substring(0, start) + str + this.text.substring(end);\n            // Move cursor to end of selection after insert\n            this.moveCursorTo(start + str.length, false);\n        }\n    }\n\n    /**\n     * Deletes a certain amount of characters in a given direction from the\n     * current cursor index. Calls {@link deleteRange} or {@link moveCursorTo}\n     * if neccessary. If text is being selected, delta is ignored and the\n     * selection is deleted instead. Note that a delta of zero doesn't delete\n     * anything.\n     *\n     * @param delta The amount and direction of the deletion. For example, if 5, then 5 characters are deleted after the cursor. If -5, then 5 characters are deleted before the cursor and the cursor is moved 5 indices left.\n     */\n    deleteText(delta: number): void {\n        if(delta === 0)\n            return;\n\n        if(this.cursorPos !== this.selectPos) {\n            // Delete selection\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n        }\n        else if(delta > 0) {\n            // Delete forwards\n            this.text = this.text.substring(0, this.cursorPos) + this.text.substring(this.cursorPos + delta);\n        }\n        else {\n            // Delete backwards\n            // NOTE, still checking if delta < 0 so that nothing is done if\n            // delta is 0\n            this.text = this.text.substring(0, this.cursorPos + delta) + this.text.substring(this.cursorPos);\n            this.moveCursor(delta, false);\n        }\n    }\n\n    /**\n     * Select a range of text (either word or non-word, but not both) which\n     * includes the given cursor position\n     *\n     * @returns Returns a 2-tuple with, respectively, the start and end of the range\n     */\n    private selectRangeAt(pos: number): [number, number] {\n        const text = this.text;\n        const wordRegex = /\\w/;\n        const isWord = wordRegex.test(text[pos]);\n        const midPos = pos;\n\n        // Grow left\n        for(; pos >= 0; pos--) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        const startPos = pos + 1;\n\n        // Grow right\n        pos = midPos;\n        for(; pos < text.length; pos++) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        return [startPos, pos];\n    }\n\n    override onFocusDropped(focusType: FocusType, _root: Root): void {\n        // Stop blinking cursor if keyboard focus lost and stop dragging if\n        // pointer focus is lost\n        if(focusType === FocusType.Keyboard)\n            this.blinkStart = 0;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this | null {\n        // If editing is disabled, abort\n        if(!this._editingEnabled)\n            return this;\n\n        if(event instanceof Leave) {\n            // Stop dragging if the pointer leaves the text input, since it\n            // won't receive pointer release events outside the widget\n            this.dragging = false;\n            this.lastClick = 0;\n            return this;\n        }\n        else if(event instanceof PointerWheel) {\n            // Don't capture wheel events\n            return null;\n        }\n        else if(event instanceof PointerEvent) {\n            // If this is a pointer event, set pointer style and handle clicks\n            root.pointerStyle = 'text';\n\n            // Request keyboard focus if this is a pointer press with the\n            // primary button\n            if(event instanceof PointerPress || event instanceof PointerMove) {\n                const isPress = event instanceof PointerPress && event.isPrimary;\n                if(isPress) {\n                    this.dragging = true;\n                    const clickTime = (new Date()).getTime();\n\n                    // Count successive clicks. Clicks counts as successive if\n                    // they come after the last click in less than 500 ms\n                    if(clickTime - this.lastClick < 500) {\n                        this.successiveClickCount++;\n                        // Wrap click counter around (there's no action above\n                        // triple click)\n                        if(this.successiveClickCount > 2)\n                            this.successiveClickCount = 0;\n                    }\n                    else\n                        this.successiveClickCount = 0;\n\n                    this.lastClick = clickTime;\n                }\n                else if(!this.dragging)\n                    return this;\n\n                // Update cursor position (and offset) from click position\n                const padding = this.inputTextInnerPadding;\n                this.moveCursorFromOffset(\n                    event.x - this.x - padding + this.offset[0],\n                    event.y - this.y - padding + this.offset[1],\n                    !isPress && this.dragging,\n                );\n\n                if(isPress) {\n                    // Prevent successive clicks from one cursor position to\n                    // another from counting as successive clicks\n                    if(this.cursorPos !== this.dragStart)\n                        this.successiveClickCount = 0;\n\n                    this.dragStart = this.cursorPos;\n                }\n\n                if(this.successiveClickCount > 0) {\n                    let start, end;\n\n                    if(this.successiveClickCount === 1) {\n                        // If double-click dragging, select ranges of text\n                        // Get the text range at the cursor and at the start of the\n                        // double click drag, then mush them together into a single\n                        // range\n                        const [doubleStart, doubleEnd] = this.selectRangeAt(this.dragStart);\n                        const [curStart, curEnd] = this.selectRangeAt(this.cursorPos);\n                        start = Math.min(doubleStart, curStart);\n                        end = Math.max(doubleEnd, curEnd);\n                    }\n                    else {\n                        // If triple-click dragging, select lines of text\n                        const startPos = Math.min(this.cursorPos, this.dragStart);\n                        const startLine = this.textHelper.getLine(startPos);\n                        start = this.textHelper.getLineStart(startLine);\n\n                        const endPos = Math.max(this.cursorPos, this.dragStart);\n                        const endLine = this.textHelper.getLine(endPos);\n                        // Include newlines so that deleting a triple-click\n                        // selection deletes entire lines\n                        end = this.textHelper.getLineEnd(endLine);\n                    }\n\n                    // Set cursor positions. Get the drag direction and swap\n                    // cursor and select pos depending on the direction\n                    if(this.cursorPos >= this.dragStart) {\n                        this.selectPos = start;\n                        this.cursorPos = end;\n                    }\n                    else {\n                        this.selectPos = end;\n                        this.cursorPos = start;\n                    }\n\n                    this.cursorOffsetDirty = true;\n                }\n\n                // Request focus\n                root.requestFocus(FocusType.Keyboard, this);\n            }\n            else if(event instanceof PointerRelease && event.isPrimary) {\n                // Stop dragging\n                this.dragging = false;\n\n                // Get mobile-friendly text input if available\n                if(root.hasMobileTextInput) {\n                    root.getTextInput(this.text).then((newValue: string | null) => {\n                        if(newValue === null)\n                            return;\n\n                        if(this.text !== newValue) {\n                            this.text = newValue;\n                            this.moveCursorTo(newValue.length, false);\n                        }\n                    });\n                }\n            }\n\n            return this;\n        }\n        else if(event instanceof KeyPress) {\n            // Stop dragging\n            this.dragging = false;\n            this.lastClick = 0;\n\n            // Ignore all key presses with alt modifier\n            if(event.alt)\n                return this;\n\n            // Ignore most key presses if control is pressed\n            if(event.ctrl) {\n                if(event.key === 'Backspace')\n                    this.deleteWord(-1); // Delete word backwards\n                else if(event.key === 'Delete')\n                    this.deleteWord(1); // Delete word forwards\n                else if(event.key === 'ArrowLeft')\n                    this.moveCursorWord(-1, event.shift); // Back-skip a word\n                else if(event.key === 'ArrowRight')\n                    this.moveCursorWord(1, event.shift); // Skip a word\n                else if(event.key === 'c' || event.key === 'C') {\n                    // Copy selected text to clipboard, if any\n                    if(this.cursorPos === this.selectPos)\n                        return this;\n\n                    const selectedText = this.text.slice(\n                        Math.min(this.cursorPos, this.selectPos),\n                        Math.max(this.cursorPos, this.selectPos),\n                    );\n\n                    if(navigator.clipboard)\n                        navigator.clipboard.writeText(selectedText);\n                    else\n                        return this;\n                }\n                else\n                    return this;\n\n                // Reset blink time for better feedback\n                this.blinkStart = Date.now();\n                return this;\n            }\n\n            // Regular key presses:\n            if(event.key.length === 1)\n                this.insertText(event.key); // Insert character\n            else if(event.key === 'Backspace')\n                this.deleteText(-1); // Delete backwards\n            else if(event.key === 'Delete')\n                this.deleteText(1); // Delete forwards\n            else if(event.key === 'ArrowLeft')\n                this.moveCursor(-1, event.shift); // Move cursor left\n            else if(event.key === 'ArrowRight')\n                this.moveCursor(1, event.shift); // Move cursor right\n            else if(event.key === 'ArrowUp')\n                this.moveCursorLine(-1, event.shift); // Move cursor up\n            else if(event.key === 'ArrowDown')\n                this.moveCursorLine(1, event.shift); // Move cursor down\n            else if(event.key === 'PageUp')\n                this.moveCursorLine(-5, event.shift); // Move cursor up x5\n            else if(event.key === 'PageDown')\n                this.moveCursorLine(5, event.shift); // Move cursor down x5\n            else if(event.key === 'Home')\n                this.moveCursorStart(event.shift); // Move cursor to beginning\n            else if(event.key === 'End')\n                this.moveCursorEnd(event.shift); // Move cursor to end\n            else if(event.key === 'Escape') {\n                root.dropFocus(FocusType.Keyboard, this); // Drop focus\n                return this; // Return now so that blink time isn't reset\n            }\n            else if(event.key === 'Enter')\n                this.insertText('\\n');\n            else if(event.key === 'Tab')\n                this.insertText('\\t');\n            else\n                return this; // Ignore key if it is unknown\n\n            // Reset blink time for better feedback\n            this.blinkStart = Date.now();\n        }\n        else if(event instanceof TextPasteEvent && event.target === this) {\n            // Insert pasted text\n            this.insertText(event.text);\n\n            // Reset blink time for better feedback\n            this.blinkStart = Date.now();\n        }\n\n        return this;\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        // Drop focus if editing is disabled\n        if(!this.editingEnabled)\n            root.dropFocus(FocusType.Keyboard, this);\n\n        // Mark as dirty when a blink needs to occur\n        if(this.blinkOn !== this.blinkWasOn)\n            this._dirty = true;\n\n        // Update TextHelper variables\n        this.textHelper.text = this.displayedText;\n        this.textHelper.font = this.inputTextFont;\n        this.textHelper.lineHeight = this.inputTextHeight;\n        this.textHelper.lineSpacing = this.inputTextSpacing;\n\n        if(this.cursorOffsetDirty) {\n            this.cursorOffset = this.textHelper.findOffsetFromIndex(this.cursorPos);\n\n            if(this.selectPos === this.cursorPos) {\n                this.selectOffset[0] = this.cursorOffset[0];\n                this.selectOffset[1] = this.cursorOffset[1];\n            }\n            else\n                this.selectOffset = this.textHelper.findOffsetFromIndex(this.selectPos);\n\n            this.cursorOffsetDirty = false;\n        }\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Only expand to the needed dimensions, but take minimum width from\n        // theme into account\n        const padding = 2 * this.inputTextInnerPadding;\n        this.textHelper.maxWidth = this.wrapText ? Math.max(maxWidth - padding, 0) : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        const effectiveMinWidth = Math.min(Math.max(this.inputTextMinWidth, minWidth), maxWidth);\n        this.width = Math.min(Math.max(effectiveMinWidth, this.textHelper.width + padding), maxWidth);\n        this.height = Math.min(Math.max(minHeight, this.textHelper.height + padding), maxHeight);\n    }\n\n    protected override handlePostLayoutUpdate(_root: Root): void {\n        // Check if panning is needed\n        const padding = this.inputTextInnerPadding;\n        const innerWidth = this.textHelper.width;\n        const innerHeight = this.textHelper.height;\n        const usableWidth = this.width - padding * 2;\n        const usableHeight = this.height - padding * 2;\n        const candidateOffset = this.offset;\n        const [cursorX, cursorY] = this.cursorOffset;\n\n        if(innerWidth > usableWidth) {\n            // Horizontal panning needed\n            const deadZone = Math.min(20, usableWidth / 2);\n            const left = candidateOffset[0] + deadZone;\n            const right = candidateOffset[0] + usableWidth - deadZone;\n\n            // Pan right\n            if(cursorX > right)\n                candidateOffset[0] += cursorX - right;\n\n            // Pan left\n            if(cursorX < left)\n                candidateOffset[0] -= left - cursorX;\n\n            // Clamp\n            if(candidateOffset[0] + usableWidth > innerWidth)\n                candidateOffset[0] = innerWidth - usableWidth;\n            if(candidateOffset[0] < 0)\n                candidateOffset[0] = 0;\n        }\n        else {\n            // Horizontal panning not needed\n            candidateOffset[0] = 0;\n        }\n\n        if(innerHeight > usableHeight) {\n            // Vertical panning needed\n            const fullLineHeight = this.textHelper.fullLineHeight;\n            const deadZone = usableHeight < 2 * fullLineHeight ? 0 : fullLineHeight / 2;\n            const top = candidateOffset[1] + deadZone;\n            const bottom = candidateOffset[1] + usableHeight - deadZone - fullLineHeight;\n\n            // Pan down\n            if(cursorY > bottom)\n                candidateOffset[1] += cursorY - bottom;\n\n            // Pan up\n            if(cursorY < top)\n                candidateOffset[1] -= top - cursorY;\n\n            // Clamp\n            if(candidateOffset[1] + usableHeight > innerHeight)\n                candidateOffset[1] = innerHeight - usableHeight;\n            if(candidateOffset[1] < 0)\n                candidateOffset[1] = 0;\n        }\n        else {\n            // Vertical panning not needed\n            candidateOffset[1] = 0;\n        }\n\n        this.offset = candidateOffset;\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, _forced: boolean): void {\n        // Paint background\n        ctx.fillStyle = this.inputBackgroundFill;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n\n        // Start clipping\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(this.x, this.y, this.width, this.height);\n        ctx.clip();\n\n        // Paint background for selection if there is a selection\n        const padding = this.inputTextInnerPadding;\n        if(this.cursorPos !== this.selectPos) {\n            ctx.fillStyle = this.inputSelectBackgroundFill;\n            if(this.cursorOffset[1] === this.selectOffset[1]) {\n                // Same line\n                const left = Math.min(this.cursorOffset[0], this.selectOffset[0]);\n                const right = Math.max(this.cursorOffset[0], this.selectOffset[0]);\n                ctx.fillRect(\n                    this.x + padding + left - this.offset[0],\n                    this.y + padding + this.cursorOffset[1] - this.offset[1],\n                    right - left,\n                    this.textHelper.fullLineHeight,\n                );\n            }\n            else {\n                // Spans multiple lines\n                let topOffset: [number, number], bottomOffset: [number, number];\n                if(this.cursorOffset[1] < this.selectOffset[1]) {\n                    topOffset = this.cursorOffset;\n                    bottomOffset = this.selectOffset;\n                }\n                else {\n                    bottomOffset = this.cursorOffset;\n                    topOffset = this.selectOffset;\n                }\n\n                // Top line:\n                const fullLineHeight = this.textHelper.fullLineHeight;\n                const topWidth = this.width + this.offset[0] - topOffset[0] - padding;\n                if(topWidth > 0) {\n                    ctx.fillRect(\n                        this.x + padding + topOffset[0] - this.offset[0],\n                        this.y + padding + topOffset[1] - this.offset[1],\n                        topWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Bottom line:\n                const bottomWidth = bottomOffset[0] + padding - this.offset[0];\n                if(bottomWidth > 0) {\n                    ctx.fillRect(\n                        this.x,\n                        this.y + padding + bottomOffset[1] - this.offset[1],\n                        bottomWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Middle lines:\n                const middleYOffset = topOffset[1] + fullLineHeight;\n                const middleHeight = bottomOffset[1] - middleYOffset;\n                if(middleHeight > 0) {\n                    ctx.fillRect(\n                        this.x,\n                        this.y + padding + middleYOffset - this.offset[1],\n                        this.width,\n                        middleHeight,\n                    );\n                }\n            }\n        }\n\n        // Paint current text value\n        let fillStyle;\n        if(this._editingEnabled) {\n            if(this._valid)\n                fillStyle = this.inputTextFill;\n            else\n                fillStyle = this.inputTextFillInvalid;\n        }\n        else\n            fillStyle = this.inputTextFillDisabled;\n\n        this.textHelper.paint(\n            ctx, fillStyle,\n            this.x + padding - this.offset[0],\n            this.y + padding - this.offset[1],\n        );\n\n        // Paint blink\n        const blinkOn = this.blinkOn;\n        this.blinkWasOn = blinkOn;\n        if(blinkOn) {\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(\n                this.x + padding + this.cursorOffset[0] - this.offset[0],\n                this.y + padding + this.cursorOffset[1] - this.offset[1],\n                this.cursorThickness,\n                this.textHelper.fullLineHeight,\n            );\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n}\n", "import { MakeDefaultTextValidatorWithCallback } from '../validators/DefaultTextValidator';\nimport type { ThemeProperties } from \"../theme/ThemeProperties\";\nimport type { VariableCallback } from '../helpers/Variable';\nimport { TextInput } from \"./TextInput\";\n\n/**\n * A {@link TextInput} with an optional callback and no validation.\n *\n * @category Widget\n */\nexport class BasicTextInput extends TextInput<string> {\n    /**\n     * Create a new BasicTextInput.\n     *\n     * Equivalent to creating a new {@link TextInput} instance with a validator\n     * created by {@link MakeDefaultTextValidatorWithCallback} and no input\n     * filter.\n     *\n     * @param callback An optional callback called when the text changes. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<string> | null = null, initialValue = '', themeProperties?: ThemeProperties) {\n        const validator = MakeDefaultTextValidatorWithCallback(callback);\n        super(validator, null, initialValue, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport type { Padding } from '../theme/Padding';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Container} with center alignment on both axes and no padding.\n *\n * Can be constrained to a specific type of children.\n *\n * Padding and alignment settings are applied via theme properties; if you pass\n * these two properties, they will be ignored in a clone of the theme\n * properties. If you want to override these two theme properties, then use\n * {@link Container} instead.\n *\n * @category Widget\n */\nexport class Center<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Center. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Center,\n        };\n        themePropertiesClone.containerPadding = <Padding>{\n            left: 0, right: 0, top: 0, bottom: 0,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import { Variable, VariableCallback } from '../helpers/Variable';\nimport { ClickHelper, ClickState } from '../helpers/ClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerWheel } from '../events/PointerWheel';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A checkbox widget; can be ticked or unticked.\n *\n * @category Widget\n */\nexport class Checkbox extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper for handling pointer clicks */\n    protected clickHelper: ClickHelper;\n    /** The helper for keeping track of the checkbox value */\n    protected variable: Variable<boolean>;\n\n    /**\n     * Create a new Checkbox.\n     *\n     * @param callback An optional callback called when the checkbox is ticked or unticked. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<boolean> | null = null, initialValue = false, themeProperties?: ThemeProperties) {\n        // Checkboxes need a clear background, have no children and don't\n        // propagate events\n        super(true, false, themeProperties);\n\n        // Save callback and initial value\n        this.variable = new Variable<boolean>(initialValue, callback);\n\n        // Setup click helper\n        this.clickHelper = new ClickHelper(this);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'checkboxLength') {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundGlowFill' ||\n                property === 'backgroundFill' ||\n                property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'checkboxInnerPadding')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /** Is the checkbox checked? */\n    set checked(checked: boolean) {\n        this.variable.value = checked;\n    }\n\n    get checked(): boolean {\n        return this.variable.value;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this | null {\n        // Ignore wheel events\n        if(event instanceof PointerWheel)\n            return null;\n\n        // Check if checkbox rectangle was pressed and swap value if so\n        const x = this.x + this.offsetX;\n        const y = this.y + this.offsetY;\n        this.clickHelper.handleClickEvent(\n            event,\n            root,\n            [x, x + this.actualLength, y, y + this.actualLength],\n        );\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect). Toggle value if clicked\n        if(this.clickHelper.clickStateChanged) {\n            this._dirty = true;\n\n            if(this.clickHelper.wasClick)\n                this.checked = !this.checked;\n        }\n\n        return this;\n    }\n\n    protected override handlePostLayoutUpdate(_root: Root): void {\n        // Mark as dirty if variable is dirty\n        if(this.variable.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find actual length\n        const length = this.checkboxLength;\n        this.actualLength = Math.min(length, maxWidth, maxHeight);\n\n        // Resolve width and height\n        this.width = this.actualLength;\n        this.height = this.actualLength;\n\n        if(this.width < minWidth)\n            this.width = minWidth;\n        if(this.height < minHeight)\n            this.height = minHeight;\n\n        // Center checkbox\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, _forced: boolean): void {\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of checkbox\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n\n        const checkboxX = this.offsetX + this.x;\n        const checkboxY = this.offsetY + this.y;\n        ctx.fillRect(\n            checkboxX, checkboxY, this.actualLength, this.actualLength,\n        );\n\n        // Draw checked part of checkbox\n        if(this.checked) {\n            if(useGlow)\n                ctx.fillStyle = this.accentFill;\n            else\n                ctx.fillStyle = this.primaryFill;\n\n            const innerPadding = this.checkboxInnerPadding;\n            const innerLength = this.actualLength - innerPadding * 2;\n\n            // Fall back to filling entire checkbox if there isn't enougn space\n            // for padding\n            if(innerLength <= 0) {\n                ctx.fillRect(\n                    checkboxX,\n                    checkboxY,\n                    this.actualLength,\n                    this.actualLength,\n                );\n            }\n            else {\n                ctx.fillRect(\n                    checkboxX + innerPadding,\n                    checkboxY + innerPadding,\n                    innerLength,\n                    innerLength,\n                );\n            }\n        }\n    }\n}\n", "import { paintField, layoutField, paintLayoutArrayField } from '../decorators/FlagFields';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A widget which displays a given image.\n *\n * @category Widget\n */\nexport class Icon extends Widget {\n    /** The current image used by the icon. */\n    private _image: HTMLImageElement;\n    /**\n     * The last source that the current image was using. Used for tracking if\n     * the image source changed and if the image is fully loaded.\n     */\n    private lastSrc: string | null = null;\n    /**\n     * The current image rotation in radians.\n     *\n     * @decorator `@paintField`\n     */\n    @paintField\n    rotation = 0;\n    /**\n     * The view box of this Icon, useful if the image used for the icon is a\n     * spritesheet. If null, the entire image will be used.\n     *\n     * @decorator `@paintLayoutArrayField(true)`\n     */\n    @paintLayoutArrayField(true)\n    viewBox: [number, number, number, number] | null;\n    /**\n     * The wanted width. If null, the image's width will be used, taking\n     * {@link viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageWidth: number | null = null;\n    /**\n     * The wanted height. If null, the image's height will be used, taking\n     * {@link viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageHeight: number | null = null;\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual image width */\n    private actualWidth = 0;\n    /** Actual image height */\n    private actualHeight = 0;\n\n    /** Create a new Icon. */\n    constructor(image: HTMLImageElement, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, themeProperties?: ThemeProperties) {\n        // Icons need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        this._image = image;\n        this.imageWidth = width;\n        this.imageHeight = height;\n        this.viewBox = viewBox;\n    }\n\n    /**\n     * The image used by this Icon.\n     *\n     * Sets {@link _image} if changed and sets {@link lastSrc} to null to mark\n     * the image as loading so that flickers are minimised.\n     *\n     * If getting, returns {@link _image}.\n     */\n    set image(image: HTMLImageElement) {\n        if(image !== this._image) {\n            this._image = image;\n            this.lastSrc = null;\n        }\n    }\n\n    get image(): HTMLImageElement {\n        return this._image;\n    }\n\n    protected override handlePreLayoutUpdate(_root: Root): void {\n        // Icons only needs to be re-drawn if image changed, which is tracked by\n        // the image setter, or if the source changed, but not if the icon isn't\n        // loaded yet\n        if(this._image?.src !== this.lastSrc && this._image?.complete) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find dimensions\n        let wantedWidth = this.imageWidth;\n        if(wantedWidth === null) {\n            if(this.viewBox === null)\n                wantedWidth = this._image.width;\n            else\n                wantedWidth = this.viewBox[2];\n        }\n\n        this.width = Math.max(Math.min(wantedWidth, maxWidth), minWidth);\n\n        let wantedHeight = this.imageHeight;\n        if(wantedHeight === null) {\n            if(this.viewBox === null)\n                wantedHeight = this._image.height;\n            else\n                wantedHeight = this.viewBox[3];\n        }\n\n        this.height = Math.max(Math.min(wantedHeight, maxHeight), minHeight);\n\n        // Find offset and actual image dimensions (preserving aspect ratio)\n        const widthRatio = this.width / wantedWidth;\n        const heightRatio = this.height / wantedHeight;\n        const scale = Math.min(widthRatio, heightRatio);\n        this.actualWidth = wantedWidth * scale;\n        this.actualHeight = wantedHeight * scale;\n        this.offsetX = (this.width - this.actualWidth) / 2;\n        this.offsetY = (this.height - this.actualHeight) / 2;\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, _forced: boolean): void {\n        // Abort if icon isn't ready yet\n        if(!this._image?.complete) {\n            this.lastSrc = null;\n            return;\n        }\n\n        // Mark as not needing to be drawn by setting the source\n        this.lastSrc = this._image.src;\n\n        // Translate, rotate and clip if rotation is not 0\n        let tdx = this.x + this.offsetX, tdy = this.y + this.offsetY;\n        const rotated = this.rotation !== 0;\n        if(rotated) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n            ctx.translate(\n                this.x + this.offsetX + this.actualWidth / 2,\n                this.y + this.offsetY + this.actualHeight / 2,\n            );\n            tdx = -this.actualWidth / 2;\n            tdy = -this.actualHeight / 2;\n            ctx.rotate(this.rotation);\n        }\n\n        // Draw image, with viewBox if it is not null\n        if(this.viewBox === null) {\n            ctx.drawImage(\n                this._image,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n        else {\n            ctx.drawImage(\n                this._image, ...this.viewBox,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n\n        // Revert transformation\n        if(rotated)\n            ctx.restore();\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { Button } from './Button';\nimport { Margin } from './Margin';\nimport { Icon } from './Icon';\n\n/**\n * A {@link Button} with an {@link Icon} inside a {@link Margin}.\n *\n * @category Widget\n */\nexport class IconButton extends Button<Margin<Icon>> {\n    /** Create a new IconButton. */\n    constructor(image: HTMLImageElement, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(\n            new Margin(\n                new Icon(image, width, height, viewBox, themeProperties),\n            ),\n            callback, themeProperties\n        );\n    }\n\n    /** This button's Icon widget */\n    get icon(): Icon {\n        return this.child.child;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { Widget } from './Widget';\n\n/**\n * A widget with empty space.\n *\n * Will always try to expand if the layout is constrained, so make sure to set\n * flex or pass it along the constructor\n *\n * @category Widget\n */\nexport class Spacing extends Widget {\n    /** The minimum width this will try to expand */\n    minWidth: number;\n    /** The minimum height this will try to expand */\n    minHeight: number;\n\n    /** Create a new Spacing. */\n    constructor(flex = 1, minWidth = 0, minHeight = 0, themeProperties?: ThemeProperties) {\n        // Spacing needs clear, never has children and doesn't propagate events\n        super(true, false, themeProperties);\n\n        this.flex = flex;\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Try to expand each axis. If axis is not constrained (can't expand),\n        // then try to use the biggest minimum length\n        if(maxWidth !== Infinity)\n            this.width = maxWidth;\n        else\n            this.width = Math.max(minWidth, this.minWidth);\n\n        if(maxHeight !== Infinity)\n            this.height = maxHeight;\n        else\n            this.height = Math.max(minHeight, this.minHeight);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { VariableCallback } from '../helpers/Variable';\nimport type { TextGetter } from './Label';\nimport { Checkbox } from './Checkbox';\nimport { Spacing } from './Spacing';\nimport { Label } from './Label';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a {@link Checkbox}.\n *\n * @category Widget\n */\nexport class LabelledCheckbox extends Row {\n    constructor(text: string | TextGetter, callback: VariableCallback<boolean> | null = null, initialValue = false, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        this.add([\n            new Label(text, themeProperties),\n            new Spacing(1, 0, 0, themeProperties),\n            new Checkbox(callback, initialValue, themeProperties),\n        ]);\n    }\n}\n", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { layoutField } from '../decorators/FlagFields';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport { Viewport } from '../core/Viewport';\nimport type { Root } from '../core/Root';\nimport type { Widget } from './Widget';\n\n/**\n * A type of container widget which is allowed to be bigger or smaller than its\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * Allows setting the offset of the child, automatically clips it if neccessary.\n * Otherwise acts like a {@link Container}. Implemented by force re-painting the\n * child and clipping it or, optionally, by using a {@link Viewport} to paint\n * the child widget to a dedicated canvas.\n *\n * @category Widget\n */\nexport class ViewportWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** See {@link widthTied}. For internal use only */\n    private _widthTied: boolean;\n    /** See {@link heightTied}. For internal use only */\n    private _heightTied: boolean;\n    /**\n     * The minimum width that this widget will try to expand to.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minWidth: number;\n    /**\n     * The minimum height that this widget will try to expand to.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minHeight: number;\n    /** The actual viewport object, or null if the child is just clipped. */\n    private viewport: Viewport | null;\n    /** See {@link offset}. For internal use only */\n    private _offset: [number, number] = [0, 0];\n    /**\n     * Child constraints for resolving layout. May be different than\n     * {@link viewport}'s constraints. By default, this is 0 minimum and\n     * Infinity maximum per axis\n     */\n    private _constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n    /** Force child re-layout? Only used when not using a Viewport */\n    protected forceReLayout = true;\n    /** Force child re-paint? Only used when not using a Viewport */\n    protected forceRePaint = true;\n\n    /** Create a new ViewportWidget. */\n    constructor(child: W, minWidth = 0, minHeight = 0, widthTied = false, heightTied = false, useViewport = false, themeProperties?: ThemeProperties) {\n        // Viewport clears its own background, has a single child and propagates\n        // events\n        super(child, false, true, themeProperties);\n\n        this.viewport = useViewport ? new Viewport() : null;\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n        this._widthTied = widthTied;\n        this._heightTied = heightTied;\n        this._constraints = [0, Infinity, 0, Infinity];\n    }\n\n    /**\n     * Offset of {@link child}. Positional events will take this into account,\n     * as well as rendering. Useful for implementing scrolling.\n     */\n    get offset(): [number, number] {\n        return [...this._offset];\n    }\n\n    set offset(offset: [number, number]) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._offset[0] !== offset[0] || this._offset[1] !== offset[1]) {\n            this._offset[0] = offset[0];\n            this._offset[1] = offset[1];\n            this._dirty = true;\n            this.correctChildPosition();\n        }\n    }\n\n    /**\n     * Accessor for {@link _constraints}. If using a {@link Viewport}, its\n     * constraints are also updated, but may be different due to\n     * {@link widthTied} or {@link heightTied}.\n     */\n    set constraints(constraints: LayoutConstraints) {\n        // Not using @flagArrayField because this also needs to set the\n        // viewport's constraints if set, although @watchArrayField could be\n        // used (TODO?)\n        if (constraints[0] !== this._constraints[0] ||\n            constraints[1] !== this._constraints[1] ||\n            constraints[2] !== this._constraints[2] ||\n            constraints[3] !== this._constraints[3])\n        {\n            // Update own constraints\n            this._constraints[0] = constraints[0];\n            this._constraints[1] = constraints[1];\n            this._constraints[2] = constraints[2];\n            this._constraints[3] = constraints[3];\n\n            // Update viewport's constaints or flag force layout\n            if(this.viewport !== null)\n                this.viewport.constraints = constraints;\n            else\n                this.forceReLayout = true;\n        }\n    }\n\n    get constraints(): LayoutConstraints {\n        return [...this._constraints];\n    }\n\n    /**\n     * Is the width tied to the child's? If true, width constraints will be\n     * ignored.\n     */\n    get widthTied(): boolean {\n        return this._widthTied;\n    }\n\n    set widthTied(widthTied: boolean) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._widthTied !== widthTied) {\n            this._widthTied = widthTied;\n            this._layoutDirty = true;\n            this.forceReLayout = true;\n        }\n    }\n\n    /**\n     * Is the height tied to the child's? If true, height constraints will be\n     * ignored.\n     */\n    get heightTied(): boolean {\n        return this._heightTied;\n    }\n\n    set heightTied(heightTied: boolean) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._heightTied !== heightTied) {\n            this._heightTied = heightTied;\n            this._layoutDirty = true;\n            this.forceReLayout = true;\n        }\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'canvasFill')\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Ignore events with no position and no target\n        if(event.target === null && !(event instanceof PointerEvent))\n            return null;\n\n        // Drop event if it is a positional event with no target outside the\n        // child's viewport. Only correct position if using a Viewport\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const vpl = this.x + this.offset[0];\n        const vpr = vpl + innerWidth;\n        const vpt = this.y + this.offset[1];\n        const vpb = vpt + innerHeight;\n        if(event instanceof PointerEvent) {\n            if(event.target === null) {\n                if(event.x < vpl)\n                    return null;\n                if(event.x >= vpr)\n                    return null;\n                if(event.y < vpt)\n                    return null;\n                if(event.y >= vpb)\n                    return null;\n            }\n\n            if(this.viewport !== null)\n                event = event.correctOffset(vpl, vpt);\n        }\n\n        // Dispatch event to child\n        return this.child.dispatchEvent(event, root);\n    }\n\n    protected override handlePreLayoutUpdate(root: Root): void {\n        const child = this.child;\n\n        // Pre-layout update child\n        child.preLayoutUpdate(root);\n\n        // If child's layout is dirty and at least one of the axes are tied,\n        // propagate layout dirtiness. Try to resolve layout if no axis is tied.\n        const tied = this._widthTied || this._heightTied;\n        if(!tied) {\n            if(this.viewport !== null)\n                this.viewport.resolveChildsLayout(child);\n            else if(child.layoutDirty || this.forceReLayout) {\n                child.resolveDimensionsAsTop(...this._constraints);\n                this.correctChildPosition();\n            }\n        }\n        else if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        const child = this.child;\n        this.forceReLayout = false;\n\n        // Post-layout update child\n        child.postLayoutUpdate(root);\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        let normalWidth = true, normalHeight = true;\n        const effectiveMinWidth = Math.max(minWidth, this.minWidth);\n        const effectiveMinheight = Math.max(minHeight, this.minHeight);\n\n        if(this._widthTied || this._heightTied) {\n            // Resolve child's layout\n            const constraints: LayoutConstraints = [...this._constraints];\n\n            if(this._widthTied) {\n                constraints[0] = effectiveMinWidth;\n                constraints[1] = maxWidth;\n            }\n\n            if(this._heightTied) {\n                constraints[2] = effectiveMinheight;\n                constraints[3] = maxHeight;\n            }\n\n            const child = this.child;\n            if(this.viewport === null) {\n                child.resolveDimensionsAsTop(...constraints);\n                this.correctChildPosition();\n            }\n            else {\n                this.viewport.constraints = constraints;\n                this.viewport.resolveChildsLayout(child);\n            }\n\n            // Tie wanted axes. Do regular layout for non-tied axes.\n            if(this._widthTied) {\n                this.width = child.dimensions[0];\n                normalWidth = false;\n            }\n\n            if(this._heightTied) {\n                this.height = child.dimensions[1];\n                normalHeight = false;\n            }\n        }\n\n        // Expand to the needed dimensions\n        if(normalWidth)\n            this.width = Math.min(effectiveMinWidth, maxWidth);\n\n        if(normalHeight)\n            this.height = Math.min(effectiveMinheight, maxHeight);\n\n        if(this.width === 0 && this.minWidth === 0 && !this._widthTied)\n            console.warn('ViewportWidget has no minimum width and width isn\\'t tied, therefore, it may be dimensionless. Set a minimum width and/or tie the width');\n        if(this.height === 0 && this.minHeight === 0 && !this._heightTied)\n            console.warn('ViewportWidget has no minimum height and height isn\\'t tied, therefore, it may be dimensionless. Set a minimum height and/or tie the height');\n    }\n\n    protected override afterPositionResolved(): void {\n        this.correctChildPosition();\n\n        // If the viewport widget changes position, but the child doesn't, then\n        // previously clipped parts may become visible, so force repaint if not\n        // using a viewport\n        if(this.viewport === null)\n            this.forceRePaint = true;\n    }\n\n    private correctChildPosition(): void {\n        if(this.viewport !== null)\n            return;\n\n        // Correct child's position only if not using a Viewport\n        const [xOffset, yOffset] = this.offset;\n        this.child.resolvePosition(this.x + xOffset, this.y + yOffset);\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        // Paint child to viewport's canvas\n        if(this.viewport !== null)\n            this.viewport.paintToCanvas(this.child, forced);\n\n        // Calculate child's source and destination\n        const [vpX, vpY, vpW, vpH] = this.roundRect(this.x, this.y, this.width, this.height);\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const [xOffset, yOffset] = this.offset;\n\n        // viewport right and bottom\n        const vpR = vpX + vpW;\n        const vpB = vpY + vpH;\n\n        // original child destination left and top\n        const origXDst = this.x + xOffset;\n        const origYDst = this.y + yOffset;\n\n        // clipped child destination left, top, width and height\n        let xDst = Math.min(Math.max(origXDst, vpX), vpR);\n        let yDst = Math.min(Math.max(origYDst, vpY), vpB);\n        let wClipped = Math.min(Math.max(origXDst + innerWidth, vpX), vpR) - xDst;\n        let hClipped = Math.min(Math.max(origYDst + innerHeight, vpY), vpB) - yDst;\n        [xDst, yDst, wClipped, hClipped] = this.roundRect(xDst, yDst, wClipped, hClipped);\n\n        // Abort if outside of bounds\n        if(wClipped === 0 || hClipped === 0) {\n            if(this.viewport === null)\n                this.child.dryPaint();\n\n            this.forceRePaint = false;\n            return;\n        }\n\n        // child source left and top\n        const xSrc = xDst - origXDst;\n        const ySrc = yDst - origYDst;\n\n        // Clear background and paint canvas\n        this.clearStart(ctx);\n        ctx.rect(vpX, vpY, vpW, vpH);\n        ctx.clip();\n        if(this.viewport !== null) {\n            ctx.drawImage(\n                this.viewport.canvas,\n                xSrc,\n                ySrc,\n                wClipped,\n                hClipped,\n                xDst,\n                yDst,\n                wClipped,\n                hClipped,\n            );\n        }\n        ctx.rect(xDst, yDst, wClipped, hClipped);\n        this.clearEnd(ctx, 'evenodd');\n\n        if(this.viewport === null) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(xDst, yDst, wClipped, hClipped);\n            ctx.clip();\n            this.child.paint(ctx, forced || this.forceRePaint);\n            ctx.restore();\n        }\n\n        this.forceRePaint = false;\n    }\n}", "import { ClickHelper, ClickState } from '../helpers/ClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { ViewportWidget } from './ViewportWidget';\nimport type { Event } from '../events/Event';\nimport { Leave } from '../events/Leave';\nimport type { Widget } from './Widget';\nimport { Root } from '../core/Root';\n\n/**\n * The mode for how a scrollbar is shown in a {@link ScrollableViewportWidget}.\n *\n * @category Widget\n */\nexport enum ScrollbarMode {\n    /** The scrollbar is an overlay and therefore only shown when needed */\n    Overlay,\n    /** The scrollbar is part of the layout and therefore always shown */\n    Layout,\n}\n\n/**\n * A wrapper for a {@link ViewportWidget} with scrollbars.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ScrollableViewportWidget<W extends Widget = Widget> extends ViewportWidget<W> {\n    /** See {@link scrollbarMode}. For internal use only */\n    private _scrollbarMode: ScrollbarMode;\n    /**\n     * The effective viewport width, for scrollbar calculations. For internal\n     * use only.\n     */\n    private effectiveWidth = 0;\n    /**\n     * The effective viewport height, for scrollbar calculations. For internal\n     * use only.\n     */\n    private effectiveHeight = 0;\n    /**\n     * ClickHelper used for checking if the horizontal scrollbar has been\n     * dragged\n     */\n    private horizontalClickHelper: ClickHelper;\n    /**\n     * ClickHelper used for checking if the vertical scrollbar has been dragged\n     */\n    private verticalClickHelper: ClickHelper;\n    /** Is the vertical scrollbar being dragged? If null, none is */\n    private verticalDragged: boolean | null = null;\n    /** What was the starting scroll value before dragging? */\n    private startingScroll = 0;\n    /** What was the normalised offset when starting drag? */\n    private startingOffset = 0;\n    /** When was the last scroll attempt in milliseconds since Unix epoch? */\n    private lastScroll = 0;\n    /** Was the horizontal scrollbar painted last frame? */\n    private horizWasPainted = false;\n    /** Was the vertical scrollbar painted last frame? */\n    private vertWasPainted = false;\n\n    /**\n     * Create a new ScrollableViewportWidget.\n     *\n     * If an axis is tied, that axis will not have a scrollbar.\n     */\n    constructor(child: W, minWidth = 0, minHeight = 0, widthTied = false, heightTied = false, scrollbarMode = ScrollbarMode.Overlay, useViewport = false, themeProperties?: ThemeProperties) {\n        super(child, minWidth, minHeight, widthTied, heightTied, useViewport, themeProperties);\n\n        this._scrollbarMode = scrollbarMode;\n        this.horizontalClickHelper = new ClickHelper(this);\n        this.verticalClickHelper = new ClickHelper(this);\n    }\n\n    /** The mode for how the scrollbar is shown. */\n    get scrollbarMode(): ScrollbarMode {\n        return this._scrollbarMode;\n    }\n\n    set scrollbarMode(scrollbarMode: ScrollbarMode) {\n        if(this._scrollbarMode !== scrollbarMode) {\n            const oldScroll = this.scroll;\n            this._scrollbarMode = scrollbarMode;\n            this.scroll = oldScroll;\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Offset of {@link child}. Positional events will take this into account,\n     * as well as rendering. Unlike {@link ViewportWidget.offset}, this will\n     * clamp to possible scroll values to avoid issues.\n     */\n    override get offset(): [number, number] {\n        return super.offset;\n    }\n\n    override set offset(offset: [number, number]) {\n        const [childWidth, childHeight] = this.child.dimensions;\n\n        super.offset = [\n            -Math.max(Math.min(-offset[0], childWidth - this.effectiveWidth), 0),\n            -Math.max(Math.min(-offset[1], childHeight - this.effectiveHeight), 0),\n        ];\n    }\n\n    /**\n     * Is the width tied to the child's? If true, width constraints will be\n     * overridden.\n     */\n    override get widthTied(): boolean {\n        return super.widthTied;\n    }\n\n    override set widthTied(widthTied: boolean) {\n        const oldScroll = this.scroll;\n        super.widthTied = widthTied;\n        this.scroll = oldScroll;\n    }\n\n    /**\n     * Is the height tied to the child's? If true, height constraints will be\n     * overridden.\n     */\n    override get heightTied(): boolean {\n        return super.heightTied;\n    }\n\n    override set heightTied(heightTied: boolean) {\n        const oldScroll = this.scroll;\n        super.heightTied = heightTied;\n        this.scroll = oldScroll;\n    }\n\n    /**\n     * The current scroll values. Similar to {@link offset}, but with normalised\n     * values (from 0 to 1).\n     */\n    get scroll(): [number, number] {\n        const [offsetX, offsetY] = this.offset;\n        const [childWidth, childHeight] = this.child.dimensions;\n        const diffX = childWidth - this.effectiveWidth;\n        const diffY = childHeight - this.effectiveHeight;\n        return [\n            diffX === 0 ? 0 : Math.min(Math.max(-offsetX / diffX, 0), 1),\n            diffY === 0 ? 0 : Math.min(Math.max(-offsetY / diffY, 0), 1),\n        ];\n    }\n\n    set scroll(scroll: [number, number]) {\n        const [childWidth, childHeight] = this.child.dimensions;\n        this.offset = [\n            -scroll[0] * (childWidth - this.effectiveWidth),\n            -scroll[1] * (childHeight - this.effectiveHeight),\n        ];\n    }\n\n    /** Get the ClickHelper of a scrollbar */\n    private getClickHelper(vertical: boolean): ClickHelper {\n        if(vertical)\n            return this.verticalClickHelper;\n        else\n            return this.horizontalClickHelper;\n    }\n\n    /** Handle a pointer/leave event for a given scrollbar */\n    private handleEventScrollbar(vertical: boolean, corner: boolean, event: Event, root: Root): boolean {\n        // Abort if the other scrollbar is being dragged\n        if(this.verticalDragged !== null && this.verticalDragged !== vertical)\n            return false;\n\n        // Get click area of scrollbar. If in overlay mode, use the filled part\n        // of the scrollbar as the click area since there is no background\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const clickRect = overlay ? fillRect : bgRect;\n        const clickArea: [number, number, number, number] = [\n            clickRect[0],\n            clickRect[0] + clickRect[2],\n            clickRect[1],\n            clickRect[1] + clickRect[3],\n        ];\n\n        // Handle click event\n        const clickHelper = this.getClickHelper(vertical);\n        clickHelper.handleClickEvent(event, root, clickArea);\n\n        const clickState = clickHelper.clickState;\n        const stateChanged = clickHelper.clickStateChanged;\n        if(stateChanged)\n            this._dirty = true;\n\n        if(clickState === ClickState.Hold) {\n            // Abort if state is not valid, but grab the event\n            if(clickHelper.pointerPos === null || !(event instanceof PointerEvent))\n                return true;\n\n            const axisIndex = vertical ? 1 : 0;\n            const scroll = this.scroll;\n\n            // Skip check if in overlay mode; can only scroll by dragging in\n            // this mode\n            let inFilledArea = overlay;\n            if(!inFilledArea) {\n                inFilledArea = clickHelper.isPointInRect(\n                    event.x,\n                    event.y,\n                    fillRect[0],\n                    fillRect[0] + fillRect[2],\n                    fillRect[1],\n                    fillRect[1] + fillRect[3],\n                );\n            }\n\n            // Find offset along scrollbar. Necessary for overlay mode since\n            // pointerPos is relative to the fillRect in that case, not bgRect\n            let thisOffset;\n            if(overlay) {\n                thisOffset = clickHelper.getNormalInRect(\n                    event.x,\n                    event.y,\n                    bgRect[0],\n                    bgRect[0] + bgRect[2],\n                    bgRect[1],\n                    bgRect[1] + bgRect[3],\n                )[axisIndex];\n            }\n            else\n                thisOffset = clickHelper.pointerPos[axisIndex];\n\n            if(stateChanged) {\n                // If this was outside the filled area, snap scrollbar\n                if(!inFilledArea) {\n                    const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                    const childLength = this.child.dimensions[axisIndex];\n                    const barLength = viewportLength / childLength;\n                    scroll[axisIndex] = (thisOffset - barLength / 2) / (1 - barLength);\n                    this.scroll = scroll;\n                }\n\n                // Drag start, save current scroll and set this scrollbar as\n                // being dragged\n                this.startingOffset = thisOffset;\n                this.startingScroll = scroll[axisIndex];\n                this.verticalDragged = vertical;\n            }\n            else {\n                // Drag continue, scroll\n                const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                const childLength = this.child.dimensions[axisIndex];\n                const barLength = viewportLength / childLength;\n                const dragDiff = thisOffset - this.startingOffset;\n                scroll[axisIndex] = this.startingScroll + dragDiff / (1 - barLength);\n                this.scroll = scroll;\n            }\n\n            return true;\n        }\n        else if(clickState === ClickState.Hover)\n            return true;\n        else if(stateChanged) {\n            // Release this scrollbar\n            this.verticalDragged = null;\n            return true;\n        }\n\n        return false;\n    }\n\n    /** Clamp offset in-place to valid scroll values. For internal use only. */\n    private clampOffset(offset: [number, number]): void {\n        const [childWidth, childHeight] = this.child.dimensions;\n\n        const minX = -(childWidth - this.effectiveWidth);\n        if(minX >= 0)\n            offset[0] = 0;\n        else if(offset[0] < minX)\n            offset[0] = minX;\n\n        const minY = -(childHeight - this.effectiveHeight);\n        if(minY >= 0)\n            offset[1] = 0;\n        else if(offset[1] < minY)\n            offset[1] = minY;\n    }\n\n    /**\n     * Handle a wheel scroll event. If scrolling fails due to being at the\n     * limit, this returns true if the last scroll attempt happened less than\n     * 200 milliseconds ago. This behaviour is disabled if\n     * {@link PointerWheel.fromDrag} is true.\n     *\n     * @returns Returns true if this changed scroll was successful\n     */\n    private handleWheelEvent(event: PointerWheel): boolean {\n        const offset = this.offset;\n        const [oldX, oldY] = offset;\n        offset[0] -= event.shift ? event.deltaY : event.deltaX;\n        offset[1] -= event.shift ? event.deltaX : event.deltaY;\n        this.clampOffset(offset);\n        this.offset = offset;\n        const [newX, newY] = this.offset;\n\n        const success = newX !== oldX || newY !== oldY;\n        const last = this.lastScroll;\n        const now = (new Date()).getTime();\n        this.lastScroll = now;\n\n        if(success)\n            return true;\n\n        if(event.fromDrag)\n            return false;\n\n        const elapsed = now - last;\n        return elapsed < 200;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === 'scrollBarThickness')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundFill' ||\n                property === 'scrollBarMinPercent' ||\n                property === 'scrollBarMinPixels' ||\n                property === 'primaryFill' ||\n                property === 'accentFill' ||\n                property === 'backgroundGlowFill')\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): Widget | null {\n        // Try to drag a scrollbar if this is a pointer or leave event with no\n        // target or target on this\n        if((event instanceof Leave || event instanceof PointerEvent) &&\n           (event.target === null || event.target === this)) {\n            const [childWidth, childHeight] = this.child.dimensions;\n            const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n            const forceCorner = !overlay && (!this.widthTied && !this.heightTied);\n            const xNeeded = childWidth > this.width;\n            const yNeeded = childHeight > this.height;\n\n            let grabbedEvent = false;\n\n            // Only handle event in scrollbar if the scrollbar is shown and\n            // needed (layout mode shows unneeded scrollbars)\n            if(!this.widthTied && (xNeeded || !overlay) &&\n               this.handleEventScrollbar(false, yNeeded || forceCorner, event, root))\n                grabbedEvent = true;\n\n            if(!this.heightTied && (yNeeded || !overlay) &&\n               this.handleEventScrollbar(true, xNeeded || forceCorner, event, root))\n                grabbedEvent = true;\n\n            // If the event was grabbed by either scrollbar, capture it\n            if(grabbedEvent) {\n                // If this is a wheel event, handle it\n                if(event instanceof PointerWheel)\n                    this.handleWheelEvent(event);\n\n                return this;\n            }\n        }\n\n        // Pass event along\n        const capturer = super.handleEvent(event, root);\n\n        // If this is a wheel event and nobody captured the event, try\n        // scrolling. If scrolling did indeed occur, then capture the event.\n        if(capturer === null && event instanceof PointerWheel && this.handleWheelEvent(event))\n            return this;\n\n        return capturer;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Check whether to reserve space or not\n        const thickness = this.scrollBarThickness;\n        const reserve = this._scrollbarMode === ScrollbarMode.Layout;\n        const reserveX = reserve && !this.heightTied;\n        const reserveY = reserve && !this.widthTied;\n\n        // If reserving space, further constrain dimensions\n        let rMinWidth, rMaxWidth, rMinHeight, rMaxHeight;\n        if(reserveX) {\n            rMaxWidth = Math.max(maxWidth - thickness, 0);\n            rMinWidth = Math.min(minWidth, rMaxWidth);\n        }\n        else {\n            rMaxWidth = maxWidth;\n            rMinWidth = minWidth;\n        }\n\n        if(reserveY) {\n            rMaxHeight = Math.max(maxHeight - thickness, 0);\n            rMinHeight = Math.min(minHeight, rMaxHeight);\n        }\n        else {\n            rMaxHeight = maxHeight;\n            rMinHeight = minHeight;\n        }\n\n        // Resolve dimensions\n        super.handleResolveDimensions(rMinWidth, rMaxWidth, rMinHeight, rMaxHeight);\n\n        // Save dimensions to effective dimensions\n        this.effectiveWidth = this.width;\n        this.effectiveHeight = this.height;\n\n        // Expand dimensions to fit scrollbars\n        if(reserveX)\n            this.width = Math.min(Math.max(this.width + thickness, minWidth), maxWidth);\n\n        if(reserveY)\n            this.height = Math.min(Math.max(this.height + thickness, minHeight), maxHeight);\n    }\n\n    protected override handlePostLayoutUpdate(root: Root): void {\n        super.handlePostLayoutUpdate(root);\n\n        // Keep scroll in bounds\n        const offset = this.offset;\n        this.clampOffset(offset);\n        this.offset = offset;\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, forced: boolean): void {\n        // Check which scrollbars need painting and update forceRePaint flag\n        const [childWidth, childHeight] = this.child.dimensions;\n        const xNeeded = childWidth > this.width;\n        const yNeeded = childHeight > this.height;\n        const paintX = this.scrollbarNeedsPaint(false, xNeeded);\n        const paintY = this.scrollbarNeedsPaint(true, yNeeded);\n\n        if(this.horizWasPainted !== paintX || this.vertWasPainted !== paintY) {\n            this.horizWasPainted = paintX;\n            this.vertWasPainted = paintY;\n            this.forceRePaint = true;\n        }\n\n        // Paint viewport\n        super.handlePainting(ctx, forced);\n\n        // Paint scrollbars\n        const forceCorner = this._scrollbarMode === ScrollbarMode.Layout &&\n                            (!this.widthTied && !this.heightTied);\n\n        if(paintX)\n            this.paintScrollbar(false, xNeeded, yNeeded || forceCorner, ctx);\n        if(paintY)\n            this.paintScrollbar(true, yNeeded, xNeeded || forceCorner, ctx);\n\n        // Paint corner if it is forced\n        if(forceCorner) {\n            const thickness = this.scrollBarThickness;\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(\n                this.x + this.width - thickness,\n                this.y + this.height - thickness,\n                thickness,\n                thickness,\n            );\n        }\n    }\n\n    /**\n     * Get the rectangles (filled and background) of a scrollbar\n     *\n     * @returns Returns a 2-tuple with 2 4-tuples. The first one is the scrollbar fill rectangle and the second one is the background fill rectangle. Each rectangle 4-tuple contains, respectively, horizontal offset, vertical offset, width and height\n     */\n    private getScrollbarRects(vertical: boolean, corner: boolean): [[number, number, number, number], [number, number, number, number]] {\n        // Calculate basic scrollbar properties\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const axisIndex = vertical ? 1 : 0;\n        const percent = this.scroll[axisIndex];\n        const childLength = this.child.dimensions[axisIndex];\n        const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n        const thickness = this.scrollBarThickness;\n        const minPercent = this.scrollBarMinPercent;\n        const minPixels = this.scrollBarMinPixels;\n\n        let viewportLengthCorner = viewportLength;\n        if(overlay)\n            viewportLengthCorner -= (corner ? thickness : 0);\n\n        const length = Math.min(\n            // Make sure scrollbar fill isn't bigger than viewport\n            Math.max(\n                // Make sure that scrollbar respects the minimum pixel length\n                minPixels,\n                Math.max(\n                    // Make sure that scrollbar respects the minimum percent\n                    viewportLength / childLength,\n                    minPercent,\n                ) * viewportLengthCorner,\n            ),\n            viewportLengthCorner,\n        );\n\n        const offset = (viewportLengthCorner - length) * percent;\n\n        // Find rectangle where filled part of scrollbar will be painted\n        let sX, sY, sWidth, sHeight;\n        if(vertical) {\n            sX = this.x + this.width - thickness;\n            sY = this.y + offset;\n            sWidth = thickness;\n            sHeight = length;\n        }\n        else {\n            sX = this.x + offset;\n            sY = this.y + this.height - thickness;\n            sWidth = length;\n            sHeight = thickness;\n        }\n\n        // Find rectangle where background of scrollbar will be painted\n        let bgX, bgY, bgWidth, bgHeight;\n        if(vertical) {\n            bgX = sX;\n            bgY = this.y;\n            bgWidth = thickness;\n            bgHeight = viewportLengthCorner;\n        }\n        else {\n            bgX = this.x;\n            bgY = sY;\n            bgWidth = viewportLengthCorner;\n            bgHeight = thickness;\n        }\n\n        return [\n            [sX, sY, sWidth, sHeight],\n            [bgX, bgY, bgWidth, bgHeight],\n        ];\n    }\n\n    /** Check if a scrollbar needs to be painted */\n    private scrollbarNeedsPaint(vertical: boolean, needed: boolean): boolean {\n        if(!needed && this._scrollbarMode === ScrollbarMode.Overlay)\n            return false;\n\n        return !(vertical ? this.heightTied : this.widthTied);\n    }\n\n    /** Paint a scrollbar. For internal use only */\n    private paintScrollbar(vertical: boolean, needed: boolean, corner: boolean, ctx: CanvasRenderingContext2D): void {\n        // Get rectangles\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n\n        // Paint background if not in overlay mode\n        if(this._scrollbarMode !== ScrollbarMode.Overlay) {\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(...bgRect);\n        }\n\n        // Paint filled part of scrollbar\n        if(needed) {\n            const clickHelper = this.getClickHelper(vertical);\n            switch(clickHelper.clickState) {\n                case ClickState.Released:\n                    ctx.fillStyle = this.primaryFill;\n                    break;\n                case ClickState.Hover:\n                case ClickState.Hold:\n                    ctx.fillStyle = this.accentFill;\n                    break;\n            }\n        }\n        else\n            ctx.fillStyle = this.backgroundGlowFill;\n\n        ctx.fillRect(...fillRect);\n    }\n}", "import { Variable, VariableCallback } from '../helpers/Variable';\nimport { ClickHelper, ClickState } from '../helpers/ClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerWheel } from '../events/PointerWheel';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A slider flexbox widget; can slide a numeric value from an inclusive minimum\n * value to an inclusive maximum value, with optional snapping along set\n * increments.\n *\n * Note that sliders can only be horizontal.\n *\n * @category Widget\n */\nexport class Slider extends Widget {\n    /** The slider's minimum value. */\n    private minValue: number;\n    /** The slider's maximum value. */\n    private maxValue: number;\n    /**\n     * The increments in which the slider changes value. If 0, there are no\n     * fixed increments.\n     */\n    private snapIncrement: number;\n    /** The helper for handling pointer clicks/drags */\n    protected clickHelper: ClickHelper;\n    /** The helper for keeping track of the slider's value */\n    protected variable: Variable<number>;\n    /** Is this a vertical slider? */\n    protected readonly vertical: boolean;\n    /** The horizontal offset of the slider */\n    private offsetX = 0;\n    /** The vertical offset of the slider */\n    private offsetY = 0;\n    /** The actual width of the slider */\n    private actualWidth = 0;\n    /** The actual height of the slider */\n    private actualHeight = 0;\n\n    /** Create a new Slider */\n    constructor(callback: VariableCallback<number> | null = null, minValue = 0, maxValue = 1, snapIncrement = 0, initialValue = 0, vertical = false, themeProperties?: ThemeProperties) {\n        // Sliders need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        if(maxValue < minValue)\n            throw new Error('Slider max value can\\'t be smaller than minimum value');\n\n        this.clickHelper = new ClickHelper(this);\n        this.variable = new Variable(Math.max(initialValue, minValue), callback);\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n        this.snapIncrement = snapIncrement;\n        this.vertical = vertical;\n    }\n\n    /** The slider's value */\n    set value(value: number) {\n        this.setValue(value);\n    }\n\n    get value(): number {\n        return this.variable.value;\n    }\n\n    /** Set the slider's value, optionally disabling callback */\n    setValue(value: number, doCallback = true): void {\n        // Snap to increments if needed\n        if(this.snapIncrement > 0)\n            value = Math.round(value / this.snapIncrement) * this.snapIncrement;\n\n        // Clamp value\n        if(value < this.minValue)\n            value = this.minValue;\n        else if(value > this.maxValue)\n            value = this.maxValue;\n\n        // Update value in variable\n        this.variable.setValue(value, doCallback);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'sliderThickness' ||\n                property === 'sliderMinLength')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'backgroundFill')\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event, root: Root): this | null {\n        // Ignore wheel events\n        if(event instanceof PointerWheel)\n            return null;\n\n        // Handle click event\n        const x = this.x + this.offsetX;\n        const y = this.y + this.offsetY;\n        this.clickHelper.handleClickEvent(event, root, [\n            x, x + this.actualWidth, y, y + this.actualHeight,\n        ]);\n\n        // If this was a click or the slider is currently being held, update\n        // value\n        if(((this.clickHelper.clickStateChanged && this.clickHelper.wasClick) || this.clickHelper.clickState == ClickState.Hold)\n            && this.clickHelper.pointerPos !== null) {\n            // Interpolate value\n            const percent = this.clickHelper.pointerPos[0];\n            this.value = this.minValue + percent * (this.maxValue - this.minValue);\n        }\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect)\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return this;\n    }\n\n    protected override handlePostLayoutUpdate(_root: Root): void {\n        // Mark as dirty if variable is dirty\n        if(this.variable.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get theme properties\n        const thickness = this.sliderThickness;\n        const minLength = this.sliderMinLength;\n\n        // Fully expand along main axis if constrained and center along cross\n        // axis\n        if(this.vertical) {\n            // Main axis\n            if(maxHeight != Infinity)\n                this.height = maxHeight;\n            else\n                this.height = Math.max(minLength, minHeight);\n\n            this.actualHeight = this.height;\n            this.offsetY = 0;\n\n            // Cross axis\n            this.width = Math.min(Math.max(thickness, minWidth), maxWidth);\n\n            this.actualWidth = Math.min(this.width, thickness);\n            this.offsetX = (this.width - this.actualWidth) / 2;\n        }\n        else {\n            // Main axis\n            if(maxWidth != Infinity)\n                this.width = maxWidth;\n            else\n                this.width = Math.max(minLength, minWidth);\n\n            this.actualWidth = this.width;\n            this.offsetY = 0;\n\n            // Cross axis\n            this.height = Math.min(Math.max(thickness, minHeight), maxHeight);\n\n            this.actualHeight = Math.min(this.height, thickness);\n            this.offsetX = (this.height - this.actualHeight) / 2;\n        }\n    }\n\n    protected override handlePainting(ctx: CanvasRenderingContext2D, _forced: boolean): void {\n        // Correct position with offset\n        const x = this.x + this.offsetX;\n        const y = this.y + this.offsetY;\n\n        // Draw filled part of slider. Use accent colour if hovering or holding\n        if(this.clickHelper.clickState === ClickState.Hover || this.clickHelper.clickState === ClickState.Hold)\n            ctx.fillStyle = this.accentFill;\n        else\n            ctx.fillStyle = this.primaryFill;\n        const fullWidth = this.actualWidth * (this.value - this.minValue) / (this.maxValue - this.minValue);\n        ctx.fillRect(x, y, fullWidth, this.actualHeight);\n\n        // Draw empty part of slider\n        ctx.fillStyle = this.backgroundFill;\n        const emptyWidth = this.actualWidth - fullWidth;\n        ctx.fillRect(x + fullWidth, y, emptyWidth, this.actualHeight);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\n\n/**\n * A {@link Margin} which stretches on the vertical axis. Useful for\n * horizontally centering labels without making them look weird if they are in\n * a row.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class TextMargin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new TextMargin. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Stretch,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import { PassthroughWidget } from './PassthroughWidget';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which changes the theme of its child and\n * completely ignores inherited themes.\n *\n * Can be constrained to a specific type of children.\n *\n * Since the new theme replaces the inherited theme, children of the child will\n * also inherit this theme since inherited themes are propagated down the widget\n * tree.\n *\n * @category Widget\n */\nexport class ThemeScope<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** The theme used for the child. */\n    private scopeTheme: Theme;\n\n    /** Create a new ThemeScope. */\n    constructor(child: W, themeOverride: Theme) {\n        super(child);\n        this.scopeTheme = themeOverride;\n    }\n\n    override set inheritedTheme(_theme: Theme | undefined) {\n        super.inheritedTheme = this.scopeTheme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.scopeTheme;\n    }\n}"],
  "mappings": "kuBAUO,YAAiC,EAAuC,CAC3E,MAAO,IAAI,SAAQ,CAAC,EAAQ,IAAY,CACpC,YAAsB,CAElB,SAAS,KAAK,YAAY,GAC1B,SAAS,KAAK,YAAY,GAG9B,YAAyB,CAErB,IACA,EAAO,GAGX,YAAqB,CAEjB,IACA,EAAO,EAAO,OAGlB,WAAsB,EAAsB,CAExC,AAAG,EAAM,KAAO,SACZ,GAAM,iBACN,KAKR,GAAM,GAAc,SAAS,cAAc,OAC3C,EAAY,GAAK,0BAGjB,GAAM,GAAgB,SAAS,cAAc,OAC7C,EAAc,GAAK,mBAGnB,GAAM,GAAW,SAAS,cAAc,KACxC,EAAS,YAAc,eAGvB,GAAM,GAAS,SAAS,cAAc,SACtC,EAAO,iBAAiB,QAAS,GACjC,EAAO,MAAQ,EAGf,GAAM,GAAgB,SAAS,cAAc,OAGvC,EAAmB,SAAS,cAAc,UAChD,EAAiB,iBAAiB,QAAS,GAC3C,EAAiB,YAAc,SAG/B,GAAM,GAAe,SAAS,cAAc,UAC5C,EAAa,iBAAiB,QAAS,GACvC,EAAa,YAAc,KAG3B,EAAc,YAAY,GAC1B,EAAc,YAAY,GAG1B,EAAc,YAAY,GAC1B,EAAc,YAAY,GAC1B,EAAc,YAAY,GAG1B,SAAS,KAAK,YAAY,GAC1B,SAAS,KAAK,YAAY,GAG1B,EAAO,MAAM,CAAE,cAAe,OC5E/B,GAAK,GAAL,UAAK,EAAL,CAEH,YAAU,GAAV,UAEA,aAAW,GAAX,aAJQ,WCGL,WAAqB,CAcxB,YAAY,EAAuB,EAA6B,EAAqB,CACjF,KAAK,OAAS,EACd,KAAK,UAAY,EACjB,KAAK,WAAa,ICfnB,mBAA6B,EAAM,CAKtC,YAAY,EAAc,EAAwB,KAAM,CACpD,MAAM,EAAQ,EAAU,SAAU,IAClC,KAAK,KAAO,EAGhB,gBAAgB,EAAuC,CACnD,MAAO,IAAI,GAAe,KAAK,KAAM,KCftC,GAAW,GAAX,UAAW,EAAX,CAEH,eAAe,UAEf,cAAc,SAKd,UAAQ,GAAR,QAMA,WAAS,IAAT,SAKA,QAAM,GAAN,QApBc,WCDX,GAAW,GAAX,UAAW,EAAX,CAEH,UAAU,UAKV,UAAQ,GAAR,QAMA,WAAS,IAAT,SAKA,QAAM,GAAN,QAlBc,WCSX,YAA2C,CA0C9C,YAAY,EAA8B,EAAuB,CAtCzD,cAAuD,KAyC3D,AAFA,KAAK,eAAiB,EAEnB,MAAO,IAAe,aAIzB,MAAK,YAAc,EAAW,WAC9B,KAAK,kBAAoB,EAAW,iBACpC,KAAK,oBAAsB,EAAW,mBACtC,KAAK,uBAAyB,EAAW,sBACzC,KAAK,yBAA2B,EAAW,wBAC3C,KAAK,aAAe,EAAW,YAC/B,KAAK,YAAc,EAAW,WAC9B,KAAK,gBAAkB,EAAW,eAClC,KAAK,oBAAsB,EAAW,mBACtC,KAAK,iBAAmB,EAAW,gBACnC,KAAK,iBAAmB,EAAW,gBACnC,KAAK,cAAgB,EAAW,aAChC,KAAK,cAAgB,EAAW,aAChC,KAAK,gBAAkB,EAAW,eAClC,KAAK,iBAAmB,EAAW,gBACnC,KAAK,gBAAkB,EAAW,eAClC,KAAK,sBAAwB,EAAW,qBACxC,KAAK,qBAAuB,EAAW,oBACvC,KAAK,2BAA6B,EAAW,0BAC7C,KAAK,eAAiB,EAAW,cACjC,KAAK,eAAiB,EAAW,cACjC,KAAK,uBAAyB,EAAW,sBACzC,KAAK,sBAAwB,EAAW,qBACxC,KAAK,iBAAmB,EAAW,gBACnC,KAAK,kBAAoB,EAAW,iBACpC,KAAK,uBAAyB,EAAW,sBACzC,KAAK,mBAAqB,EAAW,kBACrC,KAAK,WAAa,EAAW,UAC7B,KAAK,iBAAmB,EAAW,gBACnC,KAAK,oBAAsB,EAAW,mBACtC,KAAK,qBAAuB,EAAW,oBACvC,KAAK,oBAAsB,EAAW,uBArE5B,gBAAmC,CAC7C,MAAO,MAAK,kBAGF,eAAc,EAA6B,CACrD,GAAG,KAAK,iBAAmB,EACvB,OAGJ,GAAM,GAAW,KAAK,eACtB,AAAG,MAAO,IAAa,aAAe,KAAK,WAAa,MACpD,EAAS,YAAY,KAAK,UAG3B,MAAO,IAAa,aACnB,MAAK,SAAW,AAAC,GAA4B,KAAK,eAAe,GACjE,EAAS,UAAU,KAAK,WAI5B,KAAK,eAAiB,EAGtB,KAAK,iBAKC,eAAe,EAA2B,KAAY,KAiD5D,aAAwB,CAvGhC,UAwGQ,MAAO,WAAK,cAAL,OAAoB,QAAK,iBAAL,cAAqB,aAAzC,OAAuD,qBAG9D,YAAW,EAA8B,CACzC,AAAG,KAAK,cAAgB,GACpB,MAAK,YAAc,EACnB,KAAK,eAAe,kBAOxB,mBAA4B,CArHpC,UAsHQ,MAAO,WAAK,oBAAL,OAA0B,QAAK,iBAAL,cAAqB,mBAA/C,OAA4E,CAAC,KAAM,EAAG,MAAO,EAAG,IAAK,EAAG,OAAQ,MAGvH,kBAAiB,EAA4B,CAC7C,AAAG,KAAK,oBAAsB,GAC1B,MAAK,kBAAoB,EACzB,KAAK,eAAe,wBAOxB,qBAAkC,CAnI1C,UAoIQ,MAAO,WAAK,sBAAL,OAA4B,QAAK,iBAAL,cAAqB,qBAAjD,OAAoF,CAAC,WAAY,EAAU,MAAO,SAAU,EAAU,UAG7I,oBAAmB,EAAgC,CACnD,AAAG,KAAK,sBAAwB,GAC5B,MAAK,oBAAsB,EAC3B,KAAK,eAAe,0BAOxB,wBAAgC,CAjJxC,UAkJQ,MAAO,WAAK,yBAAL,OAA+B,QAAK,iBAAL,cAAqB,wBAApD,OAA6E,KAGpF,uBAAsB,EAA2B,CACjD,AAAG,KAAK,yBAA2B,GAC/B,MAAK,uBAAyB,EAC9B,KAAK,eAAe,6BAOxB,0BAA2C,CA/JnD,UAgKQ,MAAO,WAAK,2BAAL,OAAiC,QAAK,iBAAL,cAAqB,0BAAtD,OAAkG,CAAC,KAAM,EAAc,aAAc,MAAO,EAAU,YAG7J,yBAAwB,EAAoC,CAC5D,AAAG,KAAK,2BAA6B,GACjC,MAAK,yBAA2B,EAChC,KAAK,eAAe,+BAOxB,cAAyB,CA7KjC,UA8KQ,MAAO,WAAK,eAAL,OAAqB,QAAK,iBAAL,cAAqB,cAA1C,OAAyD,oBAGhE,aAAY,EAA8B,CAC1C,AAAG,KAAK,eAAiB,GACrB,MAAK,aAAe,EACpB,KAAK,eAAe,mBAOxB,aAAwB,CA3LhC,UA4LQ,MAAO,WAAK,cAAL,OAAoB,QAAK,iBAAL,cAAqB,aAAzC,OAAuD,oBAG9D,YAAW,EAA8B,CACzC,AAAG,KAAK,cAAgB,GACpB,MAAK,YAAc,EACnB,KAAK,eAAe,kBAOxB,iBAA4B,CAzMpC,UA0MQ,MAAO,WAAK,kBAAL,OAAwB,QAAK,iBAAL,cAAqB,iBAA7C,OAA+D,mBAGtE,gBAAe,EAA8B,CAC7C,AAAG,KAAK,kBAAoB,GACxB,MAAK,gBAAkB,EACvB,KAAK,eAAe,sBAOxB,qBAAgC,CAvNxC,UAwNQ,MAAO,WAAK,sBAAL,OAA4B,QAAK,iBAAL,cAAqB,qBAAjD,OAAuE,mBAG9E,oBAAmB,EAA8B,CACjD,AAAG,KAAK,sBAAwB,GAC5B,MAAK,oBAAsB,EAC3B,KAAK,eAAe,0BAOxB,kBAA0B,CArOlC,UAsOQ,MAAO,WAAK,mBAAL,OAAyB,QAAK,iBAAL,cAAqB,kBAA9C,OAAiE,OAGxE,iBAAgB,EAA2B,CAC3C,AAAG,KAAK,mBAAqB,GACzB,MAAK,iBAAmB,EACxB,KAAK,eAAe,uBAOxB,kBAA0B,CAnPlC,UAoPQ,MAAO,WAAK,mBAAL,OAAyB,QAAK,iBAAL,cAAqB,kBAA9C,OAAiE,MAGxE,iBAAgB,EAA2B,CAC3C,AAAG,KAAK,mBAAqB,GACzB,MAAK,iBAAmB,EACxB,KAAK,eAAe,uBAOxB,eAAuB,CAjQ/B,UAkQQ,MAAO,WAAK,gBAAL,OAAsB,QAAK,iBAAL,cAAqB,eAA3C,OAA2D,eAGlE,cAAa,EAA2B,CACxC,AAAG,KAAK,gBAAkB,GACtB,MAAK,cAAgB,EACrB,KAAK,eAAe,oBAOxB,eAA0B,CA/QlC,UAgRQ,MAAO,WAAK,gBAAL,OAAsB,QAAK,iBAAL,cAAqB,eAA3C,OAA2D,WAGlE,cAAa,EAA8B,CAC3C,AAAG,KAAK,gBAAkB,GACtB,MAAK,cAAgB,EACrB,KAAK,eAAe,oBAOxB,iBAAgC,CA7RxC,UA8RQ,MAAO,WAAK,kBAAL,OAAwB,QAAK,iBAAL,cAAqB,iBAA7C,OAA+D,QAGtE,gBAAe,EAAkC,CACjD,AAAG,KAAK,kBAAoB,GACxB,MAAK,gBAAkB,EACvB,KAAK,eAAe,sBAOxB,kBAAiC,CA3SzC,UA4SQ,MAAO,WAAK,mBAAL,OAAyB,QAAK,iBAAL,cAAqB,kBAA9C,OAAiE,QAGxE,iBAAgB,EAAkC,CAClD,AAAG,KAAK,mBAAqB,GACzB,MAAK,iBAAmB,EACxB,KAAK,eAAe,uBAOxB,iBAAyB,CAzTjC,UA0TQ,MAAO,WAAK,kBAAL,OAAwB,QAAK,iBAAL,cAAqB,iBAA7C,OAA+D,MAGtE,gBAAe,EAA2B,CAC1C,AAAG,KAAK,kBAAoB,GACxB,MAAK,gBAAkB,EACvB,KAAK,eAAe,sBAOxB,uBAA+B,CAvUvC,UAwUQ,MAAO,WAAK,wBAAL,OAA8B,QAAK,iBAAL,cAAqB,uBAAnD,OAA2E,KAGlF,sBAAqB,EAA2B,CAChD,AAAG,KAAK,wBAA0B,GAC9B,MAAK,sBAAwB,EAC7B,KAAK,eAAe,4BAOxB,sBAAiC,CArVzC,UAsVQ,MAAO,WAAK,uBAAL,OAA6B,QAAK,iBAAL,cAAqB,sBAAlD,OAAyE,WAGhF,qBAAoB,EAA8B,CAClD,AAAG,KAAK,uBAAyB,GAC7B,MAAK,qBAAuB,EAC5B,KAAK,eAAe,2BAOxB,4BAAuC,CAnW/C,UAoWQ,MAAO,WAAK,6BAAL,OAAmC,QAAK,iBAAL,cAAqB,4BAAxD,OAAqF,oBAG5F,2BAA0B,EAA8B,CACxD,AAAG,KAAK,6BAA+B,GACnC,MAAK,2BAA6B,EAClC,KAAK,eAAe,iCAOxB,gBAAwB,CAjXhC,UAkXQ,MAAO,WAAK,iBAAL,OAAuB,QAAK,iBAAL,cAAqB,gBAA5C,OAA6D,eAGpE,eAAc,EAA2B,CACzC,AAAG,KAAK,iBAAmB,GACvB,MAAK,eAAiB,EACtB,KAAK,eAAe,qBAOxB,gBAA2B,CA/XnC,UAgYQ,MAAO,WAAK,iBAAL,OAAuB,QAAK,iBAAL,cAAqB,gBAA5C,OAA6D,WAGpE,eAAc,EAA8B,CAC5C,AAAG,KAAK,iBAAmB,GACvB,MAAK,eAAiB,EACtB,KAAK,eAAe,qBAOxB,wBAAmC,CA7Y3C,UA8YQ,MAAO,WAAK,yBAAL,OAA+B,QAAK,iBAAL,cAAqB,wBAApD,OAA6E,UAGpF,uBAAsB,EAA8B,CACpD,AAAG,KAAK,yBAA2B,GAC/B,MAAK,uBAAyB,EAC9B,KAAK,eAAe,6BAOxB,uBAAkC,CA3Z1C,UA4ZQ,MAAO,WAAK,wBAAL,OAA8B,QAAK,iBAAL,cAAqB,uBAAnD,OAA2E,SAGlF,sBAAqB,EAA8B,CACnD,AAAG,KAAK,wBAA0B,GAC9B,MAAK,sBAAwB,EAC7B,KAAK,eAAe,4BAOxB,kBAAiC,CAzazC,UA0aQ,MAAO,WAAK,mBAAL,OAAyB,QAAK,iBAAL,cAAqB,kBAA9C,OAAiE,QAGxE,iBAAgB,EAAkC,CAClD,AAAG,KAAK,mBAAqB,GACzB,MAAK,iBAAmB,EACxB,KAAK,eAAe,uBAOxB,mBAAkC,CAvb1C,UAwbQ,MAAO,WAAK,oBAAL,OAA0B,QAAK,iBAAL,cAAqB,mBAA/C,OAAmE,QAG1E,kBAAiB,EAAkC,CACnD,AAAG,KAAK,oBAAsB,GAC1B,MAAK,kBAAoB,EACzB,KAAK,eAAe,wBAOxB,wBAAgC,CArcxC,UAscQ,MAAO,WAAK,yBAAL,OAA+B,QAAK,iBAAL,cAAqB,wBAApD,OAA6E,KAGpF,uBAAsB,EAA2B,CACjD,AAAG,KAAK,yBAA2B,GAC/B,MAAK,uBAAyB,EAC9B,KAAK,eAAe,6BAOxB,oBAA4B,CAndpC,UAodQ,MAAO,WAAK,qBAAL,OAA2B,QAAK,iBAAL,cAAqB,oBAAhD,OAAqE,OAG5E,mBAAkB,EAA2B,CAC7C,AAAG,KAAK,qBAAuB,GAC3B,MAAK,mBAAqB,EAC1B,KAAK,eAAe,yBAOxB,YAAoB,CAje5B,UAkeQ,MAAO,WAAK,aAAL,OAAmB,QAAK,iBAAL,cAAqB,YAAxC,OAAqD,MAG5D,WAAU,EAA2B,CACrC,AAAG,KAAK,aAAe,GACnB,MAAK,WAAa,EAClB,KAAK,eAAe,iBAOxB,kBAA0B,CA/elC,UAgfQ,MAAO,WAAK,mBAAL,OAAyB,QAAK,iBAAL,cAAqB,kBAA9C,OAAiE,KAGxE,iBAAgB,EAA2B,CAC3C,AAAG,KAAK,mBAAqB,GACzB,MAAK,iBAAmB,EACxB,KAAK,eAAe,uBAOxB,qBAA6B,CA7frC,UA8fQ,MAAO,WAAK,sBAAL,OAA4B,QAAK,iBAAL,cAAqB,qBAAjD,OAAuE,KAG9E,oBAAmB,EAA2B,CAC9C,AAAG,KAAK,sBAAwB,GAC5B,MAAK,oBAAsB,EAC3B,KAAK,eAAe,0BAOxB,sBAA8B,CA3gBtC,UA4gBQ,MAAO,WAAK,uBAAL,OAA6B,QAAK,iBAAL,cAAqB,sBAAlD,OAAyE,MAGhF,qBAAoB,EAA2B,CAC/C,AAAG,KAAK,uBAAyB,GAC7B,MAAK,qBAAuB,EAC5B,KAAK,eAAe,2BAOxB,qBAA6B,CAzhBrC,UA0hBQ,MAAO,WAAK,sBAAL,OAA4B,QAAK,iBAAL,cAAqB,qBAAjD,OAAuE,MAG9E,oBAAmB,EAA2B,CAC9C,AAAG,KAAK,sBAAwB,GAC5B,MAAK,oBAAsB,EAC3B,KAAK,eAAe,yBCxhBzB,mBAAoB,GAAU,CAKjC,YAAY,EAA8B,EAAuB,CAC7D,MAAM,EAAY,GAClB,KAAK,YAAc,GAAI,QAGd,gBAAmC,CAC5C,MAAO,OAAM,iBAGJ,eAAc,EAA6B,CACpD,MAAM,cAAgB,EAGP,eAAe,EAA0B,KAAY,CAEpE,OAAU,KAAY,MAAK,YACvB,EAAS,GAUjB,UAAU,EAAmD,CACzD,KAAK,YAAY,IAAI,GAOzB,YAAY,EAAmD,CAC3D,KAAK,YAAY,OAAO,KCpCzB,mBAAoB,EAAM,CAK7B,YAAY,EAAwB,KAAM,CACtC,MAAM,EAAQ,EAAU,QAAS,IAGrC,gBAAgB,EAA8B,CAC1C,MAAO,IAAI,GAAM,KCflB,YAAoB,EAAmC,CAC1D,MAAO,UAAS,EAAa,EAA2B,CACpD,GAAM,GAAY,GAAI,SACtB,OAAO,eAAe,EAAQ,EAAa,CACvC,IAAK,SAAS,EAAO,CACjB,GAAM,GAAW,EAAU,IAAI,MAC/B,AAAG,IAAU,GACT,GAAU,IAAI,KAAM,GACpB,EAAS,KAAK,KAAM,KAG5B,IAAK,UAAW,CACZ,MAAO,GAAU,IAAI,OAEzB,WAAY,GACZ,aAAc,MAWnB,YAAmB,EAA6D,CACnF,MAAO,IAAW,UAAoB,CAClC,KAAK,GAAW,KASjB,GAAM,IAAa,GAAU,UAOvB,EAAc,GAAU,gBAQ9B,WAAwB,EAAqE,CAChG,MAAO,IAAW,UAAoB,CAClC,OAAU,KAAW,GACjB,KAAK,GAAW,KASrB,GAAM,IAAmB,EAAe,CAAC,SAAU,iBAanD,YAAyB,EAAsB,EAAiB,GAAO,CAC1E,MAAO,UAAS,EAAa,EAA2B,CACpD,GAAM,GAAY,GAAI,SACtB,OAAO,eAAe,EAAQ,EAAa,CACvC,IAAK,SAAS,EAAY,CACtB,GAAG,MAAM,QAAQ,GAAQ,CACrB,GAAM,GAAW,EAAU,IAAI,MAC/B,GAAG,MAAM,QAAQ,IACb,GAAG,EAAM,SAAW,EAAS,OAAQ,CACjC,EAAS,OAAS,EAAM,OACxB,OAAQ,GAAI,EAAG,EAAI,EAAM,OAAQ,IAC7B,EAAS,GAAK,EAAM,GAExB,EAAS,KAAK,UAGd,QAAQ,GAAI,EAAG,EAAI,EAAM,OAAQ,IAC7B,GAAG,EAAS,KAAO,EAAM,GAAI,CACzB,OAAQ,GAAI,EAAG,EAAI,EAAM,OAAQ,IAC7B,EAAS,GAAK,EAAM,GAExB,EAAS,KAAK,MAEd,YAMZ,GAAU,IAAI,KAAM,CAAC,GAAG,IACxB,EAAS,KAAK,cAIf,EACC,EAAU,IAAI,KAAM,GACpB,EAAS,KAAK,UAGd,MAAM,IAAI,OAAM,2BAG5B,IAAK,UAAW,CACZ,GAAM,GAAW,EAAU,IAAI,MAC/B,MAAI,OAAM,QAAQ,GAGX,CAAC,GAAG,GAFA,GAIf,WAAY,GACZ,aAAc,MAYnB,YAAwB,EAAiB,EAAiB,GAAmD,CAChH,MAAO,IAAgB,UAAoB,CACvC,KAAK,GAAW,IACjB,GASA,YAAyB,EAAiB,GAAmD,CAChG,MAAO,IAAe,SAAU,GAS7B,YAA0B,EAAiB,GAAmD,CACjG,MAAO,IAAe,eAAgB,GAUnC,YAA6B,EAAyB,EAAiB,GAAmD,CAC7H,MAAO,IAAgB,UAAoB,CACvC,OAAU,KAAW,GACjB,KAAK,GAAW,IACrB,GAUA,YAA+B,EAAiB,GAAmD,CACtG,MAAO,IAAoB,CAAC,SAAU,gBAAiB,GCrLpD,YAAuB,EAAgB,EAAU,GAAc,CAElE,MAAO,MAAK,IAAI,EAAG,AADF,GAAU,KAAK,KAAO,KAAK,OAChB,KAAK,KAAK,KCJnC,YAAe,CA4BlB,YAAY,EAAgB,GAAI,EAAiB,GAAI,CAhBrD,iBAAiC,CAAC,EAAG,IAAU,EAAG,KAE1C,WAAQ,GAgBZ,KAAK,OAAS,SAAS,cAAc,UACrC,KAAK,OAAO,MAAQ,EACpB,KAAK,OAAO,OAAS,EAGrB,GAAM,GAAU,KAAK,OAAO,WAAW,KAAM,CAAE,MAAO,KACtD,GAAG,IAAY,KACX,KAAM,IAAI,OAAM,gCAEpB,KAAK,QAAU,KAIf,mBAAqC,CACrC,MAAO,CAAC,KAAK,OAAO,MAAO,KAAK,OAAO,QAgB3C,oBAAoB,EAAwB,CACxC,GAAG,CAAC,EAAM,aAAe,CAAC,KAAK,MAC3B,MAAO,GAGX,KAAK,MAAQ,GAGb,GAAM,CAAC,EAAU,GAAa,EAAM,WAC9B,CAAC,EAAU,EAAU,EAAW,GAAa,KAAK,YAExD,EAAM,uBAAuB,EAAU,EAAU,EAAW,GAC5D,EAAM,gBAAgB,EAAG,GAEzB,GAAM,CAAC,EAAU,GAAa,EAAM,WAEpC,GAAG,IAAa,GAAY,IAAc,EAAW,CAKjD,GAAM,GAAiB,KAAK,IAAI,GAAc,GAAW,KAAK,OAAO,OAC/D,EAAkB,KAAK,IAAI,GAAc,GAAY,KAAK,OAAO,QAEvE,GAAG,IAAmB,KAAK,OAAO,OAAS,IAAoB,KAAK,OAAO,OAAQ,CAQ/E,GAAI,GAAa,KACjB,GAAG,IAAa,GAAK,IAAc,EAAG,CAClC,EAAa,SAAS,cAAc,UACpC,EAAW,MAAQ,EACnB,EAAW,OAAS,EAEpB,GAAM,GAAU,EAAW,WAAW,MACtC,GAAG,IAAY,KACX,KAAM,IAAI,OAAM,0EAEpB,EAAQ,yBAA2B,OACnC,EAAQ,UACJ,KAAK,OACL,EAAG,EAAG,EAAU,EAChB,EAAG,EAAG,EAAU,GAIxB,KAAK,OAAO,MAAQ,EACpB,KAAK,OAAO,OAAS,EAElB,IAAe,MACd,MAAK,QAAQ,yBAA2B,OACxC,KAAK,QAAQ,UACT,EACA,EAAG,EAAG,EAAW,MAAO,EAAW,OACnC,EAAG,EAAG,EAAW,MAAO,EAAW,QAEvC,KAAK,QAAQ,yBAA2B,eAIhD,MAAO,OAGP,OAAO,GAWf,cAAc,EAAe,EAAyB,CAElD,GAAM,GAAW,EAAM,MACvB,SAAM,MAAM,KAAK,QAAS,GACnB,IAlIX,GADC,MACD,AAZG,GAYH,2BCPG,YAAW,CAiFd,YAAY,EAAe,EAAkD,KAAM,EAAe,GAAI,GAAS,CA3ErG,aAAuB,GAAI,KAM3B,cAAW,GAKrB,kBAAe,UAQL,0BAAuB,UAcvB,WAAuC,GAAI,KAAI,CACrD,CAAC,EAAU,SAAU,MACrB,CAAC,EAAU,QAAS,QAUd,oBAAgD,GAAI,KAAI,CAC9D,CAAC,EAAU,SAAU,MACrB,CAAC,EAAU,QAAS,QASxB,sBAA4C,KASlC,sBAAmB,GAWzB,KAAK,SAAW,GAAI,IACpB,KAAK,MAAQ,EACb,KAAK,oBAAsB,EAC3B,KAAK,MAAM,eAAiB,KAI5B,cAAgD,CAChD,MAAO,MAAK,SAAS,eAGrB,aAAY,EAA+C,CAC3D,KAAK,SAAS,YAAc,KAO5B,mBAAqC,CACrC,MAAO,MAAK,SAAS,oBAMrB,aAA+B,CAC/B,MAAO,MAAK,MAAM,cAYlB,UAAmB,CACnB,MAAO,MAAK,YAGZ,SAAQ,EAAqB,CAG7B,GAAG,AAFgB,KAAK,WAEN,EAKd,GAJA,KAAK,SAAW,EAIb,EACC,OAAU,KAAU,MAAK,QACrB,EAAO,SAAS,UAEnB,CACD,OAAU,KAAU,MAAK,QACrB,EAAO,UAAU,MAErB,KAAK,mBAAmB,WAExB,OAAU,KAAS,MAAK,MAAM,OAC1B,KAAK,WAAW,OAS5B,SAA4B,CAC5B,MAAO,MAAK,SAAS,OAazB,eAAyB,CAErB,MAAI,MAAK,QAGF,KAAK,SAAS,oBAAoB,KAAK,OAFnC,GAef,OAAiB,CAEb,MAAI,MAAK,QAGF,KAAK,SAAS,cAAc,KAAK,MAAO,IAFpC,GAmBf,cAAc,EAAuB,CA/NzC,MAiOQ,GAAG,CAAC,KAAK,QACL,MAAO,GAGX,GAAG,EAAM,YAAc,MAAQ,EAAM,SAAW,KAAM,CAGlD,GAAI,GAAQ,KAAK,MAAM,IAAI,EAAM,WAIjC,GAHG,MAAO,IAAU,aAChB,GAAQ,MAET,EAAM,YAAc,IAAU,KAE7B,MAAO,GAIX,EAAQ,EAAM,gBAAgB,GAIlC,KAAK,aAAe,UAGpB,GAAM,GAAW,KAAK,MAAM,cAAc,EAAO,MAcjD,GAbG,IAAa,MAIT,EAAM,YAAc,MAEnB,KAAK,WAAW,EAAM,WAO3B,EAAM,YAAc,KACnB,MAAO,KAAa,KAExB,GAAM,GAAc,QAAK,eAAe,IAAI,EAAM,aAA9B,OAA4C,KAChE,GAAG,IAAgB,EACf,MAAO,KAAa,KAIxB,AAAG,EAAM,YAAc,EAAU,SAAW,IAAgB,MACxD,KAAK,MAAM,cAAc,GAAI,GAAM,GAAc,MAErD,KAAK,eAAe,IAAI,EAAM,UAAW,GACzC,OAAU,KAAU,MAAK,QACrB,EAAO,uBAAuB,KAAM,EAAM,UAAW,EAAa,GAEtE,MAAO,KAAa,KAUxB,iBAAwB,CAEpB,GAAG,EAAC,KAAK,QAIT,QAAU,KAAU,MAAK,QACrB,EAAO,OAAO,MAGlB,KAAK,MAAM,gBAAgB,OAY/B,kBAAyB,CAErB,AAAG,CAAC,KAAK,SAIT,MAAK,MAAM,iBAAiB,MAG5B,KAAK,sBAST,mBAAmB,EAA0B,KAAY,CACrD,AAAG,IAAa,MACZ,MAAK,aAAe,GAErB,KAAK,eAAiB,KAAK,sBAC1B,MAAK,qBAAuB,KAAK,aAC9B,KAAK,sBAAwB,MAC5B,KAAK,oBAAoB,KAAK,uBAS1C,aAAa,EAAsB,EAAsB,CACrD,GAAG,IAAW,KAAM,CAEhB,GAAM,GAAe,KAAK,MAAM,IAAI,GACpC,GAAG,IAAW,EAAc,CACxB,KAAK,WAAW,GAEhB,KAAK,MAAM,IAAI,EAAW,GAC1B,OAAU,KAAU,MAAK,QACrB,EAAO,eAAe,KAAM,EAAW,KASvD,UAAU,EAAsB,EAAsB,CAGlD,GAAM,GAAe,KAAK,MAAM,IAAI,GACpC,AAAG,IAAW,GACV,KAAK,WAAW,GAQxB,WAAW,EAA4B,CACnC,GAAM,GAAe,KAAK,MAAM,IAAI,GACpC,GAAG,IAAiB,MAAQ,MAAO,IAAiB,YAAa,CAE7D,EAAa,eAAe,EAAW,MAEvC,KAAK,MAAM,IAAI,EAAW,MAC1B,OAAU,KAAU,MAAK,QACrB,EAAO,eAAe,KAAM,EAAW,OAOnD,SAAS,EAAqC,CAvYlD,MAwYQ,MAAO,QAAK,MAAM,IAAI,KAAf,OAA6B,KAMxC,iBAAiB,EAAqC,CA9Y1D,MA+YQ,MAAO,QAAK,eAAe,IAAI,KAAxB,OAAsC,KAQjD,eAAe,EAAsB,CAEjC,AAAG,KAAK,QAAQ,IAAI,IAGpB,MAAK,QAAQ,IAAI,GACd,KAAK,UAAY,EAAO,UACvB,EAAO,SAAS,OAQxB,iBAAiB,EAAsB,CAEnC,AAAG,CAAC,KAAK,QAAQ,OAAO,IAGrB,KAAK,UAAY,EAAO,WACvB,EAAO,UAAU,MAOzB,cAAqB,CAEjB,OAAU,KAAU,MAAK,QACrB,KAAK,iBAAiB,MAO1B,qBAA8B,CAC9B,MAAO,MAAK,mBAAqB,MAAQ,CAAC,KAAK,oBAQ/C,uBAAgC,CAChC,MAAO,MAAK,iBASV,aAAa,EAAe,GAA4B,iCAM1D,GAAG,KAAK,mBAAqB,MAAQ,CAAC,KAAK,iBAAkB,CAEzD,KAAK,iBAAmB,GAGxB,GAAM,GAAW,KAAM,MAAK,iBAAiB,GAG7C,YAAK,iBAAmB,GAGjB,EAGX,MAAO,UCtdR,oBAAsB,GAAK,CAgB9B,YAAY,EAAe,EAAe,GAAI,GAAS,CACnD,MAAM,EAAO,KAAM,GAGnB,KAAK,QAAU,SAAS,cAAc,UACtC,KAAK,QAAQ,SAAW,EACxB,CAAC,KAAK,QAAQ,MAAO,KAAK,QAAQ,QAAU,KAAK,WAEjD,GAAM,GAAU,KAAK,QAAQ,WAAW,KAAM,CAAE,MAAO,KACvD,GAAG,IAAY,KACX,KAAM,IAAI,OAAM,oCAEpB,KAAK,iBAAmB,EAGxB,KAAK,oBAAsB,AAAC,GAAkC,CAC1D,KAAK,QAAQ,MAAM,OAAS,GAIhC,KAAK,QAAQ,iBAAiB,QAAS,GAAS,CAC5C,EAAM,iBACH,EAAM,gBAAkB,MACvB,KAAK,cAAc,GAAI,GAAe,EAAM,cAAc,QAAQ,YAE1E,KAAK,QAAQ,gBAAkB,OAG/B,KAAK,QAAQ,MAAM,QAAU,wBAC7B,KAAK,QAAQ,MAAM,OAAS,UAYhC,QAAe,CACX,GAAI,KAAK,QAKL,KAAK,QAAQ,MAAM,eAAe,eALpB,CACd,KAAK,QAAQ,MAAM,QAAU,OAC7B,OAKJ,KAAK,kBACF,KAAK,iBACJ,EAAC,KAAK,QAAQ,MAAO,KAAK,QAAQ,QAAU,KAAK,YACrD,KAAK,mBACF,KAAK,SACJ,MAAK,iBAAiB,yBAA2B,OACjD,KAAK,iBAAiB,UAAU,KAAK,OAAQ,EAAG,MC3ErD,oBAAqC,EAAM,CAS9C,YAAY,EAAgB,EAAe,EAAc,EAAuB,EAA6B,EAAqB,CAC9H,MAAM,EAAQ,EAAW,GACzB,KAAK,MAAQ,EACb,KAAK,KAAO,EACZ,KAAK,IAAM,ICZZ,mBAAoC,GAAc,CAOrD,YAAY,EAAW,EAAW,EAAgB,EAAe,EAAc,EAAwB,KAAM,EAA8B,KAAM,CAC7I,MAAM,EAAO,EAAM,EAAK,EAAQ,EAAW,IAC3C,KAAK,EAAI,EACT,KAAK,EAAI,ICPV,mBAA8B,GAAU,CAkD3C,YAAY,EAAqB,EAA2B,EAAmC,CAC3F,MAAM,GA/CF,cAAW,GAET,YAAS,GAKT,kBAAe,GAaf,WAAQ,EAER,YAAS,EAET,OAAI,EAEJ,OAAI,EAEJ,WAAQ,EAqBd,KAAK,WAAa,EAClB,KAAK,iBAAmB,KAhBxB,OAAe,CACf,MAAO,MAAK,SAGZ,MAAK,EAAc,CACnB,AAAG,IAAS,KAAK,OACb,MAAK,MAAQ,EACb,KAAK,aAAe,OAoBxB,SAAQ,EAAkB,CAC1B,AAAG,IAAY,KAAK,UAGpB,MAAK,SAAW,EAChB,KAAK,OAAS,EACd,KAAK,aAAe,OAGpB,UAAmB,CACnB,MAAO,MAAK,YAIZ,gBAAe,EAA0B,CACzC,KAAK,cAAgB,KAGrB,iBAAoC,CACpC,MAAO,MAAK,cAGG,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAElB,KAAK,YAAe,KAAa,MAAQ,IAAa,eACrD,MAAK,OAAS,OAOlB,aAA+B,CAC/B,MAAO,CAAC,KAAK,MAAO,KAAK,WAOzB,WAA6B,CAC7B,MAAO,CAAC,KAAK,EAAG,KAAK,MAOrB,QAAiB,CACjB,MAAO,MAAK,QAAU,CAAC,KAAK,iBAI5B,cAAuB,CACvB,MAAO,MAAK,gBAWZ,gBAAyB,CACzB,MAAO,MAAK,OAAS,GAAK,KAAK,QAAU,EAQ7C,eAAe,EAAuB,EAAmB,EAa/C,YAAY,EAAc,EAA4B,CAC5D,MAAG,GAAM,SAAW,KACT,KAEA,KAaf,cAAc,EAAc,EAA2B,CACnD,GAAG,CAAC,KAAK,SACL,MAAO,MAEX,GAAG,EAAM,SAAW,MAChB,GAAG,YAAiB,IACb,GAAM,EAAI,KAAK,GAAK,EAAM,EAAI,KAAK,GAAK,EAAM,GAAK,KAAK,EAAI,KAAK,OAAS,EAAM,GAAK,KAAK,EAAI,KAAK,QAClG,MAAO,cAGX,EAAM,SAAW,MAAQ,CAAC,KAAK,iBACnC,MAAO,MAEX,MAAO,MAAK,YAAY,EAAO,GAQzB,sBAAsB,EAAmB,EAOnD,gBAAgB,EAAkB,CAC9B,AAAG,KAAK,UACJ,KAAK,sBAAsB,GAiBnC,kBAAkB,EAAkB,EAAkB,EAAmB,EAAyB,CAE9F,GAAG,CAAC,KAAK,SAAU,CACf,KAAK,MAAQ,EACb,KAAK,OAAS,EACd,KAAK,aAAe,GACpB,OAIJ,GAAG,GAAY,IACX,KAAM,IAAI,OAAM,iCAYpB,GAXG,EAAW,GAGV,SAAQ,KAAK,aAAa,yCAAgD,yFAC1E,EAAW,GAEZ,EAAW,GACV,SAAQ,KAAK,aAAa,4GAC1B,EAAW,GAGZ,GAAa,IACZ,KAAM,IAAI,OAAM,kCACpB,AAAG,EAAY,GACX,SAAQ,KAAK,cAAc,0CAAkD,2FAC7E,EAAY,GAEb,EAAY,GACX,SAAQ,KAAK,cAAc,6GAC3B,EAAY,GAIhB,GAAM,GAAW,KAAK,MAChB,EAAY,KAAK,OAgBvB,GAbA,KAAK,wBAAwB,EAAU,EAAU,EAAW,GAI5D,AAAG,KAAK,MAAQ,EACZ,MAAK,MAAQ,EACb,QAAQ,MAAM,mCAEV,KAAK,MAAQ,GACjB,MAAK,MAAQ,EACb,QAAQ,MAAM,kCAGf,KAAK,MAAQ,GAAK,CAAC,SAAS,KAAK,QAAU,MAAM,KAAK,OACrD,KAAM,IAAI,OAAM,qBAAqB,KAAK,oBAW9C,GATA,AAAG,KAAK,OAAS,EACb,MAAK,OAAS,EACd,QAAQ,MAAM,iCAEV,KAAK,OAAS,GAClB,MAAK,OAAS,EACd,QAAQ,MAAM,gCAGf,KAAK,OAAS,GAAK,CAAC,SAAS,KAAK,SAAW,MAAM,KAAK,QACvD,KAAM,IAAI,OAAM,sBAAsB,KAAK,qBAG/C,KAAK,aAAe,GAIjB,KAAa,KAAK,OAAS,IAAc,KAAK,SAC7C,MAAK,OAAS,IAWtB,uBAAuB,EAAkB,EAAkB,EAAmB,EAAyB,CACnG,KAAK,kBAAkB,EAAU,EAAU,EAAW,GAMnD,KAAa,KAAY,IAAc,MACtC,KAAK,kBACD,EACA,IAAa,IAAW,KAAK,MAAQ,EACrC,EACA,IAAc,IAAW,KAAK,OAAS,GAWzC,uBAA8B,EAOxC,gBAAgB,EAAW,EAAiB,CAExC,AAAG,KAAM,KAAK,GAAK,IAAM,KAAK,IAC1B,MAAK,OAAS,IAGlB,KAAK,EAAI,EACT,KAAK,EAAI,EAGT,KAAK,wBAQC,uBAAuB,EAAmB,EAOpD,iBAAiB,EAAkB,CAC/B,AAAG,KAAK,UACJ,KAAK,uBAAuB,GAY1B,MAAM,EAAW,EAAW,EAAe,EAAgB,EAA+B,EAA4D,KAAY,CACxK,EAAI,OACJ,EAAI,yBAA2B,OAC/B,EAAI,UAAY,UAAa,KAAK,WAClC,EAAI,YAGJ,EAAI,KAAK,KAAK,MAAM,GAAI,KAAK,MAAM,GAAI,KAAK,KAAK,GAAQ,KAAK,KAAK,IACnE,EAAI,OACJ,EAAI,OACJ,EAAI,UAWE,WAAW,EAA+B,EAA4D,KAAY,CACxH,EAAI,OACJ,EAAI,yBAA2B,OAC/B,EAAI,UAAY,UAAa,KAAK,WAClC,EAAI,YASE,SAAS,EAA+B,EAA2B,UAAiB,CAC1F,EAAI,KAAK,GACT,EAAI,OACJ,EAAI,UAUE,UAAU,EAAW,EAAW,EAAe,EAAgB,EAAe,GAAyC,CAE7H,GAAM,GAAY,EAAe,KAAK,KAAO,KAAK,MAC5C,EAAU,EAAe,KAAK,MAAQ,KAAK,KAGjD,SAAI,EAAU,GACd,EAAI,EAAU,GACP,CAAC,EAAG,EAAG,EAAQ,EAAI,GAAS,EAAG,EAAQ,EAAI,GAAU,GAWtD,eAAe,EAAgC,EAAwB,EAWjF,MAAM,EAA+B,EAAQ,GAAa,CACtD,GAAG,KAAK,cACJ,MAAO,MAAK,WAEhB,AAAG,CAAC,KAAK,QAAU,CAAC,GAKjB,MAAK,UACD,MAAK,YACJ,KAAK,MAAM,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,OAAQ,GAExD,EAAI,OACJ,KAAK,eAAe,EAAK,GACzB,EAAI,WAGR,KAAK,OAAS,IASlB,UAAiB,CACb,KAAK,OAAS,KCpdf,oBAAyD,EAAO,CAgBnE,YAAY,EAAoB,EAAqB,EAA2B,EAAmC,CAC/G,MAAM,EAAY,EAAkB,GAEpC,KAAK,UAAY,CAAC,GAAG,MAGZ,gBAAe,EAA0B,CAClD,MAAM,eAAiB,EACvB,OAAU,KAAS,MAAK,SACpB,EAAM,eAAiB,KAGlB,iBAAoC,CAC7C,MAAO,OAAM,eAGR,UAAiB,CACtB,MAAM,WAEN,OAAU,KAAS,MAAK,SACpB,EAAM,cAIV,aAAqB,CACrB,MAAO,MAAK,UAAU,UAOtB,WAAwB,CACxB,MAAO,MAAK,UAAU,WC5DvB,mBAA+D,GAAU,CAM5E,YAAY,EAAU,EAAqB,EAA2B,EAAmC,CACrG,MAAM,CAAC,GAAQ,EAAY,EAAkB,MAI7C,QAAW,CACX,MAAO,MAAK,UAAU,KCHvB,oBAA2D,EAAgB,CAE9E,YAAY,EAAU,EAAmC,CAGrD,MAAM,EAAO,GAAO,GAAM,GAGX,YAAY,EAAc,EAA2B,CAEpE,MAAO,MAAK,MAAM,cAAc,EAAO,GAGxB,sBAAsB,EAAkB,CAEvD,GAAM,GAAQ,KAAK,MACnB,EAAM,gBAAgB,GAGnB,EAAM,aACL,MAAK,aAAe,IAGT,uBAAuB,EAAkB,CAExD,GAAM,GAAQ,KAAK,MACnB,EAAM,iBAAiB,GAGpB,EAAM,OACL,MAAK,OAAS,IAGH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAGvH,GAAM,GAAQ,KAAK,MACnB,EAAM,kBAAkB,EAAU,EAAU,EAAW,GACvD,CAAC,KAAK,MAAO,KAAK,QAAU,EAAM,WAGnB,uBAA8B,CAE7C,KAAK,MAAM,gBAAgB,KAAK,EAAG,KAAK,GAGzB,eAAe,EAA+B,EAAuB,CAEpF,KAAK,MAAM,MAAM,EAAK,KCrDvB,oBAA8D,GAAqB,CAgBtF,YAAY,EAAU,EAAiC,CAAC,EAAG,IAAU,EAAG,KAAW,EAAmC,CAClH,MAAM,EAAO,GAfT,kBAAkC,CAAC,EAAG,IAAU,EAAG,KAW3D,iBAAiC,CAAC,EAAG,IAAU,EAAG,KAM9C,KAAK,aAAe,CAAC,GAAG,GAGT,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAI,GAAc,KAAK,IAAI,KAAK,IAAI,KAAK,aAAa,GAAI,GAAW,GACjE,EAAe,KAAK,IAAI,KAAK,IAAI,KAAK,aAAa,GAAI,GAAY,GACjE,EAAc,KAAK,IAAI,KAAK,IAAI,KAAK,aAAa,GAAI,GAAW,GACjE,EAAe,KAAK,IAAI,KAAK,IAAI,KAAK,aAAa,GAAI,GAAY,GAEzE,AAAG,EAAc,GACb,GAAc,GAEf,EAAe,GACd,GAAe,GAGnB,MAAM,wBAAwB,EAAa,EAAa,EAAc,KAvB1E,GADC,MACD,AAbG,GAaH,2BCZG,oBAA0C,EAAa,CAY1D,YAAY,EAAW,EAAW,EAAgB,EAAgB,EAAe,EAAc,EAAwB,KAAM,EAA8B,KAAM,CAC7J,MAAM,EAAG,EAAG,EAAO,EAAM,EAAK,EAAQ,GACtC,KAAK,OAAS,KAId,SAAkB,CAClB,MAAO,MAAK,SAAW,KAIvB,YAAqB,CACrB,MAAO,MAAK,UAIZ,UAAmB,CACnB,MAAO,MAAK,SAAW,KAIvB,cAAuB,CACvB,MAAO,MAAK,WAIZ,WAAoB,CACpB,MAAO,MAAK,SAAW,KAIvB,aAAsB,CACtB,MAAO,MAAK,WChDb,mBAA6B,GAAmB,CAEnD,YAAY,EAAW,EAAW,EAAgB,EAAgB,EAAe,EAAc,EAAwB,KAAM,CACzH,MAAM,EAAG,EAAG,EAAQ,EAAO,EAAM,EAAK,EAAQ,EAAU,SAG5D,cAAc,EAAiB,EAAiC,CAC5D,MAAO,IAAI,GAAe,KAAK,EAAI,EAAS,KAAK,EAAI,EAAS,KAAK,OAAQ,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KAAK,QAGrH,gBAAgB,EAAuC,CACnD,MAAO,IAAI,GAAe,KAAK,EAAG,KAAK,EAAG,KAAK,OAAQ,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KCZzF,mBAA2B,GAAmB,CAEjD,YAAY,EAAW,EAAW,EAAgB,EAAgB,EAAe,EAAc,EAAwB,KAAM,CACzH,MAAM,EAAG,EAAG,EAAQ,EAAO,EAAM,EAAK,GAG1C,cAAc,EAAiB,EAA+B,CAC1D,MAAO,IAAI,GAAa,KAAK,EAAI,EAAS,KAAK,EAAI,EAAS,KAAK,OAAQ,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KAAK,QAGnH,gBAAgB,EAAqC,CACjD,MAAO,IAAI,GAAa,KAAK,EAAG,KAAK,EAAG,KAAK,OAAQ,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KCPvF,GAAK,GAAL,UAAK,EAAL,CAEH,2BAEA,qBAEA,qBANQ,WAiBL,WAAkB,CAgCrB,YAAY,EAAgB,CA9B5B,oBAA6B,EAE7B,gBAAyB,EAEzB,uBAAoB,GAEpB,cAAW,GAOX,gBAAsC,KAMtC,wBAA8C,KAE9C,mBAAgB,EAUZ,KAAK,OAAS,EAclB,gBAAgB,EAAY,EAAY,EAAe,EAAgB,EAAc,EAAmC,CACpH,MAAO,CAAE,GAAK,GAAU,GAAS,GAAS,GAAK,GAAS,GAAU,IActE,cAAc,EAAY,EAAY,EAAe,EAAgB,EAAc,EAA0B,CACzG,MAAO,IAAM,GAAS,EAAK,GAAU,GAAM,GAAQ,EAAK,EAa5D,eAAe,EAAY,EAAqB,CAC5C,MAAO,IAAM,GAAK,EAAK,GAAK,GAAM,GAAK,EAAK,EAOxC,cAAc,EAAwB,EAAuB,CACjE,AAAG,KAAK,aAAe,EACnB,MAAK,eAAiB,KAAK,WAC3B,KAAK,WAAa,EAIlB,KAAK,SAAW,GAAU,KAAK,iBAAmB,EAClD,KAAK,kBAAoB,IAGzB,KAAK,kBAAoB,GAUjC,iBAAiB,EAAc,EAAY,EAAmD,CAC1F,GAAG,YAAiB,GAEhB,SAAK,UAAU,EAAU,QAAS,KAAK,QACvC,KAAK,WAAa,KACX,KAAK,cAAc,EAAqB,IAE9C,GAAG,YAAiB,GAAc,CAEnC,KAAK,WAAa,KAAK,gBAAgB,EAAM,EAAG,EAAM,EAAG,GAAG,GAI5D,GAAM,GAAS,KAAK,eAAe,GAAG,KAAK,YAC3C,GAAG,EACC,EAAK,aAAe,kBAChB,EAAM,SAAW,KACrB,SAAK,UAAU,EAAU,QAAS,KAAK,QAChC,KAAK,cAAc,EAAqB,IAKnD,MAAG,aAAiB,IAAgB,EAAM,SAAW,KAAK,cACtD,MAAK,mBAAqB,KAAK,WAC/B,EAAK,aAAa,EAAU,QAAS,KAAK,QACnC,KAAK,cAAc,EAAiB,IAI5C,YAAiB,IAAkB,EAAM,SAAW,KAAK,cACxD,GAAK,UAAU,EAAU,QAAS,KAAK,QACpC,EACQ,KAAK,cAAc,EAAkB,GAErC,KAAK,cAAc,EAAqB,IAIpD,EAAM,SAAW,KACT,KAAK,cAAc,EAAkB,GAErC,KAAK,cAAc,EAAiB,OAG/C,MAAK,kBAAoB,KC1K9B,mBAA2B,EAAa,CAS3C,YAAY,EAAW,EAAW,EAAgB,EAAgB,EAAmB,EAAgB,EAAe,EAAc,EAAwB,KAAM,CAC5J,MAAM,EAAG,EAAG,EAAO,EAAM,EAAK,EAAQ,EAAU,SAChD,KAAK,OAAS,EACd,KAAK,OAAS,EACd,KAAK,SAAW,EAGpB,cAAc,EAAiB,EAA+B,CAC1D,MAAO,IAAI,GAAa,KAAK,EAAI,EAAS,KAAK,EAAI,EAAS,KAAK,OAAQ,KAAK,OAAQ,KAAK,SAAU,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KAAK,QAG/I,gBAAgB,EAAqC,CACjD,MAAO,IAAI,GAAa,KAAK,EAAG,KAAK,EAAG,KAAK,OAAQ,KAAK,OAAQ,KAAK,SAAU,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KChBnH,oBAAuD,EAAgB,CAK1E,YAAY,EAAU,EAA0B,EAAmC,CAG/E,MAAM,EAAO,GAAO,EAAiB,GAN/B,qBAAkB,GAST,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,gBAAkB,IAEtB,AAAG,IAAa,aACjB,KAAK,gBAAkB,GACtB,AAAG,IAAa,mBACjB,KAAK,aAAe,GAChB,IAAa,sBACjB,MAAK,aAAe,IAGT,YAAY,EAAc,EAA2B,CAEpE,MAAO,MAAK,MAAM,cAAc,EAAO,GAGxB,sBAAsB,EAAkB,CAEvD,GAAM,GAAQ,KAAK,MACnB,EAAM,gBAAgB,GAGnB,EAAM,aACL,MAAK,aAAe,IAGT,uBAAuB,EAAkB,CAExD,GAAM,GAAQ,KAAK,MACnB,EAAM,iBAAiB,GAGpB,EAAM,OACL,MAAK,OAAS,IAGf,KAAK,iBACJ,MAAK,OAAS,IAGH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAM,GAAU,KAAK,iBACf,EAAW,EAAQ,KAAO,EAAQ,MAClC,EAAW,EAAQ,IAAM,EAAQ,OACnC,EAAgB,EAAW,EAC3B,EAAiB,EAAY,EAIjC,AAAG,EAAgB,GACf,GAAgB,GACjB,EAAiB,GAChB,GAAiB,GAKrB,GAAM,GAAY,KAAK,mBACnB,EAAgB,EACpB,AAAG,EAAU,aAAe,EAAU,SAClC,CAAG,IAAkB,IACjB,EAAgB,EAEhB,EAAgB,KAAK,IAAI,EAAW,EAAU,IAGtD,GAAI,GAAiB,EACrB,AAAG,EAAU,WAAa,EAAU,SAChC,CAAG,IAAmB,IAClB,EAAiB,EAEjB,EAAiB,KAAK,IAAI,EAAY,EAAU,IAIxD,GAAM,CAAC,EAAe,GAAkB,KAAK,MAAM,WACnD,KAAK,MAAM,kBAAkB,EAAe,EAAe,EAAgB,GAC3E,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WAGvC,CAAC,EAAU,GAAa,CAAC,KAAK,MAAO,KAAK,QAChD,KAAK,MAAQ,KAAK,IAAI,EAAU,EAAa,GAC7C,KAAK,OAAS,KAAK,IAAI,EAAW,EAAc,GAG7C,MAAK,QAAU,GAAY,KAAK,SAAW,GAC3C,IAAe,GAAiB,IAAgB,IAC/C,MAAK,gBAAkB,IAGZ,uBAA8B,CAE7C,GAAM,GAAU,KAAK,iBACf,EAAY,KAAK,mBAGjB,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,EAAY,EAAa,EAAQ,KAAO,EAAQ,MAChD,EAAa,EAAc,EAAQ,IAAM,EAAQ,OAGnD,EAAS,KAAK,EAAI,EAAQ,KAC9B,GAAG,EAAU,aAAe,EAAU,QAAS,CAE3C,GAAM,GAAY,KAAK,MAAQ,EAM/B,AAAG,EAAY,GACX,IAAU,EAAY,EAAU,YAIxC,GAAI,GAAS,KAAK,EAAI,EAAQ,IAC9B,GAAG,EAAU,WAAa,EAAU,QAAS,CAEzC,GAAM,GAAY,KAAK,OAAS,EAEhC,AAAG,EAAY,GACX,IAAU,EAAY,EAAU,UAIxC,GAAM,CAAC,EAAW,GAAa,KAAK,MAAM,SAC1C,KAAK,MAAM,gBAAgB,EAAQ,GAGhC,KAAc,GAAU,IAAc,IACrC,MAAK,gBAAkB,IAOrB,4BAA4B,EAA+B,EAAiB,EAA8B,KAAY,CAE5H,AAAG,MAAK,iBAAmB,IACvB,MAAK,WAAW,EAAK,GACrB,EAAI,KAAK,GAAG,KAAK,UAAU,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,SAC5D,EAAI,KAAK,GAAG,KAAK,UAAU,GAAG,KAAK,MAAM,SAAU,GAAG,KAAK,MAAM,WAAY,KAC7E,KAAK,SAAS,EAAK,WAEnB,KAAK,gBAAkB,IAI3B,KAAK,MAAM,MAAM,EAAK,GAGP,eAAe,EAA+B,EAAuB,CACpF,KAAK,4BAA4B,EAAK,KCxKvC,oBAAgD,GAAiB,CAUpE,YAAY,EAAU,EAAgC,KAAM,EAAmC,CAC3F,MAAM,EAAO,GAAO,GACpB,KAAK,YAAc,GAAI,GAAY,MACnC,KAAK,SAAW,EAGD,YAAY,EAAc,EAA2B,CAEpE,GAAG,YAAiB,GAChB,MAAO,MAGX,GAAG,KAAK,WAAa,KACjB,YAAK,YAAY,kBAAoB,GAC9B,KAKX,GADA,KAAK,YAAY,iBAAiB,EAAO,EAAM,CAAC,KAAK,EAAG,KAAK,EAAI,KAAK,MAAO,KAAK,EAAG,KAAK,EAAI,KAAK,SAChG,KAAK,YAAY,mBAAqB,KAAK,YAAY,SACtD,GAAI,CACA,KAAK,iBAEH,EAAN,CACI,QAAQ,MAAM,6BAA8B,GAIpD,MAAO,QCjCR,oBAAsD,GAAU,CAenE,YAAY,EAAU,EAAgC,KAAM,EAAmC,CAC3F,MAAM,EAAO,EAAU,GAdnB,wBAAqB,iBAQ7B,YAAS,GAYL,KAAK,WAAa,GAAI,GAAuB,CACzC,WAAY,KAAK,sBAErB,KAAK,MAAM,eAAiB,KAAK,WAU7B,kBAAyB,CAC7B,GAAM,GAAc,KAAK,mBAEzB,GAAG,KAAK,OACJ,KAAK,mBAAqB,kBAE1B,QAAO,KAAK,YAAY,gBACnB,GAAW,KACZ,KAAK,mBAAqB,aAC1B,UACC,GAAW,MACZ,KAAK,mBAAqB,qBAC1B,cAEA,KAAK,mBAAqB,iBAC1B,MAKR,AAAG,IAAgB,KAAK,oBACpB,MAAK,gBAAkB,GACvB,KAAK,WAAW,WAAa,KAAK,qBAIlC,mBAA+B,CACnC,OAAO,KAAK,wBACH,cACD,MAAO,MAAK,gBACX,aACD,MAAO,MAAK,eACX,qBACD,MAAO,MAAK,uBACX,iBACD,MAAO,MAAK,uBAEZ,KAAM,IAAI,OAAM,2BAA2B,KAAK,0BAI/C,gBAAe,EAA0B,CAClD,AAAG,IAAU,KAAK,eAGlB,MAAK,cAAgB,EACrB,KAAK,WAAW,cAAgB,MAGvB,iBAAoC,CAC7C,MAAO,MAAK,cAGG,eAAe,EAA0B,KAAY,CACpE,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,gBAAkB,GACvB,KAAK,WAAW,WAAa,KAAK,qBAEjC,AAAG,IAAa,KAAK,eACtB,MAAK,gBAAkB,GACvB,KAAK,WAAW,WAAa,KAAK,qBAEjC,AAAG,IAAa,mBACjB,KAAK,aAAe,GAChB,IAAa,sBACjB,MAAK,aAAe,IAGT,YAAY,EAAc,EAA2B,CACpE,GAAM,GAAW,MAAM,YAAY,EAAO,GAE1C,MAAG,MAAK,YAAY,mBAChB,KAAK,mBAEF,EAGQ,eAAe,EAA+B,EAAuB,CACpF,KAAK,4BAA4B,EAAK,EAAQ,KAAK,uBAlHpD,MAUH,GADC,GAAW,GAAa,UAAU,mBACnC,AAVG,GAUH,sBChCJ,GAAI,IAAkD,KAY/C,YAAyB,EAAc,EAA2B,CAErE,GAAG,KAAmB,MAElB,IAAiB,AADE,SAAS,cAAc,UACd,WAAW,MACpC,KAAmB,MAClB,KAAM,IAAI,OAAM,gCAIxB,UAAe,KAAO,EAIf,GAAe,YAAY,GCtBtC,GAAM,IAAyB,GAAI,KAAI,CAAC;AAAA,EAAM,MA2ClC,GAAL,UAAK,EAAL,CAKH,uBAQA,yBAbQ,aAwBL,WAAiB,CAAjB,aAvEP,CA8EI,UAAO,GAOP,UAAO,GAQP,cAAW,IAQX,gBAA4B,KAQ5B,iBAA6B,KAQ7B,cAAW,EAOX,cAAqB,EAGb,YAAS,EAET,aAAU,EAEV,iBAAc,EAEd,kBAAe,EAEf,eAAY,EAGZ,kBAAe,GAEf,4BAAyB,GAEzB,mBAAgB,GAEhB,YAAS,GAET,iBAAgC,MAMpC,QAAiB,CACjB,GAAM,GAAW,KAAK,OACtB,YAAK,OAAS,GACP,EAaH,iBAAiB,EAAc,EAAe,EAAqB,CACvE,GAAM,GAAU,GAAgB,KAAK,KAAK,MAAM,EAAO,GAAM,KAAK,MAClE,MAAG,KAAS,EACD,EAAQ,MAAQ,KAAK,IAAI,EAAG,EAAQ,uBAEpC,EAAO,EAAQ,MAOtB,uBAAuB,EAAkB,EAAuB,CAEpE,GAAG,GAAS,EAAM,GAAG,GACjB,MAAO,GAGX,GAAI,GAAa,EACjB,KAAM,EAAa,EAAM,OAAQ,IAAc,CAI3C,GAAM,GAAQ,EAAM,GACd,EAAW,EAAM,GACvB,GAAG,GAAS,EACR,MAAO,GAAM,GACZ,GAAG,GAAS,EAAM,IAAM,EAAQ,EACjC,MAIR,GAAG,IAAe,EAAM,OACpB,MAAO,GAAM,EAAa,GAAG,GAGjC,GAAI,GAAO,EACX,AAAG,EAAa,GACZ,GAAO,EAAM,EAAa,GAAG,IAIjC,GAAM,GAAQ,EAAM,GACpB,MAAG,GAAM,GACE,EAAO,EAAM,GAAM,GAAQ,EAAM,IAAO,GAAM,GAAK,EAAM,IAEzD,KAAK,iBAAiB,EAAM,EAAM,GAAI,GAe7C,YAAY,EAAe,EAAa,EAAkB,EAA+B,CArOrG,QAyOQ,GAAI,GAAe,EACnB,KAAM,EAAe,EAAU,OAAQ,IAAgB,CACnD,GAAM,GAAyB,EAAU,GACzC,GAAG,GAAS,EAAM,IAAM,EAAQ,EAAM,GAAI,CACtC,EAAQ,EAAM,GACd,OAOR,GAAG,EAAe,EAAG,CACjB,GAAI,GAAoC,EAAU,EAAe,GACjE,AAAG,EAAU,KAAO,GAChB,GAAQ,EAAU,GAElB,AAAG,EAAE,EAAe,EAChB,EAAY,EAAU,GAEtB,EAAY,MAGjB,IAAc,MAAQ,CAAC,EAAU,IAAM,CAAC,GAAuB,IAAI,KAAK,KAAK,KAC5E,GAAQ,EAAU,GAClB,KAKR,GAAI,GAAO,EACX,AAAG,EAAe,GACd,GAAO,EAAU,EAAe,GAAG,IAGvC,GAAI,GAAa,EACX,EAAsC,GAC5C,KAAM,EAAa,GACf,GAAG,KAAK,KAAK,KAAgB,IAAM,CAE/B,GAAM,GAAW,KAAK,eACtB,EAAQ,MAAK,MAAM,EAAO,GAAY,GAAK,EAC3C,EAAY,KAAK,CAAC,EAAY,EAAE,EAAY,EAAM,aAE9C,KAAK,KAAK,KAAgB;AAAA,EAAM,CAEpC,EAAY,KAAK,CAAC,EAAY,EAAE,EAAY,EAAM,KAE/C,EAAa,GACZ,QAAQ,KAAK,gIAEjB,UAEC,CAGD,GAAI,GAAc,KAAK,KAAK,QAAQ;AAAA,EAAM,EAAa,GACvD,AAAG,IAAgB,IACf,GAAc,KAElB,GAAI,GAAU,KAAK,KAAK,QAAQ,IAAM,EAAa,GACnD,AAAG,IAAY,IACX,GAAU,KAEd,GAAM,GAAW,KAAK,IAAI,EAAa,EAAS,GAGhD,EAAO,KAAK,iBAAiB,EAAM,EAAY,GAC/C,EAAY,KAAK,CAAC,EAAY,EAAU,EAAM,KAE9C,EAAa,EAKrB,GAAM,GAAa,EAAe,EAAY,OACxC,EAAY,QAAY,EAAY,OAAS,KAAjC,OACK,EAAU,EAAe,KAD9B,OAEK,KAEvB,MAAG,KAAc,KAEb,GAAU,OAAS,EACnB,EAAU,KAAK,CAAC,EAAO,EAAO,EAAG,KAC1B,IAEF,IAAe,GAAM,EAAU,GAAK,EAAU,IAAO,GACtD,EAAU,IAAM,EACpB,GAAU,OAAS,EACnB,EAAU,KAAK,GAAG,GACX,IAGA,GAOP,gBAAuB,CAE3B,GAAG,KAAK,uBAAwB,CAC5B,KAAK,uBAAyB,GAE9B,GAAM,GAAgB,KAAK,YACrB,EAAiB,KAAK,aAE5B,GAAG,KAAK,aAAe,MAAQ,KAAK,cAAgB,KAAM,CACtD,GAAM,GAAU,GACZ,mGACA,KAAK,MAGT,AAAG,KAAK,aAAe,KACnB,KAAK,YAAc,EAAQ,wBAE3B,KAAK,YAAc,KAAK,WAE5B,AAAG,KAAK,cAAgB,KACpB,KAAK,aAAe,EAAQ,yBAE5B,KAAK,aAAe,KAAK,gBAG7B,MAAK,YAAc,KAAK,WACxB,KAAK,aAAe,KAAK,YAI7B,AAAG,KAAkB,KAAK,aAAe,IAAmB,KAAK,eAC7D,MAAK,aAAe,IAU5B,GANG,KAAK,eACJ,MAAK,cAAgB,GACrB,KAAK,UAAY,GAAgB,IAAK,KAAK,MAAM,MAAQ,KAAK,UAI/D,CAAC,KAAK,aACL,OAGJ,KAAK,aAAe,GAEpB,GAAM,GAAiB,KAAK,YAAc,KAAK,aAE/C,GAAG,KAAK,KAAK,SAAW,EAGpB,KAAK,QAAU,EACf,KAAK,OAAS,KAAK,WAAa,IAAW,EAAI,KAAK,SACpD,KAAK,YAAY,OAAS,EAC1B,KAAK,YAAY,GAAK,CAAC,CAAC,EAAG,EAAG,EAAG,aAE7B,KAAK,WAAa,IAAU,CAEhC,KAAK,YAAY,OAAS,EAC1B,GAAI,GAAY,EAChB,KAAK,QAAU,EACf,KAAK,OAAS,EAEd,GAAM,GAAO,KAAK,KAElB,OAAY,CAER,GAAM,GAAU,KAAK,KAAK,QAAQ;AAAA,EAAM,GAClC,EAAQ,IAAY,GACpB,EAAM,EAAQ,EAAK,OAAU,EAAU,EAGvC,EAAmB,GACzB,KAAK,YAAY,EAAW,EAAK,IAAU,GAC3C,KAAK,YAAY,KAAK,GAEtB,KAAK,SAAW,EAChB,GAAM,GAAQ,EAAM,EAAM,OAAS,GAAG,GAKtC,GAJG,EAAQ,KAAK,QACZ,MAAK,OAAS,GAGf,EACC,MAGJ,EAAY,OAGf,CAED,KAAK,YAAY,OAAS,EAC1B,GAAI,GAAmB,GACjB,EAAO,KAAK,KACZ,EAAa,KACf,EAAY,GAEhB,OAAQ,GAAI,EAAG,GAAK,EAAK,QAAS,CAC9B,GAAM,GAAU,EAAW,KAAK,EAAK,IAC/B,EAAQ,IAAM,EAAK,OAIzB,GAAG,GAAW,EAAO,CAEjB,GAAG,GAAa,GAAK,CAAC,KAAK,YAAY,EAAW,EAAG,KAAK,SAAU,GAAQ,CAExE,GAAM,GAAsB,GAC5B,GAAG,KAAK,YAAY,EAAW,EAAG,KAAK,SAAU,GAAW,CAGxD,GAAG,EAAM,SAAW,EAChB,KAAM,IAAI,OAAM,mDACpB,KAAK,YAAY,KAAK,GACtB,EAAQ,MAEP,CAOD,GAAI,GAAI,EACR,KAAM,EAAI,EAAI,GACN,KAAK,YAAY,EAAG,EAAI,EAAG,KAAK,SAAU,GADjC,IACb,CAGJ,KAAK,YAAY,KAAK,GACtB,EAAQ,EAER,EAAI,EACJ,EAAY,EACZ,UAOR,GAHA,EAAY,GAGT,EAAO,CAIN,GAAG,EAAM,SAAW,EAAG,CACnB,GAAM,GAAgB,KAAK,YAAY,KAAK,YAAY,OAAS,GACjE,GAAG,IAAkB,OACjB,EAAM,KAAK,CAAC,EAAG,EAAG,EAAG,SACpB,CACD,GAAM,GAAY,EAAc,EAAc,OAAS,GACvD,AAAG,IAAc,OACb,EAAM,KAAK,CAAC,EAAG,EAAG,EAAG,KAErB,EAAM,KAAK,CAAC,EAAU,GAAI,EAAU,GAAI,EAAG,MAIvD,KAAK,YAAY,KAAK,GACtB,MAIJ,GAAG,EAAK,KAAO;AAAA,EAGX,KAAK,YAAY,EAAG,EAAI,EAAG,IAAU,GACrC,KAAK,YAAY,KAAK,GACtB,EAAQ,WAEJ,CAAC,KAAK,YAAY,EAAG,EAAI,EAAG,KAAK,SAAU,GAM/C,GAAG,KAAK,WAAa,EAAiB,CAClC,GAAM,GAAkB,EACxB,EACI,WACI,EAAK,KAAO;AAAA,GAAQ,EAAW,KAAK,EAAK,KAEjD,GAAM,GAAY,EAAM,EAAM,OAAS,GACvC,EAAM,KAAK,CACP,EACA,EACA,IAAc,OAAY,EAAU,GAAK,EACzC,KAEJ,KAAK,YAAY,KAAK,GACtB,EAAQ,GACR,aAGA,MAAK,YAAY,KAAK,GACtB,EAAQ,GACR,KAAK,YAAY,EAAG,EAAI,EAAG,IAAU,OAI5C,AAAG,KAAc,IAClB,GAAY,GAIhB,IAIJ,KAAK,OAAS,KAAK,SACnB,KAAK,QAAU,EAAiB,KAAK,YAAY,QAIzD,MAAM,EAA+B,EAAsB,EAAW,EAAiB,CAEnF,EAAI,OACJ,EAAI,YACJ,EAAI,KAAK,EAAG,EAAG,KAAK,MAAO,KAAK,QAChC,EAAI,OAGJ,EAAI,KAAO,KAAK,KAChB,EAAI,UAAY,EAChB,EAAI,aAAe,aAGnB,GAAM,GAAiB,KAAK,eACxB,EAAU,EAAI,KAAK,YAEvB,OAAU,KAAS,MAAK,YAAa,CACjC,GAAI,GAAO,EACX,OAAU,KAAS,GAEf,AAAG,CAAC,EAAM,IAAM,EAAM,GAAK,GAKvB,EAAI,SAAS,KAAK,KAAK,MAAM,EAAM,GAAI,EAAM,IAAK,EAAI,EAAM,GAYhE,EAAO,EAAM,GAEjB,GAAW,EAIf,EAAI,UAWR,oBAAoB,EAA0C,CAG1D,GAAM,GAAa,KAAK,WACxB,GAAG,GAAS,GAAK,EAAW,SAAW,EACnC,MAAO,CAAC,EAAG,GAGf,GAAI,GAAO,EACX,OAAU,KAAS,GAAY,CAC3B,GAAG,EAAQ,EAAM,EAAM,OAAS,GAAG,GAC/B,MAEJ,IAIJ,MAAG,IAAQ,EAAW,QAClB,GAAO,EAAW,OAAS,EAC3B,EAAQ,KAAK,KAAK,QAIf,CACH,KAAK,uBAAuB,EAAW,GAAO,GAC9C,EAAO,KAAK,gBAYpB,0BAA0B,EAAsD,CAG5E,GAAM,GAAiB,KAAK,eAC5B,GAAG,KAAK,OAAS,IAAO,EAAO,IAAM,GAAK,EAAO,GAAK,GAAmB,EAAO,GAAK,EACjF,MAAO,CAAC,EAAG,CAAC,EAAG,IAGnB,GAAM,GAAO,KAAK,MAAM,EAAO,GAAK,GAG9B,EAAS,KAAK,WACpB,GAAG,GAAQ,EAAO,OAAQ,CACtB,GAAM,GAAQ,KAAK,KAAK,OACxB,MAAO,CAAC,EAAO,KAAK,oBAAoB,IAI5C,GAAM,GAAU,EAAO,EACjB,EAAQ,EAAO,GACrB,GAAG,EAAM,SAAW,GAAK,EAAM,GAAG,KAAO,EAAM,GAAG,GAC9C,MAAO,CAAC,EAAM,GAAG,GAAI,CAAC,EAAM,GAAG,GAAI,IAKvC,GAAI,GAAa,EACX,EAAY,EAAM,GAAG,GAIvB,EAAU,EAAM,EAAM,OAAS,GAAG,GACtC,AAAG,KAAK,KAAK,EAAU,KAAO;AAAA,GAC1B,IAEJ,OAAQ,GAAI,EAAW,EAAI,EAAS,IAAK,CAErC,GAAM,GAAS,KAAK,uBAAuB,EAAO,EAAI,GAChD,EAAkB,GAAS,GAAc,EAI/C,GAAG,EAAO,GAAK,EACX,MAAO,CAAC,EAAG,CAAC,EAAY,IAG5B,EAAa,EAIjB,MAAO,CAAC,EAAS,CAAC,EAAY,IAOlC,QAAQ,EAAuB,CAC3B,GAAG,GAAS,EACR,MAAO,GAEX,GAAM,GAAa,KAAK,WACxB,OAAQ,GAAO,EAAG,EAAO,EAAW,OAAQ,IAAQ,CAChD,GAAM,GAAY,EAAW,GACvB,EAAY,EAAU,EAAU,OAAS,GAC/C,GAAG,EAAQ,EAAU,GACjB,MAAO,GAGf,MAAO,GAAW,OAAS,EAO/B,aAAa,EAAsB,CAC/B,GAAG,GAAQ,EACP,MAAO,GAEX,GAAM,GAAa,KAAK,WACxB,GAAG,GAAQ,EAAW,OAAQ,CAC1B,GAAM,GAAW,EAAW,EAAW,OAAS,GAChD,MAAO,GAAS,EAAS,OAAS,GAAG,GAGzC,MAAO,GAAW,GAAM,GAAG,GAQ/B,WAAW,EAAc,EAAkB,GAAc,CACrD,GAAG,EAAO,EACN,MAAO,GAEX,GAAM,GAAa,KAAK,WACxB,GAAG,GAAQ,EAAW,OAAQ,CAC1B,GAAM,GAAW,EAAW,EAAW,OAAS,GAChD,MAAO,GAAS,EAAS,OAAS,GAAG,GAGzC,GAAM,GAAY,EAAW,GACvB,EAAY,EAAU,EAAU,OAAS,GACzC,EAAY,EAAU,GAC5B,MAAG,CAAC,GAAmB,EAAY,GAChC,KAAK,KAAK,EAAY,KAAO;AAAA,GAAQ,EAAU,KAAO,EAAU,GACxD,EAAY,EAEZ,KAIX,QAAgB,CAChB,YAAK,iBACE,KAAK,UAIZ,SAAiB,CACjB,YAAK,iBACE,KAAK,WAaZ,aAA+B,CAC/B,YAAK,iBACE,CAAC,GAAG,KAAK,gBAOhB,mBAA2B,CAC3B,YAAK,iBACE,KAAK,eAOZ,oBAA4B,CAC5B,YAAK,iBACE,KAAK,gBAIZ,iBAAyB,CACzB,YAAK,iBACE,KAAK,aASZ,iBAAyB,CACzB,YAAK,iBACE,KAAK,YAAc,KAAK,eA7tBnC,GADC,EAAe,CAAC,SAAU,kBAC3B,AAPG,EAOH,oBAOA,GADC,EAAe,CAAC,SAAU,eAAgB,yBAA0B,mBACrE,AAdG,EAcH,oBAQA,GADC,EAAe,CAAC,SAAU,kBAC3B,AAtBG,EAsBH,wBAQA,GADC,EAAe,CAAC,SAAU,eAAgB,4BAC3C,AA9BG,EA8BH,0BAQA,GADC,EAAe,CAAC,SAAU,eAAgB,4BAC3C,AAtCG,EAsCH,2BAQA,GADC,EAAe,CAAC,SAAU,eAAgB,mBAC3C,AA9CG,EA8CH,wBAOA,GADC,EAAe,CAAC,SAAU,kBAC3B,AArDG,EAqDH,wBCxGG,oBAAoB,EAAO,CAqB9B,YAAY,EAA6B,EAAmC,CAGxE,MAAM,GAAM,GAAO,GAnBf,gBAAgC,KASxC,cAAW,GAYP,KAAK,WAAa,GAAI,GACtB,KAAK,WAAW,SAAW,GAAS,OACpC,KAAK,OAAS,KAcd,QAAO,EAA6B,CACpC,AAAG,YAAkB,UACjB,KAAK,WAAa,EAElB,MAAK,WAAa,KAClB,KAAK,WAAW,KAAO,MAI3B,SAA8B,CAC9B,MAAG,MAAK,aAAe,KACZ,KAAK,WAEL,KAAK,WAAW,QAO3B,OAAe,CACf,MAAO,MAAK,WAAW,KAGR,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEb,AAAG,IAAa,gBACb,IAAa,iBACb,IAAa,kBACb,IAAa,kBAEjB,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,IAAa,gBACjB,MAAK,OAAS,IAGH,sBAAsB,EAAmB,CAExD,AAAG,KAAK,aAAe,MACnB,MAAK,WAAW,KAAO,KAAK,cAEhC,KAAK,WAAW,KAAO,KAAK,aAC5B,KAAK,WAAW,WAAa,KAAK,eAClC,KAAK,WAAW,YAAc,KAAK,gBAGhC,KAAK,WAAW,OACf,MAAK,OAAS,GACd,KAAK,aAAe,IAIT,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CACvH,KAAK,WAAW,SAAW,KAAK,SAAW,EAAW,IACnD,KAAK,WAAW,OACf,MAAK,OAAS,IAElB,KAAK,MAAQ,KAAK,IAAI,KAAK,IAAI,KAAK,WAAW,MAAO,GAAW,GACjE,KAAK,OAAS,KAAK,IAAI,KAAK,IAAI,KAAK,WAAW,OAAQ,GAAY,GAGrD,eAAe,EAA+B,EAAwB,CAErF,AAAI,KAAK,UACL,GAAI,OACJ,EAAI,YACJ,EAAI,KAAK,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAC1C,EAAI,QAIR,KAAK,WAAW,MAAM,EAAK,KAAK,aAAc,KAAK,EAAG,KAAK,GAGvD,KAAK,UACL,EAAI,YA9GZ,GADC,GACD,AAdG,GAcH,wBCpBG,oBAAyB,GAAoB,CAEhD,YAAY,EAA2B,EAAgC,KAAM,EAAmC,CAC5G,GAAM,GAAwC,KAAI,GAElD,EAAqB,mBAAkC,CACnD,WAAY,EAAU,OAAQ,SAAU,EAAU,SAGtD,GAAM,GAAQ,GAAI,IAAM,EAAM,GAC9B,EAAM,SAAW,GACjB,MAAM,EAAO,EAAU,KCXxB,oBAA8B,GAAiC,CAQlE,YAAY,EAAe,EAA0B,KAAM,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC3J,AAAG,IAAa,MACZ,GAAW,GAEf,YAAoB,CAChB,MAAG,GAAW,MACP,IAAa,KACL,EAEA,EAGJ,EAGf,MACI,GAAI,IACA,EAAU,IAAM,EAAW,SAAS,KAAa,GAErD,CAAC,EAAU,IAAU,EAAW,KAChC,GAGJ,KAAK,KAAO,IClCb,oBAA8D,GAAU,CAW3E,IAAI,EAA8B,CAC9B,GAAG,MAAM,QAAQ,GACb,OAAU,KAAS,GACf,KAAK,UAAU,KAAK,GACpB,EAAM,eAAiB,KAAK,mBAIhC,MAAK,UAAU,KAAK,GACpB,EAAS,eAAiB,KAAK,eAGnC,YAAK,aAAe,GACpB,KAAK,OAAS,GACP,KAWX,OAAO,EAA8B,CACjC,GAAG,MAAM,QAAQ,GACb,OAAU,KAAS,GAAU,CACzB,GAAM,GAAM,KAAK,UAAU,QAAQ,GACnC,AAAG,IAAQ,IACP,KAAK,UAAU,OAAO,EAAK,OAGlC,CACD,GAAM,GAAM,KAAK,UAAU,QAAQ,GACnC,AAAG,IAAQ,IACP,KAAK,UAAU,OAAO,EAAK,GAGnC,YAAK,aAAe,GACpB,KAAK,OAAS,GACP,KAUX,eAAsB,CAClB,YAAK,UAAU,OAAS,EACxB,KAAK,aAAe,GACpB,KAAK,OAAS,GACP,OC1DR,oBAAwD,GAAe,CAW1E,YAAY,EAAmB,EAAmC,CAG9D,MAAM,GAAI,GAAO,GAAM,GAZnB,qBAAkB,GAIlB,iBAAc,EAEd,uBAAoB,EAQxB,KAAK,SAAW,EAGD,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,gBAAkB,IAEtB,AAAG,IAAa,aACjB,KAAK,gBAAkB,GACtB,AAAG,IAAa,0BACjB,KAAK,aAAe,GAChB,IAAa,yBACjB,MAAK,aAAe,IAGT,YAAY,EAAc,EAA2B,CAEpE,OAAU,KAAS,MAAK,SAAU,CAE9B,GAAG,CAAC,EAAM,QACN,SAGJ,GAAM,GAAW,EAAM,cAAc,EAAO,GAC5C,GAAG,IAAa,KACZ,MAAO,GAIf,MAAO,MAGQ,sBAAsB,EAAkB,CAEvD,OAAU,KAAS,MAAK,SACpB,EAAM,gBAAgB,GAGnB,EAAM,aACL,MAAK,aAAe,IAIb,uBAAuB,EAAkB,CAExD,OAAU,KAAS,MAAK,SACpB,EAAM,iBAAiB,GAGpB,EAAM,OACL,MAAK,OAAS,IAIP,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAGvH,GAAI,GAAY,EAAG,EAAc,EAAG,EAAe,EAC7C,EAAY,KAAK,SAAW,EAAY,EAG9C,AAAG,AADe,KAAK,wBACV,QAAU,EAAU,SAC7B,GAAe,KAAK,SAAW,EAAW,EACvC,GAAgB,KACf,GAAe,KAAK,SAAW,EAAW,IAGlD,KAAK,kBAAoB,EACzB,OAAU,KAAS,MAAK,SAAU,CAE9B,GAAG,CAAC,EAAM,QACN,SAEJ,KAAK,oBAEL,GAAM,CAAC,EAAe,GAAkB,EAAM,WAE9C,AAAG,KAAK,SACJ,EAAM,kBAAkB,EAAc,EAAU,EAAG,KAEnD,EAAM,kBAAkB,EAAG,IAAU,EAAc,GAEvD,GAAM,CAAC,EAAY,GAAe,EAAM,WAExC,GAAa,EAAM,KACnB,EAAc,KAAK,IAAI,KAAK,SAAW,EAAa,EAAa,GAG9D,KAAe,GAAiB,IAAgB,IAC/C,MAAK,gBAAkB,IAI/B,GAAM,GAAiB,KAAK,SAAW,EAAW,EAClD,AAAG,EAAc,GACb,GAAc,GAGlB,GAAM,GAAU,KAAK,sBACjB,EAAY,KAAK,IAAI,KAAK,kBAAoB,EAAG,GAAK,EAC1D,OAAU,KAAS,MAAK,SAEpB,AAAG,CAAC,EAAM,SAGV,IAAa,KAAK,SAAW,EAAM,WAAW,GAAK,EAAM,WAAW,IAGxE,GAAM,GAAY,EAAY,EAI9B,GAAG,GAAa,KAAY,GAAa,EAAG,CACxC,GAAM,GAAW,KAAK,MAChB,EAAY,KAAK,OAEvB,AAAG,KAAK,SACJ,MAAK,MAAQ,EACb,KAAK,OAAS,KAAK,IAAI,EAAW,IAGlC,MAAK,MAAQ,KAAK,IAAI,EAAW,GACjC,KAAK,OAAS,GAIf,MAAK,QAAU,GAAY,KAAK,SAAW,IAC1C,MAAK,gBAAkB,IAG3B,KAAK,YAAc,EAKnB,GAAI,GAAY,EAChB,OAAU,KAAS,MAAK,SAAU,CAE9B,GAAG,CAAC,EAAM,QACN,SAEJ,GAAM,CAAC,EAAe,IAAkB,EAAM,WAE9C,GAAG,KAAK,SAAU,CACd,GAAM,IAAe,KAAK,IAAI,EAAW,IACzC,EAAM,kBAAkB,EAAc,EAAU,GAAc,QAE7D,CACD,GAAM,IAAe,KAAK,IAAI,EAAW,GACzC,EAAM,kBAAkB,GAAc,GAAc,EAAc,GAGtE,GAAM,CAAC,EAAY,IAAe,EAAM,WAGxC,AAAG,KAAe,GAAiB,KAAgB,KAC/C,MAAK,gBAAkB,IAE3B,GAAM,IAAc,KAAK,SAAW,GACA,EACpC,EAAY,KAAK,IAAI,EAAG,EAAY,GAAc,GAGtD,OAKJ,GAAI,GAAiB,EACjB,EAAmB,EACvB,AAAG,EAAY,GACX,GAAmB,EAAY,GAEnC,OAAU,KAAS,MAAK,SAAU,CAE9B,GAAG,CAAC,EAAM,QACN,SAGJ,AAAG,IAAmB,GAClB,IAAkB,GAEtB,GAAM,GAAiB,EAAmB,EAAM,KAC1C,CAAC,EAAe,GAAkB,EAAM,WAC9C,GAAG,KAAK,SAAU,CACd,GAAM,GAAe,EAAiB,EACtC,EAAM,kBACF,EAAc,EACd,EAAc,OAGjB,CACD,GAAM,GAAe,EAAiB,EACtC,EAAM,kBACF,EAAc,EACd,EAAc,GAItB,GAAM,CAAC,EAAY,IAAe,EAAM,WACxC,GAAkB,KAAK,SAAW,GAAc,EAG7C,KAAe,GAAiB,KAAgB,IAC/C,MAAK,gBAAkB,IAI/B,GAAM,GAAW,KAAK,MAChB,EAAY,KAAK,OAEnB,EACJ,AAAG,KAAK,SACJ,GAAS,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,GAGd,GAAS,EACT,KAAK,MAAQ,EACb,KAAK,OAAS,GAIf,MAAK,QAAU,GAAY,KAAK,SAAW,IAC1C,MAAK,gBAAkB,IAI3B,KAAK,YAAc,KAAK,IAAI,EAAS,EAAgB,GAGtC,uBAA8B,CAE7C,GAAM,GAAY,KAAK,wBACjB,EAAS,EAAU,OAAS,EAAc,YAC1C,EAAU,EAAU,OAAS,EAAc,cAAgB,EAE3D,EAAa,EAAU,EAAI,EAAU,KACrC,EAAc,EAAU,QAAU,EAAU,QAAU,EAAI,EAAU,MACpE,EAAoB,KAAK,kBAAoB,EAAK,GAAS,EAAI,GACjE,EACJ,AAAG,GAAqB,EACpB,EAAe,EAEf,EAAe,KAAK,YAAc,EAEtC,GAAI,GAAU,KAAK,sBACnB,AAAG,GACC,IAAW,GAEf,GAAI,GAAc,MAAK,SAAW,KAAK,EAAI,KAAK,GAAK,EAAY,KAAK,YACtE,AAAG,GACC,IAAc,GAElB,OAAU,KAAS,MAAK,SAAU,CAE9B,GAAG,CAAC,EAAM,QACN,SAEJ,GAAM,CAAC,EAAW,GAAa,EAAM,SAC/B,CAAC,EAAY,GAAe,EAAM,WAExC,AAAG,KAAK,SACJ,GAAM,gBAAgB,KAAK,EAAI,EAAc,MAAK,MAAQ,GAAa,GACvE,GAAc,EAAc,GAG5B,GAAM,gBAAgB,EAAY,KAAK,EAAI,EAAc,MAAK,OAAS,IACvE,GAAc,EAAa,GAG/B,GAAM,CAAC,EAAQ,GAAU,EAAM,SAG/B,AAAG,KAAW,GAAa,IAAW,IAClC,MAAK,gBAAkB,KAIhB,eAAe,EAA+B,EAAuB,CAEpF,GAAM,GAAgD,GACtD,OAAU,KAAS,MAAK,SAEpB,AAAG,CAAC,EAAM,SAIV,GAAM,MAAM,EAAK,GAGd,MAAK,iBAAmB,IACvB,EAAU,KAAK,KAAK,UAAU,GAAG,EAAM,SAAU,GAAG,EAAM,cAIlE,GAAG,KAAK,iBAAmB,EAAQ,CAC/B,KAAK,WAAW,GAChB,EAAI,KAAK,GAAG,KAAK,UAAU,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,SAC5D,OAAU,KAAY,GAClB,EAAI,KAAK,GAAG,GAChB,KAAK,SAAS,EAAK,WAGvB,KAAK,gBAAkB,KC9UxB,oBAA6C,GAAkB,CAElE,YAAY,EAAmC,CAC3C,MAAM,GAAO,KC4Cd,oBAA4B,GAAgB,CAW/C,YAAY,EAAoC,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAChJ,MAAM,GAEN,OAAU,KAAS,GACf,GAAG,MAAO,IAAU,WAAY,CAE5B,GAAM,GAAmB,EACzB,KAAK,IAAI,EAAiB,EAAY,YAElC,MAAO,GAAM,IAAO,UAAY,MAAO,GAAM,IAAO,SAAU,CAElE,GAAM,GAAS,EAAM,GACf,EAAY,EAAM,GACxB,OAAQ,GAAI,EAAG,EAAI,EAAO,OAAQ,IAAK,CACnC,GAAI,GAAW,KACf,AAAG,EAAI,EAAU,QACb,GAAW,EAAU,IAEzB,KAAK,IAAI,GAAI,IACT,EAAO,GACP,EACA,EACA,EACA,EACA,EACA,SAKR,MAAM,IAAI,OAAM,sDAAsD,OCnF/E,mBAAyB,GAAiC,CAO7D,YAAY,EAA2B,EAAsB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CACrI,MACI,GAAI,IAAW,EAAM,EAAU,GAC/B,CAAC,EAAU,IAAU,EAAW,KAChC,GAGJ,KAAK,KAAO,IClBb,mBAA8B,EAAW,CAQ5C,YAAY,EAA2B,EAAiB,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CACxJ,MACI,EACA,IAAM,EAAW,SAAS,GAC1B,EACA,EACA,EACA,KChBL,oBAA2B,EAAgB,CAE9C,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MAAM,YAAa,YAAa,EAAY,EAAM,EAAU,EAAW,KCHxE,oBAAwB,EAAgB,CAE3C,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MAAM,MAAO,SAAU,EAAY,EAAM,EAAU,EAAW,KCH/D,oBAAuB,EAAgB,CAE1C,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MAAM,QAAS,QAAS,EAAY,EAAM,EAAU,EAAW,KCFhE,oBAAuB,EAAW,CAErC,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MACI,QACA,IAAM,CACF,EAAW,MAAQ,CAAC,EAAW,MAC/B,KAAK,MAAM,OAAS,EAAW,MAC/B,EAAW,SAAS,UAExB,EACA,EACA,EACA,GAGJ,KAAK,MAAM,OAAS,EAAW,QCjBhC,oBAAuB,EAAgB,CAE1C,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MAAM,QAAS,IAAK,EAAY,EAAM,EAAU,EAAW,KCH5D,oBAAgD,GAAkB,CAErE,YAAY,EAAmC,CAC3C,MAAM,GAAM,KCWpB,YAA0B,EAAwB,EAA6C,CAC3F,MAAO,IAAI,IACP,EAAY,OAAW,OAAW,OAAW,GAIrD,YAA0B,EAAwB,EAA6C,CAC3F,MAAO,IAAI,IACP,EAAY,OAAW,OAAW,OAAW,GAIrD,YAA8B,EAAwB,EAAiD,CACnG,MAAO,IAAI,IACP,EAAY,OAAW,OAAW,OAAW,GAIrD,YAA0B,EAAwB,EAA6C,CAC3F,MAAO,IAAI,IACP,EAAY,OAAW,OAAW,OAAW,GAIrD,YAA2B,EAAwB,EAA8C,CAC7F,MAAO,IAAI,IACP,EAAY,OAAW,OAAW,OAAW,GAU9C,GAAM,IAA0D,CAEnE,CAAC,CAAC,gBAAiB,kBAEnB,CAAC,CAAC,iBAAkB,kBAEpB,CAAC,CAAC,cAAgB,eAAgB,IAElC,CAAC,GAAkB,CAAC,aAAc,eAElC,CAAC,GAAsB,GAAkB,KActC,gBAA8B,GAAO,CASxC,YAAY,EAAgC,EAA4C,GAAgC,EAAY,EAAG,EAAY,GAAI,EAAa,GAAI,EAAmC,CACvM,GAAM,GAAwC,KAAI,GAElD,EAAqB,wBAA2C,CAC5D,KAAM,EAAc,aAAc,MAAO,EAAU,SAGvD,MAAM,GAGN,GAAM,GAAyB,CAC3B,SAAU,AAAC,GAAgB,CACvB,EAAe,SACX,EACA,EAAW,MACX,EAAW,KACX,EAAW,MAGnB,MAAO,GACP,KAAM,GACN,IAAK,IAGT,OAAU,KAAe,GACrB,KAAK,IAAI,GAAI,IACT,EAAa,EAAY,EAAW,EAAW,EAC/C,MC3GT,mBAAmD,GAAiB,CAEvE,YAAY,EAAU,EAAmC,CACrD,MAAM,EAAO,GAAM,KCGpB,mBAAgD,EAAa,CAEhE,YAAY,EAAU,EAAmC,CACrD,GAAM,GAAwC,KAAI,GAElD,EAAqB,mBAAkC,CACnD,WAAY,EAAU,OAAQ,SAAU,EAAU,QAGtD,MAAM,EAAO,KCZd,oBAAqC,GAAQ,CAiBhD,YAAY,EAAgC,EAA4C,GAAgC,EAAe,GAAI,GAAS,CAChJ,MACI,GAAI,GACA,GAAI,IAAgB,EAAgB,IAExC,GAEJ,KAAK,eAAiB,EAejB,QAAe,CAEpB,KAAK,QAAU,KAAK,eAAe,mBAAqB,KAGxD,MAAM,WC3CP,oBAAkC,GAAK,CAgB1C,YAAY,EAAgC,EAA4C,GAAgC,EAAkD,KAAM,EAAe,GAAI,GAAS,CACxM,MACI,GAAI,GACA,GAAI,IAAgB,EAAgB,IAExC,EAAqB,GAEzB,KAAK,eAAiB,EAQ1B,kBAAyB,CAErB,KAAK,QAAU,KAAK,eAAe,mBAAqB,OCrCzD,oBAAgC,GAAc,CASjD,YAAY,EAAa,EAAgB,EAAe,EAAc,EAAuB,CACzF,MAAM,EAAO,EAAM,EAAK,EAAQ,EAAU,SAAU,IACpD,KAAK,IAAM,ICbZ,oBAAyB,GAAS,CACrC,gBAAgB,EAAmC,CAC/C,MAAO,IAAI,IAAW,KAAK,IAAK,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KCFlE,mBAAuB,GAAS,CACnC,gBAAgB,EAAiC,CAC7C,MAAO,IAAI,GAAS,KAAK,IAAK,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KCIhE,YAAuC,CAAvC,aAhBP,CAkBY,iBAA0C,GAAI,KAE9C,cAAwB,GAAI,KAE5B,WAAqB,KAOrB,cAAc,EAA2C,CAC7D,GAAG,IAAS,KACR,MAAO,MAEX,GAAM,GAAa,KAAK,YAAY,IAAI,GACxC,MAAG,OAAO,IAAe,YACd,KAEJ,EAWD,kBAAkB,EAAyB,CACjD,AAAG,KAAK,QAAU,MACd,KAAK,MAAM,WAAW,EAAU,UAEpC,KAAK,MAAQ,EACb,KAAK,SAAS,QAQlB,gBAA8B,CAC1B,MAAO,MAAK,MAOhB,YAAmB,CACf,KAAK,kBAAkB,MAW3B,QAAQ,EAAa,EAAgB,EAAe,EAAoB,CACpE,KAAK,SAAS,IAAI,GAClB,GAAM,GAAa,KAAK,cAAc,KAAK,OAC3C,AAAG,IAAe,MACd,EAAW,KAAK,GAAI,GAAS,EAAK,EAAO,EAAM,EAAK,OAW5D,MAAM,EAAa,EAAgB,EAAe,EAAoB,CAClE,GAAG,KAAK,SAAS,OAAO,GAAM,CAC1B,GAAM,GAAa,KAAK,cAAc,KAAK,OAC3C,AAAG,IAAe,MACd,EAAW,KAAK,GAAI,IAAW,EAAK,EAAO,EAAM,EAAK,QAalE,SAAS,EAAa,EAAgB,EAAe,EAAoB,CACrE,GAAM,GAAU,KAAK,UAAU,GAC/B,KAAK,QAAQ,EAAK,EAAO,EAAM,GAC3B,GACA,KAAK,MAAM,EAAK,EAAO,EAAM,GAUrC,UAAU,EAAsB,CAC5B,MAAO,MAAK,SAAS,IAAI,GAM7B,SAAS,EAAkB,CACvB,AAAI,KAAK,YAAY,IAAI,IACrB,KAAK,YAAY,IAAI,EAAM,IAOnC,UAAU,EAAkB,CACxB,AAAG,KAAK,YAAY,IAAI,IACpB,MAAK,YAAY,OAAO,GACrB,IAAS,KAAK,OACb,KAAK,cAQjB,OAAO,EAAkB,CACrB,GAAM,GAAa,KAAK,cAAc,GACtC,GAAG,IAAe,KAIlB,QAAU,KAAS,GACf,EAAK,cAAc,GAGvB,EAAW,OAAS,GAYxB,eAAe,EAAY,EAAsB,EAA+B,CAC5E,AAAG,IAAc,EAAU,UAG3B,CAAG,GAAQ,KAAK,MACT,IAAa,MACZ,KAAK,aAEL,IAAa,MACjB,KAAK,kBAAkB,IAI/B,uBAAuB,EAAa,EAAuB,EAA6B,EAAmC,IC3L/H,GAAM,IAAuB,GAAI,KAAI,CACjC,YAAa,YAAa,aAAc,UAAW,MAAO,OAC1D,WAAY,SAAU,MAAO,MAGjC,YAA6B,EAAkF,CAC3G,MAAO,CAAC,EAAM,IAAK,EAAM,SAAU,EAAM,QAAS,EAAM,QAYrD,oBAAgC,GAAe,CAA/C,aArBP,CAqBO,oBAEK,cAA6B,GAAI,KAOzC,YAAY,EAAsB,EAAe,GAAY,CAEzD,AAAG,KAAK,SAAS,IAAI,IAGrB,MAAK,SAAS,IAAI,GAIf,GACC,GAAQ,iBAAiB,UAAW,AAAC,GAAU,CAxC3D,QAyCgB,AAAG,GAAqB,IAAI,EAAM,MAE3B,AADkB,YAAK,mBAAL,cAAuB,SAAS,EAAU,YAA1C,OAAuD,QACxD,MAChB,EAAM,iBAGd,KAAK,QAAQ,GAAG,GAAoB,MAGxC,EAAQ,iBAAiB,QAAS,AAAC,GAAU,CACzC,KAAK,MAAM,GAAG,GAAoB,OAI1C,EAAQ,iBAAiB,OAAQ,AAAC,GAAU,CACxC,AAAG,KAAK,iBAAiB,EAAM,gBAC3B,KAAK,gBAWjB,iBAAiB,EAAwC,CACrD,MAAO,KAAc,MAAQ,CAAC,KAAK,SAAS,IAAI,KC3DjD,YAAgC,EAAmB,EAAwC,CAC9F,GAAM,GAAO,EAAQ,wBACrB,MAAO,CACF,GAAM,QAAU,EAAK,MAAQ,EAAK,MAClC,GAAM,QAAU,EAAK,KAAO,EAAK,QCHnC,mBAA0B,EAAa,CAE1C,YAAY,EAAW,EAAW,EAAgB,EAAe,EAAc,EAAwB,KAAM,CACzG,MAAM,EAAG,EAAG,EAAO,EAAM,EAAK,EAAQ,EAAU,SAGpD,cAAc,EAAiB,EAA8B,CACzD,MAAO,IAAI,GAAY,KAAK,EAAI,EAAS,KAAK,EAAI,EAAS,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KAAK,QAGrG,gBAAgB,EAAoC,CAChD,MAAO,IAAI,GAAY,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,KAAM,KAAK,IAAK,KCdzE,GAAK,GAAL,UAAK,EAAL,CAEH,mBAEA,2BAEA,6BANQ,WCsBL,YAAsC,CAAtC,aA9BP,CAoCc,YAAwC,GAAI,KAE9C,mBAAgB,EAOd,WAAkC,GAAI,KAIxC,kBAAqC,GAAI,KAGzC,gBAAgB,EAAY,EAA2B,CAE3D,AAAG,EAAM,UAAY,MACjB,KAAK,eAAe,EAAM,QAAS,EAAY,MAGnD,EAAM,QAAU,KACb,EAAM,UAEL,EAAM,WAAW,KACb,GAAI,GAAM,EAAK,iBAAiB,EAAU,WAGlD,EAAM,SAAW,GACjB,EAAM,SAAW,EACjB,EAAM,SAAW,KASrB,gBAAgB,EAAe,GAAe,CAC1C,GAAM,GAAQ,KAAK,gBACnB,YAAK,eAAe,EAAO,EAAY,MACvC,KAAK,aAAa,IAAI,EAAO,GACtB,EAUX,kBAAkB,EAAuB,CACrC,OAAU,CAAC,EAAM,IAAU,MAAK,OAE5B,AAAG,EAAM,UAAY,GACjB,KAAK,gBAAgB,EAAM,GAGnC,KAAK,MAAM,OAAO,GAClB,KAAK,aAAa,OAAO,GAUrB,cAAc,EAAY,EAAiB,EAA2B,EAAqC,CAE/G,GAAM,GAAc,EAAM,UAAY,KACtC,AAAG,GACC,GAAM,QAAU,GAIpB,GAAM,GAAiB,EAAM,UAAY,EACzC,GAAG,CAAC,GAAkB,EAClB,OAAU,CAAC,EAAW,IAAe,MAAK,OAEtC,AAAG,IAAc,GAId,EAAW,UAAY,GACtB,KAAK,gBAAgB,EAAW,GAM5C,MAAG,CAAC,GAAmB,EAAC,GAAqB,EAAM,SAAW,GACnD,GAIJ,IAAqB,EAAM,UAAY,GACtC,MAAK,gBAAgB,EAAM,GAC3B,EAAM,QAAU,GAGb,IAKP,kBAAkB,EAAY,EAAe,EAAiC,CAClF,GAAM,CAAC,EAAO,GAAU,EAAK,WAC7B,MAAO,CAAC,EAAQ,EAAO,EAAQ,GAqBnC,YAAY,EAAY,EAAiB,EAAe,EAAe,EAAyB,EAAgB,EAAe,EAAoB,CAC/I,GAAM,GAAQ,KAAK,OAAO,IAAI,GAU9B,GATG,MAAO,IAAU,aAKjB,KAAa,MACZ,GAAW,EAAM,UAGlB,CAAC,KAAK,cAAc,EAAM,EAAS,EAAO,EAAW,IACpD,OAGJ,EAAM,SAAW,GACjB,GAAM,CAAC,EAAG,GAAK,KAAK,kBAAkB,EAAM,EAAO,GACnD,GAAG,IAAa,EAAM,SAAU,CAE5B,GAAM,GAAO,KAAK,MAAM,KAAK,KAAK,KAAK,IAAI,EAAU,EAAM,YAG3D,OAAQ,GAAM,EAAG,GAAO,EAAM,IAAO,CACjC,GAAM,GAAe,GAAM,UAAY,EAAO,IAAS,EACjD,EAAc,IAAY,EAAO,IAAS,EAEhD,AAAG,IAAe,GAGlB,CAAG,EACC,EAAM,WAAW,KAAK,GAAI,GAAa,EAAG,EAAG,EAAK,EAAO,EAAM,IAE/D,EAAM,WAAW,KAAK,GAAI,GAAe,EAAG,EAAG,EAAK,EAAO,EAAM,KAGzE,EAAM,SAAW,MAGjB,GAAM,WAAW,KAAK,GAAI,GAAY,EAAG,EAAG,EAAO,EAAM,IAG7D,AAAG,EAAM,SAAW,EAChB,KAAK,eAAe,EAAS,EAAY,UAEzC,KAAK,eAAe,EAAS,EAAY,UASjD,aAAa,EAAY,EAAuB,CAC5C,GAAM,GAAQ,KAAK,OAAO,IAAI,GAC9B,AAAG,MAAO,IAAU,aAIjB,EAAM,UAAY,EAAM,SAAW,GAClC,GAAM,SAAW,GACjB,EAAM,SAAW,EACjB,EAAM,SAAW,KACjB,EAAM,WAAW,KACb,GAAI,GAAM,EAAK,iBAAiB,EAAU,WAE9C,KAAK,eAAe,EAAS,EAAY,OAWjD,gBAAgB,EAAuB,CACnC,OAAU,KAAQ,MAAK,OAAO,OAC1B,KAAK,aAAa,EAAM,GAgBhC,aAAa,EAAY,EAAiB,EAAe,EAAe,EAAgB,EAAgB,EAAgB,EAAe,EAAoB,CACvJ,GAAM,GAAQ,KAAK,OAAO,IAAI,GAK9B,GAJG,MAAO,IAAU,aAIjB,CAAC,KAAK,cAAc,EAAM,EAAS,EAAO,IACzC,OAGJ,EAAM,SAAW,GACjB,GAAM,CAAC,EAAG,GAAK,KAAK,kBAAkB,EAAM,EAAO,GACnD,EAAM,WAAW,KAAK,GAAI,GAAa,EAAG,EAAG,EAAQ,EAAQ,GAAO,EAAO,EAAM,IAU3E,eAAe,EAAiB,EAA4B,CAGlE,MAAG,AAFa,MAAK,MAAM,IAAI,KAEhB,EACX,MAAK,MAAM,IAAI,EAAS,GACjB,IAGA,GAUf,eAAe,EAA8B,CAhTjD,MAiTQ,MAAO,QAAK,MAAM,IAAI,KAAf,OAA2B,EAAY,KAMlD,SAAS,EAAkB,CAEvB,KAAK,OAAO,IAAI,EAA0B,CACtC,WAAY,GACZ,QAAS,KACT,SAAU,EACV,SAAU,GACV,SAAU,KACV,WAAY,CAAC,EAAG,KAQxB,UAAU,EAAkB,CAExB,EAAK,cAAc,GAAI,IAGvB,GAAM,GAAQ,KAAK,OAAO,IAAI,GAC9B,AAAG,MAAO,IAAU,aAAe,EAAM,UAAY,MACjD,MAAK,eAAe,EAAM,QAAS,EAAY,MAC/C,EAAM,SAAW,MAIrB,KAAK,OAAO,OAAO,GAOvB,OAAO,EAAkB,CACrB,GAAM,GAAQ,KAAK,OAAO,IAAI,GAC9B,GAAG,MAAO,IAAU,YAChB,OAGJ,GAAM,GAAe,EAAM,UAAY,KACb,GACA,KAAK,aAAa,IAAI,EAAM,SAGtD,OAAU,KAAS,GAAM,WAAY,CAGjC,GAAG,YAAiB,IAAgB,EAAM,WAAa,KAAM,CACzD,GAAM,CAAC,EAAQ,GAAU,EAAM,SAC/B,EAAK,cAAc,GAAI,GACnB,GAAG,EAAM,WACT,EAAS,EAAM,EAAG,EAAS,EAAM,EACjC,GAAO,GAAO,GAAO,KAGzB,AAAG,YAAiB,GAChB,EAAM,SAAW,KAEjB,GAAM,SAAS,GAAK,EAAM,EAC1B,EAAM,SAAS,GAAK,EAAM,GAG9B,SAKJ,AAAG,EAAK,cAAc,GAClB,EAAM,SAAW,KACb,GAAgB,YAAiB,IACrC,GAAM,SAAW,CAAC,EAAM,EAAG,EAAM,GACjC,EAAM,WAAW,GAAK,EAAM,EAC5B,EAAM,WAAW,GAAK,EAAM,GAKpC,EAAM,WAAW,OAAS,EAI9B,eAAe,EAAa,EAAuB,EAAgC,EAGnF,uBAAuB,EAAa,EAAuB,EAA6B,EAAmC,ICjY/H,YAAyB,EAAkE,CACvF,MAAO,CAAC,EAAM,SAAU,EAAM,QAAS,EAAM,QAU1C,oBAA+B,GAAc,CAmBhD,aAAc,CACV,QAjBI,cAAuC,GAAI,SAE3C,cAAgC,GAAI,KAiBxC,KAAK,eAAiB,KAAK,gBAAgB,IAU/C,YAAY,EAAY,EAA4B,CAChD,GAAI,GAAW,KAAK,SAAS,IAAI,GACjC,AAAG,MAAO,IAAa,YACnB,KAAK,gBAAgB,GAErB,GAAwB,CACpB,UACA,cAAe,KACf,mBAAoB,KACpB,YAAa,KACb,kBAAmB,MAEvB,KAAK,SAAS,IAAI,EAAM,GACxB,EAAQ,MAAM,YAAc,QAG7B,EAAK,SACJ,KAAK,aAAa,EAAM,GAOxB,aAAa,EAA6B,CAC9C,GAAI,GAAY,KAAK,SAAS,IAAI,EAAM,WAExC,MAAG,OAAO,IAAc,aAEpB,CADgB,EAAM,cAAgB,QAElC,EAAY,KAAK,eAEjB,EAAY,KAAK,gBAAgB,IAErC,KAAK,SAAS,IAAI,EAAM,UAAW,IAGhC,EAMH,aAAa,EAAY,EAAuB,CAGpD,GAAM,GAAU,EAAS,QACzB,EAAS,cAAgB,AAAC,GAAwB,CAC9C,KAAK,YACD,EAAM,KAAK,aAAa,GACxB,GAAG,GAAuB,EAAO,GACjC,EAAM,QACN,GAAG,GAAgB,KAG3B,EAAS,mBAAqB,AAAC,GAAwB,CACnD,KAAK,aAAa,EAAM,KAAK,aAAa,KAE9C,EAAS,YAAc,AAAC,GAAsB,CAC1C,GAAI,GAAS,EAAM,OACf,EAAS,EAAM,OACnB,AAAG,IAAW,GAAK,EAAM,iBAAiB,UACtC,GAAS,EACT,EAAS,GAGb,KAAK,aACD,EAAM,KAAK,eACX,GAAG,GAAuB,EAAO,GACjC,EAAM,OAAQ,EAAM,OACpB,GAAG,GAAgB,KAG3B,EAAS,kBAAoB,AAAC,GAAsB,CAEhD,EAAM,kBAIV,EAAQ,iBAAiB,cAAe,EAAS,eACjD,EAAQ,iBAAiB,cAAe,EAAS,eACjD,EAAQ,iBAAiB,YAAa,EAAS,eAC/C,EAAQ,iBAAiB,eAAgB,EAAS,oBAClD,EAAQ,iBAAiB,QAAS,EAAS,aAC3C,EAAQ,iBAAiB,cAAe,EAAS,mBAO7C,gBAAgB,EAAuB,CAC3C,AAAG,EAAS,gBAAkB,MAC1B,GAAS,QAAQ,oBAAoB,cAAe,EAAS,eAC7D,EAAS,QAAQ,oBAAoB,cAAe,EAAS,eAC7D,EAAS,QAAQ,oBAAoB,YAAa,EAAS,eAC3D,EAAS,cAAgB,MAE1B,EAAS,qBAAuB,MAC/B,GAAS,QAAQ,oBAAoB,eAAgB,EAAS,oBAC9D,EAAS,mBAAqB,MAE/B,EAAS,cAAgB,MACxB,GAAS,QAAQ,oBAAoB,QAAS,EAAS,aACvD,EAAS,YAAc,MAExB,EAAS,oBAAsB,MAC9B,GAAS,QAAQ,oBAAoB,cAAe,EAAS,mBAC7D,EAAS,kBAAoB,MAQ5B,SAAS,EAAkB,CAChC,MAAM,SAAS,GAIf,GAAM,GAAW,KAAK,SAAS,IAAI,GACnC,AAAG,MAAO,IAAa,aACnB,KAAK,aAAa,EAAM,GAOvB,UAAU,EAAkB,CACjC,MAAM,UAAU,GAIhB,GAAM,GAAW,KAAK,SAAS,IAAI,GACnC,AAAG,MAAO,IAAa,aACnB,KAAK,gBAAgB,KClL1B,oBAAwC,GAAc,CAAtD,aAdP,CAcO,oBAEgB,aAAiC,GAAI,KAsBxD,iBAAiB,EAAiB,EAAyB,EAAkC,EAAqC,EAAgB,EAAe,EAAoB,CAGjL,GAAM,CAAC,EAAM,EAAO,GAAS,KAAK,QAAQ,EAAQ,GAGlD,AAAG,IAAS,KACR,KAAK,gBAAgB,GAErB,KAAK,YAAY,EAAM,EAAS,EAAO,EAAO,EAAU,EAAO,EAAM,GAI7E,UAAU,EAAgC,CACtC,AAAI,KAAK,QAAQ,IAAI,IACjB,GAAO,oBAAoB,MAC3B,KAAK,QAAQ,IAAI,IAIN,eAAe,EAAiB,EAA4B,CAC3E,GAAM,GAAU,MAAM,eAAe,EAAS,GAG9C,OAAU,KAAU,MAAK,QACrB,EAAO,qBAAqB,EAAS,GAEzC,MAAO,KC/CR,WAAkB,CAcrB,YAAY,EAAiB,EAAuC,KAAM,CAVlE,YAAS,GAWb,KAAK,OAAS,EACd,KAAK,SAAW,KAQhB,QAAW,CACX,MAAO,MAAK,UAGZ,OAAM,EAAU,CAChB,KAAK,SAAS,MAId,QAAiB,CACjB,GAAM,GAAW,KAAK,OACtB,YAAK,OAAS,GACP,EAWX,SAAS,EAAU,EAAa,GAAY,CACxC,GAAG,KAAK,SAAW,GAGnB,MAAK,OAAS,EACd,KAAK,OAAS,GACX,GAAc,KAAK,WAAa,MAC/B,GAAI,CACA,KAAK,SAAS,SAEZ,EAAN,CACI,QAAQ,MAAM,iCAAkC,MClEzD,oBAAyB,EAAM,CAMlC,YAAY,EAAkB,GAAI,GAAS,CACvC,MAAM,OAAW,MAGR,aAAwB,CACjC,MAAO,IAAM,KAAK,MAAM,KAAK,SAAW,UAAU,SAAS,OAGlD,YAAW,EAA8B,CAClD,MAAM,WAAa,ICVpB,YAAsC,EAAqC,EAAiB,EAAuC,KAAuB,CAG7J,MAAO,AAAC,IAA2B,CAC/B,GAAI,GAAQ,GACR,EAAqB,EAEzB,OAAU,KAAa,GAEnB,GADA,CAAC,EAAO,GAAa,EAAU,GAC5B,CAAC,EACA,MAAO,CAAC,GAAO,GAGvB,GAAG,IAAa,KACZ,GAAI,CACA,EAAS,SAEP,EAAN,CACI,QAAQ,KAAK,4CAA6C,GAIlE,MAAO,CAAC,GAAM,IC5Bf,YAA8B,EAAiC,CAClE,MAAO,CAAC,GAAM,GAaX,YAA8C,EAA4C,KAA6B,CAC1H,MAAG,KAAa,KACL,GAEJ,AAAC,GACJ,GAAS,GACF,CAAC,GAAM,IC7BtB,GAAM,IAAa,oCAUZ,YAAwB,EAAiC,CAC5D,MAAI,IAAW,KAAK,GAGb,CAAC,GAAM,WAAW,IAFd,CAAC,GAAO,KCZvB,GAAM,IAAW,UAUV,YAAsB,EAAiC,CAC1D,MAAI,IAAS,KAAK,GAGX,CAAC,GAAM,SAAS,IAFZ,CAAC,GAAO,KCDhB,YAA+B,EAAQ,EAAyB,CAEnE,MAAO,AAAC,IACD,EAAQ,EACA,CAAC,GAAO,GAEhB,EAAQ,EACA,CAAC,GAAO,GAEZ,CAAC,GAAM,GCVf,oBAAqB,EAAW,CAEnC,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MACI,MACA,IAAM,CACF,EAAW,IAAM,CAAC,EAAW,IAC7B,KAAK,MAAM,OAAS,EAAW,IAC/B,EAAW,SAAS,QAExB,EACA,EACA,EACA,GAGJ,KAAK,MAAM,OAAS,EAAW,MChBhC,oBAAyB,EAAW,CAEvC,YAAY,EAAwB,EAAO,EAAG,EAAW,GAAI,EAAY,GAAI,EAAmC,CAC5G,MACI,OACA,IAAM,CACF,EAAW,KAAO,CAAC,EAAW,KAC9B,KAAK,MAAM,OAAS,EAAW,KAC/B,EAAW,SAAS,YAExB,EACA,EACA,EACA,GAGJ,KAAK,MAAM,OAAS,EAAW,OCMhC,oBAA2B,EAAO,CA6ErC,YAAY,EAA6B,EAAmD,KAAM,EAAe,GAAI,EAAmC,CAGpJ,MAAM,GAAO,GAAO,GA3EhB,gBAAa,EAKb,gBAA6B,KAE7B,eAAY,EAEZ,kBAAiC,CAAC,EAAG,GAErC,eAAY,EAEZ,kBAAiC,CAAC,EAAG,GAErC,uBAAoB,GAEpB,qBAAkB,GAO1B,cAAW,GAeH,YAAS,CAAC,EAAG,GAOrB,cAAW,GAQX,iBAAmD,KAE3C,cAAW,GAEX,eAAY,EAKZ,eAAY,GAMZ,0BAAkC,EAQtC,KAAK,WAAa,GAAI,GACtB,KAAK,SAAW,GAAI,GAAiB,EAAc,AAAC,GAAiB,CACjE,GAAM,CAAC,EAAO,GAAkB,EAAU,GAE1C,AAAG,GACC,MAAK,YAAc,GAEpB,IAAU,KAAK,QACd,MAAK,OAAS,EACd,KAAK,OAAS,MAGtB,CAAC,KAAK,OAAQ,KAAK,aAAe,EAAU,GAC5C,KAAK,YAAc,EAGJ,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEb,AAAG,IAAa,yBACb,IAAa,iBACb,IAAa,sBACb,IAAa,sBAEjB,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,KAAa,uBACb,IAAa,iBACb,IAAa,wBACb,IAAa,yBACb,IAAa,oBAEjB,MAAK,OAAS,OASlB,UAA0B,CAC1B,GAAG,KAAK,aAAe,EACnB,MAAO,MAEX,GAAM,GAAY,KAAK,UACvB,MAAO,MAAK,MAAQ,MAAK,MAAQ,KAAK,YAAe,KAAM,GAAc,KAAO,KAUhF,iBAA0B,CAC1B,MAAO,MAAK,mBAGZ,gBAAe,EAAyB,CACxC,AAAG,KAAK,kBAAoB,GACxB,MAAK,gBAAkB,EAGnB,GACA,MAAK,WAAa,EAClB,KAAK,aAAa,EAAG,KAIzB,KAAK,OAAS,OAKlB,MAAK,EAAc,CACnB,KAAK,SAAS,MAAQ,KAGtB,OAAe,CACf,MAAO,MAAK,SAAS,SAOrB,gBAAwB,CACxB,MAAG,MAAK,SACG,SAAI,OAAO,KAAK,SAAS,MAAM,QAE/B,KAAK,SAAS,SAIzB,QAAiB,CACjB,MAAO,MAAK,UAIZ,aAAgB,CAChB,MAAO,MAAK,eAIZ,OAAe,CACf,MAAO,MAAK,WAAW,QAAQ,KAAK,WAUxC,aAAa,EAAe,EAAuB,CAE/C,KAAK,UAAY,KAAK,IAAI,KAAK,IAAI,EAAO,GAAI,KAAK,KAAK,QAEpD,GACA,MAAK,UAAY,KAAK,WAG1B,KAAK,kBAAoB,GACzB,KAAK,OAAS,GAQlB,WAAW,EAAe,EAAuB,CAC7C,KAAK,aAAa,KAAK,UAAY,EAAO,GAU9C,qBAAqB,EAAiB,EAAiB,EAAuB,CAC1E,CAAC,KAAK,UAAW,KAAK,cAAgB,KAAK,WAAW,0BAClD,CAAE,EAAS,IAGX,GACA,MAAK,UAAY,KAAK,UACtB,KAAK,aAAe,KAAK,cAM7B,KAAK,WAAa,KAAK,MACvB,KAAK,OAAS,GAQlB,eAAe,EAAe,EAAuB,CACjD,KAAK,qBACD,KAAK,aAAa,GAClB,KAAK,aAAa,GAAM,IAAM,GAAS,KAAK,WAAW,eACvD,GAOR,gBAAgB,EAAuB,CACnC,KAAK,aAAa,KAAK,WAAW,aAAa,KAAK,MAAO,GAM/D,cAAc,EAAuB,CACjC,KAAK,aAAa,KAAK,WAAW,WAAW,KAAK,KAAM,IAAQ,GASpE,eAAe,EAAe,EAAuB,CACjD,GAAG,GAAS,EACR,OAEJ,GAAM,GAAY,KACZ,EAAO,KAAK,KACd,EAAY,KAAK,UAErB,GAAG,EAAQ,EACP,KAAM,EAAQ,GAAG,CACb,GAAI,GAAa,GACjB,KAAM,GAAa,EAAK,OAAQ,IAC5B,GAAG,EAAY,EAAK,QAAU,EAAU,KAAK,EAAK,IAC9C,EAAa,WACT,EACJ,MAGR,QAIJ,MAAM,EAAQ,GAAG,CACb,IACA,GAAI,GAAa,GACjB,KAAM,GAAa,EAAG,IAClB,GAAG,GAAa,GAAK,EAAU,KAAK,EAAK,IACrC,EAAa,WACT,EACJ,MAGR,IACA,IAIR,KAAK,aAAa,EAAW,GASjC,YAAY,EAAe,EAAmB,CAC1C,AAAG,IAAU,GAIb,MAAK,KAAO,KAAK,KAAK,UAAU,EAAG,GAAS,KAAK,KAAK,UAAU,GAGhE,KAAK,UAAY,KAAK,UAAY,EAClC,KAAK,kBAAoB,IAS7B,WAAW,EAAqB,CAC5B,GAAG,IAAU,EACT,OAGJ,GAAG,KAAK,YAAc,KAAK,UAAW,CAClC,KAAK,YACD,KAAK,IAAI,KAAK,UAAW,KAAK,WAC9B,KAAK,IAAI,KAAK,UAAW,KAAK,YAElC,OAIJ,GAAM,GAAS,KAAK,UACpB,KAAK,eAAe,EAAO,IAGxB,IAAW,KAAK,WACf,KAAK,YACD,KAAK,IAAI,EAAQ,KAAK,WACtB,KAAK,IAAI,EAAQ,KAAK,YASlC,WAAW,EAAmB,CAE1B,GAAG,OAAK,cAAgB,MAAQ,CAAC,KAAK,YAAY,IAGlD,GAAG,KAAK,YAAc,KAAK,UAEvB,KAAK,KAAO,KAAK,KAAK,UAAU,EAAG,KAAK,WAAa,EAAM,KAAK,KAAK,UAAU,KAAK,WAEpF,KAAK,WAAW,EAAI,OAAQ,QAE3B,CACD,GAAM,GAAQ,KAAK,IAAI,KAAK,UAAW,KAAK,WACtC,EAAM,KAAK,IAAI,KAAK,UAAW,KAAK,WAG1C,KAAK,KAAO,KAAK,KAAK,UAAU,EAAG,GAAS,EAAM,KAAK,KAAK,UAAU,GAEtE,KAAK,aAAa,EAAQ,EAAI,OAAQ,KAa9C,WAAW,EAAqB,CAC5B,AAAG,IAAU,GAGb,CAAG,KAAK,YAAc,KAAK,UAEvB,KAAK,YACD,KAAK,IAAI,KAAK,UAAW,KAAK,WAC9B,KAAK,IAAI,KAAK,UAAW,KAAK,YAGjC,AAAG,EAAQ,EAEZ,KAAK,KAAO,KAAK,KAAK,UAAU,EAAG,KAAK,WAAa,KAAK,KAAK,UAAU,KAAK,UAAY,GAM1F,MAAK,KAAO,KAAK,KAAK,UAAU,EAAG,KAAK,UAAY,GAAS,KAAK,KAAK,UAAU,KAAK,WACtF,KAAK,WAAW,EAAO,MAUvB,cAAc,EAA+B,CACjD,GAAM,GAAO,KAAK,KACZ,EAAY,KACZ,EAAS,EAAU,KAAK,EAAK,IAC7B,EAAS,EAGf,KAAM,GAAO,GACN,EAAU,KAAK,EAAK,MAAU,EADrB,IACZ,CAIJ,GAAM,GAAW,EAAM,EAIvB,IADA,EAAM,EACA,EAAM,EAAK,QACV,EAAU,KAAK,EAAK,MAAU,EADZ,IACrB,CAIJ,MAAO,CAAC,EAAU,GAGb,eAAe,EAAsB,EAAmB,CAG7D,AAAG,IAAc,EAAU,UACvB,MAAK,WAAa,GAGP,YAAY,EAAc,EAAyB,CAElE,GAAG,CAAC,KAAK,gBACL,MAAO,MAEX,GAAG,YAAiB,GAGhB,YAAK,SAAW,GAChB,KAAK,UAAY,EACV,KAEN,GAAG,YAAiB,GAErB,MAAO,MAEN,GAAG,YAAiB,GAAc,CAMnC,GAJA,EAAK,aAAe,OAIjB,YAAiB,IAAgB,YAAiB,GAAa,CAC9D,GAAM,GAAU,YAAiB,IAAgB,EAAM,UACvD,GAAG,EAAS,CACR,KAAK,SAAW,GAChB,GAAM,GAAa,GAAI,QAAQ,UAI/B,AAAG,EAAY,KAAK,UAAY,IAC5B,MAAK,uBAGF,KAAK,qBAAuB,GAC3B,MAAK,qBAAuB,IAGhC,KAAK,qBAAuB,EAEhC,KAAK,UAAY,UAEb,CAAC,KAAK,SACV,MAAO,MAGX,GAAM,GAAU,KAAK,sBAgBrB,GAfA,KAAK,qBACD,EAAM,EAAI,KAAK,EAAI,EAAU,KAAK,OAAO,GACzC,EAAM,EAAI,KAAK,EAAI,EAAU,KAAK,OAAO,GACzC,CAAC,GAAW,KAAK,UAGlB,GAGI,MAAK,YAAc,KAAK,WACvB,MAAK,qBAAuB,GAEhC,KAAK,UAAY,KAAK,WAGvB,KAAK,qBAAuB,EAAG,CAC9B,GAAI,GAAO,EAEX,GAAG,KAAK,uBAAyB,EAAG,CAKhC,GAAM,CAAC,EAAa,GAAa,KAAK,cAAc,KAAK,WACnD,CAAC,EAAU,GAAU,KAAK,cAAc,KAAK,WACnD,EAAQ,KAAK,IAAI,EAAa,GAC9B,EAAM,KAAK,IAAI,EAAW,OAEzB,CAED,GAAM,GAAW,KAAK,IAAI,KAAK,UAAW,KAAK,WACzC,EAAY,KAAK,WAAW,QAAQ,GAC1C,EAAQ,KAAK,WAAW,aAAa,GAErC,GAAM,GAAS,KAAK,IAAI,KAAK,UAAW,KAAK,WACvC,EAAU,KAAK,WAAW,QAAQ,GAGxC,EAAM,KAAK,WAAW,WAAW,GAKrC,AAAG,KAAK,WAAa,KAAK,UACtB,MAAK,UAAY,EACjB,KAAK,UAAY,GAGjB,MAAK,UAAY,EACjB,KAAK,UAAY,GAGrB,KAAK,kBAAoB,GAI7B,EAAK,aAAa,EAAU,SAAU,UAErC,AAAG,aAAiB,IAAkB,EAAM,WAE7C,MAAK,SAAW,GAGb,EAAK,oBACJ,EAAK,aAAa,KAAK,MAAM,KAAK,AAAC,GAA4B,CAC3D,AAAG,IAAa,MAGb,KAAK,OAAS,GACb,MAAK,KAAO,EACZ,KAAK,aAAa,EAAS,OAAQ,QAMnD,MAAO,cAEH,YAAiB,GAAU,CAM/B,GAJA,KAAK,SAAW,GAChB,KAAK,UAAY,EAGd,EAAM,IACL,MAAO,MAGX,GAAG,EAAM,KAAM,CACX,GAAG,EAAM,MAAQ,YACb,KAAK,WAAW,YACZ,EAAM,MAAQ,SAClB,KAAK,WAAW,WACZ,EAAM,MAAQ,YAClB,KAAK,eAAe,GAAI,EAAM,eAC1B,EAAM,MAAQ,aAClB,KAAK,eAAe,EAAG,EAAM,eACzB,EAAM,MAAQ,KAAO,EAAM,MAAQ,IAAK,CAE5C,GAAG,KAAK,YAAc,KAAK,UACvB,MAAO,MAEX,GAAM,GAAe,KAAK,KAAK,MAC3B,KAAK,IAAI,KAAK,UAAW,KAAK,WAC9B,KAAK,IAAI,KAAK,UAAW,KAAK,YAGlC,GAAG,UAAU,UACT,UAAU,UAAU,UAAU,OAE9B,OAAO,UAGX,OAAO,MAGX,YAAK,WAAa,KAAK,MAChB,KAIX,GAAG,EAAM,IAAI,SAAW,EACpB,KAAK,WAAW,EAAM,aAClB,EAAM,MAAQ,YAClB,KAAK,WAAW,YACZ,EAAM,MAAQ,SAClB,KAAK,WAAW,WACZ,EAAM,MAAQ,YAClB,KAAK,WAAW,GAAI,EAAM,eACtB,EAAM,MAAQ,aAClB,KAAK,WAAW,EAAG,EAAM,eACrB,EAAM,MAAQ,UAClB,KAAK,eAAe,GAAI,EAAM,eAC1B,EAAM,MAAQ,YAClB,KAAK,eAAe,EAAG,EAAM,eACzB,EAAM,MAAQ,SAClB,KAAK,eAAe,GAAI,EAAM,eAC1B,EAAM,MAAQ,WAClB,KAAK,eAAe,EAAG,EAAM,eACzB,EAAM,MAAQ,OAClB,KAAK,gBAAgB,EAAM,eACvB,EAAM,MAAQ,MAClB,KAAK,cAAc,EAAM,WACxB,IAAG,EAAM,MAAQ,SAClB,SAAK,UAAU,EAAU,SAAU,MAC5B,KAEN,GAAG,EAAM,MAAQ,QAClB,KAAK,WAAW;AAAA,WACZ,EAAM,MAAQ,MAClB,KAAK,WAAW,SAEhB,OAAO,MAGX,KAAK,WAAa,KAAK,UAEtB,AAAG,aAAiB,IAAkB,EAAM,SAAW,MAExD,MAAK,WAAW,EAAM,MAGtB,KAAK,WAAa,KAAK,OAG3B,MAAO,MAGQ,sBAAsB,EAAkB,CAEvD,AAAI,KAAK,gBACL,EAAK,UAAU,EAAU,SAAU,MAGpC,KAAK,UAAY,KAAK,YACrB,MAAK,OAAS,IAGlB,KAAK,WAAW,KAAO,KAAK,cAC5B,KAAK,WAAW,KAAO,KAAK,cAC5B,KAAK,WAAW,WAAa,KAAK,gBAClC,KAAK,WAAW,YAAc,KAAK,iBAEhC,KAAK,mBACJ,MAAK,aAAe,KAAK,WAAW,oBAAoB,KAAK,WAE7D,AAAG,KAAK,YAAc,KAAK,UACvB,MAAK,aAAa,GAAK,KAAK,aAAa,GACzC,KAAK,aAAa,GAAK,KAAK,aAAa,IAGzC,KAAK,aAAe,KAAK,WAAW,oBAAoB,KAAK,WAEjE,KAAK,kBAAoB,IAI1B,KAAK,WAAW,OACf,MAAK,OAAS,GACd,KAAK,aAAe,IAIT,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAGvH,GAAM,GAAU,EAAI,KAAK,sBACzB,KAAK,WAAW,SAAW,KAAK,SAAW,KAAK,IAAI,EAAW,EAAS,GAAK,IAC1E,KAAK,WAAW,OACf,MAAK,OAAS,IAElB,GAAM,GAAoB,KAAK,IAAI,KAAK,IAAI,KAAK,kBAAmB,GAAW,GAC/E,KAAK,MAAQ,KAAK,IAAI,KAAK,IAAI,EAAmB,KAAK,WAAW,MAAQ,GAAU,GACpF,KAAK,OAAS,KAAK,IAAI,KAAK,IAAI,EAAW,KAAK,WAAW,OAAS,GAAU,GAG/D,uBAAuB,EAAmB,CAEzD,GAAM,GAAU,KAAK,sBACf,EAAa,KAAK,WAAW,MAC7B,EAAc,KAAK,WAAW,OAC9B,EAAc,KAAK,MAAQ,EAAU,EACrC,EAAe,KAAK,OAAS,EAAU,EACvC,EAAkB,KAAK,OACvB,CAAC,EAAS,GAAW,KAAK,aAEhC,GAAG,EAAa,EAAa,CAEzB,GAAM,GAAW,KAAK,IAAI,GAAI,EAAc,GACtC,EAAO,EAAgB,GAAK,EAC5B,EAAQ,EAAgB,GAAK,EAAc,EAGjD,AAAG,EAAU,GACT,GAAgB,IAAM,EAAU,GAGjC,EAAU,GACT,GAAgB,IAAM,EAAO,GAG9B,EAAgB,GAAK,EAAc,GAClC,GAAgB,GAAK,EAAa,GACnC,EAAgB,GAAK,GACpB,GAAgB,GAAK,OAIzB,GAAgB,GAAK,EAGzB,GAAG,EAAc,EAAc,CAE3B,GAAM,GAAiB,KAAK,WAAW,eACjC,EAAW,EAAe,EAAI,EAAiB,EAAI,EAAiB,EACpE,EAAM,EAAgB,GAAK,EAC3B,EAAS,EAAgB,GAAK,EAAe,EAAW,EAG9D,AAAG,EAAU,GACT,GAAgB,IAAM,EAAU,GAGjC,EAAU,GACT,GAAgB,IAAM,EAAM,GAG7B,EAAgB,GAAK,EAAe,GACnC,GAAgB,GAAK,EAAc,GACpC,EAAgB,GAAK,GACpB,GAAgB,GAAK,OAIzB,GAAgB,GAAK,EAGzB,KAAK,OAAS,EAGC,eAAe,EAA+B,EAAwB,CAErF,EAAI,UAAY,KAAK,oBACrB,EAAI,SAAS,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAG9C,EAAI,OACJ,EAAI,YACJ,EAAI,KAAK,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAC1C,EAAI,OAGJ,GAAM,GAAU,KAAK,sBACrB,GAAG,KAAK,YAAc,KAAK,UAEvB,GADA,EAAI,UAAY,KAAK,0BAClB,KAAK,aAAa,KAAO,KAAK,aAAa,GAAI,CAE9C,GAAM,GAAO,KAAK,IAAI,KAAK,aAAa,GAAI,KAAK,aAAa,IACxD,EAAQ,KAAK,IAAI,KAAK,aAAa,GAAI,KAAK,aAAa,IAC/D,EAAI,SACA,KAAK,EAAI,EAAU,EAAO,KAAK,OAAO,GACtC,KAAK,EAAI,EAAU,KAAK,aAAa,GAAK,KAAK,OAAO,GACtD,EAAQ,EACR,KAAK,WAAW,oBAGnB,CAED,GAAI,GAA6B,EACjC,AAAG,KAAK,aAAa,GAAK,KAAK,aAAa,GACxC,GAAY,KAAK,aACjB,EAAe,KAAK,cAGpB,GAAe,KAAK,aACpB,EAAY,KAAK,cAIrB,GAAM,GAAiB,KAAK,WAAW,eACjC,EAAW,KAAK,MAAQ,KAAK,OAAO,GAAK,EAAU,GAAK,EAC9D,AAAG,EAAW,GACV,EAAI,SACA,KAAK,EAAI,EAAU,EAAU,GAAK,KAAK,OAAO,GAC9C,KAAK,EAAI,EAAU,EAAU,GAAK,KAAK,OAAO,GAC9C,EACA,GAKR,GAAM,GAAc,EAAa,GAAK,EAAU,KAAK,OAAO,GAC5D,AAAG,EAAc,GACb,EAAI,SACA,KAAK,EACL,KAAK,EAAI,EAAU,EAAa,GAAK,KAAK,OAAO,GACjD,EACA,GAKR,GAAM,GAAgB,EAAU,GAAK,EAC/B,EAAe,EAAa,GAAK,EACvC,AAAG,EAAe,GACd,EAAI,SACA,KAAK,EACL,KAAK,EAAI,EAAU,EAAgB,KAAK,OAAO,GAC/C,KAAK,MACL,GAOhB,GAAI,GACJ,AAAG,KAAK,gBACJ,AAAG,KAAK,OACJ,EAAY,KAAK,cAEjB,EAAY,KAAK,qBAGrB,EAAY,KAAK,sBAErB,KAAK,WAAW,MACZ,EAAK,EACL,KAAK,EAAI,EAAU,KAAK,OAAO,GAC/B,KAAK,EAAI,EAAU,KAAK,OAAO,IAInC,GAAM,GAAU,KAAK,QACrB,KAAK,WAAa,EACf,GACC,GAAI,UAAY,EAChB,EAAI,SACA,KAAK,EAAI,EAAU,KAAK,aAAa,GAAK,KAAK,OAAO,GACtD,KAAK,EAAI,EAAU,KAAK,aAAa,GAAK,KAAK,OAAO,GACtD,KAAK,gBACL,KAAK,WAAW,iBAKxB,EAAI,YAx2BR,GADC,EAAe,CAAC,oBAAqB,YACtC,AA7BG,GA6BH,wBAeQ,GADP,MACO,AA5CL,GA4CK,sBAOR,GADC,GACD,AAnDG,GAmDH,wBCzEG,oBAA6B,GAAkB,CAUlD,YAAY,EAA4C,KAAM,EAAe,GAAI,EAAmC,CAChH,GAAM,GAAY,GAAqC,GACvD,MAAM,EAAW,KAAM,EAAc,KCHtC,oBAAgD,EAAa,CAEhE,YAAY,EAAU,EAAmC,CACrD,GAAM,GAAwC,KAAI,GAElD,EAAqB,mBAAkC,CACnD,WAAY,EAAU,OAAQ,SAAU,EAAU,QAEtD,EAAqB,iBAA4B,CAC7C,KAAM,EAAG,MAAO,EAAG,IAAK,EAAG,OAAQ,GAGvC,MAAM,EAAO,KClBd,oBAAuB,EAAO,CAiBjC,YAAY,EAA6C,KAAM,EAAe,GAAO,EAAmC,CAGpH,MAAM,GAAM,GAAO,GAlBf,aAAU,EAEV,aAAU,EAEV,kBAAe,EAiBnB,KAAK,SAAW,GAAI,GAAkB,EAAc,GAGpD,KAAK,YAAc,GAAI,GAAY,MAGpB,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEb,AAAG,IAAa,iBACjB,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,KAAa,sBACb,IAAa,kBACb,IAAa,cACb,IAAa,eACb,IAAa,yBAEjB,MAAK,OAAS,OAKlB,SAAQ,EAAkB,CAC1B,KAAK,SAAS,MAAQ,KAGtB,UAAmB,CACnB,MAAO,MAAK,SAAS,MAGN,YAAY,EAAc,EAAyB,CAElE,GAAG,YAAiB,GAChB,MAAO,MAGX,GAAM,GAAI,KAAK,EAAI,KAAK,QAClB,EAAI,KAAK,EAAI,KAAK,QACxB,YAAK,YAAY,iBACb,EACA,EACA,CAAC,EAAG,EAAI,KAAK,aAAc,EAAG,EAAI,KAAK,eAKxC,KAAK,YAAY,mBAChB,MAAK,OAAS,GAEX,KAAK,YAAY,UAChB,MAAK,QAAU,CAAC,KAAK,UAGtB,KAGQ,uBAAuB,EAAmB,CAEzD,AAAG,KAAK,SAAS,OACb,MAAK,OAAS,IAGH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAM,GAAS,KAAK,eACpB,KAAK,aAAe,KAAK,IAAI,EAAQ,EAAU,GAG/C,KAAK,MAAQ,KAAK,aAClB,KAAK,OAAS,KAAK,aAEhB,KAAK,MAAQ,GACZ,MAAK,MAAQ,GACd,KAAK,OAAS,GACb,MAAK,OAAS,GAGlB,KAAK,QAAW,MAAK,MAAQ,KAAK,cAAgB,EAClD,KAAK,QAAW,MAAK,OAAS,KAAK,cAAgB,EAGpC,eAAe,EAA+B,EAAwB,CAErF,GAAM,GAAU,KAAK,YAAY,aAAe,EAAW,OAC3C,KAAK,YAAY,aAAe,EAAW,KAG3D,AAAG,EACC,EAAI,UAAY,KAAK,mBAErB,EAAI,UAAY,KAAK,eAEzB,GAAM,GAAY,KAAK,QAAU,KAAK,EAChC,EAAY,KAAK,QAAU,KAAK,EAMtC,GALA,EAAI,SACA,EAAW,EAAW,KAAK,aAAc,KAAK,cAI/C,KAAK,QAAS,CACb,AAAG,EACC,EAAI,UAAY,KAAK,WAErB,EAAI,UAAY,KAAK,YAEzB,GAAM,GAAe,KAAK,qBACpB,EAAc,KAAK,aAAe,EAAe,EAIvD,AAAG,GAAe,EACd,EAAI,SACA,EACA,EACA,KAAK,aACL,KAAK,cAIT,EAAI,SACA,EAAY,EACZ,EAAY,EACZ,EACA,MC3Jb,oBAAmB,EAAO,CAiD7B,YAAY,EAAyB,EAAuB,KAAM,EAAwB,KAAM,EAAmD,KAAM,EAAmC,CAGxL,MAAM,GAAM,GAAO,GA7Cf,aAAyB,KAOjC,cAAW,EAgBX,gBAA4B,KAQ5B,iBAA6B,KAErB,aAAU,EAEV,aAAU,EAEV,iBAAc,EAEd,kBAAe,EAQnB,KAAK,OAAS,EACd,KAAK,WAAa,EAClB,KAAK,YAAc,EACnB,KAAK,QAAU,KAWf,OAAM,EAAyB,CAC/B,AAAG,IAAU,KAAK,QACd,MAAK,OAAS,EACd,KAAK,QAAU,SAInB,QAA0B,CAC1B,MAAO,MAAK,OAGG,sBAAsB,EAAmB,CAzFhE,QA6FQ,AAAG,SAAK,SAAL,cAAa,OAAQ,KAAK,SAAW,SAAK,SAAL,cAAa,WACjD,MAAK,aAAe,GACpB,KAAK,OAAS,IAIH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAI,GAAc,KAAK,WACvB,AAAG,IAAgB,MACf,CAAG,KAAK,UAAY,KAChB,EAAc,KAAK,OAAO,MAE1B,EAAc,KAAK,QAAQ,IAGnC,KAAK,MAAQ,KAAK,IAAI,KAAK,IAAI,EAAa,GAAW,GAEvD,GAAI,GAAe,KAAK,YACxB,AAAG,IAAiB,MAChB,CAAG,KAAK,UAAY,KAChB,EAAe,KAAK,OAAO,OAE3B,EAAe,KAAK,QAAQ,IAGpC,KAAK,OAAS,KAAK,IAAI,KAAK,IAAI,EAAc,GAAY,GAG1D,GAAM,GAAa,KAAK,MAAQ,EAC1B,EAAc,KAAK,OAAS,EAC5B,EAAQ,KAAK,IAAI,EAAY,GACnC,KAAK,YAAc,EAAc,EACjC,KAAK,aAAe,EAAe,EACnC,KAAK,QAAW,MAAK,MAAQ,KAAK,aAAe,EACjD,KAAK,QAAW,MAAK,OAAS,KAAK,cAAgB,EAGpC,eAAe,EAA+B,EAAwB,CAnI7F,MAqIQ,GAAG,CAAC,SAAK,SAAL,cAAa,UAAU,CACvB,KAAK,QAAU,KACf,OAIJ,KAAK,QAAU,KAAK,OAAO,IAG3B,GAAI,GAAM,KAAK,EAAI,KAAK,QAAS,EAAM,KAAK,EAAI,KAAK,QAC/C,EAAU,KAAK,WAAa,EAClC,AAAG,GACC,GAAI,OACJ,EAAI,YACJ,EAAI,KAAK,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QAC1C,EAAI,OACJ,EAAI,UACA,KAAK,EAAI,KAAK,QAAU,KAAK,YAAc,EAC3C,KAAK,EAAI,KAAK,QAAU,KAAK,aAAe,GAEhD,EAAM,CAAC,KAAK,YAAc,EAC1B,EAAM,CAAC,KAAK,aAAe,EAC3B,EAAI,OAAO,KAAK,WAIpB,AAAG,KAAK,UAAY,KAChB,EAAI,UACA,KAAK,OACL,EAAK,EAAK,KAAK,YAAa,KAAK,cAIrC,EAAI,UACA,KAAK,OAAQ,GAAG,KAAK,QACrB,EAAK,EAAK,KAAK,YAAa,KAAK,cAKtC,GACC,EAAI,YAtJZ,GADC,IACD,AAdG,GAcH,wBAQA,GADC,GAAsB,KACvB,AAtBG,GAsBH,uBAQA,GADC,GACD,AA9BG,GA8BH,0BAQA,GADC,GACD,AAtCG,GAsCH,2BCtCG,oBAAyB,GAAqB,CAEjD,YAAY,EAAyB,EAAuB,KAAM,EAAwB,KAAM,EAAmD,KAAM,EAAgC,KAAM,EAAmC,CAC9N,MACI,GAAI,GACA,GAAI,IAAK,EAAO,EAAO,EAAQ,EAAS,IAE5C,EAAU,MAKd,OAAa,CACb,MAAO,MAAK,MAAM,QCZnB,oBAAsB,EAAO,CAOhC,YAAY,EAAO,EAAG,EAAW,EAAG,EAAY,EAAG,EAAmC,CAElF,MAAM,GAAM,GAAO,GAEnB,KAAK,KAAO,EACZ,KAAK,SAAW,EAChB,KAAK,UAAY,EAGF,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAGvH,AAAG,IAAa,IACZ,KAAK,MAAQ,EAEb,KAAK,MAAQ,KAAK,IAAI,EAAU,KAAK,UAEzC,AAAG,IAAc,IACb,KAAK,OAAS,EAEd,KAAK,OAAS,KAAK,IAAI,EAAW,KAAK,aCzB5C,oBAA+B,GAAI,CACtC,YAAY,EAA2B,EAA6C,KAAM,EAAe,GAAO,EAAmC,CAC/I,MAAM,GAEN,KAAK,IAAI,CACL,GAAI,IAAM,EAAM,GAChB,GAAI,IAAQ,EAAG,EAAG,EAAG,GACrB,GAAI,IAAS,EAAU,EAAc,OCG1C,oBAAwD,EAAgB,CAmC3E,YAAY,EAAU,EAAW,EAAG,EAAY,EAAG,EAAY,GAAO,EAAa,GAAO,EAAc,GAAO,EAAmC,CAG9I,MAAM,EAAO,GAAO,GAAM,GAhBtB,aAA4B,CAAC,EAAG,GAMhC,kBAAkC,CAAC,EAAG,IAAU,EAAG,KAEjD,mBAAgB,GAEhB,kBAAe,GAQrB,KAAK,SAAW,EAAc,GAAI,IAAa,KAC/C,KAAK,SAAW,EAChB,KAAK,UAAY,EACjB,KAAK,WAAa,EAClB,KAAK,YAAc,EACnB,KAAK,aAAe,CAAC,EAAG,IAAU,EAAG,QAOrC,SAA2B,CAC3B,MAAO,CAAC,GAAG,KAAK,YAGhB,QAAO,EAA0B,CAEjC,AAAG,MAAK,QAAQ,KAAO,EAAO,IAAM,KAAK,QAAQ,KAAO,EAAO,KAC3D,MAAK,QAAQ,GAAK,EAAO,GACzB,KAAK,QAAQ,GAAK,EAAO,GACzB,KAAK,OAAS,GACd,KAAK,2BAST,aAAY,EAAgC,CAI5C,AAAI,GAAY,KAAO,KAAK,aAAa,IACrC,EAAY,KAAO,KAAK,aAAa,IACrC,EAAY,KAAO,KAAK,aAAa,IACrC,EAAY,KAAO,KAAK,aAAa,KAGrC,MAAK,aAAa,GAAK,EAAY,GACnC,KAAK,aAAa,GAAK,EAAY,GACnC,KAAK,aAAa,GAAK,EAAY,GACnC,KAAK,aAAa,GAAK,EAAY,GAGnC,AAAG,KAAK,WAAa,KACjB,KAAK,SAAS,YAAc,EAE5B,KAAK,cAAgB,OAI7B,cAAiC,CACjC,MAAO,CAAC,GAAG,KAAK,iBAOhB,YAAqB,CACrB,MAAO,MAAK,cAGZ,WAAU,EAAoB,CAE9B,AAAG,KAAK,aAAe,GACnB,MAAK,WAAa,EAClB,KAAK,aAAe,GACpB,KAAK,cAAgB,OAQzB,aAAsB,CACtB,MAAO,MAAK,eAGZ,YAAW,EAAqB,CAEhC,AAAG,KAAK,cAAgB,GACpB,MAAK,YAAc,EACnB,KAAK,aAAe,GACpB,KAAK,cAAgB,IAIV,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,IAAa,cACjB,MAAK,OAAS,IAGH,YAAY,EAAc,EAA2B,CAEpE,GAAG,EAAM,SAAW,MAAQ,CAAE,aAAiB,IAC3C,MAAO,MAIX,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,EAAM,KAAK,EAAI,KAAK,OAAO,GAC3B,EAAM,EAAM,EACZ,EAAM,KAAK,EAAI,KAAK,OAAO,GAC3B,EAAM,EAAM,EAClB,GAAG,YAAiB,GAAc,CAC9B,GAAG,EAAM,SAAW,MACb,GAAM,EAAI,GAEV,EAAM,GAAK,GAEX,EAAM,EAAI,GAEV,EAAM,GAAK,GACV,MAAO,MAGf,AAAG,KAAK,WAAa,MACjB,GAAQ,EAAM,cAAc,EAAK,IAIzC,MAAO,MAAK,MAAM,cAAc,EAAO,GAGxB,sBAAsB,EAAkB,CACvD,GAAM,GAAQ,KAAK,MAGnB,EAAM,gBAAgB,GAKtB,AADa,KAAK,YAAc,KAAK,YAS7B,EAAM,aACV,MAAK,aAAe,IARpB,AAAG,KAAK,WAAa,KACjB,KAAK,SAAS,oBAAoB,GAC9B,GAAM,aAAe,KAAK,gBAC9B,GAAM,uBAAuB,GAAG,KAAK,cACrC,KAAK,wBAOE,uBAAuB,EAAkB,CACxD,GAAM,GAAQ,KAAK,MACnB,KAAK,cAAgB,GAGrB,EAAM,iBAAiB,GAGpB,EAAM,OACL,MAAK,OAAS,IAGH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CACvH,GAAI,GAAc,GAAM,EAAe,GACjC,EAAoB,KAAK,IAAI,EAAU,KAAK,UAC5C,EAAqB,KAAK,IAAI,EAAW,KAAK,WAEpD,GAAG,KAAK,YAAc,KAAK,YAAa,CAEpC,GAAM,GAAiC,CAAC,GAAG,KAAK,cAEhD,AAAG,KAAK,YACJ,GAAY,GAAK,EACjB,EAAY,GAAK,GAGlB,KAAK,aACJ,GAAY,GAAK,EACjB,EAAY,GAAK,GAGrB,GAAM,GAAQ,KAAK,MACnB,AAAG,KAAK,WAAa,KACjB,GAAM,uBAAuB,GAAG,GAChC,KAAK,wBAGL,MAAK,SAAS,YAAc,EAC5B,KAAK,SAAS,oBAAoB,IAInC,KAAK,YACJ,MAAK,MAAQ,EAAM,WAAW,GAC9B,EAAc,IAGf,KAAK,aACJ,MAAK,OAAS,EAAM,WAAW,GAC/B,EAAe,IAKvB,AAAG,GACC,MAAK,MAAQ,KAAK,IAAI,EAAmB,IAE1C,GACC,MAAK,OAAS,KAAK,IAAI,EAAoB,IAE5C,KAAK,QAAU,GAAK,KAAK,WAAa,GAAK,CAAC,KAAK,YAChD,QAAQ,KAAK,0IACd,KAAK,SAAW,GAAK,KAAK,YAAc,GAAK,CAAC,KAAK,aAClD,QAAQ,KAAK,8IAGF,uBAA8B,CAC7C,KAAK,uBAKF,KAAK,WAAa,MACjB,MAAK,aAAe,IAGpB,sBAA6B,CACjC,GAAG,KAAK,WAAa,KACjB,OAGJ,GAAM,CAAC,EAAS,GAAW,KAAK,OAChC,KAAK,MAAM,gBAAgB,KAAK,EAAI,EAAS,KAAK,EAAI,GAGvC,eAAe,EAA+B,EAAuB,CAEpF,AAAG,KAAK,WAAa,MACjB,KAAK,SAAS,cAAc,KAAK,MAAO,GAG5C,GAAM,CAAC,EAAK,EAAK,EAAK,GAAO,KAAK,UAAU,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,QACvE,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,CAAC,EAAS,GAAW,KAAK,OAG1B,EAAM,EAAM,EACZ,EAAM,EAAM,EAGZ,EAAW,KAAK,EAAI,EACpB,EAAW,KAAK,EAAI,EAGtB,EAAO,KAAK,IAAI,KAAK,IAAI,EAAU,GAAM,GACzC,EAAO,KAAK,IAAI,KAAK,IAAI,EAAU,GAAM,GACzC,EAAW,KAAK,IAAI,KAAK,IAAI,EAAW,EAAY,GAAM,GAAO,EACjE,EAAW,KAAK,IAAI,KAAK,IAAI,EAAW,EAAa,GAAM,GAAO,EAItE,GAHA,CAAC,EAAM,EAAM,EAAU,GAAY,KAAK,UAAU,EAAM,EAAM,EAAU,GAGrE,IAAa,GAAK,IAAa,EAAG,CACjC,AAAG,KAAK,WAAa,MACjB,KAAK,MAAM,WAEf,KAAK,aAAe,GACpB,OAIJ,GAAM,GAAO,EAAO,EACd,EAAO,EAAO,EAGpB,KAAK,WAAW,GAChB,EAAI,KAAK,EAAK,EAAK,EAAK,GACxB,EAAI,OACD,KAAK,WAAa,MACjB,EAAI,UACA,KAAK,SAAS,OACd,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAGR,EAAI,KAAK,EAAM,EAAM,EAAU,GAC/B,KAAK,SAAS,EAAK,WAEhB,KAAK,WAAa,MACjB,GAAI,OACJ,EAAI,YACJ,EAAI,KAAK,EAAM,EAAM,EAAU,GAC/B,EAAI,OACJ,KAAK,MAAM,MAAM,EAAK,GAAU,KAAK,cACrC,EAAI,WAGR,KAAK,aAAe,KAjVxB,GADC,GACD,AAXG,GAWH,wBAOA,GADC,GACD,AAlBG,GAkBH,yBC1BG,GAAK,GAAL,UAAK,EAAL,CAEH,yBAEA,yBAJQ,WAcL,oBAAkE,GAAkB,CAwCvF,YAAY,EAAU,EAAW,EAAG,EAAY,EAAG,EAAY,GAAO,EAAa,GAAO,EAAgB,EAAuB,EAAc,GAAO,EAAmC,CACrL,MAAM,EAAO,EAAU,EAAW,EAAW,EAAY,EAAa,GAlClE,oBAAiB,EAKjB,qBAAkB,EAWlB,qBAAkC,KAElC,oBAAiB,EAEjB,oBAAiB,EAEjB,gBAAa,EAEb,qBAAkB,GAElB,oBAAiB,GAUrB,KAAK,eAAiB,EACtB,KAAK,sBAAwB,GAAI,GAAY,MAC7C,KAAK,oBAAsB,GAAI,GAAY,SAI3C,gBAA+B,CAC/B,MAAO,MAAK,kBAGZ,eAAc,EAA8B,CAC5C,GAAG,KAAK,iBAAmB,EAAe,CACtC,GAAM,GAAY,KAAK,OACvB,KAAK,eAAiB,EACtB,KAAK,OAAS,EACd,KAAK,aAAe,GACpB,KAAK,OAAS,OAST,SAA2B,CACpC,MAAO,OAAM,UAGJ,QAAO,EAA0B,CAC1C,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WAE7C,MAAM,OAAS,CACX,CAAC,KAAK,IAAI,KAAK,IAAI,CAAC,EAAO,GAAI,EAAa,KAAK,gBAAiB,GAClE,CAAC,KAAK,IAAI,KAAK,IAAI,CAAC,EAAO,GAAI,EAAc,KAAK,iBAAkB,OAQ/D,YAAqB,CAC9B,MAAO,OAAM,aAGJ,WAAU,EAAoB,CACvC,GAAM,GAAY,KAAK,OACvB,MAAM,UAAY,EAClB,KAAK,OAAS,KAOL,aAAsB,CAC/B,MAAO,OAAM,cAGJ,YAAW,EAAqB,CACzC,GAAM,GAAY,KAAK,OACvB,MAAM,WAAa,EACnB,KAAK,OAAS,KAOd,SAA2B,CAC3B,GAAM,CAAC,EAAS,GAAW,KAAK,OAC1B,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,EAAQ,EAAa,KAAK,eAC1B,EAAQ,EAAc,KAAK,gBACjC,MAAO,CACH,IAAU,EAAI,EAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EAAU,EAAO,GAAI,GAC1D,IAAU,EAAI,EAAI,KAAK,IAAI,KAAK,IAAI,CAAC,EAAU,EAAO,GAAI,OAI9D,QAAO,EAA0B,CACjC,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WAC7C,KAAK,OAAS,CACV,CAAC,EAAO,GAAM,GAAa,KAAK,gBAChC,CAAC,EAAO,GAAM,GAAc,KAAK,kBAKjC,eAAe,EAAgC,CACnD,MAAG,GACQ,KAAK,oBAEL,KAAK,sBAIZ,qBAAqB,EAAmB,EAAiB,EAAc,EAAqB,CAEhG,GAAG,KAAK,kBAAoB,MAAQ,KAAK,kBAAoB,EACzD,MAAO,GAIX,GAAM,CAAC,EAAU,GAAU,KAAK,kBAAkB,EAAU,GACtD,EAAU,KAAK,iBAAmB,EAClC,EAAY,EAAU,EAAW,EACjC,EAA8C,CAChD,EAAU,GACV,EAAU,GAAK,EAAU,GACzB,EAAU,GACV,EAAU,GAAK,EAAU,IAIvB,EAAc,KAAK,eAAe,GACxC,EAAY,iBAAiB,EAAO,EAAM,GAE1C,GAAM,GAAa,EAAY,WACzB,EAAe,EAAY,kBAIjC,GAHG,GACC,MAAK,OAAS,IAEf,IAAe,EAAW,KAAM,CAE/B,GAAG,EAAY,aAAe,MAAQ,CAAE,aAAiB,IACrD,MAAO,GAEX,GAAM,GAAY,EAAW,EAAI,EAC3B,EAAS,KAAK,OAIhB,EAAe,EACnB,AAAI,GACA,GAAe,EAAY,cACvB,EAAM,EACN,EAAM,EACN,EAAS,GACT,EAAS,GAAK,EAAS,GACvB,EAAS,GACT,EAAS,GAAK,EAAS,KAM/B,GAAI,GAcJ,GAbA,AAAG,EACC,EAAa,EAAY,gBACrB,EAAM,EACN,EAAM,EACN,EAAO,GACP,EAAO,GAAK,EAAO,GACnB,EAAO,GACP,EAAO,GAAK,EAAO,IACrB,GAGF,EAAa,EAAY,WAAW,GAErC,EAAc,CAEb,GAAG,CAAC,EAAc,CACd,GAAM,GAAiB,EAAW,KAAK,gBAAkB,KAAK,eACxD,EAAc,KAAK,MAAM,WAAW,GACpC,EAAY,EAAiB,EACnC,EAAO,GAAc,GAAa,EAAY,GAAM,GAAI,GACxD,KAAK,OAAS,EAKlB,KAAK,eAAiB,EACtB,KAAK,eAAiB,EAAO,GAC7B,KAAK,gBAAkB,MAEtB,CAED,GAAM,GAAiB,EAAW,KAAK,gBAAkB,KAAK,eACxD,EAAc,KAAK,MAAM,WAAW,GACpC,EAAY,EAAiB,EAC7B,EAAW,EAAa,KAAK,eACnC,EAAO,GAAa,KAAK,eAAiB,EAAY,GAAI,GAC1D,KAAK,OAAS,EAGlB,MAAO,OAEN,IAAG,IAAe,EAAW,MAC9B,MAAO,GACN,GAAG,EAEJ,YAAK,gBAAkB,KAChB,GAGX,MAAO,GAIH,YAAY,EAAgC,CAChD,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WAEvC,EAAO,CAAE,GAAa,KAAK,gBACjC,AAAG,GAAQ,EACP,EAAO,GAAK,EACR,EAAO,GAAK,GAChB,GAAO,GAAK,GAEhB,GAAM,GAAO,CAAE,GAAc,KAAK,iBAClC,AAAG,GAAQ,EACP,EAAO,GAAK,EACR,EAAO,GAAK,GAChB,GAAO,GAAK,GAWZ,iBAAiB,EAA8B,CACnD,GAAM,GAAS,KAAK,OACd,CAAC,EAAM,GAAQ,EACrB,EAAO,IAAM,EAAM,MAAQ,EAAM,OAAS,EAAM,OAChD,EAAO,IAAM,EAAM,MAAQ,EAAM,OAAS,EAAM,OAChD,KAAK,YAAY,GACjB,KAAK,OAAS,EACd,GAAM,CAAC,EAAM,GAAQ,KAAK,OAEpB,EAAU,IAAS,GAAQ,IAAS,EACpC,EAAO,KAAK,WACZ,EAAO,GAAI,QAAQ,UAGzB,MAFA,MAAK,WAAa,EAEf,EACQ,GAER,EAAM,SACE,GAGJ,AADS,EAAM,EACL,IAGF,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,qBAEZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,KAAa,kBACb,IAAa,uBACb,IAAa,sBACb,IAAa,eACb,IAAa,cACb,IAAa,uBACjB,MAAK,OAAS,IAGH,YAAY,EAAc,EAA2B,CAGpE,GAAI,aAAiB,IAAS,YAAiB,KAC3C,GAAM,SAAW,MAAQ,EAAM,SAAW,MAAO,CACjD,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,EAAU,KAAK,iBAAmB,EAClC,EAAc,CAAC,GAAY,CAAC,KAAK,WAAa,CAAC,KAAK,WACpD,EAAU,EAAa,KAAK,MAC5B,EAAU,EAAc,KAAK,OAE/B,EAAe,GAanB,GATG,CAAC,KAAK,WAAc,IAAW,CAAC,IAChC,KAAK,qBAAqB,GAAO,GAAW,EAAa,EAAO,IAC/D,GAAe,IAEhB,CAAC,KAAK,YAAe,IAAW,CAAC,IACjC,KAAK,qBAAqB,GAAM,GAAW,EAAa,EAAO,IAC9D,GAAe,IAGhB,EAEC,MAAG,aAAiB,IAChB,KAAK,iBAAiB,GAEnB,KAKf,GAAM,GAAW,MAAM,YAAY,EAAO,GAI1C,MAAG,KAAa,MAAQ,YAAiB,IAAgB,KAAK,iBAAiB,GACpE,KAEJ,EAGQ,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAM,GAAY,KAAK,mBACjB,EAAU,KAAK,iBAAmB,EAClC,EAAW,GAAW,CAAC,KAAK,WAC5B,EAAW,GAAW,CAAC,KAAK,UAG9B,EAAW,EAAW,EAAY,EACtC,AAAG,EACC,GAAY,KAAK,IAAI,EAAW,EAAW,GAC3C,EAAY,KAAK,IAAI,EAAU,IAG/B,GAAY,EACZ,EAAY,GAGhB,AAAG,EACC,GAAa,KAAK,IAAI,EAAY,EAAW,GAC7C,EAAa,KAAK,IAAI,EAAW,IAGjC,GAAa,EACb,EAAa,GAIjB,MAAM,wBAAwB,EAAW,EAAW,EAAY,GAGhE,KAAK,eAAiB,KAAK,MAC3B,KAAK,gBAAkB,KAAK,OAGzB,GACC,MAAK,MAAQ,KAAK,IAAI,KAAK,IAAI,KAAK,MAAQ,EAAW,GAAW,IAEnE,GACC,MAAK,OAAS,KAAK,IAAI,KAAK,IAAI,KAAK,OAAS,EAAW,GAAY,IAG1D,uBAAuB,EAAkB,CACxD,MAAM,uBAAuB,GAG7B,GAAM,GAAS,KAAK,OACpB,KAAK,YAAY,GACjB,KAAK,OAAS,EAGC,eAAe,EAA+B,EAAuB,CAEpF,GAAM,CAAC,EAAY,GAAe,KAAK,MAAM,WACvC,EAAU,EAAa,KAAK,MAC5B,EAAU,EAAc,KAAK,OAC7B,EAAS,KAAK,oBAAoB,GAAO,GACzC,EAAS,KAAK,oBAAoB,GAAM,GAE9C,AAAG,MAAK,kBAAoB,GAAU,KAAK,iBAAmB,IAC1D,MAAK,gBAAkB,EACvB,KAAK,eAAiB,EACtB,KAAK,aAAe,IAIxB,MAAM,eAAe,EAAK,GAG1B,GAAM,GAAc,KAAK,iBAAmB,GACvB,CAAC,KAAK,WAAa,CAAC,KAAK,WAQ9C,GANG,GACC,KAAK,eAAe,GAAO,EAAS,GAAW,EAAa,GAC7D,GACC,KAAK,eAAe,GAAM,EAAS,GAAW,EAAa,GAG5D,EAAa,CACZ,GAAM,GAAY,KAAK,mBACvB,EAAI,UAAY,KAAK,eACrB,EAAI,SACA,KAAK,EAAI,KAAK,MAAQ,EACtB,KAAK,EAAI,KAAK,OAAS,EACvB,EACA,IAUJ,kBAAkB,EAAmB,EAAuF,CAEhI,GAAM,GAAU,KAAK,iBAAmB,EAClC,EAAY,EAAW,EAAI,EAC3B,EAAU,KAAK,OAAO,GACtB,EAAc,KAAK,MAAM,WAAW,GACpC,EAAiB,EAAW,KAAK,gBAAkB,KAAK,eACxD,EAAY,KAAK,mBACjB,EAAa,KAAK,oBAClB,EAAY,KAAK,mBAEnB,EAAuB,EAC3B,AAAG,GACC,IAAyB,EAAS,EAAY,GAElD,GAAM,GAAS,KAAK,IAEhB,KAAK,IAED,EACA,KAAK,IAED,EAAiB,EACjB,GACA,GAER,GAGE,EAAU,GAAuB,GAAU,EAG7C,EAAI,EAAI,EAAQ,EACpB,AAAG,EACC,GAAK,KAAK,EAAI,KAAK,MAAQ,EAC3B,EAAK,KAAK,EAAI,EACd,EAAS,EACT,EAAU,GAGV,GAAK,KAAK,EAAI,EACd,EAAK,KAAK,EAAI,KAAK,OAAS,EAC5B,EAAS,EACT,EAAU,GAId,GAAI,GAAK,EAAK,EAAS,EACvB,MAAG,GACC,GAAM,EACN,EAAM,KAAK,EACX,EAAU,EACV,EAAW,GAGX,GAAM,KAAK,EACX,EAAM,EACN,EAAU,EACV,EAAW,GAGR,CACH,CAAC,EAAI,EAAI,EAAQ,GACjB,CAAC,EAAK,EAAK,EAAS,IAKpB,oBAAoB,EAAmB,EAA0B,CACrE,MAAG,CAAC,GAAU,KAAK,iBAAmB,EAC3B,GAEJ,CAAE,GAAW,KAAK,WAAa,KAAK,WAIvC,eAAe,EAAmB,EAAiB,EAAiB,EAAqC,CAE7G,GAAM,CAAC,EAAU,GAAU,KAAK,kBAAkB,EAAU,GAS5D,GANG,KAAK,iBAAmB,GACvB,GAAI,UAAY,KAAK,eACrB,EAAI,SAAS,GAAG,IAIjB,EAEC,OAAO,AADa,KAAK,eAAe,GACrB,gBACV,GAAW,SACZ,EAAI,UAAY,KAAK,YACrB,UACC,GAAW,UACX,GAAW,KACZ,EAAI,UAAY,KAAK,WACrB,UAIR,GAAI,UAAY,KAAK,mBAEzB,EAAI,SAAS,GAAG,KCnjBjB,oBAAqB,EAAO,CA0B/B,YAAY,EAA4C,KAAM,EAAW,EAAG,EAAW,EAAG,EAAgB,EAAG,EAAe,EAAG,EAAW,GAAO,EAAmC,CAGhL,MAAM,GAAM,GAAO,GAZf,aAAU,EAEV,aAAU,EAEV,iBAAc,EAEd,kBAAe,EAQnB,GAAG,EAAW,EACV,KAAM,IAAI,OAAM,wDAEpB,KAAK,YAAc,GAAI,GAAY,MACnC,KAAK,SAAW,GAAI,GAAS,KAAK,IAAI,EAAc,GAAW,GAC/D,KAAK,SAAW,EAChB,KAAK,SAAW,EAChB,KAAK,cAAgB,EACrB,KAAK,SAAW,KAIhB,OAAM,EAAe,CACrB,KAAK,SAAS,MAGd,QAAgB,CAChB,MAAO,MAAK,SAAS,MAIzB,SAAS,EAAe,EAAa,GAAY,CAE7C,AAAG,KAAK,cAAgB,GACpB,GAAQ,KAAK,MAAM,EAAQ,KAAK,eAAiB,KAAK,eAG1D,AAAG,EAAQ,KAAK,SACZ,EAAQ,KAAK,SACT,EAAQ,KAAK,UACjB,GAAQ,KAAK,UAGjB,KAAK,SAAS,SAAS,EAAO,GAGf,eAAe,EAA0B,KAAY,CACpE,MAAM,eAAe,GAErB,AAAG,IAAa,KACZ,MAAK,aAAe,GACpB,KAAK,OAAS,IAEb,AAAG,IAAa,mBACb,IAAa,kBAEjB,MAAK,aAAe,GACpB,KAAK,OAAS,IAEV,KAAa,cACb,IAAa,eACb,IAAa,mBACjB,MAAK,OAAS,IAGH,YAAY,EAAc,EAAyB,CAElE,GAAG,YAAiB,GAChB,MAAO,MAGX,GAAM,GAAI,KAAK,EAAI,KAAK,QAClB,EAAI,KAAK,EAAI,KAAK,QAOxB,GANA,KAAK,YAAY,iBAAiB,EAAO,EAAM,CAC3C,EAAG,EAAI,KAAK,YAAa,EAAG,EAAI,KAAK,eAKpC,MAAK,YAAY,mBAAqB,KAAK,YAAY,UAAa,KAAK,YAAY,YAAc,EAAW,OAC5G,KAAK,YAAY,aAAe,KAAM,CAEzC,GAAM,GAAU,KAAK,YAAY,WAAW,GAC5C,KAAK,MAAQ,KAAK,SAAW,EAAW,MAAK,SAAW,KAAK,UAKjE,MAAG,MAAK,YAAY,mBAChB,MAAK,OAAS,IAEX,KAGQ,uBAAuB,EAAmB,CAEzD,AAAG,KAAK,SAAS,OACb,MAAK,OAAS,IAGH,wBAAwB,EAAkB,EAAkB,EAAmB,EAAyB,CAEvH,GAAM,GAAY,KAAK,gBACjB,EAAY,KAAK,gBAIvB,AAAG,KAAK,SAEJ,CAAG,GAAa,IACZ,KAAK,OAAS,EAEd,KAAK,OAAS,KAAK,IAAI,EAAW,GAEtC,KAAK,aAAe,KAAK,OACzB,KAAK,QAAU,EAGf,KAAK,MAAQ,KAAK,IAAI,KAAK,IAAI,EAAW,GAAW,GAErD,KAAK,YAAc,KAAK,IAAI,KAAK,MAAO,GACxC,KAAK,QAAW,MAAK,MAAQ,KAAK,aAAe,GAIjD,CAAG,GAAY,IACX,KAAK,MAAQ,EAEb,KAAK,MAAQ,KAAK,IAAI,EAAW,GAErC,KAAK,YAAc,KAAK,MACxB,KAAK,QAAU,EAGf,KAAK,OAAS,KAAK,IAAI,KAAK,IAAI,EAAW,GAAY,GAEvD,KAAK,aAAe,KAAK,IAAI,KAAK,OAAQ,GAC1C,KAAK,QAAW,MAAK,OAAS,KAAK,cAAgB,GAIxC,eAAe,EAA+B,EAAwB,CAErF,GAAM,GAAI,KAAK,EAAI,KAAK,QAClB,EAAI,KAAK,EAAI,KAAK,QAGxB,AAAG,KAAK,YAAY,aAAe,EAAW,OAAS,KAAK,YAAY,aAAe,EAAW,KAC9F,EAAI,UAAY,KAAK,WAErB,EAAI,UAAY,KAAK,YACzB,GAAM,GAAY,KAAK,YAAe,MAAK,MAAQ,KAAK,UAAa,MAAK,SAAW,KAAK,UAC1F,EAAI,SAAS,EAAG,EAAG,EAAW,KAAK,cAGnC,EAAI,UAAY,KAAK,eACrB,GAAM,GAAa,KAAK,YAAc,EACtC,EAAI,SAAS,EAAI,EAAW,EAAG,EAAY,KAAK,gBCnLjD,oBAAoD,EAAa,CAEpE,YAAY,EAAU,EAAmC,CACrD,GAAM,GAAwC,KAAI,GAElD,EAAqB,mBAAkC,CACnD,WAAY,EAAU,OAAQ,SAAU,EAAU,SAGtD,MAAM,EAAO,KCTd,oBAAoD,GAAqB,CAK5E,YAAY,EAAU,EAAsB,CACxC,MAAM,GACN,KAAK,WAAa,KAGT,gBAAe,EAA2B,CACnD,MAAM,eAAiB,KAAK,cAGnB,iBAAoC,CAC7C,MAAO,MAAK",
  "names": []
}
