{
  "version": 3,
  "sources": ["../src/theme/FlexAlignment.ts", "../src/theme/Alignment.ts", "../src/events/Event.ts", "../src/events/ModifierEvent.ts", "../src/events/PointerEvent.ts", "../src/events/AutoScroll.ts", "../src/events/TabSelect.ts", "../src/helpers/measureTextDims.ts", "../src/decorators/FlagFields.ts", "../src/helpers/TextHelper.ts", "../src/theme/BaseTheme.ts", "../src/widgets/Widget.ts", "../src/widgets/Parent.ts", "../src/widgets/MultiParent.ts", "../src/widgets/MultiContainer.ts", "../src/widgets/SingleParent.ts", "../src/widgets/BaseContainer.ts", "../src/core/FocusType.ts", "../src/events/PointerWheel.ts", "../src/events/KeyEvent.ts", "../src/events/KeyPress.ts", "../src/events/Leave.ts", "../src/theme/Theme.ts", "../src/helpers/roundToPower2.ts", "../src/helpers/isPower2.ts", "../src/core/Viewport.ts", "../src/core/Root.ts", "../src/core/DebugInjector.ts", "../src/core/DefaultTextInputHandler.ts", "../src/events/TextPasteEvent.ts", "../src/core/DOMRoot.ts", "../src/widgets/PassthroughWidget.ts", "../src/widgets/ArtificialConstraint.ts", "../src/helpers/ClickState.ts", "../src/helpers/CompoundClickHelper.ts", "../src/helpers/GenericClickHelper.ts", "../src/events/KeyRelease.ts", "../src/events/PointerButtonEvent.ts", "../src/events/PointerRelease.ts", "../src/events/PointerPress.ts", "../src/helpers/ClickHelper.ts", "../src/helpers/ButtonClickHelper.ts", "../src/widgets/Button.ts", "../src/widgets/FilledButton.ts", "../src/widgets/Label.ts", "../src/widgets/TextButton.ts", "../src/widgets/VirtualKeyboard/GlyphVirtualKey.ts", "../src/widgets/Row.ts", "../src/widgets/VirtualKeyboard/VirtualKeyRow.ts", "../src/widgets/VirtualKeyboard/VirtualKey.ts", "../src/widgets/VirtualKeyboard/BasicVirtualKey.ts", "../src/widgets/VirtualKeyboard/BackspaceKey.ts", "../src/widgets/VirtualKeyboard/EscapeKey.ts", "../src/widgets/VirtualKeyboard/EnterKey.ts", "../src/widgets/VirtualKeyboard/ShiftKey.ts", "../src/widgets/VirtualKeyboard/SpaceKey.ts", "../src/widgets/Column.ts", "../src/widgets/VirtualKeyboard/VirtualKeyboard.ts", "../src/widgets/Container.ts", "../src/widgets/Margin.ts", "../src/core/DOMVirtualKeyboardRoot.ts", "../src/core/VirtualKeyboardRoot.ts", "../src/drivers/KeyboardDriver.ts", "../src/drivers/DOMKeyboardDriver.ts", "../src/helpers/getPointerEventNormPos.ts", "../src/events/PointerMove.ts", "../src/drivers/PointerHint.ts", "../src/drivers/PointerDriver.ts", "../src/drivers/DOMPointerDriver.ts", "../src/drivers/RayPointerDriver.ts", "../src/theme/DebugTheme.ts", "../src/state/CompositeValidator.ts", "../src/state/DefaultTextValidator.ts", "../src/state/FloatValidator.ts", "../src/state/IntValidator.ts", "../src/state/RangeValidator.ts", "../src/state/Variable.ts", "../src/state/WatchableVariable.ts", "../src/widgets/VirtualKeyboard/AltKey.ts", "../src/widgets/VirtualKeyboard/ControlKey.ts", "../src/widgets/AxisCoupling.ts", "../src/widgets/TextInput.ts", "../src/widgets/BasicTextInput.ts", "../src/widgets/Center.ts", "../src/widgets/Checkbox.ts", "../src/widgets/Icon.ts", "../src/widgets/IconButton.ts", "../src/widgets/Spacing.ts", "../src/widgets/LabelledCheckbox.ts", "../src/widgets/RadioButton.ts", "../src/widgets/LabelledRadioButton.ts", "../src/widgets/ViewportWidget.ts", "../src/widgets/ScrollableViewportWidget.ts", "../src/widgets/Slider.ts", "../src/widgets/TextArea.ts", "../src/widgets/TextMargin.ts", "../src/widgets/ThemeScope.ts"],
  "sourcesContent": ["/**\n * Alignment of multi-container contents along the main axis. Used for when\n * {@link MultiContainer} has unused space, even after distribution. Similar to\n * {@link Alignment}.\n *\n * @category Theme\n */\nexport const enum FlexAlignment {\n    /** Distribute unused space between each child. */\n    SpaceBetween = 'between',\n    /** Distribute unused space between each child and at start and end. */\n    SpaceAround = 'around',\n    /**\n     * Align the children to the start of the container, having the extra space\n     * at the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the children to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the children to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "/**\n * Alignment of container contents. Used for when {@link Container} has too much\n * space.\n *\n * @category Theme\n */\nexport const enum Alignment {\n    /** Give the extra space to the child, potentially stretching it. */\n    Stretch = 'stretch',\n    /**\n     * Align the child to the start of the container, having the extra space at\n     * the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the child to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the child to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * A generic event. This is an abstract class and must be implemented in child\n * classes.\n *\n * @category Event\n */\nexport abstract class Event {\n    /** The target of this event. Can be null */\n    readonly target: Widget | null;\n    /**\n     * The focus type of this event. Can be null.\n     *\n     * If null, this event cannot be focused, since events are focused by their\n     * {@link FocusType} as a group.\n     */\n    readonly focusType: FocusType | null;\n    /** Can this event be dispatched without a target? */\n    readonly needsFocus: boolean;\n    /** Is this event dispatched in reverse-order? */\n    readonly reversed: boolean;\n\n    /** Create a new Event. */\n    constructor(target: Widget | null, focusType: FocusType | null, needsFocus: boolean, reversed = false) {\n        this.target = target;\n        this.focusType = focusType;\n        this.needsFocus = needsFocus;\n        this.reversed = reversed;\n    }\n\n    /**\n     * Create a new Event with the same properties as this, except with a new\n     * given target.\n     */\n    abstract cloneWithTarget(target: Widget | null): Event;\n}", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * An event which contains the state of modifier keys. This is an abstract class\n * and must be implemented in child classes.\n *\n * @category Event\n */\nexport abstract class ModifierEvent extends Event {\n    /** Is shift being pressed? */\n    readonly shift: boolean;\n    /** Is control being pressed? */\n    readonly ctrl: boolean;\n    /** Is alt being pressed? */\n    readonly alt: boolean;\n\n    /** Create a new ModifierEvent. */\n    constructor(shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null, focusType: FocusType | null, needsFocus: boolean) {\n        super(target, focusType, needsFocus);\n        this.shift = shift;\n        this.ctrl = ctrl;\n        this.alt = alt;\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A pointer {@link Event}.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerEvent extends ModifierEvent {\n    /** Pointer event position's X coordinate in pixels. Not an integer. */\n    readonly x: number;\n    /** Pointer event position's Y coordinate in pixels. Not an integer. */\n    readonly y: number;\n\n    /** Create a new PointerEvent. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(shift, ctrl, alt, target, focusType, false);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Create a new PointerEvent event with the same properties as this, except\n     * with new {@link PointerEvent#x} and {@link PointerEvent#y} values\n     * corrected for a given offset.\n     */\n    abstract correctOffset(xOffset: number, yOffset: number): PointerEvent;\n}\n", "import type { Bounds } from '../helpers/Bounds';\nimport { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * An auto-scroll {@link Event}. Dispatched when a widget (or part of a widget)\n * wants to be visible to the user, such as the current caret position when\n * typing a character.\n *\n * This event is not static. As the event propagates in the UI tree, it will be\n * updated so that the wanted bounds are up-to-date.\n *\n * Note that this event is handled via {@link Widget#dispatchEvent} in a special\n * case; widgets will auto-capture the event if they are\n * {@link AutoScroll#originallyRelativeTo}, and {@link Widget#handleEvent} will\n * only be called if {@link Widget#propagatesEvents} is true. The event must be\n * re-captured by scrollable containers if a child of those containers captured\n * the event, and {@link AutoScroll#bounds} must be updated accordingly. See\n * {@link ScrollableViewportWidget#handleEvent} for an example of this.\n *\n * Has no focus type and does not need focus. Cannot be targetted.\n *\n * @category Event\n */\nexport class AutoScroll extends Event {\n    /**\n     * The widget that the auto-scroll {@link AutoScroll#bounds} will be\n     * relative to.\n     */\n    readonly originallyRelativeTo: Widget;\n    /**\n     * The portion of {@link AutoScroll#originallyRelativeTo} that needs to be\n     * in view. For example, if a 5x10 rectangle at the top-left of the widget\n     * needs to be selected, with a horizontal and vertical offset of 2, then\n     * the bounds would be [2, 2, 7, 12].\n     *\n     * Note that this is initially relative to originallyRelativeTo when the\n     * event is created, but the bounds must be relative to the capturer instead\n     * after the event is first captured.\n     *\n     * Can be changed by event handlers; typically it's changed to a scrollable\n     * container after the container is scrolled so that there are no issues\n     * with nested scrollable containers.\n     */\n    bounds: Bounds;\n\n    /**  Create a new AutoScroll. */\n    constructor(originallyRelativeTo: Widget, bounds: Bounds) {\n        super(null, null, false);\n\n        this.originallyRelativeTo = originallyRelativeTo;\n        this.bounds = [...bounds];\n    }\n\n    cloneWithTarget(target: Widget | null): AutoScroll {\n        if(target !== null && !AutoScroll.targetWarned) {\n            AutoScroll.targetWarned = true;\n            console.warn('AutoScroll events cannot be targetted to a specific widget. Target ignored');\n        }\n\n        const event = new AutoScroll(this.originallyRelativeTo, this.bounds);\n        return event;\n    }\n\n    static targetWarned = false;\n}", "import { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * A tab selection {@link Event}. Dispatched when tab is pressed and either the\n * keyboard-focused widget doesn't capture the event, or when manually\n * dispatched.\n *\n * Has no focus type and does not need focus. Cannot be targetted.\n *\n * For internal use only. Do not use this event unless you know what you're\n * doing.\n *\n * @category Event\n */\nexport class TabSelect extends Event {\n    /** The widget that the tab selected will be done relative to. */\n    readonly relativeTo: Widget | null;\n    /**\n     * A working value; has the widget that this event is relative to been\n     * reached?\n     *\n     * If false, then the {@link Root} should be searched until\n     * {@link TabSelect#relativeTo} is reached, then, set this to true. If true,\n     * then the next visited widget that has a {@link Widget#tabFocusable} value\n     * of true will be focused.\n     *\n     * Note that if {@link TabSelect#relativeTo} is null, then this will be true by\n     * default.\n     */\n    reachedRelative: boolean;\n\n    /**  Create a new TabSelect. */\n    constructor(relativeTo: Widget | null, reversed: boolean) {\n        super(null, null, false, reversed);\n\n        this.relativeTo = relativeTo;\n        this.reachedRelative = relativeTo === null;\n    }\n\n    cloneWithTarget(target: Widget | null): TabSelect {\n        if(target !== null && !TabSelect.targetWarned) {\n            TabSelect.targetWarned = true;\n            console.warn('TabSelect events cannot be targetted to a specific widget. Target ignored');\n        }\n\n        const event = new TabSelect(this.relativeTo, this.reversed);\n        event.reachedRelative = this.reachedRelative;\n        return event;\n    }\n\n    static targetWarned = false;\n}\n", "let measureContext: CanvasRenderingContext2D | null = null;\n\n/**\n * Measures the dimensions of a given string of text with a given font.\n *\n * Note that the first time calling this function is slower than subsequent\n * calls because a dedicated canvas context must be created.\n *\n * @returns Returns a the TextMetrics of the measured text.\n *\n * @category Helper\n */\nexport function measureTextDims(text: string, font: string): TextMetrics {\n    // Get canvas context if not yet got\n    if(measureContext === null) {\n        const tempCanvas = document.createElement('canvas');\n        measureContext = tempCanvas.getContext('2d');\n        if(measureContext === null)\n            throw new Error('Failed to get canvas context');\n    }\n\n    // Set font\n    measureContext.font = font;\n\n    // Measure text\n    // TODO cache a limited amount of text measurements\n    return measureContext.measureText(text);\n}\n", "/**\n * A decorator for a public field which sets calls a callback if the property's\n * value is changed.\n *\n * @typeParam V - The type of the field being watched\n * @param callback - The callback to call if the value changes. `this` is bound.\n * @category Decorator\n */\nexport function watchField<V>(callback: (oldValue: V) => void): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return function(target: Object, propertyKey: string | symbol): void {\n        const curValues = new WeakMap();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value) {\n                const oldValue = curValues.get(this);\n                if(value !== oldValue) {\n                    curValues.set(this, value);\n                    callback.call(this, oldValue);\n                }\n            },\n            get: function() {\n                return curValues.get(this);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchField} which sets a given flag to true.\n *\n * @param flagKey - The key of the flag property to set to true\n * @category Decorator\n */\nexport function flagField(flagKey: string | symbol): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchField(function(this: Object, _oldValue) {\n        (this as Record<string | symbol, unknown>)[flagKey] = true;\n    });\n}\n\n/**\n * A {@link flagField} where the flag key is `_dirty`.\n *\n * @category Decorator\n */\nexport const paintField = flagField('_dirty');\n\n/**\n * A {@link flagField} where the flag key is `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const layoutField = flagField('_layoutDirty');\n\n/**\n * A {@link watchField} which sets a given array of flags to true.\n *\n * @param flagKeys - An array containing the keys of each flag property to set to true\n * @category Decorator\n */\nexport function multiFlagField(flagKeys: Array<string | symbol>): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchField(function(this: Object, _oldValue) {\n        for(const flagKey of flagKeys)\n            (this as Record<string | symbol, unknown>)[flagKey] = true;\n    });\n}\n\n/**\n * A {@link multiFlagField} where the flag keys are `_dirty` and `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const paintLayoutField = multiFlagField(['_dirty', '_layoutDirty']);\n\n/**\n * Similar to {@link watchField}, but for array fields, like tuples. Getting the\n * property returns a shallow copy of the tuple, setting the value uses a\n * shallow copy of the input value if the current value is not an array. If both\n * the new value and the current value are arrays, then the current value's\n * members are updated; no shallow copy is created.\n *\n * @param callback - The callback to call if the value changes. `this` is bound.\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function watchArrayField(callback: () => void, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return function(target: Object, propertyKey: string | symbol): void {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const curValues = new WeakMap<Object, unknown | Array<unknown>>();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value: unknown | Array<unknown>) {\n                if(Array.isArray(value)) {\n                    const curTuple = curValues.get(this);\n                    if(Array.isArray(curTuple)) {\n                        if(value.length !== curTuple.length) {\n                            curTuple.length = value.length;\n                            for(let i = 0; i < value.length; i++)\n                                curTuple[i] = value[i];\n\n                            callback.call(this);\n                        }\n                        else {\n                            for(let i = 0; i < value.length; i++) {\n                                if(curTuple[i] !== value[i]) {\n                                    for(let j = 0; j < value.length; j++)\n                                        curTuple[j] = value[j];\n\n                                    callback.call(this);\n\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        curValues.set(this, [...value]);\n                        callback.call(this);\n                    }\n                }\n                else {\n                    if(allowNonArrays) {\n                        curValues.set(this, value);\n                        callback.call(this);\n                    }\n                    else\n                        throw new Error('Value must be an array');\n                }\n            },\n            get: function() {\n                const curTuple = curValues.get(this);\n                if(!Array.isArray(curTuple))\n                    return curTuple;\n\n                return [...curTuple];\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchArrayField} which sets a given flag to true.\n *\n * @param flagKey - The key of the flag property to set to true\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function flagArrayField(flagKey: string, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchArrayField(function(this: Object) {\n        (this as Record<string | symbol, unknown>)[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_dirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintArrayField(allowNonArrays = false): PropertyDecorator {\n    return flagArrayField('_dirty', allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_layoutDirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function layoutArrayField(allowNonArrays = false): PropertyDecorator {\n    return flagArrayField('_layoutDirty', allowNonArrays);\n}\n\n/**\n * A {@link watchArrayField} which sets a given array of flags to true.\n *\n * @param flagKeys - An array containing the keys of each flag property to set to true\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function multiFlagArrayField(flagKeys: Array<string>, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchArrayField(function(this: Object) {\n        for(const flagKey of flagKeys)\n            (this as Record<string | symbol, unknown>)[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link multiFlagArrayField} where the flag keys are `_dirty` and\n * `_layoutDirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintLayoutArrayField(allowNonArrays = false): PropertyDecorator {\n    return multiFlagArrayField(['_dirty', '_layoutDirty'], allowNonArrays);\n}\n", "import { measureTextDims } from '../helpers/measureTextDims';\nimport { multiFlagField } from '../decorators/FlagFields';\nimport { FillStyle } from '../theme/FillStyle';\n\nconst WIDTH_OVERRIDING_CHARS = new Set(['\\n', '\\t']);\n\n/**\n * A text render group. Contains all neccessary information to position a piece\n * of text.\n *\n * A 4-tuple containing, respectively, the inclusive index where the piece of\n * text starts, the exclusive index where the piece of text ends (including\n * characters that aren't rendered, such as newlines), the right horizontal\n * offset of the piece of text and whether the piece of text overrides width or\n * not.\n *\n * For characters that override width, the text range should have a length of 1\n * and will not be merged with other text render groups, else, it is a hint\n * containing the pre-measured size, for optimisation reasons, and may be merged\n * with other text render groups. Width-overidding groups where the text range\n * length is greater than 1 will have the length of each individual character as\n * an interpolation of the total length, where each character has equal width,\n * which is cheap, but innacurate; this is the reason why it is preferred to\n * have length 1 text range for width-overriding groups although you may still\n * want this for specific reasons (such as trailing space removal).\n * Width-overriding groups are also only meant to be used for whitespaces and\n * will therefore not be painted.\n *\n * Note that 0-width text render groups are valid and used for empty lines.\n *\n * @category Helper\n */\nexport type TextRenderGroup = [rangeStart: number, rangeEnd: number, right: number, overridesWidth: boolean];\n\n/**\n * A line range. Contains all neccessary information to render a line of text.\n * An array of text render groups.\n *\n * @category Helper\n */\nexport type LineRange = Array<TextRenderGroup>;\n\n/**\n * The mode to use for text wrapping in {@link TextHelper}.\n *\n * @category Helper\n */\nexport enum WrapMode {\n    /**\n     * Whitespaces always have width. The default wrapping mode for input\n     * widgets\n     */\n    Normal,\n    /**\n     * Whitespaces at the end of a line which result in an overflow have no\n     * width. The default wrapping mode for widgets that display text, since\n     * spaces at the beginning of a line due to wrapping looks weird in\n     * {@link Label | labels}. Whitespaces at the beginning of a new line are\n     * still kept, as they are deliberate.\n     */\n    Shrink,\n}\n\n/**\n * The mode to use for text alignment in {@link TextHelper}.\n *\n * @category Helper\n */\nexport enum TextAlignMode {\n    /** Align to the start of the line. Equivalent to a ratio of 0. */\n    Start = 0,\n    /** Align to the center of the line. Equivalent to a ratio of 0.5. */\n    Center = 0.5,\n    /** Align to the end of the line. Equivalent to a ratio of 0.5. */\n    End = 1,\n}\n\n/**\n * An aggregate helper class for widgets that contain text.\n *\n * Contains utilities for measuring text dimensions, converting between offsets\n * in pixels and text indices and painting.\n *\n * @category Helper\n */\nexport class TextHelper {\n    /**\n     * The current string of text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    text = '';\n    /**\n     * The current font used for rendering text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])\n    font = '';\n    /**\n     * The current maximum text width. If not Infinite, then text will be\n     * wrapped and width will be set to maxWidth.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    maxWidth = Infinity;\n    /**\n     * The height of each line of text when wrapped. If null, then the helper\n     * will try to automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineHeight: number | null = null;\n    /**\n     * The amount of spacing between lines. If null, then the helper will try to\n     * automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineSpacing: number | null = null;\n    /**\n     * The amount of spaces that each tab character is equivalent to. By\n     * default, it is equivalent to 4 spaces.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])\n    tabWidth = 4;\n    /**\n     * The mode for text wrapping\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    wrapMode: WrapMode = WrapMode.Normal;\n    /**\n     * The text alignment mode. Can also be a ratio.\n     *\n     * Note that this only aligns text in the text's width. If you have wrapping\n     * disabled (maxWidth === Infinity), then you may still need to align the\n     * widget that uses this text helper with a {@link BaseContainer}.\n     */\n    @multiFlagField(['_dirty'])\n    alignMode: TextAlignMode | number = TextAlignMode.Start;\n\n    /** The current largest text width. May be outdated. */\n    private _width = 0;\n    /** The current total text height. May be outdated. */\n    private _height = 0;\n    /** The current {@link TextHelper#lineHeight}. May be outdated */\n    private _lineHeight = 0;\n    /** The current {@link TextHelper#lineSpacing}. May be outdated */\n    private _lineSpacing = 0;\n    /** The actual {@link TextHelper#tabWidth} in pixels. May be outdated */\n    private _tabWidth = 0;\n\n    /** Does the text need to be re-measured? */\n    private measureDirty = true;\n    /** Does the line height or spacing need to be re-measured? */\n    private lineHeightSpacingDirty = true;\n    /** Does the tab width need to be re-measured? */\n    private tabWidthDirty = true;\n    /** Has the text (or properties associated with it) changed? */\n    private _dirty = false;\n    /** See {@link TextHelper#lineRanges}. For internal use only. */\n    private _lineRanges: Array<LineRange> = [];\n\n    /**\n     * Has the text (or properties associated with it) changed? Resets\n     * {@link TextHelper#_dirty} to false\n     */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Measure a slice of text taking left offset into account. If left offset\n     * is 0, then this will also add the left bounding box overhang. If not,\n     * then it will just return the width.\n     *\n     * Only for slices of text which have no width-overriding characters, else,\n     * you will get wrong measurements.\n     *\n     * @returns Returns the new horizontal offset\n     */\n    private measureTextSlice(left: number, start: number, end: number): number {\n        const metrics = measureTextDims(this.text.slice(start, end), this.font);\n        if(left === 0)\n            return metrics.width + Math.max(0, metrics.actualBoundingBoxLeft);\n        else\n            return left + metrics.width;\n    }\n\n    /**\n     * Get width from line range start to index. Handles out of bounds indices,\n     * but keeps them in the same line\n     */\n    private getLineRangeWidthUntil(range: LineRange, index: number): number {\n        // If before or at first group's start index, 0 width\n        if(index <= range[0][0])\n            return 0;\n\n        // Find text render group that this index belongs to\n        let groupIndex = 0;\n        for(; groupIndex < range.length; groupIndex++) {\n            // If index is at this group's end, return group's right value.\n            // Most width-overriding groups have a length of 1 and therefore\n            // just stop here\n            const group = range[groupIndex];\n            const groupEnd = group[1];\n            if(index == groupEnd)\n                return group[2];\n            else if(index >= group[0] && index < groupEnd)\n                break;\n        }\n\n        // If index was after line end, pick end of last group\n        if(groupIndex === range.length)\n            return range[groupIndex - 1][2];\n\n        // Find left value\n        let left = 0;\n        if(groupIndex > 0)\n            left = range[groupIndex - 1][2];\n\n        // Measure the slice of text. Interpolate if it's a width-overidding\n        // group\n        const group = range[groupIndex];\n        if(group[3])\n            return left + group[2] * (index - group[0]) / (group[1] - group[0]);\n        else\n            return this.measureTextSlice(left, group[0], index);\n    }\n\n    /**\n     * Similar to {@link measureTextDims}, but uses text render groups for\n     * optimisation purposes and for the ability of individual characters to\n     * override their natively measured size; tabs having a dynamic size that\n     * aligns them to multiples of a value and newlines having no length.\n     *\n     * @param start - The inclusive index to start measuring at. If there are render groups and unmeasured text before this index, then this value will be overridden to include the unmeasured text. Render groups will also be merged if they don't override width.\n     * @param end - The exclusive index to stop measuring at.\n     * @param lineRange - The current text render groups for this line of text. This will be updated in place.\n     * @param maxWidth - The maximum width of a line of text. If the line contains a single character, this will be ignored.\n     * @returns Returns true if the line range was modified and it fit into the maximum width\n     */\n    private measureText(start: number, end: number, maxWidth: number, lineRange: LineRange): boolean {\n        // Remove render groups that intersect the range that will be measured.\n        // Removing a group means that the group will have to be re-measured and\n        // therefore start is overridden\n        let wantedGroups = 0;\n        for(; wantedGroups < lineRange.length; wantedGroups++) {\n            const group: TextRenderGroup = lineRange[wantedGroups];\n            if(start >= group[0] && start < group[1]) {\n                start = group[0];\n                break;\n            }\n        }\n\n        // Correct start value; attempt to merge with previous groups or expand\n        // the measurement to include previous parts of text that haven't been\n        // measured yet\n        if(wantedGroups > 0) {\n            let lastGroup: TextRenderGroup | null = lineRange[wantedGroups - 1];\n            if(lastGroup[1] !== start) {\n                start = lastGroup[1];\n\n                if(--wantedGroups > 0)\n                    lastGroup = lineRange[wantedGroups];\n                else\n                    lastGroup = null;\n            }\n\n            if(lastGroup !== null && !lastGroup[3] && !WIDTH_OVERRIDING_CHARS.has(this.text[start])) {\n                start = lastGroup[0];\n                wantedGroups--;\n            }\n        }\n\n        // Find left horizontal offset\n        let left = 0;\n        if(wantedGroups > 0)\n            left = lineRange[wantedGroups - 1][2];\n\n        // Measure range of text, potentially splitting it into render groups\n        let groupStart = start;\n        const addedGroups: Array<TextRenderGroup> = [];\n        while(groupStart < end) {\n            if(this.text[groupStart] === '\\t') {\n                // Align to tab width\n                const tabWidth = this.actualTabWidth;\n                left = (Math.floor(left / tabWidth) + 1) * tabWidth;\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n            }\n            else if(this.text[groupStart] === '\\n') {\n                // Make it 0-width and ignore all other text\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n\n                if(groupStart < end)\n                    console.warn('measureText called with text range where newline was at the middle of the range instead of at the end. Some text was ignored');\n\n                break;\n            }\n            else {\n                // Find group end index; at next width-overriding character or\n                // at end\n                let nextNewline = this.text.indexOf('\\n', groupStart + 1);\n                if(nextNewline === -1)\n                    nextNewline = Infinity;\n\n                let nextTab = this.text.indexOf('\\t', groupStart + 1);\n                if(nextTab === -1)\n                    nextTab = Infinity;\n\n                const groupEnd = Math.min(nextNewline, nextTab, end);\n\n                // Measure group\n                left = this.measureTextSlice(left, groupStart, groupEnd);\n                addedGroups.push([groupStart, groupEnd, left, false]);\n\n                groupStart = groupEnd;\n            }\n        }\n\n        // Check if this fits in maximum width\n        const groupCount = wantedGroups + addedGroups.length;\n        const lastGroup = addedGroups[addedGroups.length - 1]\n                            ?? lineRange[wantedGroups - 1]\n                            ?? null;\n\n        if(lastGroup === null) {\n            // Lines ranges must have at least one group\n            lineRange.length = 0;\n            lineRange.push([start, start, 0, false]);\n            return true;\n        }\n        else if((groupCount === 1 && (lastGroup[1] - lastGroup[0]) <= 1) ||\n                lastGroup[2] <= maxWidth) {\n            lineRange.length = wantedGroups;\n            lineRange.push(...addedGroups);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Update {@link TextHelper#_width}, {@link TextHelper#_lineHeight} and\n     * {@link TextHelper#_lineSpacing}. Sets {@link TextHelper#measureDirty} to\n     * false. Does nothing if measurement is not needed.\n     */\n    private updateTextDims(): void {\n        // Update line height or line spacing if needed\n        if(this.lineHeightSpacingDirty) {\n            this.lineHeightSpacingDirty = false;\n\n            const oldLineHeight = this._lineHeight;\n            const oldLineSpacing = this._lineSpacing;\n\n            if(this.lineHeight === null || this.lineSpacing === null) {\n                const metrics = measureTextDims(\n                    '~!@#$%^&*()_+`1234567890-=qwertyuiop[]\\\\QWERTYUIOP{}|asdfghjkl;\\'ASDFGHJKL:\"zxcvbnm,./ZXCVBNM<>?',\n                    this.font,\n                );\n\n                if(this.lineHeight === null)\n                    this._lineHeight = metrics.actualBoundingBoxAscent;\n                else\n                    this._lineHeight = this.lineHeight;\n\n                if(this.lineSpacing === null)\n                    this._lineSpacing = metrics.actualBoundingBoxDescent;\n                else\n                    this._lineSpacing = this.lineSpacing;\n            }\n            else {\n                this._lineHeight = this.lineHeight;\n                this._lineSpacing = this.lineSpacing;\n            }\n\n            // If line height or spacing changed, text needs to be re-measured\n            if(oldLineHeight !== this._lineHeight || oldLineSpacing !== this._lineSpacing)\n                this.measureDirty = true;\n        }\n\n        // Update tab width if needed\n        if(this.tabWidthDirty) {\n            this.tabWidthDirty = false;\n            this._tabWidth = measureTextDims(' ', this.font).width * this.tabWidth;\n        }\n\n        // Abort if measurement not needed\n        if(!this.measureDirty)\n            return;\n\n        // Mark as clean\n        this.measureDirty = false;\n\n        const fullLineHeight = this._lineHeight + this._lineSpacing;\n\n        if(this.text.length === 0) {\n            // Special case for empty string; set height to height of single\n            // line and width to 0 if maxWidth is not set or maxWidth if set\n            this._height = fullLineHeight;\n            this._width = this.maxWidth === Infinity ? 0 : this.maxWidth;\n            this._lineRanges.length = 1;\n            this._lineRanges[0] = [[0, 0, 0, false]];\n        }\n        else if(this.maxWidth === Infinity) {\n            // Don't wrap text, but split lines when there's a newline character\n            this._lineRanges.length = 0;\n            let lineStart = 0;\n            this._height = 0;\n            this._width = 0;\n\n            const text = this.text;\n            // eslint-disable-next-line no-constant-condition\n            while(true) {\n                // Where is the next newline?\n                const newline = this.text.indexOf('\\n', lineStart);\n                const atEnd = newline === -1;\n                const end = atEnd ? text.length : (newline + 1);\n\n                // Measure this block of text and add it to the line ranges\n                const range: LineRange = [];\n                this.measureText(lineStart, end, Infinity, range);\n                this._lineRanges.push(range);\n\n                this._height += fullLineHeight;\n                const width = range[range.length - 1][2];\n                if(width > this._width)\n                    this._width = width;\n\n                // At end, abort\n                if(atEnd)\n                    break;\n\n                // Set start of next line\n                lineStart = end;\n            }\n        }\n        else {\n            // Wrap text\n            this._lineRanges.length = 0;\n            let range: LineRange = [];\n            const text = this.text;\n            const spaceRegex = /\\s/;\n            let wordStart = -1;\n\n            for(let i = 0; i <= text.length;) {\n                const isSpace = spaceRegex.test(text[i]);\n                const atEnd = i === text.length;\n\n                // If this is a whitespace, wrap the previous word and check\n                // where this character fits\n                if(isSpace || atEnd) {\n                    // Try fitting word if any\n                    if(wordStart >= 0 && !this.measureText(wordStart, i, this.maxWidth, range)) {\n                        // Overflow, check if word fits in new line\n                        const newRange: LineRange = [];\n                        if(this.measureText(wordStart, i, this.maxWidth, newRange)) {\n                            // Fits in new line. Push old line to line ranges if\n                            // it had any text render groups\n                            if(range.length === 0)\n                                throw new Error('Unexpected line range without any render groups');\n                            this._lineRanges.push(range);\n                            range = newRange;\n                        }\n                        else {\n                            // Doesn't fit in new line. Fit as much as possible\n                            // in current line and move rest to new line by\n                            // backtracking to where the split occurs. Don't\n                            // reverse this loop; although it may seem more\n                            // efficient, it breaks when the word is broken\n                            // across more than 2 lines\n                            let j = wordStart;\n                            for(; j < i - 1; j++) {\n                                if(!this.measureText(j, j + 1, this.maxWidth, range))\n                                    break;\n                            }\n                            this._lineRanges.push(range);\n                            range = newRange;\n\n                            i = j;\n                            wordStart = j;\n                            continue;\n                        }\n                    }\n\n                    wordStart = -1;\n\n                    // End line\n                    if(atEnd) {\n                        // If there isn't a render group in the line range yet,\n                        // add it. Use last group's position. If there isn't a\n                        // last group, default to the very beginning\n                        if(range.length === 0) {\n                            const lastLineRange = this._lineRanges[this._lineRanges.length - 1];\n                            if(lastLineRange === undefined)\n                                range.push([0, 0, 0, false]);\n                            else {\n                                const lastGroup = lastLineRange[lastLineRange.length - 1];\n                                if(lastGroup === undefined)\n                                    range.push([0, 0, 0, false]);\n                                else\n                                    range.push([lastGroup[1], lastGroup[1], 0, false]);\n                            }\n                        }\n\n                        this._lineRanges.push(range);\n                        break;\n                    }\n\n                    // Try fitting whitespace character\n                    if(text[i] === '\\n') {\n                        // Newline character. Break line, but measure text\n                        // anyways to update line range\n                        this.measureText(i, i + 1, Infinity, range);\n                        this._lineRanges.push(range);\n                        range = [];\n                    }\n                    else if(!this.measureText(i, i + 1, this.maxWidth, range)) {\n                        // Regular whitespace character overflow: put whitespace\n                        // in next line but measure it anyways to update line\n                        // range. If in the shrink wrap mode, then group up as\n                        // many whitespaces as possible and make a zero-width\n                        // group out of them\n                        if(this.wrapMode === WrapMode.Shrink) {\n                            const spaceGroupStart = i;\n                            do {\n                                i++;\n                            } while(text[i] !== '\\n' && spaceRegex.test(text[i]));\n\n                            const lastGroup = range[range.length - 1];\n                            range.push([\n                                spaceGroupStart,\n                                i,\n                                lastGroup !== undefined ? lastGroup[2] : 0,\n                                true,\n                            ]);\n                            this._lineRanges.push(range);\n                            range = [];\n                            continue;\n                        }\n                        else {\n                            this._lineRanges.push(range);\n                            range = [];\n                            this.measureText(i, i + 1, Infinity, range);\n                        }\n                    }\n                }\n                else if(wordStart === -1)\n                    wordStart = i;\n\n                // Incrementing down here so that we don't have to do i = j - 1\n                // when splitting words\n                i++;\n            }\n\n            // Calculate dimensions\n            this._width = this.maxWidth;\n            this._height = fullLineHeight * this._lineRanges.length;\n        }\n    }\n\n    /**\n     * Paint a single text render group with a given offset and left value for\n     * checking if the group is zero-width. left value must not be shifted.\n     *\n     * Used mainly for injecting debug code; you won't get much use out of this\n     * method unless you have a very specific need.\n     */\n    paintGroup(ctx: CanvasRenderingContext2D, group: TextRenderGroup, left: number, x: number, y: number): void {\n        // Skip width-overidding or zero-width render groups\n        if(!group[3] && group[2] > left)\n            ctx.fillText(this.text.slice(group[0], group[1]), x, y);\n    }\n\n    /** Paint all line ranges. */\n    paint(ctx: CanvasRenderingContext2D, fillStyle: FillStyle, x: number, y: number): void {\n        // Clip\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, this.width, this.height);\n        ctx.clip();\n\n        // Apply fill style and font\n        ctx.font = this.font;\n        ctx.fillStyle = fillStyle;\n        ctx.textBaseline = 'alphabetic';\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // Paint line (or lines) of text\n        const fullLineHeight = this.fullLineHeight;\n        let yOffset = y + this._lineHeight;\n        for(let line = 0; line < this._lineRanges.length; line++) {\n            let left = 0;\n            const shift = this.getLineShift(line);\n            for(const group of this._lineRanges[line]) {\n                this.paintGroup(ctx, group, left, x + left + shift, yOffset);\n                left = group[2];\n            }\n\n            yOffset += fullLineHeight;\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the beginning of a character at\n     * a given index.\n     *\n     * See {@link TextHelper#findIndexOffsetFromOffset} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the offset, in pixels. Vertical offset in the tuple is at the top of the character. Note that this is not neccessarily an integer.\n     */\n    findOffsetFromIndex(index: number): [x: number, yTop: number] {\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // If index is 0, an invalid negative number or there are no lines, it\n        // is at the beginning\n        if(index <= 0 || this._lineRanges.length === 0)\n            return [this.getLineShift(0), 0];\n\n        // Check which line the index is in\n        let line = 0;\n        for(const range of this._lineRanges) {\n            if(index < range[range.length - 1][1])\n                break;\n\n            line++;\n        }\n\n        // Special case; the index is after the end, pick the end of the text\n        if(line >= this._lineRanges.length) {\n            line = this._lineRanges.length - 1;\n            index = this.text.length;\n        }\n\n        // Get horizontal offset\n        return [\n            this.getLineRangeWidthUntil(this._lineRanges[line], index) + this.getLineShift(line),\n            line * this.fullLineHeight,\n        ];\n    }\n\n    /**\n     * Get the index and horizontal offset, in pixels, of the beginning of a\n     * character at a given offset.\n     *\n     * See {@link TextHelper#findOffsetFromIndex} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the index of the character at the offset and a 2-tuple containing the offset, in pixels. Note that this is not neccessarily an integer. Note that the returned offset is not the same as the input offset. The returned offset is exactly at the beginning of the character. This is useful for implementing selectable text.\n     */\n    findIndexOffsetFromOffset(offset: [number, number]): [number, [number, number]] {\n        // If offset is before or at first character, text is empty or there are\n        // no lines, default to index 0\n        const fullLineHeight = this.fullLineHeight;\n        const firstShift = this.getLineShift(0);\n        if(this.text === '' || (offset[0] <= firstShift && offset[1] < fullLineHeight) || offset[1] < 0)\n            return [0, [firstShift, 0]];\n\n        // Find line being selected\n        const line = Math.floor(offset[1] / fullLineHeight);\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // If this is beyond the last line, pick the last character\n        if(line >= this._lineRanges.length) {\n            const index = this.text.length;\n            return [index, this.findOffsetFromIndex(index)];\n        }\n\n        // If this is an empty line, stop\n        const yOffset = line * fullLineHeight;\n        const range = this._lineRanges[line];\n        const shift = this.getLineShift(line);\n        if(range.length === 1 && range[0][0] === range[0][1])\n            return [range[0][0], [range[0][2] + shift, yOffset]];\n\n        // TODO This has linear complexity, use binary search instead if possible\n        // For each character, find index at which offset is smaller than\n        // total length minus half length of current character\n        let lastLength = 0;\n        const lineStart = range[0][0];\n\n        // Special case; if line range ends with a newline, ignore last\n        // character\n        let lineEnd = range[range.length - 1][1];\n        if(this.text[lineEnd - 1] === '\\n')\n            lineEnd--;\n\n        const xOffsetUnshifted = offset[0] - shift;\n        for(let i = lineStart; i < lineEnd; i++) {\n            // Measure length from this index to the next\n            const length = this.getLineRangeWidthUntil(range, i + 1);\n            const criticalOffset = (length + lastLength) / 2;\n\n            // If offset is before critical offset, this is the index we're\n            // looking for\n            if(xOffsetUnshifted < criticalOffset)\n                return [i, [lastLength + shift, yOffset]];\n\n            // Update last length\n            lastLength = length;\n        }\n\n        // Offset is after full length of text, return index after end\n        return [lineEnd, [lastLength + shift, yOffset]];\n    }\n\n    /**\n     * Get a line number from a given cursor index. If out of bounds, returns\n     * nearest in-bounds line. Line numbers start at 0.\n     */\n    getLine(index: number): number {\n        if(index <= 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        for(let line = 0; line < this._lineRanges.length; line++) {\n            const lineRange = this._lineRanges[line];\n            const lastGroup = lineRange[lineRange.length - 1];\n            if(index < lastGroup[1])\n                return line;\n        }\n\n        return this._lineRanges.length - 1;\n    }\n\n    /**\n     * Get the index of the start of a line. If out of bounds, returns the\n     * nearest in-bounds index\n     */\n    getLineStart(line: number): number {\n        if(line <= 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line >= this._lineRanges.length) {\n            const lastLine = this._lineRanges[this._lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        return this._lineRanges[line][0][0];\n    }\n\n    /**\n     * Get the index of the end of a line.\n     *\n     * @param includeNewlines - If false, newline characters will be ignored and the end will be at their index, instead of after their index\n     */\n    getLineEnd(line: number, includeNewlines = true): number {\n        if(line < 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line >= this._lineRanges.length) {\n            const lastLine = this._lineRanges[this._lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        const lineRange = this._lineRanges[line];\n        const lastGroup = lineRange[lineRange.length - 1];\n        const lastIndex = lastGroup[1];\n        if(!includeNewlines && lastIndex > 0 &&\n           this.text[lastIndex - 1] === '\\n' && lastGroup[0] !== lastGroup[1])\n            return lastIndex - 1;\n        else\n            return lastIndex;\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the start of a line. Takes text\n     * wrapping into account. Line indices before first line will be treated as\n     * the first line, after the last line will be treated as a new empty line.\n     */\n    getLineShift(line: number): number {\n        // No need to do any logic if aligned to the start\n        const ratio: number = this.alignMode;\n        if(ratio === 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line < 0)\n            line = 0;\n        else if(line >= this._lineRanges.length)\n            return this.width * ratio;\n\n        const lineRange = this._lineRanges[line];\n        return (this.width - lineRange[lineRange.length - 1][2]) * ratio;\n    }\n\n    /** The current text width. Re-measures text if neccessary. */\n    get width(): number {\n        this.updateTextDims();\n        return this._width;\n    }\n\n    /** The current total text height. Re-measures text if neccessary. */\n    get height(): number {\n        this.updateTextDims();\n        return this._height;\n    }\n\n    /**\n     * Which range of text indices are used for each line.\n     *\n     * If there is no text wrapping (maxWidth is Infinity), then this will\n     * contain a single tuple containing [0, (text length)].\n     *\n     * If there is text wrapping, then this will be an array where each member\n     * is a tuple containing the starting index of a line of text and the ending\n     * index (exclusive) of a line of text.\n     */\n    get lineRanges(): Array<LineRange> {\n        this.updateTextDims();\n        return [...this._lineRanges];\n    }\n\n    /**\n     * Get the current line height, even if {@link TextHelper#lineHeight} is\n     * null. Re-measures line height if neccessary.\n     */\n    get actualLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight;\n    }\n\n    /**\n     * Get the current line spacing, even if {@link TextHelper#lineSpacing} is\n     * null. Re-measures line spacing if neccessary.\n     */\n    get actualLineSpacing(): number {\n        this.updateTextDims();\n        return this._lineSpacing;\n    }\n\n    /** Get the current tab width in pixels. Re-measures if neccessary */\n    get actualTabWidth(): number {\n        this.updateTextDims();\n        return this._tabWidth;\n    }\n\n    /**\n     * Get the height between the start of each line; the full line height.\n     *\n     * Equivalent to the sum of {@link TextHelper#actualLineHeight} and\n     * {@link TextHelper#actualLineSpacing}\n     */\n    get fullLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight + this._lineSpacing;\n    }\n}\n", "import type { FlexAlignment2D } from './FlexAlignment2D';\nimport type { ThemeProperties } from './ThemeProperties';\nimport { TextAlignMode } from '../helpers/TextHelper';\nimport type { Alignment2D } from './Alignment2D';\nimport { FlexAlignment } from './FlexAlignment';\nimport type { FillStyle } from './FillStyle';\nimport type { Padding } from './Padding';\nimport { Alignment } from './Alignment';\nimport type { Theme } from './Theme';\n\n/**\n * The base class for {@link Widget} and {@link Theme}. The backbone of the\n * theming system.\n *\n * @category Theme\n */\nexport class BaseTheme implements ThemeProperties {\n    /** See {@link BaseTheme#fallbackTheme} */\n    private _fallbackTheme?: Theme;\n    /** Listener for theme fallback */\n    private listener: ((property: string | null) => void) | null = null;\n\n    /**\n     * The fallback theme. If this theme has a missing property, the fallback\n     * theme's property will be used instead. This will automatically\n     * (un)subscribe to/from the fallback theme.\n     */\n    protected get fallbackTheme(): Theme | undefined {\n        return this._fallbackTheme;\n    }\n\n    protected set fallbackTheme(newTheme: Theme | undefined) {\n        if(this._fallbackTheme === newTheme)\n            return;\n\n        // Unsubscribe from old theme\n        const oldTheme = this._fallbackTheme;\n        if(typeof oldTheme !== 'undefined' && this.listener !== null)\n            oldTheme.unsubscribe(this.listener);\n\n        // Subscribe to new theme\n        if(typeof newTheme !== 'undefined') {\n            this.listener = (property: string | null) => this.onThemeUpdated(property);\n            newTheme.subscribe(this.listener);\n        }\n\n        // Set theme\n        this._fallbackTheme = newTheme;\n\n        // Notify that the fallback theme has changed\n        this.onThemeUpdated();\n    }\n\n    /** Called when the fallback theme changes. Does nothing by default. */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected onThemeUpdated(_property: string | null = null): void {}\n\n    /** Create a new BaseTheme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        this._fallbackTheme = fallbackTheme;\n\n        if(typeof properties === 'undefined')\n            return;\n\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE START\n        this._canvasFill = properties.canvasFill;\n        this._containerPadding = properties.containerPadding;\n        this._containerAlignment = properties.containerAlignment;\n        this._multiContainerSpacing = properties.multiContainerSpacing;\n        this._multiContainerAlignment = properties.multiContainerAlignment;\n        this._primaryFill = properties.primaryFill;\n        this._accentFill = properties.accentFill;\n        this._backgroundFill = properties.backgroundFill;\n        this._backgroundGlowFill = properties.backgroundGlowFill;\n        this._sliderMinLength = properties.sliderMinLength;\n        this._sliderThickness = properties.sliderThickness;\n        this._bodyTextFont = properties.bodyTextFont;\n        this._bodyTextFill = properties.bodyTextFill;\n        this._bodyTextHeight = properties.bodyTextHeight;\n        this._bodyTextSpacing = properties.bodyTextSpacing;\n        this._bodyTextAlign = properties.bodyTextAlign;\n        this._checkboxLength = properties.checkboxLength;\n        this._checkboxInnerPadding = properties.checkboxInnerPadding;\n        this._inputBackgroundFill = properties.inputBackgroundFill;\n        this._inputSelectBackgroundFill = properties.inputSelectBackgroundFill;\n        this._inputTextFont = properties.inputTextFont;\n        this._inputTextFill = properties.inputTextFill;\n        this._inputTextFillDisabled = properties.inputTextFillDisabled;\n        this._inputTextFillInvalid = properties.inputTextFillInvalid;\n        this._inputTextHeight = properties.inputTextHeight;\n        this._inputTextSpacing = properties.inputTextSpacing;\n        this._inputTextInnerPadding = properties.inputTextInnerPadding;\n        this._inputTextMinWidth = properties.inputTextMinWidth;\n        this._inputTextAlign = properties.inputTextAlign;\n        this._blinkRate = properties.blinkRate;\n        this._cursorThickness = properties.cursorThickness;\n        this._scrollBarThickness = properties.scrollBarThickness;\n        this._scrollBarMinPercent = properties.scrollBarMinPercent;\n        this._scrollBarMinPixels = properties.scrollBarMinPixels;\n        this._radioButtonLength = properties.radioButtonLength;\n        this._radioButtonInnerPadding = properties.radioButtonInnerPadding;\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE END\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE START\n    /** See {@link BaseTheme#canvasFill}. For internal use only. */\n    private _canvasFill?: FillStyle;\n\n    get canvasFill(): FillStyle {\n        return this._canvasFill ?? this._fallbackTheme?.canvasFill ?? 'rgba(0,0,0,0.5)';\n    }\n\n    set canvasFill(value: FillStyle | undefined) {\n        if(this._canvasFill !== value) {\n            this._canvasFill = value;\n            this.onThemeUpdated('canvasFill');\n        }\n    }\n\n    /** See {@link BaseTheme#containerPadding}. For internal use only. */\n    private _containerPadding?: Padding;\n\n    get containerPadding(): Padding {\n        return this._containerPadding ?? this._fallbackTheme?.containerPadding ?? <Padding>{left: 4, right: 4, top: 4, bottom: 4};\n    }\n\n    set containerPadding(value: Padding | undefined) {\n        if(this._containerPadding !== value) {\n            this._containerPadding = value;\n            this.onThemeUpdated('containerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#containerAlignment}. For internal use only. */\n    private _containerAlignment?: Alignment2D;\n\n    get containerAlignment(): Alignment2D {\n        return this._containerAlignment ?? this._fallbackTheme?.containerAlignment ?? <Alignment2D>{horizontal: Alignment.Start, vertical: Alignment.Start};\n    }\n\n    set containerAlignment(value: Alignment2D | undefined) {\n        if(this._containerAlignment !== value) {\n            this._containerAlignment = value;\n            this.onThemeUpdated('containerAlignment');\n        }\n    }\n\n    /** See {@link BaseTheme#multiContainerSpacing}. For internal use only. */\n    private _multiContainerSpacing?: number;\n\n    get multiContainerSpacing(): number {\n        return this._multiContainerSpacing ?? this._fallbackTheme?.multiContainerSpacing ?? 4;\n    }\n\n    set multiContainerSpacing(value: number | undefined) {\n        if(this._multiContainerSpacing !== value) {\n            this._multiContainerSpacing = value;\n            this.onThemeUpdated('multiContainerSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#multiContainerAlignment}. For internal use only. */\n    private _multiContainerAlignment?: FlexAlignment2D;\n\n    get multiContainerAlignment(): FlexAlignment2D {\n        return this._multiContainerAlignment ?? this._fallbackTheme?.multiContainerAlignment ?? <FlexAlignment2D>{main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch};\n    }\n\n    set multiContainerAlignment(value: FlexAlignment2D | undefined) {\n        if(this._multiContainerAlignment !== value) {\n            this._multiContainerAlignment = value;\n            this.onThemeUpdated('multiContainerAlignment');\n        }\n    }\n\n    /** See {@link BaseTheme#primaryFill}. For internal use only. */\n    private _primaryFill?: FillStyle;\n\n    get primaryFill(): FillStyle {\n        return this._primaryFill ?? this._fallbackTheme?.primaryFill ?? 'rgb(0,127,255)';\n    }\n\n    set primaryFill(value: FillStyle | undefined) {\n        if(this._primaryFill !== value) {\n            this._primaryFill = value;\n            this.onThemeUpdated('primaryFill');\n        }\n    }\n\n    /** See {@link BaseTheme#accentFill}. For internal use only. */\n    private _accentFill?: FillStyle;\n\n    get accentFill(): FillStyle {\n        return this._accentFill ?? this._fallbackTheme?.accentFill ?? 'rgb(0,195,255)';\n    }\n\n    set accentFill(value: FillStyle | undefined) {\n        if(this._accentFill !== value) {\n            this._accentFill = value;\n            this.onThemeUpdated('accentFill');\n        }\n    }\n\n    /** See {@link BaseTheme#backgroundFill}. For internal use only. */\n    private _backgroundFill?: FillStyle;\n\n    get backgroundFill(): FillStyle {\n        return this._backgroundFill ?? this._fallbackTheme?.backgroundFill ?? 'rgb(32,32,32)';\n    }\n\n    set backgroundFill(value: FillStyle | undefined) {\n        if(this._backgroundFill !== value) {\n            this._backgroundFill = value;\n            this.onThemeUpdated('backgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#backgroundGlowFill}. For internal use only. */\n    private _backgroundGlowFill?: FillStyle;\n\n    get backgroundGlowFill(): FillStyle {\n        return this._backgroundGlowFill ?? this._fallbackTheme?.backgroundGlowFill ?? 'rgb(48,48,48)';\n    }\n\n    set backgroundGlowFill(value: FillStyle | undefined) {\n        if(this._backgroundGlowFill !== value) {\n            this._backgroundGlowFill = value;\n            this.onThemeUpdated('backgroundGlowFill');\n        }\n    }\n\n    /** See {@link BaseTheme#sliderMinLength}. For internal use only. */\n    private _sliderMinLength?: number;\n\n    get sliderMinLength(): number {\n        return this._sliderMinLength ?? this._fallbackTheme?.sliderMinLength ?? 100;\n    }\n\n    set sliderMinLength(value: number | undefined) {\n        if(this._sliderMinLength !== value) {\n            this._sliderMinLength = value;\n            this.onThemeUpdated('sliderMinLength');\n        }\n    }\n\n    /** See {@link BaseTheme#sliderThickness}. For internal use only. */\n    private _sliderThickness?: number;\n\n    get sliderThickness(): number {\n        return this._sliderThickness ?? this._fallbackTheme?.sliderThickness ?? 10;\n    }\n\n    set sliderThickness(value: number | undefined) {\n        if(this._sliderThickness !== value) {\n            this._sliderThickness = value;\n            this.onThemeUpdated('sliderThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextFont}. For internal use only. */\n    private _bodyTextFont?: string;\n\n    get bodyTextFont(): string {\n        return this._bodyTextFont ?? this._fallbackTheme?.bodyTextFont ?? '1rem sans-serif';\n    }\n\n    set bodyTextFont(value: string | undefined) {\n        if(this._bodyTextFont !== value) {\n            this._bodyTextFont = value;\n            this.onThemeUpdated('bodyTextFont');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextFill}. For internal use only. */\n    private _bodyTextFill?: FillStyle;\n\n    get bodyTextFill(): FillStyle {\n        return this._bodyTextFill ?? this._fallbackTheme?.bodyTextFill ?? 'white';\n    }\n\n    set bodyTextFill(value: FillStyle | undefined) {\n        if(this._bodyTextFill !== value) {\n            this._bodyTextFill = value;\n            this.onThemeUpdated('bodyTextFill');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextHeight}. For internal use only. */\n    private _bodyTextHeight?: number | null;\n\n    get bodyTextHeight(): number | null {\n        return this._bodyTextHeight ?? this._fallbackTheme?.bodyTextHeight ?? null;\n    }\n\n    set bodyTextHeight(value: number | null | undefined) {\n        if(this._bodyTextHeight !== value) {\n            this._bodyTextHeight = value;\n            this.onThemeUpdated('bodyTextHeight');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextSpacing}. For internal use only. */\n    private _bodyTextSpacing?: number | null;\n\n    get bodyTextSpacing(): number | null {\n        return this._bodyTextSpacing ?? this._fallbackTheme?.bodyTextSpacing ?? null;\n    }\n\n    set bodyTextSpacing(value: number | null | undefined) {\n        if(this._bodyTextSpacing !== value) {\n            this._bodyTextSpacing = value;\n            this.onThemeUpdated('bodyTextSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextAlign}. For internal use only. */\n    private _bodyTextAlign?: TextAlignMode | number;\n\n    get bodyTextAlign(): TextAlignMode | number {\n        return this._bodyTextAlign ?? this._fallbackTheme?.bodyTextAlign ?? TextAlignMode.Start;\n    }\n\n    set bodyTextAlign(value: TextAlignMode | number | undefined) {\n        if(this._bodyTextAlign !== value) {\n            this._bodyTextAlign = value;\n            this.onThemeUpdated('bodyTextAlign');\n        }\n    }\n\n    /** See {@link BaseTheme#checkboxLength}. For internal use only. */\n    private _checkboxLength?: number;\n\n    get checkboxLength(): number {\n        return this._checkboxLength ?? this._fallbackTheme?.checkboxLength ?? 12;\n    }\n\n    set checkboxLength(value: number | undefined) {\n        if(this._checkboxLength !== value) {\n            this._checkboxLength = value;\n            this.onThemeUpdated('checkboxLength');\n        }\n    }\n\n    /** See {@link BaseTheme#checkboxInnerPadding}. For internal use only. */\n    private _checkboxInnerPadding?: number;\n\n    get checkboxInnerPadding(): number {\n        return this._checkboxInnerPadding ?? this._fallbackTheme?.checkboxInnerPadding ?? 2;\n    }\n\n    set checkboxInnerPadding(value: number | undefined) {\n        if(this._checkboxInnerPadding !== value) {\n            this._checkboxInnerPadding = value;\n            this.onThemeUpdated('checkboxInnerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#inputBackgroundFill}. For internal use only. */\n    private _inputBackgroundFill?: FillStyle;\n\n    get inputBackgroundFill(): FillStyle {\n        return this._inputBackgroundFill ?? this._fallbackTheme?.inputBackgroundFill ?? 'white';\n    }\n\n    set inputBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputBackgroundFill !== value) {\n            this._inputBackgroundFill = value;\n            this.onThemeUpdated('inputBackgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputSelectBackgroundFill}. For internal use only. */\n    private _inputSelectBackgroundFill?: FillStyle;\n\n    get inputSelectBackgroundFill(): FillStyle {\n        return this._inputSelectBackgroundFill ?? this._fallbackTheme?.inputSelectBackgroundFill ?? 'rgb(0,195,255)';\n    }\n\n    set inputSelectBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputSelectBackgroundFill !== value) {\n            this._inputSelectBackgroundFill = value;\n            this.onThemeUpdated('inputSelectBackgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFont}. For internal use only. */\n    private _inputTextFont?: string;\n\n    get inputTextFont(): string {\n        return this._inputTextFont ?? this._fallbackTheme?.inputTextFont ?? '1rem monospace';\n    }\n\n    set inputTextFont(value: string | undefined) {\n        if(this._inputTextFont !== value) {\n            this._inputTextFont = value;\n            this.onThemeUpdated('inputTextFont');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFill}. For internal use only. */\n    private _inputTextFill?: FillStyle;\n\n    get inputTextFill(): FillStyle {\n        return this._inputTextFill ?? this._fallbackTheme?.inputTextFill ?? 'black';\n    }\n\n    set inputTextFill(value: FillStyle | undefined) {\n        if(this._inputTextFill !== value) {\n            this._inputTextFill = value;\n            this.onThemeUpdated('inputTextFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFillDisabled}. For internal use only. */\n    private _inputTextFillDisabled?: FillStyle;\n\n    get inputTextFillDisabled(): FillStyle {\n        return this._inputTextFillDisabled ?? this._fallbackTheme?.inputTextFillDisabled ?? 'grey';\n    }\n\n    set inputTextFillDisabled(value: FillStyle | undefined) {\n        if(this._inputTextFillDisabled !== value) {\n            this._inputTextFillDisabled = value;\n            this.onThemeUpdated('inputTextFillDisabled');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFillInvalid}. For internal use only. */\n    private _inputTextFillInvalid?: FillStyle;\n\n    get inputTextFillInvalid(): FillStyle {\n        return this._inputTextFillInvalid ?? this._fallbackTheme?.inputTextFillInvalid ?? 'red';\n    }\n\n    set inputTextFillInvalid(value: FillStyle | undefined) {\n        if(this._inputTextFillInvalid !== value) {\n            this._inputTextFillInvalid = value;\n            this.onThemeUpdated('inputTextFillInvalid');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextHeight}. For internal use only. */\n    private _inputTextHeight?: number | null;\n\n    get inputTextHeight(): number | null {\n        return this._inputTextHeight ?? this._fallbackTheme?.inputTextHeight ?? null;\n    }\n\n    set inputTextHeight(value: number | null | undefined) {\n        if(this._inputTextHeight !== value) {\n            this._inputTextHeight = value;\n            this.onThemeUpdated('inputTextHeight');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextSpacing}. For internal use only. */\n    private _inputTextSpacing?: number | null;\n\n    get inputTextSpacing(): number | null {\n        return this._inputTextSpacing ?? this._fallbackTheme?.inputTextSpacing ?? null;\n    }\n\n    set inputTextSpacing(value: number | null | undefined) {\n        if(this._inputTextSpacing !== value) {\n            this._inputTextSpacing = value;\n            this.onThemeUpdated('inputTextSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextInnerPadding}. For internal use only. */\n    private _inputTextInnerPadding?: number;\n\n    get inputTextInnerPadding(): number {\n        return this._inputTextInnerPadding ?? this._fallbackTheme?.inputTextInnerPadding ?? 2;\n    }\n\n    set inputTextInnerPadding(value: number | undefined) {\n        if(this._inputTextInnerPadding !== value) {\n            this._inputTextInnerPadding = value;\n            this.onThemeUpdated('inputTextInnerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextMinWidth}. For internal use only. */\n    private _inputTextMinWidth?: number;\n\n    get inputTextMinWidth(): number {\n        return this._inputTextMinWidth ?? this._fallbackTheme?.inputTextMinWidth ?? 100;\n    }\n\n    set inputTextMinWidth(value: number | undefined) {\n        if(this._inputTextMinWidth !== value) {\n            this._inputTextMinWidth = value;\n            this.onThemeUpdated('inputTextMinWidth');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextAlign}. For internal use only. */\n    private _inputTextAlign?: TextAlignMode | number;\n\n    get inputTextAlign(): TextAlignMode | number {\n        return this._inputTextAlign ?? this._fallbackTheme?.inputTextAlign ?? TextAlignMode.Start;\n    }\n\n    set inputTextAlign(value: TextAlignMode | number | undefined) {\n        if(this._inputTextAlign !== value) {\n            this._inputTextAlign = value;\n            this.onThemeUpdated('inputTextAlign');\n        }\n    }\n\n    /** See {@link BaseTheme#blinkRate}. For internal use only. */\n    private _blinkRate?: number;\n\n    get blinkRate(): number {\n        return this._blinkRate ?? this._fallbackTheme?.blinkRate ?? 0.8;\n    }\n\n    set blinkRate(value: number | undefined) {\n        if(this._blinkRate !== value) {\n            this._blinkRate = value;\n            this.onThemeUpdated('blinkRate');\n        }\n    }\n\n    /** See {@link BaseTheme#cursorThickness}. For internal use only. */\n    private _cursorThickness?: number;\n\n    get cursorThickness(): number {\n        return this._cursorThickness ?? this._fallbackTheme?.cursorThickness ?? 1;\n    }\n\n    set cursorThickness(value: number | undefined) {\n        if(this._cursorThickness !== value) {\n            this._cursorThickness = value;\n            this.onThemeUpdated('cursorThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarThickness}. For internal use only. */\n    private _scrollBarThickness?: number;\n\n    get scrollBarThickness(): number {\n        return this._scrollBarThickness ?? this._fallbackTheme?.scrollBarThickness ?? 8;\n    }\n\n    set scrollBarThickness(value: number | undefined) {\n        if(this._scrollBarThickness !== value) {\n            this._scrollBarThickness = value;\n            this.onThemeUpdated('scrollBarThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarMinPercent}. For internal use only. */\n    private _scrollBarMinPercent?: number;\n\n    get scrollBarMinPercent(): number {\n        return this._scrollBarMinPercent ?? this._fallbackTheme?.scrollBarMinPercent ?? 0.1;\n    }\n\n    set scrollBarMinPercent(value: number | undefined) {\n        if(this._scrollBarMinPercent !== value) {\n            this._scrollBarMinPercent = value;\n            this.onThemeUpdated('scrollBarMinPercent');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarMinPixels}. For internal use only. */\n    private _scrollBarMinPixels?: number;\n\n    get scrollBarMinPixels(): number {\n        return this._scrollBarMinPixels ?? this._fallbackTheme?.scrollBarMinPixels ?? 20;\n    }\n\n    set scrollBarMinPixels(value: number | undefined) {\n        if(this._scrollBarMinPixels !== value) {\n            this._scrollBarMinPixels = value;\n            this.onThemeUpdated('scrollBarMinPixels');\n        }\n    }\n\n    /** See {@link BaseTheme#radioButtonLength}. For internal use only. */\n    private _radioButtonLength?: number;\n\n    get radioButtonLength(): number {\n        return this._radioButtonLength ?? this._fallbackTheme?.radioButtonLength ?? 12;\n    }\n\n    set radioButtonLength(value: number | undefined) {\n        if(this._radioButtonLength !== value) {\n            this._radioButtonLength = value;\n            this.onThemeUpdated('radioButtonLength');\n        }\n    }\n\n    /** See {@link BaseTheme#radioButtonInnerPadding}. For internal use only. */\n    private _radioButtonInnerPadding?: number;\n\n    get radioButtonInnerPadding(): number {\n        return this._radioButtonInnerPadding ?? this._fallbackTheme?.radioButtonInnerPadding ?? 2;\n    }\n\n    set radioButtonInnerPadding(value: number | undefined) {\n        if(this._radioButtonInnerPadding !== value) {\n            this._radioButtonInnerPadding = value;\n            this.onThemeUpdated('radioButtonInnerPadding');\n        }\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE END\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { AutoScroll } from '../events/AutoScroll';\nimport type { Viewport } from '../core/Viewport';\nimport type { Padding } from '../theme/Padding';\nimport { TabSelect } from '../events/TabSelect';\nimport type { Bounds } from '../helpers/Bounds';\nimport { BaseTheme } from '../theme/BaseTheme';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Rect } from '../helpers/Rect';\nimport type { Root } from '../core/Root';\n\nconst fontSizeSuffixCharsRegex = /[%a-zA-Z]+/;\nconst fontSizeRegex = /[0-9]+(\\.[0-9]+)?(%|cap|ch|ex|vmin|vmax|Q|r?em|r?lh|i[cn]|[cm]m|p[xct]|v[hwib])/;\nconst twoPi = Math.PI * 2;\n\n/**\n * A generic widget. All widgets extend this class. All widgets extend\n * {@link BaseTheme} so that the theme in use can be overridden.\n *\n * @category Widget\n */\nexport abstract class Widget extends BaseTheme {\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist,\n     * but will still be present in the UI tree.\n     */\n    private _enabled = true;\n    /** Widget will only be painted if dirty is true. */\n    protected _dirty = true;\n    /**\n     * If this is true, widget needs their layout resolved. If implementing a\n     * container, propagate this up.\n     */\n    protected _layoutDirty = true;\n    /**\n     * Widget will have its background automatically cleared when painting if\n     * needsClear is true. The background fill style used is\n     * {@link BaseTheme#canvasFill}.\n     */\n    readonly needsClear: boolean;\n    /**\n     * Widget will get targetted events even if the target is not itself if it\n     * this is true. Useful for implementing container widgets.\n     */\n    readonly propagatesEvents: boolean;\n    /** Width of widget in pixels. */\n    protected width = 0;\n    /** Height of widget in pixels. */\n    protected height = 0;\n    /** Absolute horizontal offset of widget in pixels. */\n    protected x = 0;\n    /** Absolute vertical offset of widget in pixels. */\n    protected y = 0;\n    /**\n     * The ideal width of the widget in pixels; if non-integer widget dimensions\n     * were allowed, the widget would have this size. Use this for layout\n     * calculations, but never use this for painting so that subpixel issues are\n     * avoided.\n     */\n    protected idealWidth = 0;\n    /** The ideal height of the widget in pixels. See {@link Widget#width}. */\n    protected idealHeight = 0;\n    /**\n     * The ideal absolute horizontal offset of the widget in pixels; if\n     * non-integer positions were allowed, the widget would have this position.\n     * Use this for layout calculations, but never use this for painting so that\n     * subpixel issues are avoided.\n     */\n    protected idealX = 0;\n    /**\n     * The ideal absolute vertical offset of the widget in pixels. See\n     * {@link Widget#x}.\n     */\n    protected idealY = 0;\n    /** {@link Widget#flex} but for internal use. */\n    protected _flex = 0;\n    /**\n     * The {@link Root} that this widget is currently inside.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null.\n     */\n    protected _root: Root | null = null;\n    /**\n     * The {@link Viewport} that this widget is currently painting to. A UI tree\n     * can have multiple Viewports due to {@link ViewportWidget}, so this is not\n     * equivalent to {@link Root#viewport}.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null.\n     */\n    protected _viewport: Viewport | null = null;\n    /**\n     * The parent {@link Widget} of this widget.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null, but root\n     * widgets will also have a null parent.\n     */\n    protected _parent: Widget | null = null;\n    /** Can this widget be focused by pressing tab? */\n    protected tabFocusable = false;\n\n    /**\n     * How much this widget will expand relative to other widgets in a flexbox\n     * container. If changed, sets {@link Widget#_layoutDirty} to true.\n     */\n    get flex(): number {\n        return this._flex;\n    }\n\n    set flex(flex: number) {\n        if(flex !== this._flex) {\n            this._flex = flex;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** Create a new Widget. */\n    constructor(needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        this.needsClear = needsClear;\n        this.propagatesEvents = propagatesEvents;\n    }\n\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     *\n     * If changed, calls {@link Widget#forceDirty}\n     *\n     * If getting, {@link Widget#_enabled} is returned.\n     */\n    set enabled(enabled: boolean) {\n        if(enabled === this._enabled)\n            return;\n\n        this._enabled = enabled;\n        this.forceDirty();\n    }\n\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    /**\n     * The inherited theme of this widget. Sets {@link BaseTheme#fallbackTheme}.\n     */\n    set inheritedTheme(theme: Theme | undefined) {\n        this.fallbackTheme = theme;\n    }\n\n    get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(this.needsClear && (property === null || property === 'canvasFill'))\n            this._dirty = true;\n    }\n\n    /**\n     * Get the resolved dimensions. Returns a 2-tuple containing\n     * {@link Widget#width} and {@link Widget#height}.\n     *\n     * Use {@link Widget#idealDimensions} for layout calculations.\n     */\n    get dimensions(): [number, number] {\n        return [this.width, this.height];\n    }\n\n    /**\n     * Get the resolved ideal dimensions. Returns a 2-tuple containing\n     * {@link Widget#idealWidth} and {@link Widget#idealHeight}.\n     *\n     * Use this for layout calculations, and {@link Widget#dimensions} for\n     * painting.\n     */\n    get idealDimensions(): [number, number] {\n        return [this.idealWidth, this.idealHeight];\n    }\n\n    /**\n     * Get the resolved position. Returns a 2-tuple containing {@link Widget#x}\n     * and {@link Widget#y}.\n     *\n     * Use {@link Widget#idealPosition} for layout calculations.\n     */\n    get position(): [number, number] {\n        return [this.x, this.y];\n    }\n\n    /**\n     * Get the resolved ideal position. Returns a 2-tuple containing\n     * {@link Widget#idealX} and {@link Widget#idealY}.\n     *\n     * Use this for layout calculations, and {@link Widget#position} for\n     * painting.\n     */\n    get idealPosition(): [number, number] {\n        return [this.idealX, this.idealY];\n    }\n\n    /** Get the rectangle bounds (left, right, top, bottom) of this widget. */\n    get bounds(): Bounds {\n        const x = this.x;\n        const y = this.y;\n        return [x, x + this.width, y, y + this.height];\n    }\n\n    /** Similar to {@link Widget#bounds}, but uses ideal values */\n    get idealBounds(): Bounds {\n        const x = this.idealX;\n        const y = this.idealY;\n        return [x, x + this.idealWidth, y, y + this.idealHeight];\n    }\n\n    /** Get the rectangle (x, y, width, height) of this widget. */\n    get rect(): Rect {\n        return [this.x, this.y, this.width, this.height];\n    }\n\n    /** Similar to {@link Widget#rect}, but uses ideal values */\n    get idealRect(): Rect {\n        return [this.idealX, this.idealY, this.idealWidth, this.idealHeight];\n    }\n\n    /**\n     * Check if the widget is dirty. Returns {@link Widget#_dirty}, as long as\n     * {@link Widget#dimensionless} is not true.\n     */\n    get dirty(): boolean {\n        return this._dirty && !this.dimensionless;\n    }\n\n    /**\n     * Check if the widget's layout is dirty. Returns\n     * {@link Widget#_layoutDirty}.\n     */\n    get layoutDirty(): boolean {\n        return this._layoutDirty;\n    }\n\n    /**\n     * Check if the widget has zero width or height.\n     *\n     * If true, {@link Widget#paint} will do nothing and {@link Widget#dirty}\n     * will be false even if {@link Widget#_dirty} is true.\n     *\n     * Usually becomes true when containers overflow.\n     */\n    get dimensionless(): boolean {\n        return this.width == 0 || this.height == 0;\n    }\n\n    /**\n     * Called when a focus type has been grabbed by this Widget. Does nothing by\n     * default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    onFocusGrabbed(focusType: FocusType): void {}\n\n    /**\n     * Called when a focus type owned by this Widget has been dropped. Does\n     * nothing by default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    onFocusDropped(focusType: FocusType): void {}\n\n    /**\n     * Widget event handling callback. If the event is to be captured, the\n     * capturer is returned, else, null.\n     *\n     * By default, this will do nothing and capture the event if it is targetted\n     * at itself.\n     *\n     * If overriding, return the widget that has captured the event (could be\n     * `this`, for example, or a child widget if implementing a container), or\n     * null if no widget captured the event. Make sure to not capture any events\n     * that you do not need, or you may have unexpected results; for example, if\n     * you capture all dispatched events indiscriminately, a {@link TabSelect}\n     * event may be captured and result in weird behaviour when the user\n     * attempts to use tab to select another widget.\n     */\n    protected handleEvent(event: Event): Widget | null {\n        if(event.target === this)\n            return this;\n        else\n            return null;\n    }\n\n    /**\n     * Called when an event is passed to the Widget. Checks if the target\n     * matches the Widget, unless the Widget propagates events, or if the event\n     * is a {@link PointerEvent} and is in the bounds of the Widget. If neither\n     * of the conditions are true, the event is not captured (null is returned),\n     * else, the {@link Widget#handleEvent} method is called and its result is\n     * returned. Must not be overridden.\n     *\n     * @returns Returns the widget that captured the event or null if none captured the event.\n     */\n    dispatchEvent(event: Event): Widget | null {\n        if(!this._enabled)\n            return null;\n\n        if(event.target === null) {\n            if(event instanceof PointerEvent) {\n                if(event.x < this.x || event.y < this.y || event.x >= this.x + this.width || event.y >= this.y + this.height)\n                    return null;\n            }\n            else if(event instanceof AutoScroll) {\n                if(event.originallyRelativeTo === this)\n                    return this;\n                else if(!this.propagatesEvents)\n                    return null;\n            }\n        }\n        else if(event.target !== this && !this.propagatesEvents)\n            return null;\n\n        let capturer = null;\n        if(event.reversed)\n            capturer = this.handleEvent(event);\n\n        if(event instanceof TabSelect) {\n            if(event.reachedRelative) {\n                if(this.tabFocusable && (capturer === this || capturer === null)) {\n                    // console.info('Found tab selection candidate:', this.constructor.name);\n                    return this;\n                }\n            }\n            else if(event.relativeTo === this) {\n                // console.info('Reached relativeTo:', this.constructor.name, '(has capturer?', capturer !== null, ')');\n                event.reachedRelative = true;\n            }\n        }\n\n        if(!event.reversed)\n            capturer = this.handleEvent(event);\n\n        return capturer;\n    }\n\n    /**\n     * Generic update method which is called before layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePreLayoutUpdate(): void {}\n\n    /**\n     * Generic update method which is called before layout is resolved. Calls\n     * {@link Widget#handlePreLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    preLayoutUpdate(): void {\n        if(this._enabled)\n            this.handlePreLayoutUpdate();\n    }\n\n    /**\n     * Resolve dimensions of this widget. Must be implemented; set\n     * {@link Widget#width} and {@link Widget#height}.\n     */\n    protected abstract handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void;\n\n    /**\n     * Wrapper for {@link Widget#handleResolveDimensions}. Does nothing if\n     * {@link Widget#_enabled} is false. If the resolved dimensions change,\n     * {@link Widget#_dirty} is set to true. {@link Widget#_layoutDirty} is set\n     * to false. If the widget is not loose and the layout has non-infinite max\n     * constraints, then the widget is stretched to fit max constraints. Must\n     * not be overridden.\n     */\n    resolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Return early if disabled; make widget dimensionless and clear layout\n        // dirty flag\n        if(!this._enabled) {\n            this.width = 0;\n            this.height = 0;\n            this.idealWidth = 0;\n            this.idealHeight = 0;\n            this._layoutDirty = false;\n            return;\n        }\n\n        // Validate constraints\n        if(minWidth == Infinity)\n            throw new Error('minWidth must not be infinite');\n        if(minWidth > maxWidth) {\n            // Not throwing here because floating pointer precision errors\n            // sometimes trigger this due to tight constraints\n            console.warn(`minWidth (${minWidth}) must not be greater than maxWidth (${maxWidth}). Set minWidth to maxWidth. This may be caused by floating pointer precision errors`);\n            minWidth = maxWidth;\n        }\n        if(minWidth < 0) {\n            console.warn(`minWidth (${minWidth}) must not be lesser than 0. Set minWidth to 0. This may be caused by floating pointer precision errors`);\n            minWidth = 0;\n        }\n\n        if(minHeight == Infinity)\n            throw new Error('minHeight must not be infinite');\n        if(minHeight > maxHeight) {\n            console.warn(`minHeight (${minHeight}) must not be greater than maxHeight (${maxHeight}). Set minHeight to maxHeight. This may be caused by floating pointer precision errors`);\n            minHeight = maxHeight;\n        }\n        if(minHeight < 0) {\n            console.warn(`minHeight (${minHeight}) must not be lesser than 0. Set minHeight to 0. This may be caused by floating pointer precision errors`);\n            minHeight = 0;\n        }\n\n        // Keep track of old dimensions to compare later\n        const oldWidth = this.idealWidth;\n        const oldHeight = this.idealHeight;\n\n        // Resolve dimensions\n        this.handleResolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Validate resolved dimensions, handling overflows, underflows and\n        // invalid dimensions\n        if(this.idealWidth < minWidth) {\n            this.idealWidth = minWidth;\n            console.error('Horizontal underflow in widget');\n        }\n        else if(this.idealWidth > maxWidth) {\n            this.idealWidth = maxWidth;\n            console.error('Horizontal overflow in widget');\n        }\n\n        if(this.idealWidth < 0 || !isFinite(this.idealWidth) || isNaN(this.idealWidth))\n            throw new Error(`Disallowed width (${this.idealWidth}) in widget`);\n\n        if(this.idealHeight < minHeight) {\n            this.idealHeight = minHeight;\n            console.error('Vertical underflow in widget');\n        }\n        else if(this.idealHeight > maxHeight) {\n            this.idealHeight = maxHeight;\n            console.error('Vertical overflow in widget');\n        }\n\n        if(this.idealHeight < 0 || !isFinite(this.idealHeight) || isNaN(this.idealHeight))\n            throw new Error(`Disallowed height (${this.idealHeight}) in widget`);\n\n        // Clear layout dirty flag\n        this._layoutDirty = false;\n\n        // If dimensions changed (compare with tracked old dimensions), then set\n        // dirty flag\n        if(oldWidth !== this.idealWidth || oldHeight !== this.idealHeight)\n            this._dirty = true;\n\n        //console.log('Resolved layout of', this.constructor.name);\n    }\n\n    /**\n     * Like {@link Widget#resolveDimensions} but for widgets at the top of the\n     * widget tree (the child of the {@link Root}). This retries dimension\n     * resolving if there is at least one unconstrained axis so that flex layout\n     * works even in infinite layout.\n     */\n    resolveDimensionsAsTop(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Resolve dimensions again, now with maximum constraints. This is so\n        // that widgets that depend on max constraints, such as containers that\n        // handle flexbox layout, work properly. Only do this if constraints\n        // don't already have maximum dimensions.\n        if(maxWidth === Infinity || maxHeight === Infinity) {\n            this.resolveDimensions(\n                minWidth,\n                maxWidth === Infinity ? this.idealWidth : maxWidth,\n                minHeight,\n                maxHeight === Infinity ? this.idealHeight : maxHeight,\n            );\n        }\n    }\n\n    /**\n     * Called after resolving position of this widget. Should be implemented if\n     * widget is a container; call resolvePosition of children. Does nothing by\n     * default.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected afterPositionResolved(): void {}\n\n    /**\n     * Set the position of this widget and calls\n     * {@link Widget#afterPositionResolved}. If the resolved position changes,\n     * sets {@link Widget#_dirty} to true. Does nothing if\n     * {@link Widget#_enabled} is false. Must not be overridden.\n     */\n    resolvePosition(x: number, y: number): void {\n        // Set position\n        this.idealX = x;\n        this.idealY = y;\n\n        // Call hook\n        this.afterPositionResolved();\n    }\n\n    /**\n     * Sets {@link Widget#x}, {@link Widget#y}, {@link Widget#width} and\n     * {@link Widget#y} from {@link Widget#idealX}, {@link Widget#idealY},\n     * {@link Widget#idealWidth} and {@link Widget#idealHeight} by rounding\n     * them. If the final values have changed, {@link Widget#_dirty} is set to\n     * true.\n     *\n     * Can be overridden, but `super.finalizeBounds` must still be called; if\n     * you have parts of the widget that can be pre-calculated when the layout\n     * is known, such as the length and offset of a {@link Checkbox}, or\n     * non-default dirty flags, such as {@link MultiContainer#backgroundDirty},\n     * then this is the perfect method to override, since it's only called after\n     * the layout is resolved to final (non-ideal) values, is only called if\n     * needed (unlike {@link postLayoutUpdate}, which is always called after the\n     * layout phase) and can be used to compare old and new positions and\n     * dimensions.\n     *\n     * Abstract container widgets such as {@link Parent} must always override\n     * this and call `finalizeBounds` on each child widget.\n     */\n    finalizeBounds(): void {\n        // Round bounds\n        const [scaleX, scaleY] = this.viewport.effectiveScale;\n        const newX = Math.floor(this.idealX * scaleX) / scaleX;\n        const newY = Math.floor(this.idealY * scaleY) / scaleY;\n        const newWidth = Math.ceil((this.idealX + this.idealWidth) * scaleX) / scaleX - newX;\n        const newHeight = Math.ceil((this.idealY + this.idealHeight) * scaleY) / scaleY - newY;\n\n        // Mark as dirty if bounds have changed\n        if(newX !== this.x || newY !== this.y || newWidth !== this.width || newHeight !== this.height)\n            this._dirty = true;\n\n        // Set final bounds\n        this.x = newX;\n        this.y = newY;\n        this.width = newWidth;\n        this.height = newHeight;\n    }\n\n    /**\n     * Generic update method called after {@link finalizeBounds} and before\n     * {@link handlePostLayoutUpdate}. However, unlike handlePostLayoutUpdate,\n     * it may be called multiple times in one frame and if {@link _layoutDirty}\n     * is set to true in this method, then a re-layout will occur in the same\n     * frame. Useful if you have logic which depends on the layout, but causes\n     * layout changes, such as for dispatching {@link AutoScroll} events.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePostFinalizeBounds(): void {}\n\n    /**\n     * Calls {@link Widget#handlePostFinalizeBounds} if widget is enabled. Must\n     * not be overridden.\n     */\n    postFinalizeBounds(): void {\n        if(this._enabled)\n            this.handlePostFinalizeBounds();\n    }\n\n    /**\n     * Generic update method which is called after layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePostLayoutUpdate(): void {}\n\n    /**\n     * Generic update method which is called after layout is resolved. Calls\n     * {@link Widget#handlePostLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    postLayoutUpdate(): void {\n        if(this._enabled)\n            this.handlePostLayoutUpdate();\n    }\n\n    /**\n     * Paiting utility: clears background of widget. Should not be overridden.\n     *\n     * Rounds to nearest pixels; no subpixel clearing.\n     *\n     * The background fill style used is {@link ThemeProperties#canvasFill}.\n     *\n     * @param fillStyle - The fill style to use for clearing. If null (default), then the value of {@link ThemeProperties#canvasFill} is used\n     */\n    protected clear(x: number, y: number, width: number, height: number, fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        const ctx = this.viewport.context;\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n        // These are rounded because clipping and filling doesn't\n        // work properly with decimal points\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Paiting utility: start a clear operation with no clipping path, the user\n     * has to add their own paths to the context. Should not be overridden.\n     *\n     * @param fillStyle - The fill style to use for clearing. If null (default), then the value of {@link ThemeProperties#canvasFill} is used\n     */\n    protected clearStart(fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        const ctx = this.viewport.context;\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n    }\n\n    /**\n     * Paiting utility: end a clear operation (from {@link Widget#clearStart}). Should\n     * not be overridden.\n     *\n     * @param fillRule - The canvas fill rule for clipping. See the {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip#parameters | canvas clip documentation}\n     */\n    protected clearEnd(fillRule: CanvasFillRule = 'nonzero'): void {\n        const ctx = this.viewport.context;\n        ctx.clip(fillRule);\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Painting utility: paints a circle. Should not be overridden. Coordinates\n     * are relative to the center of the circle. Uses ctx's current fillStyle.\n     * Does not restore the context state after finishing.\n     */\n    protected paintCircle(x: number, y: number, radius: number): void {\n        const ctx = this.viewport.context;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, twoPi);\n        ctx.fill();\n    }\n\n    /**\n     * Widget painting callback. By default does nothing. Do painting logic here\n     * when extending Widget. Even if {@link Widget#_dirty} is false, if this\n     * method is called, then the widget must still be painted. Should be\n     * overridden.\n     *\n     * @param forced - Was this widget force-painted? If calling a child's paint method, propagate this value\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    protected handlePainting(forced: boolean): void {}\n\n    /**\n     * Called when the Widget is dirty and the Root is being rendered. Does\n     * nothing if dirty flag is not set, else, clears the background if\n     * {@link Widget#needsClear} is true, calls the\n     * {@link Widget#handlePainting} method and unsets the dirty flag.\n     * Automatically calls {@link Widget#dryPaint} if\n     * {@link Widget#dimensionless} is true. Must not be overridden.\n     *\n     * @param force - Force re-paint even if {@link Widget#_dirty} is false\n     */\n    paint(force = false): void {\n        if(this.dimensionless)\n            return this.dryPaint();\n\n        if(!this._dirty && !force)\n            return;\n\n        //console.log('Painted', this.constructor.name);\n\n        if(this._enabled) {\n            if(this.needsClear)\n                this.clear(this.x, this.y, this.width, this.height);\n\n            const ctx = this.viewport.context;\n            ctx.save();\n            this.handlePainting(force);\n            ctx.restore();\n        }\n\n        this._dirty = false;\n    }\n\n    /**\n     * Unset this widget's dirty flag. Call this when painting a child that you\n     * know will not be visible, such as if clipping and the child is out of\n     * bounds. If implementing a container widget, override this so that each\n     * child widget's dryPaint method is called.\n     */\n    dryPaint(): void {\n        this._dirty = false;\n    }\n\n    /**\n     * Force a full theme update. An alias for\n     * {@link Widget#onThemeUpdated}(null). Used by {@link Root#resolution}\n     */\n    forceThemeUpdate(): void {\n        this.onThemeUpdated();\n    }\n\n    /**\n     * Force the widget to be fully re-painted and have layout resolved. For\n     * internal use only or for use by {@link Parent} widgets so that children\n     * get properly marked as dirty when added to a new container after reuse.\n     *\n     * Should be overridden if the derived Widget has more dirty flags other\n     * than the default ones (such as {@link MultiContainer#backgroundDirty}),\n     * but `super.forceDirty` must be called.\n     */\n    forceDirty(): void {\n        this._dirty = true;\n        this._layoutDirty = true;\n    }\n\n    /** Scale a given font string by a given scaling factor */\n    protected scaleFont(font: string, factor: number): string {\n        // Find font-size\n        let findPos = font.search(fontSizeRegex);\n        let suffix, value, matchSize = 0;\n        if(findPos == -1) {\n            // font-size not found. Try to find absolute/relative sizes and\n            // convert them to scaled rem sizes. For relative sizes, you can't\n            // tell the parent element's font size, so assume it has 1rem of\n            // size\n            if((findPos = font.search('xx-small')) !== -1)\n                value = 0.5625 * factor, matchSize = 8;\n            else if((findPos = font.search('x-small')) !== -1)\n                value = 0.625 * factor, matchSize = 7;\n            else if((findPos = font.search('small')) !== -1)\n                value = 0.8333 * factor, matchSize = 5;\n            else if((findPos = font.search('medium')) !== -1)\n                value = factor, matchSize = 6;\n            else if((findPos = font.search('large')) !== -1)\n                value = 1.125 * factor, matchSize = 5;\n            else if((findPos = font.search('x-large')) !== -1)\n                value = 1.5 * factor, matchSize = 7;\n            else if((findPos = font.search('xx-large')) !== -1)\n                value = 2 * factor, matchSize = 8;\n            else if((findPos = font.search('smaller')) !== -1)\n                value = 0.8333 * factor, matchSize = 7;\n            else if((findPos = font.search('larger')) !== -1)\n                value = 1.125 * factor, matchSize = 6;\n            else\n                value = factor; // not found, assume 1rem original font size\n\n            suffix = 'rem';\n        } else {\n            // font-size found. Find out match size\n            const match = font.match(fontSizeRegex);\n            if(match === null)\n                throw new Error('Unexpected null font-size match'); // this should never happen\n\n            const matchStr = match[0];\n            matchSize = matchStr.length;\n\n            // Find suffix in match\n            const suffixMatch = matchStr.match(fontSizeSuffixCharsRegex);\n            if(suffixMatch === null)\n                throw new Error('Unexpected null font-size suffix match'); // this should also never happen\n\n            suffix = suffixMatch[0];\n\n            // Parse numeric part of match and scale it\n            value = parseFloat(matchStr) * factor;\n        }\n\n        // Replace size in font string with new scaled one\n        return font.substring(0, findPos) + value.toString() + suffix + font.substring(findPos + matchSize, font.length);\n    }\n\n    /**\n     * Check if this Widget is active (is in a UI tree). If not, then this\n     * Widget must not be used. Must not be overridden.\n     */\n    get active(): boolean {\n        return this._root !== null;\n    }\n\n    /**\n     * Similar to {@link Widget#_root}, but throws an error if the widget is not\n     * {@link Widget#active}.\n     */\n    get root(): Root {\n        if(!this.active)\n            throw new Error('Cannot get root; Widget is not active');\n\n        // XXX active makes sure that _root is not null, but typescript doesn't\n        // detect this. force the type system to treat it as non-null\n        return this._root as Root;\n    }\n\n    /**\n     * Similar to {@link Widget#_viewport}, but throws an error if the widget is\n     * not {@link Widget#active}.\n     */\n    get viewport(): Viewport {\n        if(!this.active)\n            throw new Error('Cannot get viewport; Widget is not active');\n\n        // XXX active makes sure that _viewport is not null, but typescript\n        // doesn't detect this. force the type system to treat it as non-null\n        return this._viewport as Viewport;\n    }\n\n    /**\n     * Similar to {@link Widget#_parent}, but throws an error if the widget is\n     * not {@link Widget#active}.\n     */\n    get parent(): Widget | null {\n        if(!this.active)\n            throw new Error('Cannot get parent; Widget is not active');\n\n        return this._parent;\n    }\n\n    /**\n     * Called when the Widget is added to a UI tree. Should be overridden for\n     * resource management, but `super.activate` must be called.\n     *\n     * If the widget is already in a UI tree (already has a {@link parent} or is\n     * the {@link Root#child | root Widget}, both checked via\n     * {@link Widget#active}), then this method will throw an exception; a\n     * Widget cannot be in multiple UI trees.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param root - The {@link Root} of the UI tree\n     * @param viewport - The {@link Viewport} in this part of the UI tree. A UI tree can have multiple nested Viewports due to {@link ViewportWidget}\n     * @param parent - The new parent of this Widget. If `null`, then this Widget has no parent and is the {@link Root#child | root Widget}\n     */\n    activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        if(this.active)\n            throw new Error('Attempt to activate active Widget');\n\n        this._root = root;\n        this._viewport = viewport;\n        this._parent = parent;\n        this.forceDirty();\n    }\n\n    /**\n     * Called when the Widget is removed from a UI tree. Should be overridden\n     * for resource management, but `super.deactivate` must be called.\n     *\n     * Sets {@link Widget#_root}, {@link Widget#_viewport} and\n     * {@link Widget#_parent} to null.\n     *\n     * If the widget was not in a UI tree, then an exception is thrown.\n     */\n    deactivate(): void {\n        if(!this.active)\n            throw new Error('Attempt to deactivate inactive Widget');\n\n        this._root = null;\n        this._viewport = null;\n        this._parent = null;\n    }\n\n    /**\n     * {@link AutoScroll | Auto-scroll} to this widget. Uses the whole widget as\n     * the {@link AutoScroll#bounds | auto-scroll bounds}.\n     */\n    autoScroll(): void {\n        this.root.dispatchEvent(new AutoScroll(this, [0, this.idealWidth, 0, this.idealHeight]));\n    }\n\n    // XXX WIDGET AUTO-GENERATED CODE START\n    override get containerPadding(): Padding {\n        const pad = super.containerPadding, res = this._root?.resolution ?? 1;\n        return <Padding>{left: pad.left * res, right: pad.right * res, top: pad.top * res, bottom: pad.bottom * res}\n    }\n\n    override set containerPadding(value: Padding | undefined) {\n        super.containerPadding = value;\n    }\n\n    override get multiContainerSpacing(): number {\n        return super.multiContainerSpacing * (this._root?.resolution ?? 1);\n    }\n\n    override set multiContainerSpacing(value: number | undefined) {\n        super.multiContainerSpacing = value;\n    }\n\n    override get sliderMinLength(): number {\n        return super.sliderMinLength * (this._root?.resolution ?? 1);\n    }\n\n    override set sliderMinLength(value: number | undefined) {\n        super.sliderMinLength = value;\n    }\n\n    override get sliderThickness(): number {\n        return super.sliderThickness * (this._root?.resolution ?? 1);\n    }\n\n    override set sliderThickness(value: number | undefined) {\n        super.sliderThickness = value;\n    }\n\n    private _cachedFont_bodyTextFont = '';\n    private _cachedLastFont_bodyTextFont = '';\n\n    override get bodyTextFont(): string {\n        const superVal = super.bodyTextFont;\n        if(superVal !== this._cachedLastFont_bodyTextFont) {\n            this._cachedLastFont_bodyTextFont = superVal;\n            this._cachedFont_bodyTextFont = this.scaleFont(superVal, this._root?.resolution ?? 1);\n        }\n        return this._cachedFont_bodyTextFont;\n    }\n\n    override set bodyTextFont(value: string | undefined) {\n        super.bodyTextFont = value;\n    }\n\n    override get bodyTextHeight(): number | null {\n        const superVal = super.bodyTextHeight;\n        return superVal === null ? superVal : (superVal * (this._root?.resolution ?? 1));\n    }\n\n    override set bodyTextHeight(value: number | null | undefined) {\n        super.bodyTextHeight = value;\n    }\n\n    override get bodyTextSpacing(): number | null {\n        const superVal = super.bodyTextSpacing;\n        return superVal === null ? superVal : (superVal * (this._root?.resolution ?? 1));\n    }\n\n    override set bodyTextSpacing(value: number | null | undefined) {\n        super.bodyTextSpacing = value;\n    }\n\n    override get checkboxLength(): number {\n        return super.checkboxLength * (this._root?.resolution ?? 1);\n    }\n\n    override set checkboxLength(value: number | undefined) {\n        super.checkboxLength = value;\n    }\n\n    override get checkboxInnerPadding(): number {\n        return super.checkboxInnerPadding * (this._root?.resolution ?? 1);\n    }\n\n    override set checkboxInnerPadding(value: number | undefined) {\n        super.checkboxInnerPadding = value;\n    }\n\n    private _cachedFont_inputTextFont = '';\n    private _cachedLastFont_inputTextFont = '';\n\n    override get inputTextFont(): string {\n        const superVal = super.inputTextFont;\n        if(superVal !== this._cachedLastFont_inputTextFont) {\n            this._cachedLastFont_inputTextFont = superVal;\n            this._cachedFont_inputTextFont = this.scaleFont(superVal, this._root?.resolution ?? 1);\n        }\n        return this._cachedFont_inputTextFont;\n    }\n\n    override set inputTextFont(value: string | undefined) {\n        super.inputTextFont = value;\n    }\n\n    override get inputTextHeight(): number | null {\n        const superVal = super.inputTextHeight;\n        return superVal === null ? superVal : (superVal * (this._root?.resolution ?? 1));\n    }\n\n    override set inputTextHeight(value: number | null | undefined) {\n        super.inputTextHeight = value;\n    }\n\n    override get inputTextSpacing(): number | null {\n        const superVal = super.inputTextSpacing;\n        return superVal === null ? superVal : (superVal * (this._root?.resolution ?? 1));\n    }\n\n    override set inputTextSpacing(value: number | null | undefined) {\n        super.inputTextSpacing = value;\n    }\n\n    override get inputTextInnerPadding(): number {\n        return super.inputTextInnerPadding * (this._root?.resolution ?? 1);\n    }\n\n    override set inputTextInnerPadding(value: number | undefined) {\n        super.inputTextInnerPadding = value;\n    }\n\n    override get inputTextMinWidth(): number {\n        return super.inputTextMinWidth * (this._root?.resolution ?? 1);\n    }\n\n    override set inputTextMinWidth(value: number | undefined) {\n        super.inputTextMinWidth = value;\n    }\n\n    override get cursorThickness(): number {\n        return super.cursorThickness * (this._root?.resolution ?? 1);\n    }\n\n    override set cursorThickness(value: number | undefined) {\n        super.cursorThickness = value;\n    }\n\n    override get scrollBarThickness(): number {\n        return super.scrollBarThickness * (this._root?.resolution ?? 1);\n    }\n\n    override set scrollBarThickness(value: number | undefined) {\n        super.scrollBarThickness = value;\n    }\n\n    override get scrollBarMinPixels(): number {\n        return super.scrollBarMinPixels * (this._root?.resolution ?? 1);\n    }\n\n    override set scrollBarMinPixels(value: number | undefined) {\n        super.scrollBarMinPixels = value;\n    }\n\n    override get radioButtonLength(): number {\n        return super.radioButtonLength * (this._root?.resolution ?? 1);\n    }\n\n    override set radioButtonLength(value: number | undefined) {\n        super.radioButtonLength = value;\n    }\n\n    override get radioButtonInnerPadding(): number {\n        return super.radioButtonInnerPadding * (this._root?.resolution ?? 1);\n    }\n\n    override set radioButtonInnerPadding(value: number | undefined) {\n        super.radioButtonInnerPadding = value;\n    }\n\n    // XXX WIDGET AUTO-GENERATED CODE END\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Viewport } from '../core/Viewport';\nimport type { Theme } from '../theme/Theme';\nimport { Widget } from '../widgets/Widget';\nimport type { Root } from '../core/Root';\n\n/**\n * A class for widgets which may have children.\n *\n * Overrides the {@link Widget#inheritedTheme} accessor so that inherited themes\n * are propagated to children, and {@link Widget#dryPaint} so that dry painting\n * this parent also dry paints the children. Also provides utilities for getting\n * the amount of children, a public iterator for children and a protected child\n * list. This way, widgets that extend this class can decide if modifying the\n * list of children should be public or not.\n *\n * Can be constrained to a specific type of children.\n *\n * See {@link MultiParent} and {@link SingleParent} for more specialised\n * versions.\n *\n * @category Widget\n */\nexport abstract class Parent<W extends Widget = Widget> extends Widget {\n    /**\n     * This widget's children. Note that this is marked as readonly so that it\n     * cannot be accidentally replaced with a new array. This way, references to\n     * this array are always valid. If you want to clear this array, set the\n     * length to zero instead of creating a new instance. readonly still means\n     * that you can add/remove elements to/from the array.\n     *\n     * See {@link Parent#children} for the public iterator getter.\n     */\n    protected readonly _children: Array<W>;\n\n    /**\n     * Create a new Parent. Automatically adds all widgets in the input array\n     * to {@link Parent#_children}.\n     */\n    constructor(children: Array<W>, needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super(needsClear, propagatesEvents, themeProperties);\n\n        this._children = [...children];\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        super.inheritedTheme = theme;\n        for(const child of this.children)\n            child.inheritedTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return super.inheritedTheme;\n    }\n\n    override dryPaint(): void {\n        super.dryPaint();\n\n        for(const child of this.children)\n            child.dryPaint();\n    }\n\n    override forceDirty(): void {\n        super.forceDirty();\n\n        for(const child of this.children)\n            child.forceDirty();\n    }\n\n    /** Get amount of children of this parent widget. */\n    get childCount(): number {\n        return this._children.length;\n    }\n\n    /**\n     * Get iterator for children of this parent widget. Cannot modify list of\n     * children via this iterator; for read-only purposes only.\n     */\n    get children(): Iterable<W> {\n        return this._children.values();\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n\n        for(const child of this.children)\n            child.activate(root, viewport, this);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n\n        for(const child of this.children)\n            child.deactivate();\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        for(const child of this.children)\n            child.finalizeBounds();\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with any\n * amount of children and public access to modifying this list of children.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport abstract class MultiParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Add child(ren) to this widget.\n     *\n     * {@link Widget#_layoutDirty} and {@link Widget#_dirty} are set to true and\n     * each child's {@link Widget#inheritedTheme} is set so that new children\n     * inherit this widget's theme.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param children - If this is a widget, then it is pushed to {@link Parent#_children}. If this is an array of widgets, then each widget is pushed to {@link Parent#_children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    add(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            const isActive = this.active;\n\n            for(const child of children) {\n                this._children.push(child);\n                child.inheritedTheme = this.inheritedTheme;\n\n                if(isActive)\n                    child.activate(this.root, this.viewport, this);\n            }\n        }\n        else {\n            this._children.push(children);\n            children.inheritedTheme = this.inheritedTheme;\n\n            if(this.active)\n                children.activate(this.root, this.viewport, this);\n        }\n\n        this.forceDirty();\n        return this;\n    }\n\n    /**\n     * Remove child(ren) from this widget.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param children - If this is a widget, then it is removed from {@link Parent#_children}. If this is an array of widgets, then each widget is removed from {@link Parent#_children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    remove(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            const isActive = this.active;\n\n            for(const child of children) {\n                const pos = this._children.indexOf(child);\n\n                if(pos !== -1)\n                    this._children.splice(pos, 1);\n                if(isActive)\n                    child.deactivate();\n            }\n        }\n        else {\n            const pos = this._children.indexOf(children);\n\n            if(pos !== -1)\n                this._children.splice(pos, 1);\n            if(this.active)\n                children.deactivate();\n        }\n\n        this.forceDirty();\n        return this;\n    }\n\n    /**\n     * Remove all children from this widget.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @returns Returns this so that the method is chainable.\n     */\n    clearChildren(): this {\n        if(this.active) {\n            for(const child of this._children)\n                child.deactivate();\n        }\n\n        this._children.length = 0;\n        this.forceDirty();\n        return this;\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { FlexAlignment } from '../theme/FlexAlignment';\nimport { Alignment } from '../theme/Alignment';\nimport type { Event } from '../events/Event';\nimport { MultiParent } from './MultiParent';\nimport { Widget } from './Widget';\n\n/**\n * A {@link MultiParent} which automatically paints children, adds spacing,\n * propagates events and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * Note that there is no padding. Put this inside a {@link Margin} if padding is\n * needed.\n *\n * @category Widget\n */\nexport class MultiContainer<W extends Widget = Widget> extends MultiParent<W> {\n    /** Is the container's background dirty? */\n    private backgroundDirty = true;\n    /** Is this container vertical? */\n    private vertical: boolean;\n    /** The unused space along the main axis after resolving dimensions */\n    private unusedSpace = 0;\n    /** The number of enabled children in this container */\n    private enabledChildCount = 0;\n\n    /** Create a MultiContainer. */\n    constructor(vertical: boolean, themeProperties?: ThemeProperties) {\n        // MultiContainers clear their own background, have children and\n        // propagate events\n        super([], false, true, themeProperties);\n\n        this.vertical = vertical;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'multiContainerAlignment')\n            this._layoutDirty = true;\n        else if(property === 'multiContainerSpacing')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Reverse children if necessary\n        let children = this.children;\n        if(event.reversed)\n            children = Array.from(children).reverse();\n\n        // Find which widget the event should go to\n        for(const child of children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Stop if event was captured\n            const captured = child.dispatchEvent(event);\n            if(captured !== null)\n                return captured;\n        }\n\n        // Event wasn't dispatched to any child\n        return null;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update children\n        for(const child of this.children) {\n            child.preLayoutUpdate();\n\n            // If child's layout is dirty, set own layoutDirty flag\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostFinalizeBounds(): void {\n        // Post-finalize bounds update children\n        for(const child of this.children) {\n            child.postFinalizeBounds();\n\n            // If child's layout is dirty, set self's layout as dirty so that\n            // same-frame re-layouts are triggered\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update children\n        for(const child of this.children) {\n            child.postLayoutUpdate();\n\n            // If child is dirty, set own dirty flag\n            if(child.dirty)\n                this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve children's layout with loose constraints along the main axis\n        // to get their wanted dimensions and calculate total flex ratio\n        let totalFlex = 0, crossLength = 0, minCrossAxis = 0;\n        const maxLength = this.vertical ? maxHeight : maxWidth;\n\n        const alignment = this.multiContainerAlignment;\n        if(alignment.cross === Alignment.Stretch) {\n            minCrossAxis = this.vertical ? maxWidth : maxHeight;\n            if(minCrossAxis == Infinity)\n                minCrossAxis = this.vertical ? minWidth : minHeight;\n        }\n\n        this.enabledChildCount = 0;\n        for(const child of this.children) {\n            // Resolve dimensions of disabled children with zero-width\n            // constraints just so layout dirty flag is cleared\n            if(!child.enabled) {\n                child.resolveDimensions(0, 0, 0, 0);\n                continue;\n            }\n\n            this.enabledChildCount++;\n\n            const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n\n            if(this.vertical)\n                child.resolveDimensions(minCrossAxis, maxWidth, 0, Infinity);\n            else\n                child.resolveDimensions(0, Infinity, minCrossAxis, maxHeight);\n\n            const [childWidth, childHeight] = child.idealDimensions;\n\n            totalFlex += child.flex;\n            crossLength = Math.max(this.vertical ? childWidth : childHeight, crossLength);\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Clamp cross length\n        const minCrossLength = this.vertical ? minWidth : minHeight;\n        if(crossLength < minCrossLength)\n            crossLength = minCrossLength;\n\n        // Get free space\n        const spacing = this.multiContainerSpacing;\n        let usedSpace = Math.max(this.enabledChildCount - 1, 0) * spacing;\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            usedSpace += this.vertical ? child.idealDimensions[1] : child.idealDimensions[0];\n        }\n\n        const freeSpace = maxLength - usedSpace;\n\n        // Don't do flexbox calculations if free space is infinite\n        // (unconstrained main axis) or if there isn't any free space.\n        if(freeSpace == Infinity || freeSpace <= 0) {\n            const oldWidth = this.idealWidth;\n            const oldHeight = this.idealHeight;\n\n            if(this.vertical) {\n                this.idealWidth = crossLength;\n                this.idealHeight = Math.min(usedSpace, maxHeight);\n            }\n            else {\n                this.idealWidth = Math.min(usedSpace, maxWidth);\n                this.idealHeight = crossLength;\n            }\n\n            // Mark background as dirty if dimensions changed\n            if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight)\n                this.backgroundDirty = true;\n\n            // Set unused space to 0; no alignment should be done\n            this.unusedSpace = 0;\n\n            // Resolve children's layout, but now with strict constraints so\n            // that they stretch properly and shrink children if neccessary (on\n            // overflow)\n            let spaceLeft = maxLength;\n            for(const child of this.children) {\n                // Ignore disabled children\n                if(!child.enabled)\n                    continue;\n\n                const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n\n                if(this.vertical) {\n                    const wantedLength = Math.min(spaceLeft, oldChildHeight);\n                    child.resolveDimensions(minCrossAxis, maxWidth, wantedLength, wantedLength);\n                }\n                else {\n                    const wantedLength = Math.min(spaceLeft, oldChildWidth);\n                    child.resolveDimensions(wantedLength, wantedLength, minCrossAxis, maxHeight);\n                }\n\n                const [childWidth, childHeight] = child.idealDimensions;\n\n                // Mark background as dirty if child's dimensions changed\n                if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                    this.backgroundDirty = true;\n\n                const childLength = this.vertical ? oldChildHeight\n                                                  : oldChildWidth;\n                spaceLeft = Math.max(0, spaceLeft - childLength - spacing);\n            }\n\n            return;\n        }\n\n        // Resolve children's layout with constraints restricted to distributed\n        // free space. Calculate used space after flexbox calculations.\n        let usedSpaceAfter = 0;\n        let freeSpacePerFlex = 0;\n        if(totalFlex > 0)\n            freeSpacePerFlex = freeSpace / totalFlex;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Add spacing to used space if this is not the first widget\n            if(usedSpaceAfter !== 0)\n                usedSpaceAfter += spacing;\n\n            const dedicatedSpace = freeSpacePerFlex * child.flex;\n            const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n            if(this.vertical) {\n                const wantedLength = dedicatedSpace + oldChildHeight;\n                child.resolveDimensions(\n                    minCrossAxis, maxWidth,\n                    wantedLength, wantedLength,\n                );\n            }\n            else {\n                const wantedLength = dedicatedSpace + oldChildWidth;\n                child.resolveDimensions(\n                    wantedLength, wantedLength,\n                    minCrossAxis, maxHeight,\n                );\n            }\n\n            const [childWidth, childHeight] = child.idealDimensions;\n            usedSpaceAfter += this.vertical ? childHeight : childWidth;\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Resolve width and height\n        const oldWidth = this.idealWidth;\n        const oldHeight = this.idealHeight;\n\n        let length;\n        if(this.vertical) {\n            length = maxHeight;\n            this.idealWidth = crossLength;\n            this.idealHeight = length;\n        }\n        else {\n            length = maxWidth;\n            this.idealWidth = length;\n            this.idealHeight = crossLength;\n        }\n\n        // Mark background as dirty if dimensions changed\n        if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight)\n            this.backgroundDirty = true;\n\n        // Calculate final unused space; used for alignment. Clamp to zero just\n        // in case XXX is that neccessary?\n        this.unusedSpace = Math.max(length - usedSpaceAfter, 0);\n    }\n\n    protected override afterPositionResolved(): void {\n        // Align children\n        const alignment = this.multiContainerAlignment;\n        const around = alignment.main === FlexAlignment.SpaceAround;\n        const between = alignment.main === FlexAlignment.SpaceBetween || around;\n        const mainRatio = (between ? 0 : alignment.main as number);\n        const crossRatio = (alignment.cross === Alignment.Stretch ? 0 : alignment.cross);\n        const effectiveChildren = this.enabledChildCount - 1 + (around ? 2 : 0);\n        let extraSpacing;\n        if(effectiveChildren <= 0)\n            extraSpacing = 0;\n        else\n            extraSpacing = this.unusedSpace / effectiveChildren;\n\n        let spacing = this.multiContainerSpacing;\n        if(between)\n            spacing += extraSpacing;\n\n        let mainOffset = (this.vertical ? this.idealY : this.idealX) + mainRatio * this.unusedSpace;\n        if(around)\n            mainOffset += extraSpacing;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            const [oldChildX, oldChildY] = child.idealPosition;\n            const [childWidth, childHeight] = child.idealDimensions;\n\n            if(this.vertical) {\n                child.resolvePosition(this.idealX + crossRatio * (this.idealWidth - childWidth), mainOffset);\n                mainOffset += childHeight + spacing;\n            }\n            else {\n                child.resolvePosition(mainOffset, this.idealY + crossRatio * (this.idealHeight - childHeight));\n                mainOffset += childWidth + spacing;\n            }\n\n            const [childX, childY] = child.idealPosition;\n\n            // Mark background as dirty if child's position changed\n            if(childX !== oldChildX || childY !== oldChildY)\n                this.backgroundDirty = true;\n        }\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Paint children and build clipping region if background is dirty\n        const clipRects: [number, number, number, number][] = [];\n        for(const child of this.children) {\n            // Paint child\n            child.paint(forced);\n\n            // Add to clipping region if needed. Don't add disabled children to\n            // clipping region\n            if(child.enabled && (this.backgroundDirty || forced))\n                clipRects.push(child.rect);\n        }\n\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart();\n            const ctx = this.viewport.context;\n            ctx.rect(...this.rect);\n            for(const clipRect of clipRects)\n                ctx.rect(...clipRect);\n            this.clearEnd('evenodd');\n        }\n\n        this.backgroundDirty = false;\n    }\n\n    override dryPaint(): void {\n        this.backgroundDirty = false;\n        super.dryPaint();\n    }\n\n    override forceDirty(): void {\n        super.forceDirty();\n        this.backgroundDirty = true;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} mixin class for parents with a\n * single mandatory child.\n *\n * @category Widget\n */\nexport abstract class SingleParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Create a new SingleParent instance.\n     *\n     * @param child - The mandatory single child of this widget. Cannot be changed later, unless {@link Parent#_children} is changed directly via the widget using this mixin.\n     */\n    constructor(child: W, needsClear: boolean, propagatesEvents: boolean, themeProperties?: ThemeProperties) {\n        super([child], needsClear, propagatesEvents, themeProperties);\n    }\n\n    /** This widget's child. */\n    get child(): W {\n        return this._children[0];\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { FillStyle } from '../theme/FillStyle';\nimport { Alignment } from '../theme/Alignment';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and automatically paints\n * the child, adds padding, propagates events (if enabled) and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class BaseContainer<W extends Widget = Widget> extends SingleParent<W> {\n    /** Does the background need to be cleared? */\n    protected backgroundDirty = true;\n\n    /** Create a new BaseContainer. */\n    constructor(child: W, propagateEvents: boolean, themeProperties?: ThemeProperties) {\n        // Containers clear their own background, have a child and may propagate\n        // events\n        super(child, false, propagateEvents, themeProperties);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostFinalizeBounds(): void {\n        // Post-finalize bounds update child\n        const child = this.child;\n        child.postFinalizeBounds();\n\n        // If child's layout is dirty, set self's layout as dirty so that\n        // same-frame re-layouts are triggered\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n\n        // If background is dirty, set self as dirty\n        if(this.backgroundDirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get padding\n        const padding = this.containerPadding;\n        const hPadding = padding.left + padding.right;\n        const vPadding = padding.top + padding.bottom;\n        let childMaxWidth = maxWidth - hPadding;\n        let childMaxHeight = maxHeight - vPadding;\n\n        // If there isn't enough space for padding, resolve child's layout with\n        // a tight fit of 0 for axis with lack of space\n        if(childMaxWidth < 0)\n            childMaxWidth = 0;\n        if(childMaxHeight < 0)\n            childMaxHeight = 0;\n\n        // Provide minimum constraints if using stretch alignment, correcting\n        // for padding. If maximum constraints are available (not infinite), use\n        // those instead\n        const alignment = this.containerAlignment;\n        let childMinWidth = 0;\n        if(alignment.horizontal === Alignment.Stretch) {\n            if(childMaxWidth !== Infinity)\n                childMinWidth = childMaxWidth;\n            else\n                childMinWidth = Math.max(minWidth - hPadding, 0);\n        }\n\n        let childMinHeight = 0;\n        if(alignment.vertical === Alignment.Stretch) {\n            if(childMaxHeight !== Infinity)\n                childMinHeight = childMaxHeight;\n            else\n                childMinHeight = Math.max(minHeight - vPadding, 0);\n        }\n\n        // Resolve child's dimensions\n        const [oldChildWidth, oldChildHeight] = this.child.idealDimensions;\n        this.child.resolveDimensions(childMinWidth, childMaxWidth, childMinHeight, childMaxHeight);\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        // Resolve own dimensions\n        const [oldWidth, oldHeight] = [this.idealWidth, this.idealHeight];\n        this.idealWidth = Math.max(minWidth, childWidth + hPadding);\n        this.idealHeight = Math.max(minHeight, childHeight + vPadding);\n\n        // Mark background as dirty if own size or child's size changed\n        if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight ||\n           childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n            this.backgroundDirty = true;\n    }\n\n    protected override afterPositionResolved(): void {\n        // Get padding and alignment\n        const padding = this.containerPadding;\n        const alignment = this.containerAlignment;\n\n        // Calculate used space\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const usedWidth = childWidth + padding.left + padding.right;\n        const usedHeight = childHeight + padding.top + padding.bottom;\n\n        // Horizontal offset\n        let childX = this.idealX + padding.left;\n        if(alignment.horizontal !== Alignment.Stretch) {\n            // Get free space for this axis\n            const freeSpace = this.idealWidth - usedWidth;\n\n            // Ignore if free space is negative or zero, as in, the child didn't\n            // even get the space they requested or just enough space. If there\n            // is free space, distribute free space according to chosen\n            // alignment ratio\n            if(freeSpace > 0)\n                childX += freeSpace * alignment.horizontal;\n        }\n\n        // Vertical offset\n        let childY = this.idealY + padding.top;\n        if(alignment.vertical !== Alignment.Stretch) {\n            // Same logic as above, but for vertical axis\n            const freeSpace = this.idealHeight - usedHeight;\n\n            if(freeSpace > 0)\n                childY += freeSpace * alignment.vertical;\n        }\n\n        // Resolve child's position\n        const [oldChildX, oldChildY] = this.child.idealPosition;\n        this.child.resolvePosition(childX, childY);\n\n        // If child's position changed, mark background as dirty\n        if(oldChildX !== childX || oldChildY !== childY)\n            this.backgroundDirty = true;\n    }\n\n    /**\n     * Implementation of handlePainting; separate from handlePainting so that\n     * the fillStyle for the background clear can be overridden.\n     */\n    protected handleBaseContainerPainting(forced: boolean, fillStyle: FillStyle | null = null): void {\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart(fillStyle);\n            const ctx = this.viewport.context;\n            ctx.rect(...this.rect);\n            ctx.rect(...this.child.rect);\n            this.clearEnd('evenodd');\n\n            this.backgroundDirty = false;\n        }\n\n        // Paint child\n        this.child.paint(forced);\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        this.handleBaseContainerPainting(forced);\n    }\n\n    override dryPaint(): void {\n        this.backgroundDirty = false;\n        super.dryPaint();\n    }\n\n    override forceDirty(): void {\n        super.forceDirty();\n        this.backgroundDirty = true;\n    }\n}\n", "/**\n * The focus type of an {@link Event}. Used to categorise events when focusing\n * {@link Widget | widgets} in {@link Root | roots}.\n *\n * @category Core\n */\nexport enum FocusType {\n    /** Used for widgets that need pointer input, such as {@link Button} */\n    Pointer = 0,\n    /** Used for widgets that need text input, such as {@link TextInput} */\n    Keyboard = 1,\n    /**\n     * Similar to keyboard focus, but used for checking whether a widget has\n     * been tabbed into (focused by pressing the tab key).\n     *\n     * If a widget gains a tab focus, then it also gain a keyboard focus. If a\n     * widgets gains a keyboard focus, then it also gains a tab focus. However,\n     * losing the tab focus doesn't automatically lose the keyboard focus, and\n     * losing the keyboard focus doesn't automatically lose the tab focus.\n     *\n     * This focus should only be used internally. Do not manually request tab\n     * focus unless you know what you are doing.\n     */\n    Tab = 2,\n}\n", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * The scrolling mode that determines how the {@link PointerWheel#deltaX},\n * {@link PointerWheel#deltaY} and {@link PointerWheel#deltaZ} values are\n * interpreted.\n */\nexport enum PointerWheelMode {\n    /** In this mode, delta values are measured in pixels. */\n    Pixel,\n    /**\n     * In this mode, delta values are measured in line heights. The height of a\n     * line is supplied as an argument to the\n     * {@link PointerWheel#getDeltaPixels} method.\n     */\n    Line,\n    /**\n     * In this mode, delta values are measured in {@link Widget} dimensions,\n     * minus {@link PointerWheel.PageLinesError | a few lines} or\n     * {@link PointerWheel.PagePercentError | a percentage of the dimensions},\n     * whichever is smaller. Both line height and dimensions are supplied as\n     * arguments to the {@link PointerWheel#getDeltaPixels} method.\n     */\n    Page,\n}\n\n/**\n * Convert DOM WheelEvent.deltaMode to {@link PointerWheelMode}, or null if the\n * DOM delta mode is unknown.\n */\nexport function parseDOMDeltaMode(domDeltaMode: number): PointerWheelMode | null {\n    switch(domDeltaMode) {\n        case 0:\n            return PointerWheelMode.Pixel;\n        case 1:\n            return PointerWheelMode.Line;\n        case 2:\n            return PointerWheelMode.Page;\n        default:\n            return null;\n    }\n}\n\n/**\n * A pointer wheel {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerWheel extends PointerEvent {\n    /**\n     * Wheel event horizontal scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaX: number;\n    /**\n     * Wheel event vertical scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaY: number;\n    /**\n     * Wheel event depth scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaZ: number;\n    /**\n     * The mode of the delta values; how the delta values should be\n     * interpreted. See {@link PointerWheelMode}\n     */\n    readonly deltaMode: PointerWheelMode;\n    /** Was this wheel event created from a pointer drag? */\n    readonly fromDrag: boolean;\n\n    /** The amount of lines to remove from a page scroll */\n    static readonly PageLinesError = 3;\n    /** The percentage of a page to remove from a page scroll */\n    static readonly PagePercentError = 0.1;\n\n    /** Create a new PointerWheel. */\n    constructor(x: number, y: number, deltaX: number, deltaY: number, deltaZ: number, deltaMode: PointerWheelMode, fromDrag: boolean, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n        this.deltaX = deltaX;\n        this.deltaY = deltaY;\n        this.deltaZ = deltaZ;\n        this.deltaMode = deltaMode;\n        this.fromDrag = fromDrag;\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerWheel {\n        return new PointerWheel(this.x - xOffset, this.y - yOffset, this.deltaX, this.deltaY, this.deltaZ, this.deltaMode, this.fromDrag, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerWheel {\n        return new PointerWheel(this.x, this.y, this.deltaX, this.deltaY, this.deltaZ, this.deltaMode, this.fromDrag, this.shift, this.ctrl, this.alt, target);\n    }\n\n    /**\n     * Get the scroll delta in pixels, even if the\n     * {@link PointerWheel#deltaMode} is not {@link PointerWheelMode.Pixel}.\n     *\n     * @param forceLimit - Should the delta be limited by {@link PointerWheel.PageLinesError} and {@link PointerWheel.PagePercentError}, if {@link PointerWheel#deltaMode} is not {@link PointerWheelMode.Page}?\n     * @param lineHeight - The full height (line height with spacing) of a line, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerWidth - The width of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerHeight - The height of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerDepth - The depth of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta. Only used for custom containers/widgets with a Z-axis\n     * @returns Returns a 3-tuple containing the x, y and z components, repectively, of the wheel event in pixels.\n     */\n    getDeltaPixels(forceLimit: boolean, lineHeight: number, containerWidth: number, containerHeight: number, containerDepth = 0): [x: number, y: number, z: number] {\n        let limitX = Infinity, limitY = Infinity, limitZ = Infinity;\n        if(forceLimit || this.deltaMode !== PointerWheelMode.Page) {\n            const linesError = lineHeight * PointerWheel.PageLinesError;\n            limitX = containerWidth - Math.min(containerWidth * PointerWheel.PagePercentError, linesError);\n            limitY = containerHeight - Math.min(containerHeight * PointerWheel.PagePercentError, linesError);\n            limitZ = containerDepth - Math.min(containerDepth * PointerWheel.PagePercentError, linesError);\n        }\n\n        switch(this.deltaMode) {\n            case PointerWheelMode.Pixel:\n                return [\n                    Math.min(limitX, Math.abs(this.deltaX)) * Math.sign(this.deltaX),\n                    Math.min(limitY, Math.abs(this.deltaY)) * Math.sign(this.deltaY),\n                    Math.min(limitZ, Math.abs(this.deltaZ)) * Math.sign(this.deltaZ)\n                ];\n            case PointerWheelMode.Line:\n                return [\n                    Math.min(limitX, Math.abs(this.deltaX) * lineHeight) * Math.sign(this.deltaX),\n                    Math.min(limitY, Math.abs(this.deltaY) * lineHeight) * Math.sign(this.deltaY),\n                    Math.min(limitZ, Math.abs(this.deltaZ) * lineHeight) * Math.sign(this.deltaZ)\n                ];\n            case PointerWheelMode.Page:\n            {\n                const linesError = lineHeight * PointerWheel.PageLinesError;\n                return [\n                    (Math.abs(this.deltaX) * containerWidth - Math.min(containerWidth * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaX),\n                    (Math.abs(this.deltaY) * containerHeight - Math.min(containerHeight * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaY),\n                    (Math.abs(this.deltaZ) * containerDepth - Math.min(containerDepth * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaZ)\n                ];\n            }\n            default:\n                throw new Error(`Unknown PointerWheelMode value: ${this.deltaMode}`);\n        }\n    }\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A keyboard {@link ModifierEvent}. This is an abstract class and is\n * implemented in the child classes {@link KeyPress} and {@link KeyRelease}.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport abstract class KeyEvent extends ModifierEvent {\n    /**\n     * This event's key. Uses the same values as the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key}\n     * Web API.\n     */\n    readonly key: string;\n\n    /** Create a new KeyEvent. */\n    constructor(key: string, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null) {\n        super(shift, ctrl, alt, target, FocusType.Keyboard, true);\n        this.key = key;\n    }\n}\n", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key press {@link KeyEvent} (key down). Also dispatched on key repeats.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyPress extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyPress {\n        return new KeyPress(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { FocusType} from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * A leave {@link Event}. Dispatched when the pointer leaves the root or the\n * focus capturer changes to another widget.\n *\n * Has a focus type of {@link FocusType.Pointer} and needs focus.\n *\n * @category Event\n */\nexport class Leave extends Event {\n    /**\n     * Create a new KeyEvent. Sets {@link Event#target}, {@link Event#focusType}\n     * to {@link FocusType.Pointer} and {@link Event#needsFocus} to true.\n     */\n    constructor(target: Widget | null = null) {\n        super(target, FocusType.Pointer, true);\n    }\n\n    cloneWithTarget(target: Widget | null): Leave {\n        return new Leave(target);\n    }\n}\n", "import type { ThemeProperties } from './ThemeProperties';\nimport { BaseTheme } from './BaseTheme';\n\n/**\n * Provides styling for {@link Widget | Widgets}.\n *\n * @category Theme\n */\nexport class Theme extends BaseTheme {\n    /** Listeners that are listening for changes in this theme (or fallback) */\n    protected subscribers: Set<(property: string | null) => void>;\n\n    /** Create a new Theme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        super(properties, fallbackTheme);\n        this.subscribers = new Set();\n    }\n\n    override get fallbackTheme(): Theme | undefined {\n        return super.fallbackTheme;\n    }\n\n    override set fallbackTheme(newTheme: Theme | undefined) {\n        super.fallbackTheme = newTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        // Notify all subscribers\n        for(const listener of this.subscribers)\n            listener(property);\n    }\n\n    /**\n     * Subscribe to this theme. When a change occurs in the theme, the passed\n     * listener callback will be called. The argument used for the callback will\n     * be null if the theme's fallback has changed and therefore all properties\n     * are to be assumed as changed, else, the argument will be a string\n     * containing the name of the theme property that changed.\n     */\n    subscribe(listener: (property: string | null) => void): void {\n        this.subscribers.add(listener);\n    }\n\n    /**\n     * Unsubscribe from this theme; removes the listener callback from the list\n     * of subscribers.\n     */\n    unsubscribe(listener: (property: string | null) => void): void {\n        this.subscribers.delete(listener);\n    }\n}", "/**\n * Rounds a given number up or down to a power of 2. Useful for working with\n * textures.\n *\n * @param number - The number to round\n * @param roundUp - If true, rounds the number to the smallest power of 2 greater\n * or equal to the input, else, rounds the number to the greatest power of 2\n * smaller or equal to the input.\n *\n * @returns Returns the rounded number\n *\n * @category Helper\n */\nexport function roundToPower2(number: number, roundUp = true): number {\n    const roundFun = roundUp ? Math.ceil : Math.floor;\n    return Math.pow(2, roundFun(Math.log2(number)));\n}", "/**\n * Checks whether a given number is a power of 2 greater than 0.\n *\n * @param number - The number to check\n * @returns Returns true if the number is a power of 2 greater than 0\n * @category Helper\n */\nexport function isPower2(number: number): boolean {\n    return (number & (number - 1)) === 0;\n}", "import { paintField, paintArrayField } from '../decorators/FlagFields';\nimport type { LayoutConstraints } from './LayoutConstraints';\nimport { roundToPower2 } from '../helpers/roundToPower2';\nimport type { Widget } from '../widgets/Widget';\nimport { isPower2 } from '../helpers/isPower2';\n\n/**\n * Viewports are internally used to manage a canvas' size and painting. It is\n * used by {@link Root} and {@link ViewportWidget}.\n *\n * @category Core\n */\nexport class Viewport {\n    /** The Viewport's child. Painting and layout will be relative to this. */\n    readonly child: Widget;\n    /**\n     * Layout constraints of viewport when resolving widget's layout. A 4-tuple\n     * containing, respectively, minimum width, maximum width, minimum height\n     * and maximum height.\n     *\n     * By default, has no minimum width nor height and unconstrained maximum\n     * width and height.\n     *\n     * @decorator `@paintArrayField()`\n     */\n    @paintArrayField()\n    constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n    /**\n     * The maximum width the {@link Viewport#canvas} can have. If the layout\n     * exceeds this width, then the content will be scaled to fit the canvas\n     */\n    @paintField\n    maxCanvasWidth = Infinity;\n    /**\n     * The maximum height the {@link Viewport#canvas} can have. If the layout\n     * exceeds this height, then the content will be scaled to fit the canvas\n     */\n    @paintField\n    maxCanvasHeight = Infinity;\n    /** Have the constraints been changed? */\n    private _dirty = true;\n\n    /** The internal canvas. Widgets are painted to this */\n    readonly canvas: HTMLCanvasElement;\n    /** The internal canvas' context. Alpha is enabled. */\n    readonly context: CanvasRenderingContext2D;\n\n    /** Has the warning for dimensionless canvases been issued? */\n    private static dimensionlessWarned = false;\n    /** Has the warning for non-power of 2 dimensions been issued? */\n    private static powerOf2Warned = false;\n    /**\n     * The maximum retries allowed for\n     * {@link Viewport#resolveChildsLayout | resolving the layout}. The first\n     * attempt is not counted. Only retries that exceed this limit are\n     * discarded; if maxRelayout is 4, then the 5th retry will be discarded.\n     */\n    private static maxRelayout = 4;\n\n    /**\n     * Create a new Viewport.\n     *\n     * Creates a new canvas with a starting width and height, setting\n     * {@link Viewport#canvas} and {@link Viewport#context}. Failure to get a\n     * canvas context results in an exception.\n     */\n    constructor(child: Widget, startingWidth = 64, startingHeight = 64) {\n        this.child = child;\n\n        // Create internal canvas\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = startingWidth;\n        this.canvas.height = startingHeight;\n\n        // Get context out of canvas\n        const context = this.canvas.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error('Failed to get canvas context');\n\n        this.context = context;\n    }\n\n    /**\n     * The current dimensions of the {@link Viewport#canvas | internal canvas}\n     */\n    get canvasDimensions(): [number, number] {\n        return [this.canvas.width, this.canvas.height];\n    }\n\n    /**\n     * Resolves the given child's layout by calling\n     * {@link Widget#resolveDimensionsAsTop} with the current\n     * {@link Viewport#constraints}, {@link Widget#resolvePosition} and\n     * {@link Widget#finalizeBounds}. After calling finalizeBounds,\n     * {@link Widget#handlePostFinalizeBounds} is called. Note that if the\n     * layout is marked as dirty while resolving the layout, then a re-layout\n     * will occur until either the layout is no longer marked as dirty or the\n     * {@link Viewport.maxRelayout | maximum retries} are reached.\n     *\n     * If the child's layout is not dirty, then only handlePostFinalizeBounds is\n     * called. Note that this may still trigger a re-layout.\n     *\n     * Expands {@link Viewport#canvas} if the new layout is too big for the\n     * current canvas. Expansion is done in powers of 2 to avoid issues with\n     * external 3D libraries.\n     *\n     * @returns Returns true if the child was resized, else, false.\n     */\n    resolveChildsLayout(): boolean {\n        let relayouts = 0;\n        if(!this.child.layoutDirty && !this._dirty) {\n            // even if a layout resolution is not needed, the hook still needs\n            // to be called at least once per frame\n            this.child.postFinalizeBounds();\n            relayouts++;\n\n            if(!this.child.layoutDirty)\n                return false;\n        }\n\n        // Remove constraints' dirty flag\n        this._dirty = false;\n\n        // Resolve child's layout\n        const [oldWidth, oldHeight] = this.child.dimensions;\n        let newWidth = oldWidth;\n        let newHeight = oldHeight;\n        let wasResized = false;\n\n        while(this.child.layoutDirty) {\n            if(relayouts > Viewport.maxRelayout) {\n                console.warn('Maximum re-layouts exceeded. Is there a Widget type that is immediately marking the layout as dirty after resolving it?')\n                break;\n            }\n            const [minWidth, maxWidth, minHeight, maxHeight] = this.constraints;\n\n            this.child.resolveDimensionsAsTop(minWidth, maxWidth, minHeight, maxHeight);\n            this.child.resolvePosition(0, 0);\n\n            [newWidth, newHeight] = this.child.idealDimensions;\n            const [newScaleX, newScaleY] = this.getAppliedScaleFrom(newWidth, newHeight);\n            newWidth = Math.round(newWidth * newScaleX) / newScaleX;\n            newHeight = Math.round(newHeight * newScaleY) / newScaleY;\n            wasResized = newWidth !== oldWidth || newHeight !== oldHeight;\n\n            this.child.finalizeBounds();\n            this.child.postFinalizeBounds();\n\n            relayouts++;\n        }\n\n        if(relayouts > 1)\n            console.warn(`The last frame required ${relayouts - 1} re-layouts. Make sure to only mark a layout as dirty while resolving the layout unless absolutely necessary`);\n\n        // Re-scale canvas if neccessary.\n        if(wasResized) {\n            // Canvas dimensions are rounded to the nearest power of 2, favoring\n            // bigger powers. This is to avoid issues with mipmapping, which\n            // requires texture sizes to be powers of 2. Make sure that the\n            // maximum canvas dimensions aren't exceeded\n            const newCanvasWidth = Math.min(Math.max(roundToPower2(newWidth), this.canvas.width), this.maxCanvasWidth);\n            const newCanvasHeight = Math.min(Math.max(roundToPower2(newHeight), this.canvas.height), this.maxCanvasHeight);\n\n            if(newCanvasWidth === 0 || newCanvasHeight === 0) {\n                if(!Viewport.dimensionlessWarned) {\n                    Viewport.dimensionlessWarned = true;\n                    console.warn('Canvas has 0 width or height. Are you using an empty Root?');\n                }\n            }\n            else if(!isPower2(newCanvasWidth) || !isPower2(newCanvasHeight)) {\n                if(!Viewport.powerOf2Warned) {\n                    Viewport.powerOf2Warned = true;\n                    console.warn('Canvas has a width or height that is not a power of 2, which may create mipmapping issues. Make sure to use power of 2 starting and maximum canvas dimensions.');\n                }\n            }\n\n            if(newCanvasWidth !== this.canvas.width || newCanvasHeight !== this.canvas.height) {\n                // Resizing a canvas clears its contents. To mitigate this, copy\n                // the canvas contents to a new canvas, resize the canvas and\n                // copy the contents back. To avoid unnecessary copying, the\n                // canvas will not be copied if the old dimensions of the child\n                // were 0x0\n                // TODO resizing is kinda expensive. maybe find a better way?\n                const oldCanvasWidth = this.canvas.width;\n                const oldCanvasHeight = this.canvas.height;\n\n                let copyCanvas = null;\n                if(oldCanvasWidth !== 0 && oldCanvasHeight !== 0) {\n                    copyCanvas = document.createElement('canvas');\n                    copyCanvas.width = oldCanvasWidth;\n                    copyCanvas.height = oldCanvasHeight;\n\n                    const copyCtx = copyCanvas.getContext('2d');\n                    if(copyCtx === null)\n                        throw new Error('Failed to get context of temporary canvas for resizing original canvas');\n\n                    copyCtx.globalCompositeOperation = 'copy';\n                    copyCtx.drawImage(\n                        this.canvas,\n                        0, 0, oldCanvasWidth, oldCanvasHeight,\n                        0, 0, oldCanvasWidth, oldCanvasHeight,\n                    );\n                }\n\n                this.canvas.width = newCanvasWidth;\n                this.canvas.height = newCanvasHeight;\n\n                if(copyCanvas !== null) {\n                    this.context.globalCompositeOperation = 'copy';\n                    this.context.drawImage(\n                        copyCanvas,\n                        0, 0, copyCanvas.width, copyCanvas.height,\n                        0, 0, Math.min(copyCanvas.width, this.maxCanvasWidth), Math.min(copyCanvas.height, this.maxCanvasHeight),\n                    );\n                    this.context.globalCompositeOperation = 'source-over';\n                }\n            }\n        }\n\n        return wasResized;\n    }\n\n    /** Get the canvas scale that will be applied given a width and height */\n    private getAppliedScaleFrom(width: number, height: number): [scaleX: number, scaleY: number] {\n        let scaleX = 1, scaleY = 1;\n        if(width > this.maxCanvasWidth)\n            scaleX = this.maxCanvasWidth / width;\n        if(height > this.maxCanvasHeight)\n            scaleY = this.maxCanvasHeight / height;\n\n        return [scaleX, scaleY];\n    }\n\n    /**\n     * Get the canvas scale that will be applied to the Viewport's child. Used\n     * for checking whether a child's dimensions exceed\n     * {@link Viewport#maxCanvasWidth} or {@link Viewport#maxCanvasHeight}\n     */\n    get effectiveScale(): [scaleX: number, scaleY: number] {\n        return this.getAppliedScaleFrom(...this.child.dimensions);\n    }\n\n    /**\n     * Paint a given child to {@link Viewport#canvas}.\n     *\n     * Nothing is done if the child was not dirty.\n     *\n     * @param force - Force re-paint even if child.{@link Widget#dirty} is false\n     * @returns Returns true if the child was dirty, else, false.\n     */\n    paintToCanvas(force: boolean): boolean {\n        // Paint child\n        const wasDirty = this.child.dirty;\n\n        // scale canvas if child dimensions exceed maximum canvas dimensions\n        const [scaleX, scaleY] = this.effectiveScale;\n        const needsSquish = scaleX !== 1 || scaleY !== 1;\n        if(needsSquish) {\n            this.context.save();\n            this.context.scale(scaleX, scaleY);\n        }\n\n        this.child.paint(force);\n\n        if(needsSquish)\n            this.context.restore();\n\n        return wasDirty;\n    }\n}", "import type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { LayoutConstraints } from './LayoutConstraints';\nimport type { TextInputHandler } from './TextInputHandler';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerWheel } from '../events/PointerWheel';\nimport type { Widget } from '../widgets/Widget';\nimport { TabSelect } from '../events/TabSelect';\nimport { KeyPress } from '../events/KeyPress';\nimport type { Event } from '../events/Event';\nimport { FocusType } from './FocusType';\nimport { Leave } from '../events/Leave';\nimport type { Driver } from './Driver';\nimport { Theme } from '../theme/Theme';\nimport { Viewport } from './Viewport';\n\n/**\n * A Root is the parent of all widgets, but not a widget itself. It contains a\n * single child and manages dimensions and input handling\n *\n * @category Core\n */\nexport class Root {\n    /** The internal viewport. Manages drawing */\n    protected viewport: Viewport;\n    /** The list of drivers registered to this root */\n    protected drivers: Set<Driver> = new Set();\n    /**\n     * Is the Root enabled? For internal use only.\n     *\n     * See {@link Root#enabled}\n     */\n    protected _enabled = true;\n    /**\n     * The pointer style this root wants. Will be set on\n     * {@link Root#postLayoutUpdate} by {@link Root#pointerStyleHandler}\n     */\n    pointerStyle = 'default';\n    /**\n     * The actual current pointer style.\n     *\n     * For internal use only.\n     *\n     * See {@link Root#pointerStyle}\n     */\n    protected _currentPointerStyle = 'default';\n    /**\n     * Pointer style handler, decides how to show the given pointer style.\n     * Normally a function which sets the CSS cursor style of the Root's canvas\n     */\n    pointerStyleHandler: PointerStyleHandler | null;\n    /**\n     * Current component foci (event targets for each focus type).\n     *\n     * For internal use only.\n     *\n     * See {@link Root#requestFocus}, {@link Root#dropFocus},\n     * {@link Root#clearFocus} and {@link Root#getFocus}\n     */\n    protected _foci: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n        [FocusType.Tab, null],\n    ]);\n    /**\n     * Last capturer of each component focus (event targets for each focus\n     * type).\n     *\n     * For internal use only.\n     *\n     * See {@link Root#getFocusCapturer}\n     */\n    protected _fociCapturers: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n        [FocusType.Tab, null],\n    ]);\n    /**\n     * Handler for mobile-friendly text input. If not null, widgets that need\n     * text may call this to get a string.\n     *\n     * See {@link Root#hasMobileTextInput}, {@link Root#usingMobileTextInput}\n     * and {@link Root#getTextInput}\n     */\n    textInputHandler: TextInputHandler | null = null;\n    /**\n     * Is the mobile-friendly text input in use?\n     *\n     * For internal use only.\n     *\n     * See {@link Root#hasMobileTextInput}, {@link Root#usingMobileTextInput}\n     * and {@link Root#getTextInput}\n     */\n    protected _mobileTextInUse = false;\n    /** See {@link resolution} */\n    private _resolution = 1;\n    /** Has the warning for poorly captured TabSelect events been issued? */\n    private static badTabCaptureWarned = false;\n\n    /**\n     * Creates a new Root.\n     *\n     * Sets {@link Root#child}, {@link Root#pointerStyleHandler} and\n     * {@link Root#child}'s {@link Widget#inheritedTheme | inherited theme}.\n     *\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(child: Widget, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        this.viewport = new Viewport(child);\n        this.pointerStyleHandler = pointerStyleHandler;\n        this.child.inheritedTheme = theme;\n        this.child.activate(this, this.viewport, null);\n    }\n\n    /** The {@link Root#viewport}'s {@link Viewport#constraints | constraints} */\n    get constraints(): LayoutConstraints {\n        return this.viewport.constraints;\n    }\n\n    set constraints(constraints: LayoutConstraints) {\n        this.viewport.constraints = constraints;\n    }\n\n    /**\n     * The {@link Root#viewport}'s\n     * {@link Viewport#canvasDimensions | canvasDimensions}\n     */\n    get canvasDimensions(): [number, number] {\n        return this.viewport.canvasDimensions;\n    }\n\n    /**\n     * The {@link Root#child}'s {@link Widget#dimensions | dimensions}\n     */\n    get dimensions(): [number, number] {\n        return this.child.dimensions;\n    }\n\n    /**\n     * Is this root enabled? If not enabled, painting, updating or resolving\n     * layout will do nothing. {@link Root#drivers | Drivers} will also be\n     * notified by calling {@link Driver#onEnable} or {@link Driver#onDisable},\n     * pointer style will be reset ({@link Root#updatePointerStyle} called with\n     * 'default') and all {@link Root#_foci | foci} will be cleared\n     * ({@link Root#clearFocus}).\n     *\n     * See {@link Root#_enabled}\n     */\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    set enabled(newEnabled: boolean) {\n        const oldEnabled = this._enabled;\n\n        if(oldEnabled !== newEnabled) {\n            this._enabled = newEnabled;\n\n            // Call driver hooks, reset pointer style and release foci if UI\n            // disabled\n            if(newEnabled) {\n                for(const driver of this.drivers)\n                    driver.onEnable(this);\n            }\n            else {\n                for(const driver of this.drivers)\n                    driver.onDisable(this);\n\n                this.updatePointerStyle('default');\n\n                for(const focus of this._foci.keys())\n                    this.clearFocus(focus);\n            }\n        }\n    }\n\n\n    /**\n     * The {@link Root#viewport}'s {@link Viewport#canvas | canvas}\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.viewport.canvas;\n    }\n\n    /**\n     * Resolve the layout of this root. Does nothing if root is disabled.\n     *\n     * Calls {@link Root#viewport}'s {@link Viewport#resolveChildsLayout} with\n     * {@link Root#child}\n     *\n     * Call this before calling {@link Root#postLayoutUpdate} and after calling\n     * {@link Root#preLayoutUpdate}\n     *\n     * @returns Returns true if viewport was resized\n     */\n    resolveLayout(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.resolveChildsLayout();\n    }\n\n    /**\n     * Paint this root's next frame if needed. Does nothing if root is disabled.\n     *\n     * Calls {@link Root#viewport}'s {@link Viewport#paintToCanvas} with\n     * {@link Root#child}.\n     *\n     * Call this after calling {@link Root#postLayoutUpdate}.\n     *\n     * @returns Returns whether the child was dirty or not. Use this to tell an external 3D library whether to update a mesh's texture or not.\n     */\n    paint(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.paintToCanvas(false);\n    }\n\n    /**\n     * Dispatches an {@link Event} to this root's {@link Root#child} by calling\n     * {@link Widget#dispatchEvent}. Updates\n     * {@link Root#_fociCapturers | foci capturers} and notifies\n     * {@link Root#drivers} by calling {@link Driver#onFocusCapturerChanged} if\n     * the capturer changes. Does nothing if root is disabled.\n     *\n     * Note that if an event with a focus is dispatched and no widget captures\n     * the event due to the widget not existing anymore or being disabled, the\n     * focus type of the event will be cleared in the root with\n     * {@link Root#clearFocus}.\n     *\n     * @returns Returns true if the event was captured\n     */\n    dispatchEvent(event: Event): boolean {\n        // Ignore event if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        // If event is focusable and is missing a target...\n        if(event.focusType !== null && event.target === null) {\n            // Ignore event if it needs a focus but there is no component\n            // focused in the needed focus\n            let focus = this._foci.get(event.focusType);\n            if(typeof focus === 'undefined')\n                focus = null;\n\n            if(event.needsFocus && focus === null) {\n                // console.warn('Dropped event due to lack of target:', event.constructor.name);\n\n                // special case for tab key with no currently focused widget;\n                // try to do tab selection\n                if(event instanceof KeyPress && event.key === 'Tab') {\n                    // console.warn('Dispatched tab selection (no focused widget)');\n                    this.dispatchEvent(new TabSelect(this.getFocus(FocusType.Tab), event.shift));\n                }\n\n                return false;\n            }\n\n            // Set event target\n            event = event.cloneWithTarget(focus);\n        }\n\n        // Clear pointer style. This will be set by children if neccessary\n        if((event instanceof PointerEvent && !(event instanceof PointerWheel)) || event instanceof Leave)\n            this.pointerStyle = 'default';\n\n        // Pass event down to internal Container\n        let captured = this.child.dispatchEvent(event);\n        if(captured === null) {\n            if(event instanceof KeyPress) {\n                if(event.key === 'Tab') {\n                    // special case for tab key; try to do tab selection\n                    // console.warn('Dispatched tab selection (uncaptured key event)');\n                    this.dispatchEvent(new TabSelect(this.getFocus(FocusType.Tab), event.shift));\n                }\n                else if(event.key === 'Escape') {\n                    // special case for escape key; clear keyboard focus\n                    this.clearFocus(FocusType.Keyboard);\n                }\n            }\n\n            // If this was a tab selection relative to a widget, but the widget\n            // was not found, try again but with no relative widget. This\n            // happens when a removed widget still has tab focus\n            if(event instanceof TabSelect && event.relativeTo !== null) {\n                event = new TabSelect(null, event.reversed);\n                captured = this.child.dispatchEvent(event);\n                // console.warn('Tab select event re-dispatched due to relative widget not being found');\n            }\n        }\n\n        if(event instanceof TabSelect) {\n            if(event.reachedRelative && captured === null) {\n                // If the tab selection failed even though the relative widget\n                // was reached, then the end of the search was likely reached.\n                // Try to start from the beginning again\n                // console.warn('Tab select event re-dispatched due to wrap-around');\n                captured = this.child.dispatchEvent(event);\n            }\n\n            if(captured) {\n                if(!event.reachedRelative && !Root.badTabCaptureWarned) {\n                    Root.badTabCaptureWarned = true;\n                    console.warn(`TabSelect event captured by widget (${captured.constructor.name}), but reachedRelative was false; a widget type is probably capturing events by default`);\n                    console.groupCollapsed('Stack trace');\n                    console.trace();\n                    console.groupEnd();\n                }\n\n                // Request tab focus if tab select event was captured\n                this.requestFocus(FocusType.Tab, captured);\n            }\n        }\n\n        // if(captured)\n        //     console.info('Event', event.constructor.name, 'captured by widget:', captured.constructor.name);\n\n        // Update focus capturer if it changed\n        if(event.focusType === null)\n            return captured !== null;\n\n        const oldCapturer = this.getFocusCapturer(event.focusType);\n        if(oldCapturer === captured)\n            return captured !== null;\n\n        // Special case: when the pointer focus capturer changes, dispatch a\n        // leave event to the last capturer\n        if(event.focusType === FocusType.Pointer && oldCapturer !== null)\n            this.child.dispatchEvent(new Leave(oldCapturer));\n\n        this._fociCapturers.set(event.focusType, captured);\n        for(const driver of this.drivers)\n            driver.onFocusCapturerChanged(this, event.focusType, oldCapturer, captured);\n\n        return captured !== null;\n    }\n\n    /**\n     * Do a pre-layout update; calls {@link Root#drivers}' {@link Driver#update}\n     * and {@link Root#child}'s {@link Widget#preLayoutUpdate}. Does nothing if\n     * root is disabled.\n     *\n     * Call this before calling {@link Root#resolveLayout}\n     */\n    preLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Update drivers\n        for(const driver of this.drivers)\n            driver.update(this);\n\n        // Pre-layout update child\n        this.child.preLayoutUpdate();\n    }\n\n\n    /**\n     * Do a post-layout update; calls {@link Root#child}'s\n     * {@link Widget#postLayoutUpdate} and {@link Root#updatePointerStyle}. Does\n     * nothing if root is disabled.\n     *\n     * Call this before calling {@link Root#paint} and after calling\n     * {@link Root#resolveLayout}\n     */\n    postLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Post-layout update child\n        this.child.postLayoutUpdate();\n\n        // Update pointer style\n        this.updatePointerStyle();\n    }\n\n    /**\n     * Calls {@link Root#pointerStyleHandler} if the {@link Root#pointerStyle}\n     * has changed (checked by comparing with\n     * {@link Root#_currentPointerStyle}). Also updates\n     * {@link Root#_currentPointerStyle}. Can also be optionally supplied a new\n     * pointer style.\n     */\n    updatePointerStyle(newStyle: string | null = null): void {\n        if(newStyle !== null)\n            this.pointerStyle = newStyle;\n\n        if(this.pointerStyle !== this._currentPointerStyle) {\n            this._currentPointerStyle = this.pointerStyle;\n            if(this.pointerStyleHandler !== null)\n                this.pointerStyleHandler(this._currentPointerStyle);\n        }\n    }\n\n    /**\n     * Sets the current {@link Root#_foci | focus} of a given type to a given\n     * widget. If the focus changes, {@link Root#clearFocus} is called and\n     * {@link Root#drivers} are notified by calling\n     * {@link Driver#onFocusChanged}.\n     */\n    requestFocus(focusType: FocusType, widget: Widget): void {\n        if(widget !== null) {\n            // Replace focus if current focus is not the desired one\n            const currentFocus = this._foci.get(focusType);\n            if(widget !== currentFocus) {\n                this.clearFocus(focusType);\n                // console.log('Set focus type', focusType, 'to widget type', widget.constructor.name);\n                this._foci.set(focusType, widget);\n                widget.onFocusGrabbed(focusType);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, focusType, widget);\n            }\n\n            // special cases for keyboard and tab foci, since they are\n            // usually together. a focus that is implied by another focus is\n            // called a partner focus\n            let partnerFocus = null;\n            if(focusType === FocusType.Keyboard)\n                partnerFocus = FocusType.Tab;\n            if(focusType === FocusType.Tab)\n                partnerFocus = FocusType.Keyboard;\n\n            if(partnerFocus !== null && widget !== this._foci.get(partnerFocus)) {\n                this.clearFocus(partnerFocus);\n                // console.log('Set partner focus type', partnerFocus, 'to widget type', widget.constructor.name);\n                this._foci.set(partnerFocus, widget);\n                widget.onFocusGrabbed(partnerFocus);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, partnerFocus, widget);\n            }\n        }\n    }\n\n    /**\n     * Clears the current {@link Root#_foci | focus} of a given type if it is\n     * currently set to a given widget. Achieved by calling\n     * {@link Root#clearFocus}.\n     */\n    dropFocus(focusType: FocusType, widget: Widget): void {\n        // NOTE: Use this instead of clearFocus if your intent is to make sure a\n        // SPECIFIC COMPONENT is no longer focused, NOT ANY COMPONENT\n        const currentFocus = this._foci.get(focusType);\n        if(widget === currentFocus)\n            this.clearFocus(focusType);\n    }\n\n    /**\n     * Clears the current {@link Root#_foci | focus} of a given type. If there\n     * was a focus set, {@link Root#drivers} are notified by calling\n     * {@link Driver#onFocusChanged}.\n     */\n    clearFocus(focusType: FocusType): void {\n        const currentFocus = this._foci.get(focusType);\n        if(currentFocus) {\n            // console.log('Dropped focus type', focusType, 'from widget type', currentFocus.constructor.name);\n            currentFocus.onFocusDropped(focusType);\n\n            this._foci.set(focusType, null);\n            for(const driver of this.drivers)\n                driver.onFocusChanged(this, focusType, null);\n\n            // XXX no special case for clearing keyboard/tab focus. keyboard\n            // implies tab and vice-versa, but lack of keyboard does not imply\n            // lack of tab and vice-versa\n        }\n    }\n\n    /**\n     * Gets the current {@link Root#_foci | focus} of a given type.\n     */\n    getFocus(focusType: FocusType): Widget | null {\n        return this._foci.get(focusType) ?? null;\n    }\n\n    /**\n     * Gets the last {@link Root#_fociCapturers | focus capturer} of a given\n     * type.\n     */\n    getFocusCapturer(focusType: FocusType): Widget | null {\n        return this._fociCapturers.get(focusType) ?? null;\n    }\n\n    /**\n     * Registers a {@link Driver} to the root, adding it to the\n     * {@link Root#drivers} list and calling {@link Driver#onEnable}. If the\n     * driver was already registered, nothing happens.\n     */\n    registerDriver(driver: Driver): void {\n        // If driver is not registered, register it\n        if(this.drivers.has(driver))\n            return;\n\n        this.drivers.add(driver);\n        if(this._enabled && driver.onEnable)\n            driver.onEnable(this);\n    }\n\n    /**\n     * Unregisters a {@link Driver} from the root, removing it from the\n     * {@link Root#drivers} list and calling {@link Driver#onDisable}. If the\n     * driver was not registered, nothing happens.\n     */\n    unregisterDriver(driver: Driver): void {\n        // If driver is registered, unregister it\n        if(!this.drivers.delete(driver))\n            return;\n\n        if(this._enabled && driver.onDisable)\n            driver.onDisable(this);\n    }\n\n    /**\n     * Unregisters all {@link Root#drivers} from the root, by calling\n     * {@link Root#unregisterDriver}.\n     */\n    clearDrivers(): void {\n        // Unregister all drivers\n        for(const driver of this.drivers)\n            this.unregisterDriver(driver);\n    }\n\n    /**\n     * Can {@link Root#getTextInput} be called? True if\n     * {@link Root#textInputHandler} is not null and\n     * {@link Root#usingMobileTextInput} is false.\n     */\n    get hasMobileTextInput(): boolean {\n        return this.textInputHandler !== null && !this._mobileTextInUse;\n    }\n\n    /**\n     * Is {@link Root#getTextInput} in use?\n     *\n     * See {@link Root#_mobileTextInUse}.\n     */\n    get usingMobileTextInput(): boolean {\n        return this._mobileTextInUse;\n    }\n\n    /**\n     * Get text input from the user. Used for mobile where keyboard events are\n     * hard to get.\n     *\n     * @returns If this is already in use ({@link Root#usingMobileTextInput}), returns null, else, returns a string typed by the user.\n     */\n    async getTextInput(initialInput = ''): Promise<string | null> {\n        // Only get if text input is currently available\n        // XXX even though this if statement is equivalent to\n        // hasMobileTextInput, typescript type inference is bad and only works\n        // if its done this way, else it thinks that textInputHandler may be\n        // null and throws an error when compiling\n        if(this.textInputHandler !== null && !this._mobileTextInUse) {\n            // Flag text input as in-use\n            this._mobileTextInUse = true;\n\n            // Get input from handler\n            const newInput = await this.textInputHandler(initialInput);\n\n            // Flag text input as not in-use\n            this._mobileTextInUse = false;\n\n            // Return new value\n            return newInput;\n        }\n\n        return null;\n    }\n\n    /**\n     * The resolution of this Root; theme properties that are absolute sizes in\n     * pixels will automatically be multiplied by this value. Keep this value in\n     * mind when implementing your own properties that have absolute sizes.\n     */\n    get resolution(): number {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number) {\n        if(this._resolution !== resolution) {\n            this._resolution = resolution;\n            this.child.forceThemeUpdate();\n        }\n    }\n\n    /**\n     * Shortcut for {@link Root#viewport}'s\n     * {@link Viewport#maxCanvasWidth} property\n     */\n    get maxCanvasWidth(): number {\n        return this.viewport.maxCanvasWidth;\n    }\n\n    set maxCanvasWidth(maxCanvasWidth: number) {\n        this.viewport.maxCanvasWidth = maxCanvasWidth;\n    }\n\n    /**\n     * Shortcut for {@link Root#viewport}'s\n     * {@link Viewport#maxCanvasHeight} property\n     */\n    get maxCanvasHeight(): number {\n        return this.viewport.maxCanvasHeight;\n    }\n\n    set maxCanvasHeight(maxCanvasHeight: number) {\n        this.viewport.maxCanvasHeight = maxCanvasHeight;\n    }\n\n    /**\n     * Get the scale used for the {@link Root#viewport}. The horizontal and/or\n     * vertical scale may not be 1 if {@link Root#maxCanvasWidth} or\n     * {@link Root#maxCanvasHeight} are exceeded.\n     *\n     * Note that this is only valid after resolving {@link Root#child}'s layout.\n     *\n     * Equivalent to getting {@link Viewport#effectiveScale} on\n     * {@link Root#viewport}.\n     */\n    get effectiveScale(): [scaleX: number, scaleY: number] {\n        return this.viewport.effectiveScale;\n    }\n\n    /**\n     * The root widget of this UI tree. Equivalent to getting\n     * {@link Root#viewport}.{@link Viewport#child}.\n     */\n    get child(): Widget {\n        return this.viewport.child;\n    }\n}\n", "// Need to use unsafe code which abuses the any type\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { TextRenderGroup } from '../helpers/TextHelper';\nimport { MultiContainer } from '../widgets/MultiContainer';\nimport { BaseContainer } from '../widgets/BaseContainer';\nimport type { FillStyle } from '../theme/FillStyle';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { BaseTheme } from '../theme/BaseTheme';\nimport { Widget } from '../widgets/Widget';\nimport { Root } from './Root';\n\nconst features: Map<string, [enabled: boolean, description: string]> = new Map();\n\n/**\n * Check if a debug feature is enabled.\n *\n * @param debugFeature - The debug feature name, for example, \"watchflag.Widget._dirty\"\n * @returns Returns true if the debug feature is enabled. If the feature doesn't exist, returns false.\n */\nexport function isDebugFeatureEnabled(debugFeature: string): boolean {\n    const featureConfig = features.get(debugFeature);\n    if(featureConfig === undefined) {\n        console.warn(`Unknown debug feature \"${debugFeature}\"; defaulting to not enabled`);\n        return false;\n    }\n\n    return featureConfig[0];\n}\n\n/**\n * Enable or disable a debug feature.\n *\n * @param debugFeature - The debug feature name, for example, \"watchflag.Widget._dirty\"\n * @param enabled - Should the feature be enabled or disabled? If undefined, toggles the feature\n */\nexport function toggleDebugFeature(debugFeature: string, enabled?: boolean): void {\n    const featureConfig = features.get(debugFeature);\n    if(featureConfig === undefined) {\n        console.warn(`Unknown debug feature \"${debugFeature}\"; ignored`);\n        return;\n    }\n\n    const [wasEnabled, _description] = featureConfig;\n\n    if(enabled === undefined)\n        enabled = !wasEnabled;\n\n    if(wasEnabled !== enabled) {\n        featureConfig[0] = enabled;\n        console.info(`[canvas-ui] ${enabled ? 'En' : 'Dis'}abled \"${debugFeature}\" debug feature`);\n    }\n}\n\n/** List all debug features in the console. */\nexport function listDebugFeatures(): void {\n    for(const [feature, featureConfig] of features)\n        console.info(`[canvas-ui] \"${feature}\" (${featureConfig[0] ? 'en' : 'dis'}abled): ${featureConfig[1]}`);\n}\n\n/**\n * Inject code for a new debug feature that watches when a class' property is\n * set to true and prints to the console.\n *\n * @param classObj - The class. Widget for example\n * @param flagKey - The key of the property to watch. \"_dirty\" for example\n */\nexport function injectWatchflagFeature(classObj: any, flagKey: string): void {\n    const propertyPath = `${classObj.name}.${flagKey}`;\n    const featureName = `watchflag.${propertyPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const featureNameStrace = `watchflag.${propertyPath}.strace`;\n    if(features.has(featureNameStrace)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureNameStrace}; ignored`);\n        return;\n    }\n\n    const valueMap: WeakMap<any, boolean> = new WeakMap();\n    Object.defineProperty(classObj.prototype, flagKey, {\n        get() {\n            return valueMap.get(this);\n        },\n        set(newValue) {\n            if(isDebugFeatureEnabled(featureName)) {\n                const oldVal = valueMap.get(this);\n                if(!oldVal && newValue) {\n                    const msg = `[canvas-ui ${featureName}] ${this.constructor.name}.${flagKey} set to true`;\n                    if(isDebugFeatureEnabled(featureNameStrace)) {\n                        console.groupCollapsed(msg);\n                        console.trace();\n                        console.groupEnd();\n                    }\n                    else\n                        console.debug(msg);\n                }\n            }\n\n            valueMap.set(this, newValue);\n        },\n    });\n\n    features.set(featureName, [false, `Show when ${propertyPath} is set to true`]);\n    features.set(featureNameStrace, [false, `Print stack trace when ${featureName} shows that a flag has been set`]);\n}\n\n/**\n * Inject code for a new debug feature that traces when a class' method is\n * called, if the class calls the same method for other objects (prints tree)\n * and how long each call took in milliseconds.\n *\n * @param classObj - The class. Widget for example\n * @param methodKey - The key of the property to watch. \"paint\" for example\n * @param messageGenerator - A function that returns a string with extra information about the function call. For example, a function which returns \" (forced)\" if Widget.paint is called with forced set to true\n */\nexport function injectTraceFeature(classObj: any, methodKey: string, messageGenerator: ((...args: any[]) => string) | null = null): void {\n    const methodPath = `${classObj.name}.${methodKey}`;\n    const featureName = `trace.${methodPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const msgStack: Array<string> = [];\n    const msgIndices: Map<any, number> = new Map();\n    const methodOrig = classObj.prototype[methodKey];\n    let traceLevel = 0;\n\n    function logMsgStack(): void {\n        if(traceLevel === 0) {\n            if(isDebugFeatureEnabled(featureName))\n                console.debug(`[canvas-ui ${featureName}] Trace:\\n${msgStack.join('\\n')}`);\n\n            traceLevel = 0;\n            msgStack.length = 0;\n            msgIndices.clear();\n        }\n    }\n\n    classObj.prototype[methodKey] = function(...args: any[]) {\n        traceLevel++;\n        let msgIndex = msgIndices.get(this);\n\n        if(msgIndex === undefined) {\n            msgIndex = msgStack.length;\n            msgIndices.set(this, msgIndex);\n            let prefix;\n            if(traceLevel > 1)\n                prefix = '  '.repeat(traceLevel - 2) + '> ';\n            else\n                prefix = '';\n\n            msgStack.push(`${prefix}${this.constructor.name}`);\n        }\n        else\n            msgStack[msgIndex] += ', recall';\n\n        if(messageGenerator !== null)\n            msgStack[msgIndex] += messageGenerator.apply(this, args);\n\n        const startTime = (new Date()).getTime();\n\n        try {\n            const returnVal = methodOrig.apply(this, args);\n            msgStack[msgIndex] += ` <${(new Date()).getTime() - startTime} ms>`;\n            return returnVal;\n        }\n        catch(e) {\n            msgStack[msgIndex] += ' <exception thrown>';\n            throw e;\n        }\n        finally {\n            traceLevel--;\n            logMsgStack();\n        }\n    }\n\n    features.set(featureName, [false, `Trace ${methodPath} method calls`]);\n}\n\n/**\n * Inject code for a new debug feature that returns a random fill colour in a\n * given property when enabled.\n *\n * EPILEPSY WARNING: This debug feature may trigger epileptic seizures when\n * enabled, especially for widgets that frequently update.\n *\n * @param classObj - The class. BaseTheme for example\n * @param themePropertyKey - The key of the property to override. \"canvasFill\" for example\n */\nexport function injectRandomFillFeature(classObj: any, themePropertyKey: string): void {\n    const propertyPath = `${classObj.name}.${themePropertyKey}`;\n    const featureName = `randomfill.${propertyPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const propertyOrig = Object.getOwnPropertyDescriptor(classObj.prototype, themePropertyKey);\n    Object.defineProperty(classObj.prototype, themePropertyKey, {\n        get() {\n            if(isDebugFeatureEnabled(featureName))\n                return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n            else if(propertyOrig?.get !== undefined)\n                return propertyOrig.get.apply(this);\n        },\n        set(newValue) {\n            if(propertyOrig?.set !== undefined)\n                propertyOrig.set.apply(this, [newValue]);\n        },\n    });\n\n    features.set(featureName, [false, `(EPILEPSY WARNING) Override the ${propertyPath} theme property with a new random colour every time the theme property's value is fetched. Useful for visualising widget painting`]);\n}\n\n/**\n * Inject code for a new debug feature that calls console.trace when a specific\n * method is called and this feature is enabled.\n *\n * @param classObj - The class. Widget for example\n * @param methodKey - The key of the property to watch. \"paint\" for example\n */\nexport function injectStackTraceFeature(classObj: any, methodKey: string): void {\n    const methodPath = `${classObj.name}.${methodKey}`;\n    const featureName = `stacktrace.${methodPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const methodOrig = classObj.prototype[methodKey];\n    classObj.prototype[methodKey] = function(...args: any[]) {\n        if(isDebugFeatureEnabled(featureName)) {\n            console.groupCollapsed(`[canvas-ui ${featureName}] ${classObj.name}.${methodKey} called`);\n            console.trace();\n            console.groupEnd();\n        }\n\n        return methodOrig.apply(this, args);\n    }\n\n    features.set(featureName, [false, `Print stack trace when ${methodPath} is called`]);\n}\n\n/**\n * Check if a given number is whole, given a minimum distance from the nearest\n * whole number. If sensitivity is 0, then the number must be an integer. If\n * not, the it can be near an integer and still count as whole.\n */\nfunction isWhole(val: number, sensitivity: number) {\n    const clamped = Math.abs(val) % 1;\n    if(clamped < sensitivity)\n        return true;\n    else if(clamped > 1 - sensitivity)\n        return true;\n    else\n        return false;\n}\n\nlet injected = false;\n\n/**\n * Inject all default debug code. Call this before doing anything if you want to\n * enable debugging. Has no effect when called more than once.\n */\nexport function injectDebugCode(): void {\n    if(injected) {\n        console.warn('[canvas-ui] Already injected debug code; ignored');\n        return;\n    }\n\n    injected = true;\n\n    // trace.Widget.paint\n    injectTraceFeature(Widget, 'paint', (forced) => {\n        return forced ? ' (forced)' : '';\n    });\n    // trace.Widget.resolveDimensions\n    injectTraceFeature(Widget, 'resolveDimensions', (minWidth, maxWidth, minHeight, maxHeight) => {\n        return ` (${minWidth}, ${maxWidth}, ${minHeight}, ${maxHeight})`;\n    });\n    // trace.Widget.resolvePosition\n    injectTraceFeature(Widget, 'resolvePosition', (x, y) => {\n        return ` (${x}, ${y})`;\n    });\n    // trace.Widget.dispatchEvent\n    injectTraceFeature(Widget, 'dispatchEvent', (event) => {\n        return ` (${event.constructor.name})`;\n    });\n    // stacktrace.Root.resolveLayout\n    injectStackTraceFeature(Root, 'resolveLayout');\n    // stacktrace.Root.paint\n    injectStackTraceFeature(Root, 'paint');\n    // stacktrace.Root.dispatchEvent\n    injectStackTraceFeature(Root, 'dispatchEvent');\n    // stacktrace.Root.preLayoutUpdate\n    injectStackTraceFeature(Root, 'preLayoutUpdate');\n    // stacktrace.Root.postLayoutUpdate\n    injectStackTraceFeature(Root, 'postLayoutUpdate');\n    // stacktrace.Root.updatePointerStyle\n    injectStackTraceFeature(Root, 'updatePointerStyle');\n    // stacktrace.Root.requestFocus\n    injectStackTraceFeature(Root, 'requestFocus');\n    // stacktrace.Root.dropFocus\n    injectStackTraceFeature(Root, 'dropFocus');\n    // stacktrace.Root.clearFocus\n    injectStackTraceFeature(Root, 'clearFocus');\n    // stacktrace.Root.getFocus\n    injectStackTraceFeature(Root, 'getFocus');\n    // stacktrace.Root.getFocusCapturer\n    injectStackTraceFeature(Root, 'getFocusCapturer');\n    // stacktrace.Root.registerDriver\n    injectStackTraceFeature(Root, 'registerDriver');\n    // stacktrace.Root.unregisterDriver\n    injectStackTraceFeature(Root, 'unregisterDriver');\n    // stacktrace.Root.clearDrivers\n    injectStackTraceFeature(Root, 'clearDrivers');\n    // stacktrace.Root.getTextInput\n    injectStackTraceFeature(Root, 'getTextInput');\n    // stacktrace.Widget.onThemeUpdated\n    injectStackTraceFeature(Widget, 'onThemeUpdated');\n    // stacktrace.Widget.onFocusDropped\n    injectStackTraceFeature(Widget, 'onFocusDropped');\n    // stacktrace.Widget.handleEvent\n    injectStackTraceFeature(Widget, 'handleEvent');\n    // stacktrace.Widget.dispatchEvent\n    injectStackTraceFeature(Widget, 'dispatchEvent');\n    // stacktrace.Widget.handlePreLayoutUpdate\n    injectStackTraceFeature(Widget, 'handlePreLayoutUpdate');\n    // stacktrace.Widget.preLayoutUpdate\n    injectStackTraceFeature(Widget, 'preLayoutUpdate');\n    // stacktrace.Widget.handleResolveDimensions\n    injectStackTraceFeature(Widget, 'handleResolveDimensions');\n    // stacktrace.Widget.resolveDimensions\n    injectStackTraceFeature(Widget, 'resolveDimensions');\n    // stacktrace.Widget.resolveDimensionsAsTop\n    injectStackTraceFeature(Widget, 'resolveDimensionsAsTop');\n    // stacktrace.Widget.afterPositionResolved\n    injectStackTraceFeature(Widget, 'afterPositionResolved');\n    // stacktrace.Widget.resolvePosition\n    injectStackTraceFeature(Widget, 'resolvePosition');\n    // stacktrace.Widget.handlePostLayoutUpdate\n    injectStackTraceFeature(Widget, 'handlePostLayoutUpdate');\n    // stacktrace.Widget.postLayoutUpdate\n    injectStackTraceFeature(Widget, 'postLayoutUpdate');\n    // stacktrace.Widget.clear\n    injectStackTraceFeature(Widget, 'clear');\n    // stacktrace.Widget.clearStart\n    injectStackTraceFeature(Widget, 'clearStart');\n    // stacktrace.Widget.clearEnd\n    injectStackTraceFeature(Widget, 'clearEnd');\n    // stacktrace.Widget.roundRect\n    injectStackTraceFeature(Widget, 'roundRect');\n    // stacktrace.Widget.handlePainting\n    injectStackTraceFeature(Widget, 'handlePainting');\n    // stacktrace.Widget.paint\n    injectStackTraceFeature(Widget, 'paint');\n    // stacktrace.Widget.dryPaint\n    injectStackTraceFeature(Widget, 'dryPaint');\n    // stacktrace.Widget.forceThemeUpdate\n    injectStackTraceFeature(Widget, 'forceThemeUpdate');\n    // stacktrace.Widget.forceDirty\n    injectStackTraceFeature(Widget, 'forceDirty');\n    // stacktrace.Widget.scaleFont\n    injectStackTraceFeature(Widget, 'scaleFont');\n    // watchflag.Widget._dirty\n    injectWatchflagFeature(Widget, '_dirty');\n    // watchflag.Widget._layoutDirty\n    injectWatchflagFeature(Widget, '_layoutDirty');\n    // watchflag.BaseContainer.backgroundDirty\n    injectWatchflagFeature(BaseContainer, 'backgroundDirty');\n    // watchflag.MultiContainer.backgroundDirty\n    injectWatchflagFeature(MultiContainer, 'backgroundDirty');\n    // randomfill.BaseTheme.canvasFill\n    injectRandomFillFeature(BaseTheme, 'canvasFill');\n    // randomfill.BaseTheme.primaryFill\n    injectRandomFillFeature(BaseTheme, 'primaryFill');\n    // randomfill.BaseTheme.accentFill\n    injectRandomFillFeature(BaseTheme, 'accentFill');\n    // randomfill.BaseTheme.backgroundFill\n    injectRandomFillFeature(BaseTheme, 'backgroundFill');\n    // randomfill.BaseTheme.backgroundGlowFill\n    injectRandomFillFeature(BaseTheme, 'backgroundGlowFill');\n    // randomfill.BaseTheme.bodyTextFill\n    injectRandomFillFeature(BaseTheme, 'bodyTextFill');\n    // randomfill.BaseTheme.inputBackgroundFill\n    injectRandomFillFeature(BaseTheme, 'inputBackgroundFill');\n    // randomfill.BaseTheme.inputSelectBackgroundFill\n    injectRandomFillFeature(BaseTheme, 'inputSelectBackgroundFill');\n    // randomfill.BaseTheme.inputTextFill\n    injectRandomFillFeature(BaseTheme, 'inputTextFill');\n    // randomfill.BaseTheme.inputTextFillDisabled\n    injectRandomFillFeature(BaseTheme, 'inputTextFillDisabled');\n    // randomfill.BaseTheme.inputTextFillInvalid\n    injectRandomFillFeature(BaseTheme, 'inputTextFillInvalid');\n\n    // textrendergroups; special debug feature for TextRenderGroup\n    features.set(\n        'textrendergroups',\n        [\n            false,\n            `Draw text render groups in a TextHelper with alternating background colours (green and red). Width overriding groups have a blue background and zero-width groups have a black background. Throws an exception on negative width groups`,\n        ]\n    );\n\n    const textHelperAlternate: WeakMap<TextHelper, boolean> = new Map();\n    const textHelperPaintOrig = TextHelper.prototype.paint;\n    TextHelper.prototype.paint = function(ctx: CanvasRenderingContext2D, fillStyle: FillStyle, x: number, y: number): void {\n        textHelperAlternate.set(this, false);\n        textHelperPaintOrig.apply(this, [ctx, fillStyle, x, y]);\n    };\n\n    const textHelperPaintGroupOrig = TextHelper.prototype.paintGroup;\n    TextHelper.prototype.paintGroup = function(ctx: CanvasRenderingContext2D, group: TextRenderGroup, left: number, x: number, y: number): void {\n        if(isDebugFeatureEnabled('textrendergroups')) {\n            const origFillStyle = ctx.fillStyle;\n            const height = this.actualLineHeight;\n            const fullHeight = this.fullLineHeight;\n            if(!group[3] && group[2] > left) {\n                const alternate = textHelperAlternate.get(this);\n                ctx.fillStyle = alternate ? 'rgba(255, 0, 0, 0.5)'\n                                          : 'rgba(0, 255, 0, 0.5)';\n                ctx.fillRect(x, y - height, group[2] - left, fullHeight);\n                textHelperAlternate.set(this, !alternate);\n                ctx.fillStyle = origFillStyle;\n            }\n            else {\n                let debugWidth = group[2] - left;\n                ctx.fillStyle = debugWidth > 0 ? 'rgba(0, 0, 255, 0.5)'\n                                               : 'rgba(0, 0, 0, 0.5)';\n                if(debugWidth == 0)\n                    debugWidth = 4;\n                else if(debugWidth < 0)\n                    throw new Error('Unexpected group with negative width');\n\n                ctx.fillRect(x, y - height, debugWidth, fullHeight);\n            }\n        }\n\n        textHelperPaintGroupOrig.apply(this, [ctx, group, left, x, y]);\n    };\n\n    // warnsubpixels; special debug feature for Widget\n    features.set(\n        'warnsubpixels',\n        [\n            false,\n            `Print a console warning whenever a Widget is detected to have non-integer width, height, x or y. Only warned once per Widget type`,\n        ]\n    );\n\n    const warnedSubX: Set<string> = new Set();\n    const warnedSubY: Set<string> = new Set();\n    const warnedSubWidth: Set<string> = new Set();\n    const warnedSubHeight: Set<string> = new Set();\n    const msgLeft = '[canvas-ui warnsubpixels] Widget type \"';\n    const msgMid = '\" has a non-integer ';\n    const msgRight = ', which will create clipping issues due to subpixels. This message won\\'t be shown again for this widget type';\n\n    const finalizeBoundsOrig = Widget.prototype.finalizeBounds;\n    Widget.prototype.finalizeBounds = function(): void {\n        finalizeBoundsOrig.apply(this);\n        const typeName = this.constructor.name;\n\n        if(isDebugFeatureEnabled('warnsubpixels')) {\n            const [scaleX, scaleY] = this.root.effectiveScale;\n            const [x, y] = this.position;\n            if(!isWhole(x * scaleX, 1e-10) && !warnedSubX.has(typeName)) {\n                warnedSubX.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}X coordinate (${x})${msgRight}`);\n            }\n\n            if(!isWhole(y * scaleY, 1e-10) && !warnedSubY.has(typeName)) {\n                warnedSubY.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}Y coordinate (${y})${msgRight}`);\n            }\n\n            const [width, height] = this.dimensions;\n            if(!isWhole(width * scaleX, 1e-10) && !warnedSubWidth.has(typeName)) {\n                warnedSubWidth.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}width (${width})${msgRight}`);\n            }\n\n            if(!isWhole(height * scaleY, 1e-10) && !warnedSubHeight.has(typeName)) {\n                warnedSubHeight.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}height (${height})${msgRight}`);\n            }\n        }\n    };\n\n    // Make debug functions available in global scope\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (window as any).canvasDebug = {\n        enabled: isDebugFeatureEnabled,\n        toggle: toggleDebugFeature,\n        list: listDebugFeatures,\n    };\n\n    console.info('[canvas-ui] Injected debug code; the library will be slower');\n    console.info('[canvas-ui] Check if a debug feature is enabled in the console with canvasDebug.enabled(debugFeature: string)');\n    console.info('[canvas-ui] Enable a debug feature in the console with canvasDebug.toggle(debugFeature: string, enabled?: boolean)');\n    console.info('[canvas-ui] List debug features in the console with canvasDebug.list()');\n}", "/**\n * The default implementation of {@link TextInputHandler}.\n *\n * Creates a new popup div with a CSS ID of 'textInputHandler' and an overlay\n * div with CSS ID 'textInputHandlerOverlay', adding both to the HTML body.\n * Resolves the promise once user input is finished by clicking the OK or Cancel\n * buttons.\n *\n * @category Core\n */\nexport function DefaultTextInputHandler(initialInput: string): Promise<string> {\n    return new Promise((accept, _reject) => {\n        function closePopup() {\n            // Close text input popup\n            document.body.removeChild(containerElem);\n            document.body.removeChild(overlayElem);\n        }\n\n        function cancelHandler() {\n            // Click cancel; close popup and accept with initial input string\n            closePopup();\n            accept(initialInput);\n        }\n\n        function okHandler() {\n            // Click OK; close popup and accept with new input string\n            closePopup();\n            accept(inElem.value);\n        }\n\n        function enterChecker(event: KeyboardEvent) {\n            // Check if enter key was pressed\n            if(event.key == 'Enter') {\n                event.preventDefault();\n                okHandler();\n            }\n        }\n\n        // Create overlay\n        const overlayElem = document.createElement('div');\n        overlayElem.id = 'textInputHandlerOverlay';\n\n        // Create container\n        const containerElem = document.createElement('div');\n        containerElem.id = 'textInputHandler';\n\n        // Create text element\n        const textElem = document.createElement('p');\n        textElem.textContent = 'Change text:';\n\n        // Create input element\n        const inElem = document.createElement('input');\n        inElem.addEventListener('keyup', enterChecker);\n        inElem.value = initialInput;\n\n        // Create button row element\n        const buttonRowElem = document.createElement('div');\n\n        // Create cancel button element\n        const cancelButtonElem = document.createElement('button');\n        cancelButtonElem.addEventListener('click', cancelHandler);\n        cancelButtonElem.textContent = 'Cancel';\n\n        // Create OK button element\n        const okButtonElem = document.createElement('button');\n        okButtonElem.addEventListener('click', okHandler);\n        okButtonElem.textContent = 'OK';\n\n        // Add to row\n        buttonRowElem.appendChild(cancelButtonElem);\n        buttonRowElem.appendChild(okButtonElem);\n\n        // Add to container\n        containerElem.appendChild(textElem);\n        containerElem.appendChild(inElem);\n        containerElem.appendChild(buttonRowElem);\n\n        // Add overlay and container to body\n        document.body.appendChild(overlayElem);\n        document.body.appendChild(containerElem);\n\n        // Focus input\n        inElem.focus({ preventScroll: false });\n    });\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport { Event } from './Event';\n\n/**\n * An event which contains text pasted by the clipboard.\n *\n * Has a focus type of {@link FocusType.Keyboard} and does not need focus.\n *\n * @category Event\n */\nexport class TextPasteEvent extends Event {\n    /** The pasted text */\n    readonly text: string;\n\n    /** Create a new Event. */\n    constructor(text: string, target: Widget | null = null) {\n        super(target, FocusType.Keyboard, false);\n        this.text = text;\n    }\n\n    cloneWithTarget(target: Widget | null): TextPasteEvent {\n        return new TextPasteEvent(this.text, target);\n    }\n}", "import { TextPasteEvent } from '../events/TextPasteEvent';\nimport type { Widget } from '../widgets/Widget';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * Like Root, but for easy use in an HTML page.\n *\n * Instead of calling each individual update method, simply call\n * {@link DOMRoot#update} on every animation frame. {@link Driver | Drivers}\n * still need to be manually registered.\n *\n * @category Core\n */\nexport class DOMRoot extends Root {\n    /** This root's canvas element. Add this to the HTML body */\n    readonly domElem: HTMLCanvasElement;\n    /** This root's canvas element's context. Used for painting */\n    private domCanvasContext: CanvasRenderingContext2D;\n\n    /**\n     * Create a new DOMRoot.\n     *\n     * Sets {@link Root#child} and {@link Root#child}'s\n     * {@link Widget#inheritedTheme | inherited theme}. Also sets up a\n     * {@link Root#pointerStyleHandler} which simply sets the CSS cursor style\n     * of {@link DOMRoot#domElem}. Creates {@link DOMRoot#domElem} and\n     * {@link DOMRoot#domCanvasContext}.\n     *\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(child: Widget, theme: Theme = new Theme()) {\n        super(child, null, theme);\n\n        // Make DOM element, which is a canvas, and get a 2D context for it\n        this.domElem = document.createElement('canvas');\n        this.domElem.tabIndex = 1;\n        this.updateDOMDims();\n\n        const context = this.domElem.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error('Failed to get DOM canvas context');\n\n        this.domCanvasContext = context;\n\n        // Setup pointer style handler\n        this.pointerStyleHandler = (newPointerStyle: string): void => {\n            this.domElem.style.cursor = newPointerStyle;\n        };\n\n        // Listen to paste events\n        this.domElem.addEventListener('paste', event => {\n            event.preventDefault();\n            if(event.clipboardData !== null)\n                this.dispatchEvent(new TextPasteEvent(event.clipboardData.getData('text')));\n        });\n        this.domElem.contentEditable = 'true';\n\n        // Remove styling added by contenteditable\n        this.domElem.style.outline = '0px solid transparent';\n        this.domElem.style.caretColor = 'transparent';\n        this.domElem.style.cursor = 'default';\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link DOMRoot#domElem}'s display style is set to\n     * 'none', hiding it.\n     *\n     * Calls {@link Root#preLayoutUpdate}, {@link Root#resolveLayout},\n     * {@link Root#postLayoutUpdate} and {@link Root#paint}.\n     */\n    update(): void {\n        if(!this.enabled) {\n            this.domElem.style.display = 'none';\n            return;\n        }\n        else\n            this.domElem.style.removeProperty('display');\n\n        this.preLayoutUpdate();\n        if(this.resolveLayout()) {\n            this.updateDOMDims();\n            this.autoScale();\n        }\n        this.postLayoutUpdate();\n        if(this.paint()) {\n            this.domCanvasContext.globalCompositeOperation = 'copy';\n            this.domCanvasContext.drawImage(this.canvas, 0, 0);\n        }\n    }\n\n    override get resolution(): number {\n        return super.resolution;\n    }\n\n    override set resolution(resolution: number) {\n        super.resolution = resolution;\n        this.autoScale();\n    }\n\n    /** Update the width and height of {@link DOMRoot#domElem} */\n    private updateDOMDims(): void {\n        const [scaleX, scaleY] = this.effectiveScale;\n        const [dimsX, dimsY] = this.dimensions;\n        // XXX canvas width/height is auto-truncated, so manually round it\n        // so that values such as 99.9997 don't get turned into 99 instead\n        // of 100\n        this.domElem.width = Math.round(dimsX * scaleX);\n        this.domElem.height = Math.round(dimsY * scaleY);\n    }\n\n    /** Apply CSS scaling to the DOM element depending on the Root resolution */\n    private autoScale(): void {\n        const [scaleX, scaleY] = this.effectiveScale;\n        this.domElem.style.width = (this.domElem.width / this.resolution / scaleX).toString() + 'px';\n        this.domElem.style.height = (this.domElem.height / this.resolution / scaleY).toString() + 'px';\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport { Widget } from './Widget';\n\n/**\n * A {@link SingleParent} which contains a single child and does nothing,\n * passing all events through to its child. Useful for widgets that are only\n * used for logic, like {@link ThemeScope}.\n *\n * Can be constrained to a specific type of children.\n *\n * Since this does nothing on its own, it should not be used on its own.\n * Instead, extend this class if you are looking for a way to do wrapper widgets\n * that provide extra logic.\n *\n * @category Widget\n */\nexport class PassthroughWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        // Passthrough widgets dont need a clear background, have a child and\n        // propagate events\n        super(child, false, true, themeProperties);\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostFinalizeBounds(): void {\n        // Post-finalize bounds update child\n        const child = this.child;\n        child.postFinalizeBounds();\n\n        // If child's layout is dirty, set self's layout as dirty so that\n        // same-frame re-layouts are triggered\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve child's dimensions and set own resolved dimensions to be\n        // equal to the child's\n        const child = this.child;\n        child.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n        [this.idealWidth, this.idealHeight] = child.idealDimensions;\n    }\n\n    protected override afterPositionResolved(): void {\n        // Resolve child's position to be the same as this widget's position\n        this.child.resolvePosition(this.idealX, this.idealY);\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Paint child\n        this.child.paint(forced);\n    }\n}", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { layoutArrayField } from '../decorators/FlagFields';\nimport { PassthroughWidget } from './PassthroughWidget';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which imposes further layout constraints onto a\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ArtificialConstraint<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** See {@link ArtificialConstraint#constraints}. For internal use only */\n    private _constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n\n    /**\n     * The further constraints given to the child. A 4-tuple containing,\n     * respectively, minimum width, maximum width, minimum height and maximum\n     * height. Changing this sets {@link Widget#_layoutDirty} to true.\n     * Constraints are only applied if they are more restrictive than the\n     * original constraints.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutArrayField()`\n     */\n    @layoutArrayField()\n    constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, constraints: LayoutConstraints = [0, Infinity, 0, Infinity], themeProperties?: ThemeProperties) {\n        super(child, themeProperties);\n\n        this._constraints = [...constraints];\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Further restrict constraints if possible. Scale custom constraints\n        // with resolution\n        const res = this.root?.resolution ?? 1;\n        let newMinWidth = Math.min(Math.max(this._constraints[0] * res, minWidth), maxWidth);\n        let newMinHeight = Math.min(Math.max(this._constraints[2] * res, minHeight), maxHeight);\n        const newMaxWidth = Math.min(Math.max(this._constraints[1] * res, minWidth), maxWidth);\n        const newMaxHeight = Math.min(Math.max(this._constraints[3] * res, minHeight), maxHeight);\n\n        if(newMinWidth > newMaxWidth)\n            newMinWidth = newMaxWidth;\n\n        if(newMinHeight > newMaxHeight)\n            newMinHeight = newMaxHeight;\n\n        // Resolve dimensions\n        super.handleResolveDimensions(newMinWidth, newMaxWidth, newMinHeight, newMaxHeight);\n    }\n}", "/**\n * The current state of a {@link BaseClickHelper}\n *\n * @category Helper\n */\nexport enum ClickState {\n    /** No pointer is hovering over this clickable widget */\n    Released = 0,\n    /** A pointer is hovering over this clickable widget */\n    Hover = 1,\n    /** A pointer's button is being held down over this clickable widget */\n    Hold = 2,\n}", "import { GenericClickHelper } from \"./GenericClickHelper\";\nimport { BaseClickHelper } from \"./BaseClickHelper\";\nimport { ClickState } from \"./ClickState\";\n\n/**\n * A class that mixes multiple {@link GenericClickHelper} instances into one.\n * Useful if you want a widget to be both clickable by a pointer and by the\n * enter key\n *\n * @category Helper\n */\nexport class CompoundClickHelper implements BaseClickHelper {\n    /** The {@link GenericClickHelper} instances being mixed */\n    private clickHelpers: GenericClickHelper[];\n\n    constructor(clickHelpers: GenericClickHelper[]) {\n        this.clickHelpers = clickHelpers;\n    }\n\n    get lastClickState(): ClickState {\n        let highestState = ClickState.Released;\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.lastClickState > highestState)\n                highestState = clickHelper.lastClickState;\n        }\n\n        return highestState;\n    }\n\n    get clickState(): ClickState {\n        let highestState = ClickState.Released;\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.clickState > highestState)\n                highestState = clickHelper.clickState;\n        }\n\n        return highestState;\n    }\n\n    /**\n     * See {@link BaseClickHelper#clickStateChanged}.\n     *\n     * Note that this does not check if the combined state has changed, it only\n     * check if any of the states in {@link CompoundClickHelper#clickHelpers}\n     * has changed, meaning that this can be true while\n     * {@link CompoundClickHelper#clickState} is equal to\n     * {@link CompoundClickHelper#lastClickState}. To check whether the combined\n     * state changed, compare the aforementioned values. This is the default\n     * behaviour so that clicks aren't dropped.\n     */\n    get clickStateChanged(): boolean {\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.clickStateChanged)\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Similar to {@link BaseClickHelper#wasClick}, except that the wasClick\n     * property for each click helper is only true if the\n     * {@link BaseClickHelper#clickStateChanged} property is also true.\n     */\n    get wasClick(): boolean {\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.wasClick && clickHelper.clickStateChanged)\n                return true;\n        }\n\n        return false;\n    }\n}", "import { BaseClickHelper } from './BaseClickHelper';\nimport { Widget } from '../widgets/Widget';\nimport { ClickState } from './ClickState';\n\n/**\n * An aggregate helper class for widgets that can be clicked, in the general\n * sense that the widget is/has a button or is clickable. This does not mean\n * that the widget is only clickable with a pointer; it could also be \"clicked\"\n * with a keyboard.\n *\n * Keeps its current click state as well as its last click state, and whether\n * the last click state change resulted in an actual click.\n *\n * @category Helper\n */\nexport class GenericClickHelper implements BaseClickHelper {\n    /** Last click state */\n    lastClickState: ClickState = ClickState.Released;\n    /** The current click state */\n    clickState: ClickState = ClickState.Released;\n    /** Did the last click event handle result in a click state change? */\n    clickStateChanged = false;\n    /** Did the last click state change result in a click? */\n    wasClick = false;\n    /** The Widget aggregating this helper */\n    protected widget: Widget;\n\n    /**\n     * Create a new GenericClickHelper\n     *\n     * @param widget - The Widget aggregating this helper\n     */\n    constructor(widget: Widget) {\n        this.widget = widget;\n    }\n\n    /**\n     * Set {@link GenericClickHelper#clickState} and update\n     * {@link GenericClickHelper#lastClickState} if current one differs. Updates\n     * {@link GenericClickHelper#wasClick} and\n     * {@link GenericClickHelper#clickStateChanged} flags.\n     */\n    setClickState(clickState: ClickState, inside: boolean): void {\n        if(this.clickState !== clickState) {\n            this.lastClickState = this.clickState;\n            this.clickState = clickState;\n\n            // If last state was a hold and pointer is still inside click\n            // area, this was a click\n            this.wasClick = inside && this.lastClickState === ClickState.Hold;\n            this.clickStateChanged = true;\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key release {@link KeyEvent} (key up).\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyRelease extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyRelease {\n        return new KeyRelease(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { PointerEvent } from './PointerEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A {@link PointerEvent} for button presses/releases, containing helpers for\n * checking whether it was the left/primary button, right/secondary button or\n * middle/tertiary button. Always take the button ID into account when handling\n * this event as you get a pair of {@link PointerPress} and\n * {@link PointerRelease} events per button ID.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerButtonEvent extends PointerEvent {\n    /**\n     * The ID of the button affected.\n     *\n     * 0: left/primary button.\n     * 1: right/secondary button.\n     * 2: middle/tertiary button.\n     * etc...\n     */\n    readonly button: number;\n\n    /** Create a new PointerButtonEvent. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(x, y, shift, ctrl, alt, target, focusType);\n        this.button = button;\n    }\n\n    /** Is the button affected the left/primary button? */\n    get isLeft(): boolean {\n        return this.button === 0;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isLeft} */\n    get isPrimary(): boolean {\n        return this.isLeft;\n    }\n\n    /** Is the button affected the right/secondary button? */\n    get isRight(): boolean {\n        return this.button === 1;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isRight} */\n    get isSecondary(): boolean {\n        return this.isRight;\n    }\n\n    /** Is the button affected the middle/tertiary button? */\n    get isMiddle(): boolean {\n        return this.button === 2;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isMiddle} */\n    get isTertiary(): boolean {\n        return this.isMiddle;\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { FocusType } from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer release {@link PointerButtonEvent} (pointer button up).\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerRelease extends PointerButtonEvent {\n    /** Create a new PointerRelease. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerRelease {\n        return new PointerRelease(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerRelease {\n        return new PointerRelease(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer press {@link PointerButtonEvent} (pointer button down).\n *\n * Has no focus type and does not need focus.\n *\n * @category Event\n */\nexport class PointerPress extends PointerButtonEvent {\n    /** Create a new PointerPress. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerPress {\n        return new PointerPress(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerPress {\n        return new PointerPress(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n\n", "import { PointerRelease } from '../events/PointerRelease';\nimport { GenericClickHelper } from './GenericClickHelper';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport { ClickState } from './ClickState';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\nimport type { Bounds } from './Bounds';\n\n/**\n * An aggregate helper class for widgets that can be clicked.\n *\n * Keeps its current click state as well as its last click state, last pointer\n * position and whether the last click state change resulted in an actual click.\n *\n * @category Helper\n */\nexport class ClickHelper extends GenericClickHelper {\n    /**\n     * Last pointer position in normalised coordinates ([0,0] to [1,1]). If\n     * there is no last pointer position, such as after a leave event, this will\n     * be null. If pointer position was outside box, it will be beyond the [0,0]\n     * to [1,1] range.\n     */\n    pointerPos: [number, number] | null = null;\n    /**\n     * Like {@link ClickHelper#pointerPos}, but only updated when a hold state\n     * begins.\n     *\n     * Useful for implementing draggable widgets.\n     */\n    startingPointerPos: [number, number] | null = null;\n    /** Which pointer button should count as a click? Left button by default */\n    pointerButton = 0;\n\n    /**\n     * Normalise pointer coordinates inside a rectangle\n     *\n     * @param pX - Pointer X coordinate, in pixels\n     * @param pY - Pointer Y coordinate, in pixels\n     * @param rLeft - Rectangle's left coordinate, in pixels\n     * @param rRight - Rectangle's right coordinate, in pixels\n     * @param rTop - Rectangle's top coordinate, in pixels\n     * @param rBottom - Rectangle's bottom coordinate, in pixels\n     * @returns Returns normalised coordinates\n     */\n    getNormalInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): [number, number] {\n        return [(pX - rLeft) / (rRight - rLeft), (pY - rTop) / (rBottom - rTop)];\n    }\n\n    /**\n     * Check if a point, in pixels, is inside a rectangle.\n     *\n     * @param pX - Pointer X coordinate, in pixels\n     * @param pY - Pointer Y coordinate, in pixels\n     * @param rLeft - Rectangle's left coordinate, in pixels\n     * @param rRight - Rectangle's right coordinate, in pixels\n     * @param rTop - Rectangle's top coordinate, in pixels\n     * @param rBottom - Rectangle's bottom coordinate, in pixels\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isPointInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): boolean {\n        return pX >= rLeft && pX < rRight && pY >= rTop && pY < rBottom;\n    }\n\n    /**\n     * Check if a normalised point is inside a rectangle.\n     *\n     * Since the coordinates are normalised, you don't have to define the\n     * coordinates of the rectangle, which may seem counterintuitive.\n     *\n     * @param pX - Pointer X coordinate, normalised\n     * @param pY - Pointer Y coordinate, normalised\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isNormalInRect(pX: number, pY: number): boolean {\n        return pX >= 0 && pX < 1 && pY >= 0 && pY < 1;\n    }\n\n    /**\n     * Updates the current {@link GenericClickHelper#clickState} given an event,\n     * as well as {@link Root#_foci | focus}, {@link Root#pointerStyle},\n     * {@link GenericClickHelper#wasClick} and\n     * {@link GenericClickHelper#clickStateChanged} flags.\n     *\n     * @param bounds - A 4-tuple containing, respectively, left coordinate, right coordinate, top coordinate and bottom coordinate of clickable area, in pixels\n     */\n    handleClickEvent(event: Event, root: Root, bounds: Bounds): void {\n        if(event instanceof Leave) {\n            // Drop focus on this widget if this is a leave event\n            root.dropFocus(FocusType.Pointer, this.widget);\n            this.pointerPos = null;\n            return this.setClickState(ClickState.Released, false);\n        }\n        else if(event instanceof PointerEvent) {\n            // Normalise pointer coordinates in click area\n            this.pointerPos = this.getNormalInRect(event.x, event.y, ...bounds);\n\n            // If pointer is over the clickable rectangle, then change the\n            // pointer style, else, if not targetted, drop focus\n            const inside = this.isNormalInRect(...this.pointerPos);\n            if(inside)\n                root.pointerStyle = 'pointer';\n            else if(event.target === null) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Released, false);\n            }\n\n            // If this is a press event, request focus and set starting\n            // pointer coordinates. Ignore if wrong button\n            if(event instanceof PointerPress && event.button === this.pointerButton) {\n                this.startingPointerPos = this.pointerPos;\n                root.requestFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Hold, inside);\n            }\n\n            // If this is a release event, drop focus. Ignore if wrong button\n            if(event instanceof PointerRelease && event.button === this.pointerButton) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                if(inside)\n                    return this.setClickState(ClickState.Hover, inside);\n                else\n                    return this.setClickState(ClickState.Released, inside);\n            }\n\n            // If event was focused, then it's a hold, else, it's a hover\n            if(event.target === null)\n                return this.setClickState(ClickState.Hover, inside);\n            else\n                return this.setClickState(ClickState.Hold, inside);\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}", "import { CompoundClickHelper } from \"./CompoundClickHelper\";\nimport { GenericClickHelper } from \"./GenericClickHelper\";\nimport { PointerEvent } from \"../events/PointerEvent\";\nimport { PointerWheel } from \"../events/PointerWheel\";\nimport { KeyRelease } from \"../events/KeyRelease\";\nimport type { Widget } from \"../widgets/Widget\";\nimport { KeyEvent } from \"../events/KeyEvent\";\nimport { KeyPress } from \"../events/KeyPress\";\nimport { FocusType } from \"../core/FocusType\";\nimport type { Event } from \"../events/Event\";\nimport { ClickHelper } from \"./ClickHelper\";\nimport { ClickState } from \"./ClickState\";\nimport type { Root } from \"../core/Root\";\nimport { Leave } from \"../events/Leave\";\nimport type { Bounds } from \"./Bounds\";\n\n/**\n * A {@link CompoundClickHelper} specialised for {@link Button}-like widgets.\n * Handles pointer clicks and enter key-presses if the widget has a keyboard\n * focus.\n *\n * {@link GenericClickHelper} methods are still available, however, calls to the\n * new methods provided by this class are preferrable; mostly they implement\n * {@link Widget} methods.\n *\n * @category Helper\n */\nexport class ButtonClickHelper extends CompoundClickHelper {\n    /** The helper for handling pointer clicks */\n    protected pointerClickHelper: ClickHelper;\n    /** The helper for handling enter key presses */\n    protected keyboardClickHelper: GenericClickHelper;\n    /** The widget that will be auto-scrolled when keyboard focused */\n    private widget: Widget;\n\n    constructor(widget: Widget) {\n        const pointerClickHelper = new ClickHelper(widget);\n        const keyboardClickHelper = new GenericClickHelper(widget);\n        super([pointerClickHelper, keyboardClickHelper])\n\n        this.pointerClickHelper = pointerClickHelper;\n        this.keyboardClickHelper = keyboardClickHelper;\n        this.widget = widget;\n    }\n\n    /**\n     * Handle focus grabbing from {@link Widget#onFocusGrabbed}. If keyboard\n     * focus is gained, then the button is hovered via the\n     * {@link ButtonClickHelper#keyboardClickHelper} click helper\n     *\n     * @param focusType - The focus type from {@link Widget#onFocusGrabbed}\n     * @returns Returns true if the focus type was the keyboard focus (and therefore the button probably needs to be re-painted)\n     */\n    onFocusGrabbed(focusType: FocusType): boolean {\n        if(focusType === FocusType.Keyboard) {\n            this.keyboardClickHelper.setClickState(ClickState.Hover, true);\n            this.widget.autoScroll();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle focus dropping from {@link Widget#onFocusDropped}. If keyboard\n     * focus is dropped, then the button is released via the\n     * {@link ButtonClickHelper#keyboardClickHelper} click helper\n     *\n     * @param focusType - The focus type from {@link Widget#onFocusDropped}\n     * @returns Returns true if the focus type was the keyboard focus (and therefore the button probably needs to be re-painted)\n     */\n    onFocusDropped(focusType: FocusType): boolean {\n        if(focusType === FocusType.Keyboard) {\n            this.keyboardClickHelper.setClickState(ClickState.Released, false);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle event from {@link Widget#handleEvent}. Does most of the button\n     * logic.\n     *\n     * @param event - The event from {@link Widget#handleEvent}\n     * @param root - The root from {@link Widget#handleEvent}\n     * @param enabled - Is the button being clicked enabled? If not, then the click state will remain unchanged, but the event will be captured\n     * @param bounds - The bounding box to be used for detecting pointer clicks\n     * @returns Returns a 2-tuple containing, respective, whether a click occurred, and whether the event should be captured\n     */\n    handleEvent(event: Event, root: Root, enabled: boolean, bounds: Bounds): [wasClick: boolean, capture: boolean] {\n        if(event instanceof PointerWheel) {\n            // Ignore wheel events\n            return [false, false];\n        }\n        else if(event instanceof KeyEvent) {\n            // Discard non-enter key events\n\n            // don't capture non-enter presses so that tab selection works\n            if(event.key !== 'Enter')\n                return [false, false];\n        }\n        else if(!(event instanceof PointerEvent || event instanceof Leave)) {\n            // Discard unhandled events\n            return [false, false];\n        }\n\n        // Abort if not enabled, but still absorb events\n        if(!enabled) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.clickStateChanged = false;\n            return [false, true];\n        }\n\n        // Update button state\n        if(event instanceof KeyPress) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.setClickState(ClickState.Hold, true);\n            this.widget.autoScroll();\n        }\n        else if(event instanceof KeyRelease) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.setClickState(ClickState.Hover, true);\n        }\n        else {\n            this.keyboardClickHelper.clickStateChanged = false;\n            this.pointerClickHelper.handleClickEvent(event, root, bounds);\n        }\n\n        // Check if button was pressed and call callback if so\n        return [\n            this.clickStateChanged && this.wasClick,\n            true\n        ];\n    }\n}", "import { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { FocusType } from '../core/FocusType';\nimport { BaseContainer } from './BaseContainer';\nimport type { Event } from '../events/Event';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which can be {@link ClickHelper | clicked} as a\n * button. Since the button grabs all events, no events are propagated to the\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Button<W extends Widget = Widget> extends BaseContainer<W> {\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /**\n     * The callback for clicking this button. If null, the button is not\n     * clickable but will still absorb events.\n     */\n    callback: (() => void) | null;\n\n    /** Create a new Button. */\n    constructor(child: W, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(child, false, themeProperties);\n        this.clickHelper = new ButtonClickHelper(this);\n        this.callback = callback;\n        this.tabFocusable = true;\n    }\n\n    /**\n     * Click the button. If there is a callback, then the callback will be\n     * called\n     */\n    click(): void {\n        if(this.callback !== null) {\n            try {\n                this.callback();\n            }\n            catch(e) {\n                console.error('Exception in Icon callback', e);\n            }\n        }\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        this.clickHelper.onFocusGrabbed(focusType);\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        this.clickHelper.onFocusDropped(focusType);\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event, this.root, this.callback !== null, this.bounds\n        );\n\n        if(wasClick)\n            this.click();\n\n        return capture ? this : null;\n    }\n}\n", "import { ThemeProperties } from '../theme/ThemeProperties';\nimport { watchField } from '../decorators/FlagFields';\nimport { ClickState } from '../helpers/ClickState';\nimport { FillStyle } from '../theme/FillStyle';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Widget } from './Widget';\nimport { Theme } from '../theme/Theme';\nimport { Button } from './Button';\n\n/**\n * A {@link Button} which overrides the canvas colour, meaning that it has a\n * filled background.\n *\n * Can be constrained to a specific type of children.\n *\n * This button version can also be \"forced down\"; the button becomes similar to\n * being pressed, visually. Useful for implementing widgets such as\n * {@link ShiftKey}.\n *\n * @category Widget\n */\nexport class FilledButton<W extends Widget = Widget> extends Button<W> {\n    /** Theme property used for overriding the canvas colour. */\n    private backgroundProperty = 'backgroundFill';\n    /**\n     * Is the button currently forced down?\n     *\n     * @decorator `@watchField(FilledButton.prototype.updateBackground)`\n     */\n    @watchField(FilledButton.prototype.updateBackground)\n    forced = false;\n    /** The inherited theme for the child */\n    private childTheme: Theme;\n\n    /** Create a new FilledButton. */\n    constructor(child: W, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(child, callback, themeProperties);\n\n        // Make theme that will be inherited by child. Later, this theme's\n        // canvasFill property will be changed, notifying the child. Make the\n        // child inherit the theme. fallbackTheme is also later set when this\n        // widget inherits a theme\n        this.childTheme = new Theme(<ThemeProperties>{\n            canvasFill: this.getBackgroundFill(),\n        });\n        this.child.inheritedTheme = this.childTheme;\n    }\n\n    /**\n     * Update the background fill.\n     *\n     * Sets {@link FilledButton#backgroundProperty} depending on\n     * {@link FilledButton#forced} and {@link ButtonClickHelper#clickState},\n     * sets {@link FilledButton#childTheme}.{@link Theme#canvasFill} and flags\n     * {@link FilledButton#backgroundDirty} as true.\n     */\n    private updateBackground(): void {\n        const oldProperty = this.backgroundProperty;\n\n        if(this.forced)\n            this.backgroundProperty = 'primaryFill';\n        else {\n            switch(this.clickHelper.clickState) {\n            case ClickState.Hold:\n                this.backgroundProperty = 'accentFill';\n                break;\n            case ClickState.Hover:\n                this.backgroundProperty = 'backgroundGlowFill';\n                break;\n            default:\n                this.backgroundProperty = 'backgroundFill';\n                break;\n            }\n        }\n\n        // Update canvasFill property of child's theme\n        if(oldProperty !== this.backgroundProperty) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n    }\n\n    private getBackgroundFill(): FillStyle {\n        switch(this.backgroundProperty) {\n            case 'primaryFill':\n                return this.primaryFill;\n            case 'accentFill':\n                return this.accentFill;\n            case 'backgroundGlowFill':\n                return this.backgroundGlowFill;\n            case 'backgroundFill':\n                return this.backgroundFill;\n            default:\n                throw new Error(`Unknown theme property: ${this.backgroundProperty}`);\n        }\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        if(theme === this.fallbackTheme)\n            return;\n\n        this.fallbackTheme = theme;\n        this.childTheme.fallbackTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === this.backgroundProperty) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        super.onFocusGrabbed(focusType);\n\n        if(focusType === FocusType.Keyboard)\n            this.updateBackground();\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        super.onFocusDropped(focusType);\n\n        if(focusType === FocusType.Keyboard)\n            this.updateBackground();\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        const capturer = super.handleEvent(event);\n\n        if(this.clickHelper.clickStateChanged)\n            this.updateBackground();\n\n        return capturer;\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        this.handleBaseContainerPainting(forced, this.getBackgroundFill());\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { TextHelper, WrapMode } from '../helpers/TextHelper';\nimport { layoutField } from '../decorators/FlagFields';\nimport { Widget } from './Widget';\n\n/**\n * A function which returns a string. An alternative to supplying a\n * {@link Label} with a string if you have a text value that constantly changes.\n *\n * @category Widget\n */\nexport type TextGetter = () => string;\n\n/**\n * A widget which displays a line of text.\n *\n * @category Widget\n */\nexport class Label extends Widget {\n    /**\n     * The text getter source. If this is not null, text will be updated with\n     * the return value of this callback, every update.\n     */\n    private textGetter: TextGetter | null = null;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /**\n     * Is text wrapping enabled? If not, text will clipped on overflow\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText = true;\n\n    /**\n     * Create a new Label.\n     *\n     * @param source - The text source of the label. Has the same behaviour as setting {@link Label#source}.\n     */\n    constructor(source: string | TextGetter, themeProperties?: ThemeProperties) {\n        // Labels need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        this.textHelper = new TextHelper();\n        this.textHelper.wrapMode = WrapMode.Shrink;\n        this.source = source;\n    }\n\n    /**\n     * This label's text source. If you want to get the current text string,\n     * then use {@link Label#text} instead.\n     *\n     * When setting, if source is a {@link TextGetter}, then\n     * {@link Label#textGetter} is set, else, {@link Label#textGetter} is set to\n     * null and and the {@link Label#textHelper}'s\n     * {@link TextHelper#text | text} is set.\n     *\n     * When getting, if {@link Label#textGetter} is set, then it is returned,\n     * else, {@link Label#textHelper}.{@link TextHelper#text | text} is\n     * returned.\n     */\n    set source(source: string | TextGetter) {\n        if(source instanceof Function)\n            this.textGetter = source;\n        else {\n            this.textGetter = null;\n            this.textHelper.text = source;\n        }\n    }\n\n    get source(): string | TextGetter {\n        if(this.textGetter !== null)\n            return this.textGetter;\n        else\n            return this.textHelper.text;\n    }\n\n    /**\n     * The current text value. If you want to get the current text source, then\n     * use {@link Label#source} instead.\n     */\n    get text(): string {\n        return this.textHelper.text;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFont' ||\n                property === 'labelMinWidth' ||\n                property === 'labelMinAscent' ||\n                property === 'labelMinDescent')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFill')\n            this._dirty = true;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Update text helper variables\n        if(this.textGetter !== null)\n            this.textHelper.text = this.textGetter();\n\n        this.textHelper.font = this.bodyTextFont;\n        this.textHelper.lineHeight = this.bodyTextHeight;\n        this.textHelper.lineSpacing = this.bodyTextSpacing;\n        this.textHelper.alignMode = this.bodyTextAlign;\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.textHelper.maxWidth = this.wrapText ? maxWidth : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        this.idealWidth = Math.max(Math.min(this.textHelper.width, maxWidth), minWidth);\n        this.idealHeight = Math.max(Math.min(this.textHelper.height, maxHeight), minHeight);\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Start clipping if text wrapping is disabled\n        const ctx = this.viewport.context;\n        if(!this.wrapText) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n        }\n\n        // Paint text\n        this.textHelper.paint(ctx, this.bodyTextFill, this.idealX, this.idealY);\n\n        // Stop clipping if text wrapping is disabled\n        if(!this.wrapText)\n            ctx.restore();\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { TextAlignMode } from '../helpers/TextHelper';\nimport { Alignment } from '../theme/Alignment';\nimport { FilledButton } from './FilledButton';\nimport type { TextGetter } from './Label';\nimport { Label } from './Label';\n\n/**\n * A {@link FilledButton} with a {@link Label}. Alignment is forced to be\n * horizontally centered and vertically stretching like in {@link TextMargin}.\n * Text-wrapping is disabled so that text is centered properly.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class TextButton extends FilledButton<Label> {\n    /** Create a new TextButton. */\n    constructor(text: string | TextGetter, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Stretch,\n        };\n\n        const label = new Label(text, themeProperties);\n        label.wrapText = false;\n        label.bodyTextAlign = TextAlignMode.Center;\n        super(label, callback, themePropertiesClone);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { KeyContext } from './KeyContext';\nimport { TextButton } from '../TextButton';\n\n/**\n * A {@link VirtualKey} which emits key presses for a given glyph (character),\n * handling alternative versions of the glyph when shift is held down, such as\n * uppercase variants, or exclamation marks for ones.\n *\n * For other specific keys, see {@link BasicVirtualKey}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class GlyphVirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new GlyphVirtualKey.\n     *\n     * @param glyph - The glyph to emit/show when shift is not held.\n     * @param altGlyph - The alternative glyph to emit/show when shift is held.\n     * @param keyContext - The {@link KeyContext} shared by other keys to tell when shift is being held in a virtual keyboard.\n     */\n    constructor(glyph: string, altGlyph: string | null = null, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        if(altGlyph === null)\n            altGlyph = glyph;\n\n        function getGlyph() {\n            if(keyContext.shift) {\n                if(altGlyph === null)\n                    return glyph;\n                else\n                    return altGlyph;\n            }\n            else\n                return glyph;\n        }\n\n        super(\n            new TextButton(\n                getGlyph, () => keyContext.callback(getGlyph()), themeProperties,\n            ),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeProperties,\n        );\n\n        this.flex = flex;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { MultiContainer } from './MultiContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A horizontal {@link MultiContainer}.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Row<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Row. */\n    constructor(themeProperties?: ThemeProperties) {\n        super(false, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { GlyphVirtualKey } from './GlyphVirtualKey';\nimport type { KeyContext } from './KeyContext';\nimport type { VirtualKey } from './VirtualKey';\nimport { Row } from '../Row';\n\n/**\n * A template for a single virtual keyboard key. A function that, when called\n * given a {@link KeyContext} and theme override, returns a {@link VirtualKey}\n * which can be used as a virtual keyboard key widget.\n *\n * Example:\n * ```typescript\n * const template: VirtualKeyTemplate = (keyContext, themeProperties) => new BackspaceKey(keyContext, themeProperties);\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyTemplate = (keyContext: KeyContext, themeProperties?: ThemeProperties) => VirtualKey;\n\n/**\n * A template for multiple {@link GlyphVirtualKey} virtual keyboard keys. A\n * 2-tuple of strings, where each string has the same length. Each character of\n * the string represents a glyph to add to a keyboard row. The first string of\n * the tuple has the regular glyphs, while the second string string of the tuple\n * has the alternative glyphs.\n *\n * Example:\n * ```typescript\n * const template: GlyphVirtualKeysTemplate = ['qwertyuiop', 'QWERTYUIOP'];\n * ```\n *\n * @category Widget\n */\nexport type GlyphVirtualKeysTemplate = [string, string];\n\n/**\n * A template for a single row of virtual keyboard keys. An array of\n * {@link GlyphVirtualKeysTemplate} and {@link VirtualKeyTemplate}.\n *\n * Example:\n * ```typescript\n * const backspaceTemplate: VirtualKeyTemplate = (keyContext, themeProperties) => new BackspaceKey(keyContext, themeProperties);\n * const rowTemplate: VirtualKeyRowTemplate = [['`1234567890-=', '~!@#$%^&*()_+'], backspaceTemplate];\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyRowTemplate = Array<GlyphVirtualKeysTemplate | VirtualKeyTemplate>;\n\n/**\n * A {@link Row} of {@link VirtualKey | virtual keys}. Generates given a\n * template.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class VirtualKeyRow extends Row<VirtualKey> {\n    /**\n     * Create a new VirtualKeyRow.\n     *\n     * @param rowTemplate - Template for this row of virtual keys.\n     * @param keyContext - The {@link KeyContext} to be shared among all virtual keys in this row.\n     * @param flex - The flex to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minWidth - The minWidth to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param minHeight - The minHeight to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}\n     * @param themeProperties - The themeProperties to pass to each key widget and this row\n     */\n    constructor(rowTemplate: VirtualKeyRowTemplate, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        for(const entry of rowTemplate) {\n            if(typeof entry === 'function') {\n                // Entry is in template function format\n                const templateFunction = entry;\n                this.add(templateFunction(keyContext, themeProperties));\n            }\n            else if(typeof entry[0] === 'string' && typeof entry[1] === 'string') {\n                // Entry is in multiple glyphs format\n                const glyphs = entry[0];\n                const altGlyphs = entry[1];\n                for(let i = 0; i < glyphs.length; i++) {\n                    let altGlyph = null;\n                    if(i < altGlyphs.length)\n                        altGlyph = altGlyphs[i];\n\n                    this.add(new GlyphVirtualKey(\n                        glyphs[i],\n                        altGlyph,\n                        keyContext,\n                        flex,\n                        minWidth,\n                        minHeight,\n                        themeProperties,\n                    ));\n                }\n            }\n            else {\n                throw new Error(`Unknown virtual key row template format for entry: ${entry}`);\n            }\n        }\n    }\n}", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { TextGetter } from '../../widgets/Label';\nimport { TextButton } from '../TextButton';\n\n/**\n * An {@link ArtificialConstraint} with a {@link TextButton} which calls a given\n * callback and displays a given text source.\n *\n * For now there's nothing special about this class; it's just a common base\n * class for virtual keyboard key widgets.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class VirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new VirtualKey.\n     *\n     * @param text - The text to display in the virtual key.\n     * @param callback - The callback called when the button is pressed.\n     */\n    constructor(text: string | TextGetter, callback: () => void, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            new TextButton(text, callback, themeProperties),\n            [minWidth, Infinity, minHeight, Infinity],\n            themeProperties,\n        );\n\n        this.flex = flex;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { TextGetter } from '../../widgets/Label';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which emits key presses of a given key code.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class BasicVirtualKey extends VirtualKey {\n    /**\n     * Create a new BasicVirtualKey.\n     *\n     * @param text - The text to display in the virtual key.\n     * @param keyCode - The {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | key code} to emit in the keyContext's callback when the virtual key is pressed\n     * @param keyContext - The {@link KeyContext} shared by other virtual keyboard key widgets.\n     */\n    constructor(text: string | TextGetter, keyCode: string, keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            text,\n            () => keyContext.callback(keyCode),\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Backspace' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class BackspaceKey extends BasicVirtualKey {\n    /** Create a new BackspaceKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 60, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Backspace', 'Backspace', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Escape' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class EscapeKey extends BasicVirtualKey {\n    /** Create a new EscapeKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 24, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Esc', 'Escape', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Enter' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class EnterKey extends BasicVirtualKey {\n    /** Create a new EnterKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 72, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Enter', 'Enter', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a shift key; toggles\n * {@link KeyContext#shift} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class ShiftKey extends VirtualKey {\n    /** Create a new ShiftKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 84, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Shift',\n            () => {\n                keyContext.shift = !keyContext.shift;\n                this.child.forced = keyContext.shift;\n                keyContext.callback('Shift');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.shift;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport { BasicVirtualKey } from './BasicVirtualKey';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits ' ' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class SpaceKey extends BasicVirtualKey {\n    /** Create a new SpaceKey. */\n    constructor(keyContext: KeyContext, flex = 1, minWidth = 84, minHeight = 24, themeProperties?: ThemeProperties) {\n        super('Space', ' ', keyContext, flex, minWidth, minHeight, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { MultiContainer } from './MultiContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A vertical {@link MultiContainer}.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Column<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Column. */\n    constructor(themeProperties?: ThemeProperties) {\n        super(true, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyboardDriver } from '../../drivers/KeyboardDriver';\nimport type { FlexAlignment2D } from '../../theme/FlexAlignment2D';\nimport type { VirtualKeyRowTemplate } from './VirtualKeyRow';\nimport { FlexAlignment } from '../../theme/FlexAlignment';\nimport { Alignment } from '../../theme/Alignment';\nimport { VirtualKeyRow } from './VirtualKeyRow';\nimport type { KeyContext } from './KeyContext';\nimport { BackspaceKey } from './BackspaceKey';\nimport { EscapeKey } from './EscapeKey';\nimport { EnterKey } from './EnterKey';\nimport { ShiftKey } from './ShiftKey';\nimport { SpaceKey } from './SpaceKey';\nimport { Column } from '../Column';\n\n/**\n * A template for the keys in a {@link VirtualKeyboard}. Each member of the\n * array contains the template for a row of keys, from top to bottom.\n *\n * @category Widget\n */\nexport type VirtualKeyboardTemplate = Array<VirtualKeyRowTemplate>;\n\nfunction EnterKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): EnterKey {\n    return new EnterKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction ShiftKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): ShiftKey {\n    return new ShiftKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction BackspaceKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): BackspaceKey {\n    return new BackspaceKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction SpaceKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): SpaceKey {\n    return new SpaceKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\nfunction EscapeKeyTemplate(keyContext: KeyContext, themeProperties?: ThemeProperties): EscapeKey {\n    return new EscapeKey(\n        keyContext, undefined, undefined, undefined, themeProperties,\n    );\n}\n\n/**\n * The default template for the keys in a {@link VirtualKeyboard}; A QWERTY\n * keyboard with US layout.\n *\n * @category Widget\n */\nexport const defaultVirtualKeyboardTemplate: VirtualKeyboardTemplate = [\n    // First row\n    [['`1234567890-=', '~!@#$%^&*()_+']],\n    // Second row\n    [['qwertyuiop[]\\\\', 'QWERTYUIOP{}|']],\n    // Third row\n    [['asdfghjkl;\\'', 'ASDFGHJKL:\"'], EnterKeyTemplate],\n    // Fourth row\n    [ShiftKeyTemplate, ['zxcvbnm,./', 'ZXCVBNM<>?']],\n    // Fifth row\n    [BackspaceKeyTemplate, SpaceKeyTemplate, EscapeKeyTemplate],\n];\n\n/**\n * A virtual keyboard widget.\n *\n * Needs a {@link KeyboardDriver} so that key events can be queued.\n *\n * Equivalent to creating a {@link Column} of {@link VirtualKeyRow} with a shared\n * {@link KeyContext}. Key rows will be created with SpaceBetween main alignment\n * and Stretch cross alignment.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class VirtualKeyboard extends Column {\n    /**\n     * Create a new VirtualKeyboard.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param flexRatio - The flexRatio to use when creating {@link GlyphVirtualKey | glyphs keys}\n     * @param mainBasis - The mainBasis to use when creating {@link GlyphVirtualKey | glyphs keys}\n     * @param crossBasis - The crossBasis to use when creating {@link GlyphVirtualKey | glyphs keys}\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, flexRatio = 0, mainBasis = 24, crossBasis = 24, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.multiContainerAlignment = <FlexAlignment2D>{\n            main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch,\n        };\n\n        super(themePropertiesClone);\n\n        // Make context\n        const keyContext = <KeyContext>{\n            callback: (key: string) => {\n                keyboardDriver.keyPress(\n                    key,\n                    keyContext.shift,\n                    keyContext.ctrl,\n                    keyContext.alt,\n                );\n            },\n            shift: false,\n            ctrl: false,\n            alt: false,\n        };\n\n        for(const rowTemplate of keyboardTemplate) {\n            this.add(new VirtualKeyRow(\n                rowTemplate, keyContext, flexRatio, mainBasis, crossBasis,\n                themePropertiesClone,\n            ));\n        }\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { BaseContainer } from './BaseContainer';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link BaseContainer} which always propagates events. Use this widget if\n * you are not sure what that means.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Container<W extends Widget = Widget> extends BaseContainer<W> {\n    /** Create a new Container. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        super(child, true, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Container} with center alignment on both axes and default padding,\n * similar to {@link Center}.\n *\n * Can be constrained to a specific type of children.\n *\n * Alignment settings are applied via theme properties; if you pass this\n * property, it will be ignored in a clone of the theme properties. If you want\n * to override this theme property property, then use {@link Container} instead.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Margin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Margin. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Center,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { DOMRoot } from './DOMRoot';\n\n/**\n * A {@link DOMRoot} with similar functionality to {@link VirtualKeyboardRoot}.\n * In this version {@link VirtualKeyboardRoot#updateVisibility} doesn't exist.\n * Instead, just call {@link DOMVirtualKeyboardRoot#update} like in DOMRoot.\n *\n * @category Core\n */\nexport class DOMVirtualKeyboardRoot extends DOMRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link Root#child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template} and\n     * {@link Root#child}'s {@link Widget#inheritedTheme | inherited theme}.\n     * Also sets up a {@link Root#pointerStyleHandler} which simply sets the CSS\n     * cursor style of {@link DOMRoot#domElem}. Creates {@link DOMRoot#domElem}\n     * and {@link DOMRoot#domCanvasContext}.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link DOMRoot#domElem}'s display style is set to\n     * 'none', hiding it.\n     *\n     * Calls {@link Root#preLayoutUpdate}, {@link Root#resolveLayout},\n     * {@link Root#postLayoutUpdate} and {@link Root#paint}.\n     *\n     * Also updates the visibility of this root; if the keyboard driver has no\n     * focused root, then the root is disabled, else, it is enabled.\n     */\n    override update(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.needsInput;\n\n        // Update normally\n        super.update();\n    }\n}", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * A {@link Root} containing a single {@link VirtualKeyboard} widget inside a\n * {@link Margin}. Automatically disables itself if not needed, but\n * {@link VirtualKeyboardRoot#updateVisibility} must be called every frame for\n * this behaviour to occur.\n *\n * @category Core\n */\nexport class VirtualKeyboardRoot extends Root {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link VirtualKeyboardRoot#child} to a new {@link Margin} containing\n     * a {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link VirtualKeyboardRoot#pointerStyleHandler} and\n     * {@link VirtualKeyboardRoot#child}'s\n     * {@link Widget#inheritedTheme | inherited theme}.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            pointerStyleHandler, theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.needsInput;\n    }\n}", "import type { KeyEvent } from '../events/KeyEvent';\nimport { KeyRelease } from '../events/KeyRelease';\nimport type { Widget } from '../widgets/Widget';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic keyboard {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending keyboard events to\n * registered roots.\n *\n * @category Driver\n */\nexport class KeyboardDriver implements Driver {\n    /** The list of key down/up events that haven't been dispatched yet. */\n    private eventQueues: Map<Root, Array<KeyEvent>> = new Map();\n    /** A set containing the keys currently down. */\n    private keysDown: Set<string> = new Set();\n    /** The currently focused root. New keyboard events will go to this root */\n    private focus: Root | null = null;\n    /**\n     * The last {@link Root} that had \"activity\"; the last Root where any focus\n     * was grabbed. Used as a fallback when there is no focus. If this is null,\n     * then a root from {@link KeyboardDriver#eventQueues} is picked; this\n     * fallback of a fallback may result in weird behaviour if there are more\n     * than 1 Roots, since eventQueues is a Map, and Map iteration is not\n     * guaranteed to be in the same order\n     */\n    private lastActivity: Root | null = null;\n\n    /**\n     * Get the {@link KeyboardDriver#eventQueues | event queue} of a given root.\n     * If this driver is not registered to the given root or the given root is\n     * disabled, making it not present in eventQueues, then null is returned.\n     */\n    private getEventQueue(root: Root | null): Array<KeyEvent> | null {\n        if(root === null)\n            return null;\n\n        const eventQueue = this.eventQueues.get(root);\n        if(typeof eventQueue === 'undefined')\n            return null;\n\n        return eventQueue;\n    }\n\n    /**\n     * Changes the current {@link KeyboardDriver#focus | root focus}.\n     *\n     * If there was a previous root focus, that root's {@link Root#clearFocus}\n     * is called with {@link FocusType#Keyboard}.\n     *\n     * {@link KeyboardDriver#keysDown} is cleared.\n     */\n    protected changeFocusedRoot(root: Root | null): void {\n        if(this.focus === root)\n            return;\n\n        if(this.focus !== null)\n            this.focus.clearFocus(FocusType.Keyboard);\n\n        this.focus = root;\n        this.keysDown.clear();\n    }\n\n    /**\n     * Get the current {@link KeyboardDriver#focus | root focus}.\n     *\n     * @returns Returns {@link KeyboardDriver#focus}\n     */\n    getFocusedRoot(): Root | null {\n        return this.focus;\n    }\n\n    /**\n     * Similar to {@link KeyboardDriver#getFocusedRoot}, but can fall back to\n     * {@link KeyboardDriver#lastActivity} if {@link KeyboardDriver#focus} is\n     * null, or a {@link Root} in {@link KeyboardDriver#eventQueues} if\n     * lastActivity is also null.\n     */\n    getEffectiveFocusedRoot(): Root | null {\n        if(this.focus)\n            return this.focus;\n        else if(this.lastActivity)\n            return this.lastActivity;\n        else if(this.eventQueues.size > 0)\n            return this.eventQueues.keys().next().value;\n        else\n            return null;\n    }\n\n    /**\n     * Clear the current {@link KeyboardDriver#focus | root focus}. Calls\n     * {@link KeyboardDriver#changeFocusedRoot} with null.\n     */\n    clearFocus(): void {\n        this.changeFocusedRoot(null);\n    }\n\n    /**\n     * Push a new {@link KeyPress} event to {@link KeyboardDriver#eventQueues}.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyDown(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        this.keysDown.add(key);\n        const eventQueue = this.getEventQueue(this.getEffectiveFocusedRoot());\n        if(eventQueue !== null)\n            eventQueue.push(new KeyPress(key, shift, ctrl, alt, null));\n    }\n\n    /**\n     * Push a new {@link KeyRelease} event to {@link KeyboardDriver#eventQueues}.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyUp(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        if(this.keysDown.delete(key)) {\n            const eventQueue = this.getEventQueue(this.getEffectiveFocusedRoot());\n            if(eventQueue !== null)\n                eventQueue.push(new KeyRelease(key, shift, ctrl, alt, null));\n        }\n    }\n\n    /**\n     * Calls {@link KeyboardDriver#keyDown} followed by\n     * {@link KeyboardDriver#keyUp}. If the key was already down before calling\n     * ({@link KeyboardDriver#isKeyDown}), keyUp is not called.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyPress(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const wasDown = this.isKeyDown(key);\n        this.keyDown(key, shift, ctrl, alt);\n        if(!wasDown)\n            this.keyUp(key, shift, ctrl, alt);\n    }\n\n    /**\n     * Check if a key is pressed.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     *\n     * @returns Returns true if key was in {@link KeyboardDriver#keysDown}\n     */\n    isKeyDown(key: string): boolean {\n        return this.keysDown.has(key);\n    }\n\n    /**\n     * Adds enabled root to {@link KeyboardDriver#eventQueues}.\n     */\n    onEnable(root: Root): void {\n        if(!this.eventQueues.has(root))\n            this.eventQueues.set(root, []);\n    }\n\n    /**\n     * Removes disabled root from {@link KeyboardDriver#eventQueues}. If the\n     * root was the {@link KeyboardDriver#focus}, then\n     * {@link KeyboardDriver#clearFocus | the focus is cleared }.\n     */\n    onDisable(root: Root): void {\n        if(this.eventQueues.has(root)) {\n            this.eventQueues.delete(root);\n            if(root === this.focus)\n                this.clearFocus();\n        }\n    }\n\n    /**\n     * Dispatches all {@link KeyboardDriver#eventQueues | queued events } for\n     * the root and clears its event queue\n     */\n    update(root: Root): void {\n        const eventQueue = this.getEventQueue(root);\n        if(eventQueue === null)\n            return;\n\n        // Dispatch queued keyboard events\n        for(const event of eventQueue)\n            root.dispatchEvent(event);\n\n        // Clear event queue\n        eventQueue.length = 0;\n    }\n\n    /**\n     * Does nothing if the new focus type is not a {@link FocusType.Keyboard}.\n     * If the focus comes from a root which is not the\n     * {@link KeyboardDriver#focus | root focus}, then the root focus is\n     * {@link KeyboardDriver#changeFocusedRoot | changed to the new root}. If\n     * there is no new focused widget (the root's keyboard focus was cleared),\n     * then nothing happens.\n     *\n     * This behaviour is confusing, however, it's required so that the keyboard\n     * focus \"lingers\" for future tab key presses; this way, pressing tab can do\n     * tab selection even when there is no widget that wants keyboard input.\n     * When a focus is lingering, then it means that key events are still being\n     * dispatched to the last focused root, but they don't have a target. This\n     * way, most events get dropped, but tab key events are used for tab\n     * selection.\n     */\n    onFocusChanged(root: Root, focusType: FocusType, newFocus: Widget | null): void {\n        if(newFocus !== null)\n            this.lastActivity = root;\n\n        if(focusType !== FocusType.Keyboard)\n            return;\n\n        if(root !== this.focus && newFocus !== null)\n            this.changeFocusedRoot(root);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n\n    /**\n     * Check if the currently focused root needs keyboard input. Virtual\n     * keyboard should query this property to know when to show themselves.\n     */\n    get needsInput(): boolean {\n        return this.focus !== null && this.focus.getFocus(FocusType.Keyboard) !== null;\n    }\n}\n", "import { KeyboardDriver } from './KeyboardDriver';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * The set of keys that will call preventDefault if captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_KEYS = new Set([\n    'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Home',\n    'PageDown', 'PageUp', 'Tab', ' ',\n]);\n\n/**\n * The set of keys that will call preventDefault when holding ctrl if captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_CTRL_KEYS = new Set([\n    'a', 'A',\n]);\n\n/**\n * The set of keys that will call preventDefault, even if not captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_FORCE_KEYS = new Set([\n    'Tab'\n]);\n\n/**\n * Unpack a KeyboardEvent into a 4-tuple containing the event's key and modifier\n * key state. The 4-tuple contains, respectively, the key\n * {@link https://developer.mozilla.org/docs/Web/API/KeyboardEvent/key | KeyboardEvent.key}\n * of the event, whether shift is being held, whether ctrl is being held, and\n * whether alt is being held\n *\n * @category Driver\n */\nfunction unpackKeyboardEvent(event: KeyboardEvent): [key: string, shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.key, event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A container which has all the event listeners for a {@link Root} DOM bind to\n * a {@link DOMKeyboardDriver}; a link between a DOM element and an existing\n * Root.\n *\n * @category Driver\n */\nexport interface DOMKeyboardDriverBind {\n    blurListen: ((this: HTMLElement, event: FocusEvent) => void) | null,\n    keydownListen: ((this: HTMLElement, event: KeyboardEvent) => void) | null,\n    keyupListen: ((this: HTMLElement, event: KeyboardEvent) => void) | null\n}\n\n/**\n * A {@link KeyboardDriver} which listens for key events from HTML DOM elements.\n *\n * Note that if a DOM element is unfocused in the DOM to an unbound DOM element,\n * the root focus is cleared. If this creates issues, other DOM elements can be\n * bound without listening for key events.\n *\n * @category Driver\n */\nexport class DOMKeyboardDriver extends KeyboardDriver {\n    /**\n     * The list of HTML DOM elements bound to this keyboard driver and their\n     * event listeners\n     */\n    private domElems: Map<HTMLElement, DOMKeyboardDriverBind> = new Map();\n\n    /** Calls preventDefault on a keyboard event if needed. */\n    maybePreventDefault(event: KeyboardEvent): void {\n        if(PREVENT_DEFAULT_KEYS.has(event.key) || (PREVENT_DEFAULT_CTRL_KEYS.has(event.key) && event.ctrlKey)) {\n            if(PREVENT_DEFAULT_FORCE_KEYS.has(event.key))\n                event.preventDefault();\n            else {\n                const currentFocus = this.getFocusedRoot()?.getFocus(FocusType.Keyboard) ?? null;\n                if(currentFocus !== null)\n                    event.preventDefault();\n            }\n        }\n    }\n\n    /**\n     * Bind an HTML DOM element to this keyboard driver.\n     *\n     * If the root was already bound,\n     * {@link DOMKeyboardDriver#removeListeners} is called, replacing the old\n     * listeners. Populates {@link DOMKeyboardDriver#domElems} with the new\n     * bind.\n     *\n     * @param listenToKeys - If true, event listeners will be added to listen for keys. blur event listeners are always added no matter what.\n     */\n    bindDOMElem(domElem: HTMLElement, listenToKeys = true): void {\n        let bind = this.domElems.get(domElem);\n        if(bind !== undefined) {\n            console.warn('Rebinding DOMKeyboardDriver. Are you calling bindDOMElem with the same HTML element multiple times?');\n            this.removeListeners(domElem, bind);\n        }\n        else {\n            bind = <DOMKeyboardDriverBind>{\n                blurListen: null,\n                keydownListen: null,\n                keyupListen: null\n            };\n            this.domElems.set(domElem, bind);\n        }\n\n        this.addListeners(domElem, bind, listenToKeys);\n    }\n\n    /**\n     * Unbind an HTML DOM element from this keyboard driver. Removes all used\n     * listeners.\n     */\n    unbindDOMElem(domElem: HTMLElement): void {\n        const bind = this.domElems.get(domElem);\n        if(bind === undefined)\n            return;\n\n        this.removeListeners(domElem, bind);\n        this.domElems.delete(domElem);\n    }\n\n    /** Add pointer event listeners to DOM element. */\n    private addListeners(domElem: HTMLElement, bind: DOMKeyboardDriverBind, listenToKeys = true): void {\n        // Listen for keyboard events, filling event queue, and blur event for\n        // clearing keyboard focus\n        bind.blurListen = (event) => {\n            // XXX should the HTMLElement cast be done?\n            if(this.shouldClearFocus(event.relatedTarget as HTMLElement))\n                this.clearFocus();\n        };\n\n        domElem.addEventListener('blur', bind.blurListen);\n\n        if(listenToKeys) {\n            bind.keydownListen = (event) => {\n                this.maybePreventDefault(event);\n                this.keyDown(...unpackKeyboardEvent(event));\n            };\n\n            bind.keyupListen = (event) => {\n                this.maybePreventDefault(event);\n                this.keyUp(...unpackKeyboardEvent(event));\n            };\n\n            domElem.addEventListener('keydown', bind.keydownListen);\n            domElem.addEventListener('keyup', bind.keyupListen);\n        }\n    }\n\n    /**\n     * Remove event listeners from DOM element and unset tracked listeners in\n     * bind.\n     */\n    private removeListeners(domElem: HTMLElement, bind: DOMKeyboardDriverBind): void {\n        if(bind.blurListen) {\n            domElem.removeEventListener('blur', bind.blurListen);\n            bind.blurListen = null;\n        }\n\n        if(bind.keydownListen) {\n            domElem.removeEventListener('keydown', bind.keydownListen);\n            bind.keydownListen = null;\n        }\n\n        if(bind.keyupListen) {\n            domElem.removeEventListener('keyup', bind.keyupListen);\n            bind.keyupListen = null;\n        }\n    }\n\n    /**\n     * Check if the {@link KeyboardDriver#focus | root focus} should be cleared\n     * given that the HTML DOM focus has been lost to another HTML DOM element\n     *\n     * @param newTarget - The HTML DOM element to which the focus has been lost to\n     */\n    shouldClearFocus(newTarget: HTMLElement | null): boolean {\n        return newTarget === null || !this.domElems.has(newTarget);\n    }\n}\n", "/**\n * Extracts the position of a DOM MouseEvent and normalises it. Useful for\n * implementing mouse input.\n *\n * @returns Returns a 2-tuple containing the normalised coordinates; the first\n * element contains the normalised x axis, and the second element contains the\n * normalised y axis\n *\n * @category Helper\n */\nexport function getPointerEventNormPos(event: MouseEvent, domElem: HTMLElement): [number, number] {\n    const rect = domElem.getBoundingClientRect();\n    return [\n        (event.clientX - rect.left) / rect.width,\n        (event.clientY - rect.top) / rect.height,\n    ];\n}", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer move {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerMove extends PointerEvent {\n    /** Create a new PointerMove. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerMove {\n        return new PointerMove(this.x - xOffset, this.y - yOffset, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerMove {\n        return new PointerMove(this.x, this.y, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "/**\n * A {@link PointerDriver}'s pointer hint; each registered pointer has a pointer\n * hint which tracks whether the pointer is not in use, hovering a root or\n * pressing a root. Useful for styling pointers depending on if they are\n * hovering/pressing a root or not.\n *\n * @category Driver\n */\nexport enum PointerHint {\n    /** The pointer is currently not hovering any root. */\n    None,\n    /** The pointer is currently hovering a root. */\n    Hovering,\n    /** The pointer is currently hovering and pressing a root. */\n    Pressing,\n}", "import { PointerWheel, PointerWheelMode } from '../events/PointerWheel';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerMove } from '../events/PointerMove';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Event } from '../events/Event';\nimport { PointerHint } from './PointerHint';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\n/**\n * A container which has the state associated with a specific {@link Root} for\n * use in a {@link PointerDriver}.\n *\n * @category Driver\n */\nexport interface PointerDriverState {\n    eventQueue: Array<Event>;\n    pointer: number | null;\n    pressing: number;\n    hovering: boolean;\n    dragLast: [number, number] | null;\n    dragOrigin: [number, number];\n}\n\n/**\n * A generic pointer {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending pointer events to\n * registered roots and (un)registering pointers.\n *\n * @category Driver\n */\nexport class PointerDriver implements Driver {\n    /**\n     * The current state for each registered and enabled root. Contains whether\n     * each root is pressing, hovering, which pointer is bound to it and its\n     * event queue\n     */\n    protected states: Map<Root, PointerDriverState> = new Map();\n    /**\n     * The next available pointer ID. See {@link PointerDriver#registerPointer}\n     */\n    private nextPointerID = 0;\n    /**\n     * The {@link PointerHint | hints} for each pointer. The keys are pointer\n     * IDs, while the values are that pointer's hint.\n     *\n     * See {@link PointerDriver#getPointerHint}\n     */\n    protected hints: Map<number, PointerHint> = new Map();\n    /**\n     * The dragToScroll value of every pointer ID. See\n     * {@link PointerDriver#registerPointer}.\n     */\n    private dragToScroll: Map<number, boolean> = new Map();\n\n    /** Unassign a pointer from a given root and its state. */\n    private unassignPointer(root: Root, state: PointerDriverState) {\n        // Clear pointer state\n        if(state.pointer !== null)\n            this.setPointerHint(state.pointer, PointerHint.None);\n\n        // Clear state\n        state.pointer = null;\n        if(state.hovering) {\n            // Queue up Leave event if hovering\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n        }\n        state.hovering = false;\n        state.pressing = 0;\n        state.dragLast = null;\n    }\n\n    /**\n     * Register a new pointer.\n     *\n     * @param dragToScroll - If true, then dragging will result in PointerWheel events if no widget captures the events.\n     * @returns Returns {@link PointerDriver#nextPointerID} and increments it\n     */\n    registerPointer(dragToScroll = false): number {\n        const newID = this.nextPointerID++;\n        this.setPointerHint(newID, PointerHint.None);\n        this.dragToScroll.set(newID, dragToScroll);\n        return newID;\n    }\n\n    /**\n     * Unregister a pointer.\n     *\n     * If a root has this pointer bound to it, the pointer is unbound from the\n     * root, a Leave event is queued to the root and the hovering and pressing\n     * state of the root is set to false.\n     */\n    unregisterPointer(pointer: number): void {\n        for(const [root, state] of this.states) {\n            // Unassign pointer if unregistered pointer was assigned to root\n            if(state.pointer === pointer)\n                this.unassignPointer(root, state);\n        }\n\n        this.hints.delete(pointer);\n        this.dragToScroll.delete(pointer);\n    }\n\n    /**\n     * Check if a given pointer can queue an event to a given root. Also\n     * automatically assigns pointer to root if possible. For internal use only.\n     *\n     * @param state - The root's state. Although the function could technically get the state itself, it's passed to avoid repetition since you will need the state yourself\n     * @param givingActiveInput - Is the pointer giving active input (pressing button or scrolling)? If so, then it can auto-assign if the root is not being pressed by another pointer\n     */\n    private canQueueEvent(root: Root, pointer: number, state: PointerDriverState, givingActiveInput: boolean): boolean {\n        // If there is no pointer assigned, assign this one\n        const firstAssign = state.pointer === null;\n        if(firstAssign)\n            state.pointer = pointer;\n\n        // If pointer is entering this root for the first time, then find which\n        // root the pointer was assigned to and queue a leave event\n        const pointerMatches = state.pointer === pointer;\n        if(!pointerMatches || firstAssign) {\n            for(const [otherRoot, otherState] of this.states) {\n                // Ignore if its this root\n                if(otherRoot === root)\n                    continue;\n\n                // If other root has this pointer assigned, unassign it\n                if(otherState.pointer === pointer)\n                    this.unassignPointer(otherRoot, otherState);\n            }\n        }\n\n        // Ignore if pointer is not the assigned one and not giving active input\n        // or being pressed by the assigned pointer\n        if(!pointerMatches && (!givingActiveInput || state.pressing > 0))\n            return false;\n        else {\n            // Replace assigned pointer and clear old assigned pointer's hint if\n            // pointer changed and giving active input\n            if(givingActiveInput && state.pointer !== pointer) {\n                this.unassignPointer(root, state);\n                state.pointer = pointer;\n            }\n\n            return true;\n        }\n    }\n\n    /** Denormalise normalised pointer coordinates. Internal use only. */\n    private denormaliseCoords(root: Root, xNorm: number, yNorm: number): [number, number] {\n        const [width, height] = root.dimensions;\n        return [xNorm * width, yNorm * height];\n    }\n\n    /**\n     * Queue up a pointer event to a given root. The type of\n     * {@link PointerEvent} is decided automatically based on the root's state\n     * and whether its pressing or not.\n     *\n     * @param pointer - The registered pointer ID\n     * @param xNorm - The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm - The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param pressing - Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     *\n     * If null, the last pressing state is used, meaning that the pressing state\n     * has not changed. Useful if getting pointer movement in an event based\n     * environment where you only know when a pointer press occurs, but not if\n     * the pointer is pressed or not\n     */\n    movePointer(root: Root, pointer: number, xNorm: number, yNorm: number, pressing: number | null, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // If press state was not supplied, then it hasn't changed. Use the last\n        // state\n        if(pressing === null)\n            pressing = state.pressing;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, pressing > 0))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        if(pressing !== state.pressing) {\n            // Get how many bits in the bitmask you need to check\n            const bits = Math.floor(Math.log2(Math.max(pressing, state.pressing)));\n\n            // Check which buttons changed and generate an event for each\n            for(let bit = 0; bit <= bits; bit++) {\n                const wasPressed = ((state.pressing >> bit) & 0x1) === 1;\n                const isPressed = ((pressing >> bit) & 0x1) === 1;\n\n                if(wasPressed === isPressed)\n                    continue;\n\n                if(isPressed)\n                    state.eventQueue.push(new PointerPress(x, y, bit, shift, ctrl, alt));\n                else\n                    state.eventQueue.push(new PointerRelease(x, y, bit, shift, ctrl, alt));\n            }\n\n            state.pressing = pressing;\n        }\n        else\n            state.eventQueue.push(new PointerMove(x, y, shift, ctrl, alt));\n\n        // Update pointer's hint\n        if(state.pressing > 0)\n            this.setPointerHint(pointer, PointerHint.Pressing);\n        else\n            this.setPointerHint(pointer, PointerHint.Hovering);\n    }\n\n    /**\n     * Queue up a {@link Leave} event to a given root. Event will only be queued\n     * if the root was being hovered.\n     *\n     * @param pointer - The registered pointer ID\n     */\n    leavePointer(root: Root, pointer: number): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Queue leave event if this is the assigned pointer and if hovering\n        if(state.hovering && state.pointer == pointer) {\n            state.hovering = false;\n            state.pressing = 0;\n            state.dragLast = null;\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n            this.setPointerHint(pointer, PointerHint.None);\n        }\n    }\n\n    /**\n     * Queue up a {@link Leave} event to any root with the given pointer\n     * assigned. Event will only be queued if the root was being hovered.\n     * Pointer will also be unassigned from root.\n     *\n     * @param pointer - The registered pointer ID\n     */\n    leaveAnyPointer(pointer: number): void {\n        for(const root of this.states.keys())\n            this.leavePointer(root, pointer);\n    }\n\n    /**\n     * Queue up a mouse wheel event in a given 2D direction. Event will only be\n     * queued if the root was being hovered.\n     *\n     * @param pointer - The registered pointer ID\n     * @param xNorm - The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm - The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param deltaX - How much was scrolled horizontally, in pixels\n     * @param deltaY - How much was scrolled vertically, in pixels\n     * @param deltaZ - How much was scrolled in the Z axis, in pixels. Rarely used\n     * @param deltaMode - How the delta values should be interpreted\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    wheelPointer(root: Root, pointer: number, xNorm: number, yNorm: number, deltaX: number, deltaY: number, deltaZ: number, deltaMode: PointerWheelMode, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, true))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        state.eventQueue.push(new PointerWheel(x, y, deltaX, deltaY, deltaZ, deltaMode, false, shift, ctrl, alt));\n    }\n\n    /**\n     * Set a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer - The registered pointer ID\n     * @param hint - The new pointer hint\n     * @returns Returns true if the pointer hint changed, else, false\n     */\n    protected setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const oldHint = this.hints.get(pointer);\n\n        if(oldHint !== hint) {\n            this.hints.set(pointer, hint);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Get a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer - The registered pointer ID\n     *\n     * @returns Returns the given pointer ID's hint. If the pointer ID is not registered, {@link PointerHint.None} is returned.\n     */\n    getPointerHint(pointer: number): PointerHint {\n        return this.hints.get(pointer) ?? PointerHint.None;\n    }\n\n    /**\n     * Creates a state for the enabled root in {@link PointerDriver#states}.\n     */\n    onEnable(root: Root): void {\n        // Create new state for UI that just got enabled\n        this.states.set(root, <PointerDriverState>{\n            eventQueue: [],\n            pointer: null,\n            pressing: 0,\n            hovering: false,\n            dragLast: null,\n            dragOrigin: [0, 0],\n        });\n    }\n\n    /**\n     * Dispatches a leave event for the disabled root and deletes the state of\n     * the disabled root from {@link PointerDriver#states}.\n     */\n    onDisable(root: Root): void {\n        // Dispatch leave event\n        root.dispatchEvent(new Leave());\n\n        // Reset hint for assigned pointer and stop dragging\n        const state = this.states.get(root);\n        if(typeof state !== 'undefined' && state.pointer !== null) {\n            this.setPointerHint(state.pointer, PointerHint.None);\n            state.dragLast = null;\n        }\n\n        // Delete state for UI thats about to get disabled\n        this.states.delete(root);\n    }\n\n    /**\n     * Dispatches all queued events (found in {@link PointerDriver#states}) for\n     * the root and clears its event queue\n     */\n    update(root: Root): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Check if drag to scroll is enabled for this root\n        const dragToScroll = state.pointer === null\n                                ? false\n                                : this.dragToScroll.get(state.pointer);\n\n        // Dispatch all queued events for this root\n        for(const event of state.eventQueue) {\n            // If this is a pointer event and pointer is dragging, continue\n            // doing dragging logic\n            if(event instanceof PointerEvent && state.dragLast !== null) {\n                const [startX, startY] = state.dragLast;\n                root.dispatchEvent(new PointerWheel(\n                    ...state.dragOrigin,\n                    startX - event.x, startY - event.y, 0,\n                    PointerWheelMode.Pixel, false, false, false, true,\n                ));\n\n                if(event instanceof PointerRelease)\n                    state.dragLast = null;\n                else {\n                    state.dragLast[0] = event.x;\n                    state.dragLast[1] = event.y;\n                }\n\n                continue;\n            }\n\n            // Dispatch event. If nobody captures the event, dragToScroll is\n            // enabled and this is a pointer press, then start dragging\n            if(root.dispatchEvent(event))\n                state.dragLast = null;\n            else if(dragToScroll && event instanceof PointerPress) {\n                state.dragLast = [event.x, event.y];\n                state.dragOrigin[0] = event.x;\n                state.dragOrigin[1] = event.y;\n            }\n        }\n\n        // Clear queue\n        state.eventQueue.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusChanged(_root: Root, _focusType: FocusType, _newFocus: Widget | null): void {}\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n", "import { getPointerEventNormPos } from '../helpers/getPointerEventNormPos';\nimport { parseDOMDeltaMode } from '../events/PointerWheel';\nimport { PointerDriver } from './PointerDriver';\nimport type { Root } from '../core/Root';\n\n/**\n * A container which has all the event listeners for a {@link Root} DOM bind to\n * a {@link DOMPointerDriver}; a link between a DOM element and an existing\n * Root.\n *\n * @category Driver\n */\nexport interface DOMPointerDriverBind {\n    domElem: HTMLElement,\n    pointerListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerleaveListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    wheelListen: ((this: HTMLElement, event: WheelEvent) => void) | null,\n    contextMenuListen: ((this: HTMLElement, event: MouseEvent) => void) | null\n}\n\n/**\n * Unpack a MouseEvent into a 3-tuple containing the event's modifier key state.\n * The 3-tuple contains, respectively, whether shift is being held, whether ctrl\n * is being held, and whether alt is being held.\n *\n * @category Driver\n */\nfunction unpackModifiers(event: MouseEvent): [shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A {@link PointerDriver} which listens for pointer events from HTML DOM\n * elements. Each HTML DOM element is bound to a specific root, which synergizes\n * well with DOMRoot.\n *\n * @category Driver\n */\nexport class DOMPointerDriver extends PointerDriver {\n    /** The HTML DOM element and listeners that each root is bound to */\n    private domElems: WeakMap<Root, DOMPointerDriverBind> = new WeakMap();\n    /** The mapping between each DOM pointer ID and canvas-ui pointer ID */\n    private pointers: Map<number, number> = new Map();\n    /**\n     * The pointer ID of the mouse. Registered in constructor. This is needed\n     * due to wheel events not being part of the DOM PointerEvent interface and\n     * therefore not having a pointerID field. This is also safe because there\n     * can only be one mouse.\n     */\n    private mousePointerID: number;\n\n    /**\n     * Create a new DOMPointerDriver.\n     *\n     * Automatically registers a pointer to be used by the mouse.\n     */\n    constructor() {\n        super();\n\n        this.mousePointerID = this.registerPointer(false);\n    }\n\n    /**\n     * Bind an HTML DOM element to a specific root.\n     *\n     * If the root was already bound,\n     * {@link DOMPointerDriver#removeListeners} is called, replacing the old\n     * listeners. Populates {@link DOMPointerDriver#domElems} with the new bind.\n     * Calls {@link DOMPointerDriver#addListeners} if root is enabled.\n     */\n    bindDOMElem(root: Root, domElem: HTMLElement): void {\n        let rootBind = this.domElems.get(root);\n        if(rootBind !== undefined) {\n            console.warn('Rebinding DOMPointerDriver. Are you calling bindDOMElem with the same HTML element multiple times?');\n            this.removeListeners(rootBind);\n        }\n        else {\n            rootBind = <DOMPointerDriverBind>{\n                domElem,\n                pointerListen: null,\n                pointerleaveListen: null,\n                wheelListen: null,\n                contextMenuListen: null,\n            };\n            this.domElems.set(root, rootBind);\n            domElem.style.touchAction = 'none';\n        }\n\n        if(root.enabled)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Unbind a HTML DOM element from this pointer driver that is bound to a\n     * given Root. Removes all used listeners.\n     */\n    unbindDOMElem(root: Root): void {\n        const rootBind = this.domElems.get(root);\n        if(rootBind === undefined)\n            return;\n\n        this.removeListeners(rootBind);\n        this.domElems.delete(root);\n    }\n\n    /**\n     * Get the canvas-ui pointer ID of a given event. If the event has a pointer\n     * which hasn't been registered yet, then it is registered automatically\n     */\n    private getPointerID(event: PointerEvent): number {\n        let pointerID = this.pointers.get(event.pointerId);\n\n        if(pointerID === undefined) {\n            const isMouse = event.pointerType === 'mouse';\n            if(isMouse)\n                pointerID = this.mousePointerID;\n            else\n                pointerID = this.registerPointer(true);\n\n            this.pointers.set(event.pointerId, pointerID);\n        }\n\n        return pointerID;\n    }\n\n    /** Add pointer event listeners to root's DOM element. */\n    private addListeners(root: Root, rootBind: DOMPointerDriverBind): void {\n        // Make listeners for mouse events, queueing events. Add them to the\n        // root DOM bind so they can be removed later when needed\n        const domElem = rootBind.domElem;\n        if(rootBind.pointerListen === null) {\n            rootBind.pointerListen = (event: PointerEvent) => {\n                this.movePointer(\n                    root, this.getPointerID(event),\n                    ...getPointerEventNormPos(event, domElem),\n                    event.buttons,\n                    ...unpackModifiers(event),\n                );\n            }\n\n            domElem.addEventListener('pointermove', rootBind.pointerListen);\n            domElem.addEventListener('pointerdown', rootBind.pointerListen);\n            domElem.addEventListener('pointerup', rootBind.pointerListen);\n        }\n\n        if(rootBind.pointerleaveListen === null) {\n            rootBind.pointerleaveListen = (event: PointerEvent) => {\n                this.leavePointer(root, this.getPointerID(event));\n            }\n\n            domElem.addEventListener('pointerleave', rootBind.pointerleaveListen);\n        }\n\n        if(rootBind.wheelListen === null) {\n            rootBind.wheelListen = (event: WheelEvent) => {\n                const deltaMode = parseDOMDeltaMode(event.deltaMode);\n                if(deltaMode === null)\n                    return;\n\n                this.wheelPointer(\n                    root, this.mousePointerID,\n                    ...getPointerEventNormPos(event, domElem),\n                    event.deltaX, event.deltaY, event.deltaZ, deltaMode,\n                    ...unpackModifiers(event),\n                );\n            }\n\n            domElem.addEventListener('wheel', rootBind.wheelListen, { passive: false });\n        }\n\n        if(rootBind.contextMenuListen === null) {\n            rootBind.contextMenuListen = (event: MouseEvent) => {\n                // Prevent right-click from opening context menu\n                event.preventDefault();\n            }\n\n            domElem.addEventListener('contextmenu', rootBind.contextMenuListen);\n        }\n    }\n\n    /**\n     * Remove pointer event listeners from root's DOM element and unset tracked\n     * listeners in root's bind.\n     */\n    private removeListeners(rootBind: DOMPointerDriverBind): void {\n        if(rootBind.pointerListen !== null) {\n            rootBind.domElem.removeEventListener('pointermove', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerdown', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerup', rootBind.pointerListen);\n            rootBind.pointerListen = null;\n        }\n        if(rootBind.pointerleaveListen !== null) {\n            rootBind.domElem.removeEventListener('pointerleave', rootBind.pointerleaveListen);\n            rootBind.pointerleaveListen = null;\n        }\n        if(rootBind.wheelListen !== null) {\n            rootBind.domElem.removeEventListener('wheel', rootBind.wheelListen);\n            rootBind.wheelListen = null;\n        }\n        if(rootBind.contextMenuListen !== null) {\n            rootBind.domElem.removeEventListener('contextmenu', rootBind.contextMenuListen);\n            rootBind.contextMenuListen = null;\n        }\n    }\n\n    /**\n     * Calls {@link PointerDriver#onEnable} and\n     * {@link DOMPointerDriver#addListeners} to each bound root.\n     */\n    override onEnable(root: Root): void {\n        super.onEnable(root);\n\n        // Add event listeners for pointer when root is enabled, if the root is\n        // bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(rootBind !== undefined)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Calls {@link PointerDriver#onDisable} and\n     * {@link DOMPointerDriver#removeListeners} to each bound root.\n     */\n    override onDisable(root: Root): void {\n        super.onDisable(root);\n\n        // Remove event listeners for pointer when root is disabled, if the root\n        // is bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(rootBind !== undefined)\n            this.removeListeners(rootBind);\n    }\n}", "import type { RayPointerSource } from './RayPointerSource';\nimport type { PointerHint } from './PointerHint';\nimport { PointerDriver } from './PointerDriver';\nimport { Root } from '../core/Root';\n\n/**\n * A {@link PointerDriver} which gets pointer events from raycasts in a 3D\n * engine's world. This is an abstract class and must be implemented. For an\n * example, see\n * [canvas-ui-three](https://github.com/rafern/canvas-ui-three)'s\n * ThreeRayPointerDriver implementation.\n *\n * @category Driver\n */\nexport abstract class RayPointerDriver extends PointerDriver {\n    /** The sources which this is assigned to */\n    protected readonly sources: Set<RayPointerSource> = new Set();\n\n    /**\n     * Cast a ray in the world and get which root was intersected and where.\n     *\n     * @param origin - The world position where the ray is starting\n     * @param direction - A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @returns Returns a 3-tuple containing, in this order, the intersected root or null if none intersected, the normalised x axis of the intersection and the normalised y axis of the intersection. If no root was intersected, use bogus values for x and y\n     */\n    abstract castRay(origin: [number, number, number], direction: [number, number, number]): [Root | null, number, number];\n\n    /**\n     * Receive a ray from a {@link RayPointerSource}.\n     *\n     * @param pointer - The source's pointer ID, given when setting the source's sink\n     * @param pressing - Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param origin - The world position where the ray is starting\n     * @param direction - A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    handlePointerRay(pointer: number, pressing: number | null, origin: [number, number, number], direction: [number, number, number], shift: boolean, ctrl: boolean, alt: boolean): void {\n        // Cast a ray and get the root that intersects with the ray and the\n        // intersection coordinates\n        const [root, xNorm, yNorm] = this.castRay(origin, direction);\n\n        // Queue a leave event if no root intersected, else, queue a move event\n        if(root === null)\n            this.leaveAnyPointer(pointer);\n        else\n            this.movePointer(root, pointer, xNorm, yNorm, pressing, shift, ctrl, alt);\n    }\n\n    /** Add a source. Assigns itself to the given source. */\n    addSource(source: RayPointerSource): void {\n        if(!this.sources.has(source)) {\n            source.setRayPointerDriver(this);\n            this.sources.add(source);\n        }\n    }\n\n    protected override setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const changed = super.setPointerHint(pointer, hint);\n\n        // Call onPointerHintChanged handler for each source\n        for(const source of this.sources)\n            source.onPointerHintChanged(pointer, hint);\n\n        return changed;\n\n    }\n}\n", "import { FillStyle } from './FillStyle';\nimport { Theme } from './Theme';\n\n/**\n * A theme which always gives out a random canvas fill colour. Used for\n * debugging when painting occurs. Has no properties but always has a fallback\n * theme.\n *\n * @category Theme\n */\nexport class DebugTheme extends Theme {\n    /**\n     * Create a new DebugTheme instance.\n     *\n     * @param fallback - The actual theme to use. Canvas fill color will be ignored as it is randomly generated. If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(fallback: Theme = new Theme()) {\n        super(undefined, fallback);\n    }\n\n    override get canvasFill(): FillStyle {\n        return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n    }\n\n    override set canvasFill(value: FillStyle | undefined) {\n        super.canvasFill = value;\n    }\n}\n", "import type { Validator, UnknownValidator } from './Validator';\nimport type { VariableCallback } from './VariableCallback';\n\n/**\n * Creates a new {@link Validator} which is a list of validators merged into\n * one.\n *\n * @param validators - The list of validators to be merged. The validators will be run in the order of the array.\n * @param defaultValue - The bogus value that will be returned if the input is invalid\n * @param callback - A callback which is called if validation succeeds. If null, no such callback will be called.\n * @typeParam U - The type of the input.\n * @typeParam V - The type of the output (the transformed input).\n *\n * @category Validator\n */\nexport function MakeCompositeValidator<U, V>(validators: Array<UnknownValidator>, defaultValue: V, callback: VariableCallback<V> | null = null): Validator<U, V> {\n    // TODO there must be a better way to do this which preserves type checking.\n    // maybe make Validator a class which can be chained with other validators?\n    return (value: U): [boolean, V] => {\n        let valid = true;\n        let nextValue: unknown = value;\n\n        for(const validator of validators) {\n            [valid, nextValue] = validator(nextValue);\n            if(!valid)\n                return [false, defaultValue];\n        }\n\n        if(callback !== null) {\n            try {\n                callback(nextValue as V);\n            }\n            catch(e) {\n                console.warn('Exception in CompositeValidator callback:', e);\n            }\n        }\n\n        return [true, nextValue as V];\n    };\n}", "import type { VariableCallback } from './VariableCallback';\nimport type { TextValidator } from './Validator';\n\n/**\n * A {@link TextValidator} which does nothing. Always reports a string as valid\n * and returns the input as the transformed input.\n *\n * @category Validator\n */\nexport function DefaultTextValidator(text: string): [boolean, string] {\n    return [true, text];\n}\n\n/**\n * Create a new {@link TextValidator} which calls a given callback. Always\n * reports a string as valid and returns the input as the transformed input,\n * like {@link DefaultTextValidator}.\n *\n * Note that this is only useful if a callback is supplied. If null is given as\n * the callback, then this will simply return {@link DefaultTextValidator}.\n *\n * @category Validator\n */\nexport function MakeDefaultTextValidatorWithCallback(callback: VariableCallback<string> | null = null): TextValidator<string> {\n    if(callback === null)\n        return DefaultTextValidator;\n\n    return (text: string): [boolean, string] => {\n        callback(text);\n        return [true, text];\n    }\n}", "const floatRegex = /^-?(\\.\\d+|\\d+(\\.(\\d+)?)?)(e\\d+)?$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * number. If valid, then it transforms the input string into a float.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function FloatValidator(text: string): [boolean, number] {\n    if(!floatRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseFloat(text)];\n}", "const intRegex = /^-?\\d+$/;\n\n/**\n * A {@link Validator} which reports an input string as valid if it is a valid\n * integer. If valid, then it transforms the input string into an integer.\n *\n * The transformed input for invalid inputs is NaN.\n *\n * @category Validator\n */\nexport function IntValidator(text: string): [boolean, number] {\n    if(!intRegex.test(text))\n        return [false, NaN];\n\n    return [true, parseInt(text)];\n}", "import type { Validator } from './Validator';\n\n/**\n * Creates a {@link Validator} which checks whether an input value is within a\n * specified exclusive range (can't be an inclusive range), always returning the\n * original input value.\n *\n * @typeParam V - The type of the input (and output, since it is unchanged).\n *\n * @category Validator\n */\nexport function MakeRangeValidator<V>(min: V, max: V): Validator<V, V> {\n    // TODO make a system for inclusive ranges\n    return (value: V): [boolean, V] => {\n        if(value < min)\n            return [false, value];\n\n        if(value > max)\n            return [false, value];\n\n        return [true, value];\n    };\n}", "/**\n * An aggregate helper class for widgets that contain a variable with a\n * specified type which is intended to be controlled by the user.\n *\n * Useful for implementing widgets such as sliders, checkboxes, text input,\n * etc...\n *\n * @typeParam V - The type of {@link Variable#value}.\n *\n * @category Helper\n */\nexport class Variable<V> {\n    /** The current value, for internal use. */\n    private _value: V;\n    /** Has the value changed? */\n    private _dirty = false;\n\n    /**\n     * Create a new Variable.\n     *\n     * @param initialValue - The initial value of this variable. Sets {@link Variable#_value}.\n     */\n    constructor(initialValue: V) {\n        this._value = initialValue;\n    }\n\n    /**\n     * The current value.\n     *\n     * If setting, {@link Variable#setValue} is called.\n     */\n    get value(): V {\n        return this._value;\n    }\n\n    set value(value: V) {\n        this.setValue(value);\n    }\n\n    /** Has the value changed? Resets {@link Variable#_dirty} to false */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Sets {@link Variable#_value}. Does nothing if the value is already the\n     * one specified.\n     *\n     * @param notify - If true, then {@link Variable#_dirty} is set to true if the value changes.\n     * @returns Returns true if the value was changed, false if not\n     */\n    setValue(value: V, notify = true): boolean {\n        if(this._value === value)\n            return false;\n\n        this._value = value;\n\n        if(notify)\n            this._dirty = true;\n\n        return true;\n    }\n}\n", "import { VariableCallback } from \"./VariableCallback\";\nimport { Variable } from \"./Variable\";\n\nexport class WatchableVariable<V> extends Variable<V> {\n    /** The function callbacks called when the value is changed */\n    private callbacks: Set<VariableCallback<V>> = new Set();\n\n    hasCallback(callback: VariableCallback<V>): boolean {\n        return this.callbacks.has(callback);\n    }\n\n    watch(callback: VariableCallback<V>): boolean {\n        if(this.hasCallback(callback))\n            return false;\n\n        this.callbacks.add(callback);\n        return true;\n    }\n\n    unwatch(callback: VariableCallback<V>): boolean {\n        return this.callbacks.delete(callback);\n    }\n\n    override setValue(value: V, notify = true): boolean {\n        const changed = super.setValue(value, notify);\n\n        if(changed && notify) {\n            for(const callback of this.callbacks) {\n                try {\n                    callback(value);\n                }\n                catch(e) {\n                    console.error('Exception in Variable callback', e);\n                }\n            }\n        }\n\n        return changed;\n    }\n}", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as an alt key; toggles\n * {@link KeyContext#alt} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class AltKey extends VirtualKey {\n    /** Create a new AltKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 42, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Alt',\n            () => {\n                keyContext.alt = !keyContext.alt;\n                this.child.forced = keyContext.alt;\n                keyContext.callback('Alt');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.alt;\n    }\n}\n", "import type { ThemeProperties } from '../../theme/ThemeProperties';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a control key; toggles\n * {@link KeyContext#ctrl} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class ControlKey extends VirtualKey {\n    /** Create a new ControlKey. */\n    constructor(keyContext: KeyContext, flex = 0, minWidth = 42, minHeight = 24, themeProperties?: ThemeProperties) {\n        super(\n            'Ctrl',\n            () => {\n                keyContext.ctrl = !keyContext.ctrl;\n                this.child.forced = keyContext.ctrl;\n                keyContext.callback('Control');\n            },\n            flex,\n            minWidth,\n            minHeight,\n            themeProperties,\n        );\n\n        this.child.forced = keyContext.ctrl;\n    }\n}\n", "/**\n * An axis coupling mode is a mode that is applied to a {@link ViewportWidget}\n * on a per-axis basis. The mode controls how a ViewportWidget's axis length\n * relates to a ViewportWidget child's axis length.\n *\n * If two axes are not coupled, then they do not affect each other's length in\n * any way. If two axes are bi-directionally coupled, then they will always have\n * the same length. If two axes are uni-directionally coupled, then one axis\n * will affect the length of another axis, but not the other way around.\n *\n * @category Widget\n */\nexport enum AxisCoupling {\n    /**\n     * Doesn't couple a {@link ViewportWidget}'s axis to its child; the\n     * viewport's axis length is completely separate from the child's axis\n     * length.\n     *\n     * Default axis coupling mode for ViewportWidget.\n     */\n    None,\n    /**\n     * Bi-directional coupling. The {@link ViewportWidget}'s axis will be equal\n     * to its child's axis. Use this if the axis being tied isn't meant to be\n     * scrollable.\n     */\n    Bi,\n    /**\n     * Uni-directional coupling. The {@link ViewportWidget}'s axis will be\n     * resolved as a regular Widget, but the result will be transferred to the\n     * child's minimum axis length constraint.\n     *\n     * Default axis coupling mode for {@link TextArea}.\n     */\n    Uni,\n}\n", "import { layoutField, multiFlagField, paintArrayField } from '../decorators/FlagFields';\nimport { WatchableVariable } from '../state/WatchableVariable';\nimport { ThemeProperties } from '../theme/ThemeProperties';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { TextPasteEvent } from '../events/TextPasteEvent';\nimport type { TextValidator } from '../state/Validator';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { PointerMove } from '../events/PointerMove';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { AutoScroll } from '../events/AutoScroll';\nimport { TabSelect } from '../events/TabSelect';\nimport type { Bounds } from '../helpers/Bounds';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Rect } from '../helpers/Rect';\nimport { Leave } from '../events/Leave';\nimport { Widget } from './Widget';\n\n/**\n * A flexbox widget that allows for a single line of text input.\n *\n * Supports obscuring the text with {@link TextInput#hideText}, which shows all\n * characters as black circles like in password fields, text validation and\n * toggling editing.\n *\n * If a {@link TextInputHandler} is set, then that will be used instead of\n * keyboard input for mobile compatibility.\n *\n * @typeParam V - The type of {@link TextInput#validValue}; the type of the transformed value returned by the validator.\n *\n * @category Widget\n */\nexport class TextInput<V> extends Widget {\n    /**\n     * At what timestamp did the blinking start. If 0, then the text cursor is\n     * not blinking.\n     */\n    private blinkStart = 0;\n    /**\n     * Was the cursor shown last frame due to blinking? If null, then the text\n     * cursor is not blinking.\n     */\n    private blinkWasOn: boolean | null = null;\n    /** Current cursor position (index, not offset). */\n    private cursorPos = 0;\n    /** Current cursor offset in pixels. */\n    private cursorOffset: [number, number] = [0, 0];\n    /** Current cursor selection start position (index, not offset). */\n    private selectPos = 0;\n    /** Current cursor selection start offset in pixels. */\n    private selectOffset: [number, number] = [0, 0];\n    /** Does the cursor offset need to be updated? */\n    private cursorOffsetDirty = false;\n    /** Is editing enabled? */\n    private _editingEnabled = true;\n    /**\n     * Is the text hidden?\n     *\n     * @decorator `@multiFlagField(['cursorOffsetDirty', '_dirty'])`\n     */\n    @multiFlagField(['cursorOffsetDirty', '_dirty'])\n    hideText = false;\n    /** Is the text valid? */\n    private _valid;\n    /** Last valid value. */\n    private _validValue;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /** The helper for keeping track of the input value */\n    protected variable: WatchableVariable<string>;\n    /**\n     * Current offset of the text in the text box. Used on overflow.\n     *\n     * @decorator `@paintArrayField()`\n     */\n    @paintArrayField()\n    private offset = [0, 0];\n    /**\n     * Is text wrapping enabled? If not, text will be panned if needed\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText = true;\n    /**\n     * An input filter; a function which dictates whether a certain input can be\n     * inserted in the text. If the function returns false given the input,\n     * then the input will not be inserted in the text. Useful for preventing\n     * newlines or forcing numeric input. Note that the input is not\n     * neccessarily a character; it can be a whole sentence.\n     */\n    inputFilter: ((input: string) => boolean) | null = null;\n    /** Is the pointer dragging? */\n    private dragging = false;\n    /** When was the last pointer click? For detecting double/triple-clicks */\n    private lastClick = 0;\n    /**\n     * The cursor position when dragging was started. Used for\n     * double/triple-click dragging.\n     */\n    private dragStart = -1;\n    /**\n     * How many clicks have there been after a first click where the time\n     * between each click is less than 500 ms. Used for detecting double/triple\n     * clicks\n     */\n    private successiveClickCount: 0 | 1 | 2 = 0;\n    /**\n     * Can tab characters be typed in this input widget? If true, then pressing\n     * tab will not move the focus to the next widget, unless tab is a filtered\n     * character.\n     *\n     * If tab is not a filtered character and this is true, holding shift will\n     * move to the next widget instead of typing the character, not move to the\n     * previous focusable widget.\n     */\n    typeableTab = false;\n    /**\n     * Should the caret position be {@link AutoScroll | auto-scrolled} after the\n     * layout is finalized?\n     */\n    private needsAutoScroll = false;\n\n    /** Create a new TextInput. */\n    constructor(validator: TextValidator<V>, inputFilter: ((input: string) => boolean) | null = null, initialValue = '', themeProperties?: ThemeProperties) {\n        // TextInputs clear their own background, have no children and don't\n        // propagate events\n        super(false, false, themeProperties);\n\n        this.tabFocusable = true;\n        this.textHelper = new TextHelper();\n        this.variable = new WatchableVariable<string>(initialValue);\n        this.variable.watch((text: string) => {\n            const [valid, validatedValue] = validator(text);\n\n            if(valid)\n                this._validValue = validatedValue;\n\n            if(valid !== this._valid) {\n                this._valid = valid;\n                this._dirty = true;\n            }\n        });\n        [this._valid, this._validValue] = validator(initialValue);\n        this.inputFilter = inputFilter;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n            this.cursorOffsetDirty = true;\n        }\n        else if(property === 'inputTextInnerPadding' ||\n                property === 'inputTextFont' ||\n                property === 'inputTextHeight' ||\n                property === 'inputTextSpacing')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'inputBackgroundFill' ||\n                property === 'inputTextFill' ||\n                property === 'inputTextFillInvalid' ||\n                property === 'inputTextFillDisabled' ||\n                property === 'cursorThickness')\n        {\n            this._dirty = true;\n        }\n        else if(property === 'inputTextAlign')\n            this.cursorOffsetDirty = true;\n    }\n\n    /**\n     * Is the text cursor shown?\n     *\n     * @returns Returns true if the text cursor is shown, false if not shown but the text input is in use, or null if the text cursor is not shown due to the text input not being in use.\n     */\n    get blinkOn(): boolean | null {\n        if(this.blinkStart === 0)\n            return null;\n\n        const blinkRate = this.blinkRate;\n        return Math.trunc(((Date.now() - this.blinkStart) / (500 * blinkRate)) % 2) === 0;\n    }\n\n    /**\n     * Is editing enabled?\n     *\n     * Tied to {@link TextInput#_editingEnabled}. If changed,\n     * {@link Widget#_dirty} is set to true. If disabled, blinking stops and the\n     * cursor position is reset to the beginning.\n     */\n    get editingEnabled(): boolean {\n        return this._editingEnabled;\n    }\n\n    set editingEnabled(editingEnabled: boolean) {\n        if(this._editingEnabled !== editingEnabled) {\n            this._editingEnabled = editingEnabled;\n\n            // Disable blinking and reset cursor position if disabled\n            if(!editingEnabled) {\n                this.blinkStart = 0;\n                this.moveCursorTo(0, false);\n            }\n\n            // Mark as dirty; the text color changes\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * The current text value.\n     *\n     * Should not be used internally as a setter (but using it as a getter is\n     * fine); if you are extending TextInput, use this.variable.value instead.\n     */\n    set text(text: string) {\n        this.variable.value = text;\n\n        // clamp cursor positions if the new text has a smaller length\n        // than the old text\n        const textLength = this.variable.value.length;\n        if(this.cursorPos > textLength) {\n            this.cursorPos = textLength;\n            this.cursorOffsetDirty = true;\n        }\n        if(this.selectPos > textLength) {\n            this.selectPos = textLength;\n            this.cursorOffsetDirty = true;\n        }\n    }\n\n    get text(): string {\n        return this.variable.value;\n    }\n\n    /**\n     * Get the text as it is shown. If the text is hidden, all characters are\n     * replaced with a black circle.\n     */\n    get displayedText(): string {\n        if(this.hideText)\n            return '\u25CF'.repeat(this.variable.value.length);\n        else\n            return this.variable.value;\n    }\n\n    /** Is the current value in the text input valid? */\n    get valid(): boolean {\n        return this._valid;\n    }\n\n    /** The last valid value, transformed by the validator. */\n    get validValue(): V {\n        return this._validValue;\n    }\n\n    /** The current line number, starting from 0. */\n    get line(): number {\n        return this.textHelper.getLine(this.cursorPos);\n    }\n\n    /** Auto-scroll to the caret if the {@link blinkStart | caret is shown}. */\n    private autoScrollCaret(): void {\n        // Auto-scroll if caret is shown\n        if(this.blinkStart !== 0)\n            this.needsAutoScroll = true;\n    }\n\n    /**\n     * Move the cursor to a given index.\n     *\n     * Sets {@link Widget#_dirty} and {@link TextInput#cursorOffsetDirty} to\n     * true.\n     *\n     * @param select - Should this do text selection?\n     */\n    moveCursorTo(index: number, select: boolean): void {\n        // Update cursor position, checking for boundaries\n        this.cursorPos = Math.min(Math.max(index, 0), this.text.length);\n\n        if(!select)\n            this.selectPos = this.cursorPos;\n\n        // Update cursor offset\n        this.cursorOffsetDirty = true;\n        this._dirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Move the cursor by a given index delta. Calls\n     * {@link TextInput#moveCursorTo}\n     *\n     * @param delta - The change in index; if a positive number, the cursor will be moved right by that amount, else, the cursor will be moved left by that amount.\n     */\n    moveCursor(delta: number, select: boolean): void {\n        this.moveCursorTo(this.cursorPos + delta, select);\n    }\n\n    /**\n     * Move the cursor given a given pointer offset.\n     *\n     * @param offsetX - The horizontal offset in pixels, relative to the text area with padding removed\n     * @param offsetY - The vertical offset in pixels, relative to the text area with padding removed\n     * @param select - Should this do text selection?\n     */\n    moveCursorFromOffset(offsetX: number, offsetY: number, select: boolean): void {\n        [this.cursorPos, this.cursorOffset] = this.textHelper.findIndexOffsetFromOffset(\n            [ offsetX, offsetY ],\n        );\n\n        if(!select) {\n            this.selectPos = this.cursorPos;\n            this.selectOffset = this.cursorOffset;\n        }\n\n        // Start blinking cursor and mark component as dirty, to\n        // make sure that cursor blink always resets for better\n        // feedback\n        this.blinkStart = Date.now();\n        this._dirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Move the cursor by a given line delta. Calls\n     * {@link TextInput#moveCursorFromOffset}\n     *\n     * @param delta - The change in line; if a positive number, the cursor will be moved down by that amount, else, the cursor will be moved up by that amount.\n     */\n    moveCursorLine(delta: number, select: boolean): void {\n        this.moveCursorFromOffset(\n            this.cursorOffset[0],\n            this.cursorOffset[1] + (0.5 + delta) * this.textHelper.fullLineHeight,\n            select,\n        );\n    }\n\n    /**\n     * Move the cursor to the start of the line. Calls\n     * {@link TextInput#moveCursorTo}\n     */\n    moveCursorStart(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineStart(this.line), select);\n    }\n\n    /**\n     * Move the cursor to the end of the line. Calls\n     * {@link TextInput#moveCursorTo}\n     */\n    moveCursorEnd(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineEnd(this.line, false), select);\n    }\n\n    /**\n     * Move the cursor by skipping over a number of words. Calls\n     * {@link TextInput#moveCursorTo}\n     *\n     * @param delta - The change in words; if a positive number, the cursor skip this amount of words, else, it will do the same, but backwards.\n     */\n    moveCursorWord(delta: number, select: boolean): void {\n        if(delta == 0)\n            return;\n\n        const wordRegex = /\\w/;\n        const text = this.text;\n        let targetPos = this.cursorPos;\n\n        if(delta > 0) {\n            while(delta > 0) {\n                let insideWord = false;\n                for(; targetPos <= text.length; targetPos++) {\n                    if(targetPos < text.length && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                delta--;\n            }\n        }\n        else {\n            while(delta < 0) {\n                targetPos--;\n                let insideWord = false;\n                for(; targetPos >= 0; targetPos--) {\n                    if(targetPos >= 0 && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                targetPos++;\n                delta++;\n            }\n        }\n\n        this.moveCursorTo(targetPos, select);\n    }\n\n    /**\n     * Deletes a range of text and moves the cursor to the start of the range.\n     *\n     * @param start - The inclusive index of the start of the text range\n     * @param end - The exclusive index of the end of the text range\n     */\n    deleteRange(start: number, end: number): void {\n        if(start === end)\n            return;\n\n        // Delete text\n        this.variable.value = this.text.substring(0, start) + this.text.substring(end);\n\n        // Update cursor position\n        this.cursorPos = this.selectPos = start;\n        this.cursorOffsetDirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Like {@link TextInput#moveCursorWord}, but for deleting words. Calls\n     * {@link TextInput#moveCursorWord} and {@link TextInput#deleteRange}. If\n     * text is being selected, delta is ignored and the selection is deleted\n     * instead. Note that a delta of zero doesn't delete anything.\n     */\n    deleteWord(delta: number): void {\n        if(delta === 0)\n            return;\n\n        // Delete selection\n        if(this.cursorPos !== this.selectPos) {\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n            return;\n        }\n\n        // Move cursor by wanted words\n        const oldPos = this.cursorPos;\n        this.moveCursorWord(delta, false);\n\n        // If cursor position is different, delete\n        if(oldPos !== this.cursorPos) {\n            this.deleteRange(\n                Math.min(oldPos, this.cursorPos),\n                Math.max(oldPos, this.cursorPos),\n            );\n        }\n    }\n\n    /**\n     * Insert text at the current cursor index. Calls\n     * {@link TextInput#moveCursorTo} afterwards.\n     */\n    insertText(str: string): void {\n        // Abort if input can't be inserted\n        if(this.inputFilter !== null && !this.inputFilter(str))\n            return;\n\n        if(this.selectPos === this.cursorPos) {\n            // Insert string in current cursor position\n            this.variable.value = this.text.substring(0, this.cursorPos) + str + this.text.substring(this.cursorPos);\n            // Move cursor neccessary amount forward\n            this.moveCursor(str.length, false);\n        }\n        else {\n            const start = Math.min(this.cursorPos, this.selectPos);\n            const end = Math.max(this.cursorPos, this.selectPos);\n\n            // Replace text in selection with the one being inserted\n            this.variable.value = this.text.substring(0, start) + str + this.text.substring(end);\n            // Move cursor to end of selection after insert\n            this.moveCursorTo(start + str.length, false);\n        }\n    }\n\n    /**\n     * Deletes a certain amount of characters in a given direction from the\n     * current cursor index. Calls {@link TextInput#deleteRange} or\n     * {@link TextInput#moveCursorTo} if neccessary. If text is being selected,\n     * delta is ignored and the selection is deleted instead. Note that a delta\n     * of zero doesn't delete anything.\n     *\n     * @param delta - The amount and direction of the deletion. For example, if 5, then 5 characters are deleted after the cursor. If -5, then 5 characters are deleted before the cursor and the cursor is moved 5 indices left.\n     */\n    deleteText(delta: number): void {\n        if(delta === 0)\n            return;\n\n        if(this.cursorPos !== this.selectPos) {\n            // Delete selection\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n        }\n        else if(delta > 0) {\n            // Delete forwards\n            this.variable.value = this.text.substring(0, this.cursorPos) + this.text.substring(this.cursorPos + delta);\n            // XXX normally, deleting forwards doens't require updating the\n            // cursor offset, but when there is text wrapping, delete can change\n            // the cursor offset (pressing delete on a long word in the next\n            // line, causing text wrapping to move the cursor to the previous\n            // line). because of this edge case, mark the cursor offset as dirty\n            this.cursorOffsetDirty = true;\n            this.autoScrollCaret();\n        }\n        else {\n            // Delete backwards\n            // NOTE, still checking if delta < 0 so that nothing is done if\n            // delta is 0\n            this.variable.value = this.text.substring(0, this.cursorPos + delta) + this.text.substring(this.cursorPos);\n            this.moveCursor(delta, false);\n        }\n    }\n\n    /**\n     * Select a range of text (either word or non-word, but not both) which\n     * includes the given cursor position\n     *\n     * @returns Returns a 2-tuple with, respectively, the start and end of the range\n     */\n    private selectRangeAt(pos: number): [number, number] {\n        const text = this.text;\n        const wordRegex = /\\w/;\n        const isWord = wordRegex.test(text[pos]);\n        const midPos = pos;\n\n        // Grow left\n        for(; pos >= 0; pos--) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        const startPos = pos + 1;\n\n        // Grow right\n        pos = midPos;\n        for(; pos < text.length; pos++) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        this.autoScrollCaret();\n\n        return [startPos, pos];\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        // If keyboard focus is gained and the caret isn't shown yet, select the\n        // last character and start blinking the caret\n        if(focusType === FocusType.Keyboard && this.blinkStart === 0) {\n            this.blinkStart = Date.now();\n            this.selectPos = this.variable.value.length;\n            this.cursorPos = this.selectPos;\n            this.cursorOffsetDirty = true;\n            this.autoScrollCaret();\n        }\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        // Stop blinking cursor if keyboard focus lost and stop dragging if\n        // pointer focus is lost\n        if(focusType === FocusType.Keyboard)\n            this.blinkStart = 0;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        // If editing is disabled, abort\n        if(!this._editingEnabled)\n            return null;\n\n        const root = this.root;\n\n        if(event instanceof Leave) {\n            // Stop dragging if the pointer leaves the text input, since it\n            // won't receive pointer release events outside the widget\n            this.dragging = false;\n            this.lastClick = 0;\n            return this;\n        }\n        else if(event instanceof PointerWheel) {\n            // Don't capture wheel events\n            return null;\n        }\n        else if(event instanceof PointerEvent) {\n            // If this is a pointer event, set pointer style and handle clicks\n            root.pointerStyle = 'text';\n\n            // Request keyboard focus if this is a pointer press with the\n            // primary button\n            if(event instanceof PointerPress || event instanceof PointerMove) {\n                const isPress = event instanceof PointerPress && event.isPrimary;\n                if(isPress) {\n                    this.dragging = true;\n                    const clickTime = (new Date()).getTime();\n\n                    // Count successive clicks. Clicks counts as successive if\n                    // they come after the last click in less than 500 ms\n                    if(clickTime - this.lastClick < 500) {\n                        this.successiveClickCount++;\n                        // Wrap click counter around (there's no action above\n                        // triple click)\n                        if(this.successiveClickCount > 2)\n                            this.successiveClickCount = 0;\n                    }\n                    else\n                        this.successiveClickCount = 0;\n\n                    this.lastClick = clickTime;\n                }\n                else if(!this.dragging)\n                    return this;\n\n                // Update cursor position (and offset) from click position\n                const padding = this.inputTextInnerPadding;\n                this.moveCursorFromOffset(\n                    event.x - this.idealX - padding + this.offset[0],\n                    event.y - this.idealY - padding + this.offset[1],\n                    !isPress && this.dragging,\n                );\n\n                if(isPress) {\n                    // Prevent successive clicks from one cursor position to\n                    // another from counting as successive clicks\n                    if(this.cursorPos !== this.dragStart)\n                        this.successiveClickCount = 0;\n\n                    this.dragStart = this.cursorPos;\n                }\n\n                if(this.successiveClickCount > 0) {\n                    let start, end;\n\n                    if(this.successiveClickCount === 1) {\n                        // If double-click dragging, select ranges of text\n                        // Get the text range at the cursor and at the start of the\n                        // double click drag, then mush them together into a single\n                        // range\n                        const [doubleStart, doubleEnd] = this.selectRangeAt(this.dragStart);\n                        const [curStart, curEnd] = this.selectRangeAt(this.cursorPos);\n                        start = Math.min(doubleStart, curStart);\n                        end = Math.max(doubleEnd, curEnd);\n                    }\n                    else {\n                        // If triple-click dragging, select lines of text\n                        const startPos = Math.min(this.cursorPos, this.dragStart);\n                        const startLine = this.textHelper.getLine(startPos);\n                        start = this.textHelper.getLineStart(startLine);\n\n                        const endPos = Math.max(this.cursorPos, this.dragStart);\n                        const endLine = this.textHelper.getLine(endPos);\n                        // Include newlines so that deleting a triple-click\n                        // selection deletes entire lines\n                        end = this.textHelper.getLineEnd(endLine);\n                    }\n\n                    // Set cursor positions. Get the drag direction and swap\n                    // cursor and select pos depending on the direction\n                    if(this.cursorPos >= this.dragStart) {\n                        this.selectPos = start;\n                        this.cursorPos = end;\n                    }\n                    else {\n                        this.selectPos = end;\n                        this.cursorPos = start;\n                    }\n\n                    this.cursorOffsetDirty = true;\n                }\n\n                // Request focus\n                root.requestFocus(FocusType.Keyboard, this);\n            }\n            else if(event instanceof PointerRelease && event.isPrimary) {\n                // Stop dragging\n                this.dragging = false;\n\n                // Get mobile-friendly text input if available\n                if(root.hasMobileTextInput) {\n                    root.getTextInput(this.text).then((newValue: string | null) => {\n                        if(newValue === null)\n                            return;\n\n                        if(this.text !== newValue) {\n                            this.text = newValue;\n                            this.moveCursorTo(newValue.length, false);\n                        }\n                    });\n                }\n            }\n\n            return this;\n        }\n        else if(event instanceof KeyPress) {\n            // Stop dragging\n            this.dragging = false;\n            this.lastClick = 0;\n\n            // Ignore all key presses with alt modifier\n            if(event.alt)\n                return this;\n\n            // Ignore most key presses if control is pressed\n            if(event.ctrl) {\n                if(event.key === 'Backspace')\n                    this.deleteWord(-1); // Delete word backwards\n                else if(event.key === 'Delete')\n                    this.deleteWord(1); // Delete word forwards\n                else if(event.key === 'ArrowLeft')\n                    this.moveCursorWord(-1, event.shift); // Back-skip a word\n                else if(event.key === 'ArrowRight')\n                    this.moveCursorWord(1, event.shift); // Skip a word\n                else if(event.key === 'c' || event.key === 'C') {\n                    // Copy selected text to clipboard, if any\n                    if(this.cursorPos === this.selectPos)\n                        return this;\n\n                    const selectedText = this.text.slice(\n                        Math.min(this.cursorPos, this.selectPos),\n                        Math.max(this.cursorPos, this.selectPos),\n                    );\n\n                    if(navigator.clipboard)\n                        navigator.clipboard.writeText(selectedText);\n                    else\n                        return this;\n                }\n                else if(event.key === 'a' || event.key === 'A') {\n                    this.cursorPos = this.text.length;\n                    this.selectPos = 0;\n                    this.cursorOffsetDirty = true;\n                    this._dirty = true;\n                }\n                else\n                    return this;\n\n                // Reset blink time for better feedback\n                this.blinkStart = Date.now();\n                return this;\n            }\n\n            // Regular key presses:\n            if(event.key.length === 1)\n                this.insertText(event.key); // Insert character\n            else if(event.key === 'Backspace')\n                this.deleteText(-1); // Delete backwards\n            else if(event.key === 'Delete')\n                this.deleteText(1); // Delete forwards\n            else if(event.key === 'ArrowLeft')\n                this.moveCursor(-1, event.shift); // Move cursor left\n            else if(event.key === 'ArrowRight')\n                this.moveCursor(1, event.shift); // Move cursor right\n            else if(event.key === 'ArrowUp')\n                this.moveCursorLine(-1, event.shift); // Move cursor up\n            else if(event.key === 'ArrowDown')\n                this.moveCursorLine(1, event.shift); // Move cursor down\n            else if(event.key === 'PageUp')\n                this.moveCursorLine(-5, event.shift); // Move cursor up x5\n            else if(event.key === 'PageDown')\n                this.moveCursorLine(5, event.shift); // Move cursor down x5\n            else if(event.key === 'Home')\n                this.moveCursorStart(event.shift); // Move cursor to beginning\n            else if(event.key === 'End')\n                this.moveCursorEnd(event.shift); // Move cursor to end\n            else if(event.key === 'Escape') {\n                // Return now so that blink time isn't reset.\n                // Don't capture so that focus is dropped\n                return null;\n            }\n            else if(event.key === 'Enter')\n                this.insertText('\\n');\n            else if(event.key === 'Tab') {\n                if(this.typeableTab) {\n                    // HACK if shift if being held, do a tab-selection but don't\n                    // do reverse order. not capturing the event makes its do it\n                    // in normal order, so manually do tab-selection and capture\n                    // the event\n                    if(event.shift) {\n                        // console.warn('Dispatched tab select from TextInput');\n                        root.dispatchEvent(new TabSelect(this, false));\n                        return this;\n                    }\n                    else\n                        this.insertText('\\t');\n                }\n                else\n                    return null; // don't capture, let tab select another widget\n            }\n            else\n                return this; // Ignore key if it is unknown\n\n            // Reset blink time for better feedback\n            this.blinkStart = Date.now();\n        }\n        else if(event instanceof TextPasteEvent) {\n            if(event.target === this) {\n                // Insert pasted text\n                this.insertText(event.text);\n\n                // Reset blink time for better feedback\n                this.blinkStart = Date.now();\n            }\n        }\n        else if(event.target !== this) {\n            // unhandled event type. don't capture\n            return null;\n        }\n\n        return this;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Drop focus if editing is disabled\n        if(!this.editingEnabled)\n            this.root.dropFocus(FocusType.Keyboard, this);\n\n        // Mark as dirty when a blink needs to occur\n        if(this.blinkOn !== this.blinkWasOn)\n            this._dirty = true;\n\n        // Update TextHelper variables\n        this.textHelper.text = this.displayedText;\n        this.textHelper.font = this.inputTextFont;\n        this.textHelper.lineHeight = this.inputTextHeight;\n        this.textHelper.lineSpacing = this.inputTextSpacing;\n        this.textHelper.alignMode = this.inputTextAlign;\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostFinalizeBounds(): void {\n        // TODO revert textHelper.width/height and cursorOffset/selectOffset\n        // rounding when the positioning system is fixed to allow non-integer\n        // positions\n        // - done, but still need to clean things up. do another round\n\n        // Update cursor offset. Needs to be updated post-layout because it is\n        // dependent on maxWidth. Round to nearest integer to avoid\n        // anti-aliasing artifacts (cursor loses sharpness despite being fully\n        // vertical)\n        if(this.cursorOffsetDirty) {\n            this.cursorOffset = this.textHelper.findOffsetFromIndex(this.cursorPos);\n            // this.cursorOffset[0] = Math.round(this.cursorOffset[0]);\n            // this.cursorOffset[1] = Math.round(this.cursorOffset[1]);\n\n            if(this.selectPos === this.cursorPos) {\n                this.selectOffset[0] = this.cursorOffset[0];\n                this.selectOffset[1] = this.cursorOffset[1];\n            }\n            else {\n                this.selectOffset = this.textHelper.findOffsetFromIndex(this.selectPos);\n                // this.selectOffset[0] = Math.round(this.selectOffset[0]);\n                // this.selectOffset[1] = Math.round(this.selectOffset[1]);\n            }\n\n            this.cursorOffsetDirty = false;\n        }\n\n        // Check if panning is needed\n        const padding = this.inputTextInnerPadding;\n        // XXX width/height need to be rounded, otherwise the error between the\n        // ideal width and the rounded width is large enough for panning to be\n        // possible, creating subpixel-aligned carets (which have anti-aliasing\n        // artifacts)\n        // const innerWidth = Math.round(this.textHelper.width);\n        // const innerHeight = Math.round(this.textHelper.height);\n        const innerWidth = this.textHelper.width;\n        const innerHeight = this.textHelper.height;\n        const usableWidth = this.idealWidth - padding * 2;\n        const usableHeight = this.idealHeight - padding * 2;\n        const candidateOffset = this.offset;\n        const [cursorX, cursorY] = this.cursorOffset;\n\n        if(innerWidth > usableWidth) {\n            // Horizontal panning needed\n            const deadZone = Math.min(20, usableWidth / 2);\n            const left = candidateOffset[0] + deadZone;\n            const right = candidateOffset[0] + usableWidth - deadZone;\n\n            // Pan right\n            if(cursorX > right)\n                candidateOffset[0] += cursorX - right;\n\n            // Pan left\n            if(cursorX < left)\n                candidateOffset[0] -= left - cursorX;\n\n            // Clamp\n            if(candidateOffset[0] + usableWidth > innerWidth)\n                candidateOffset[0] = innerWidth - usableWidth;\n            if(candidateOffset[0] < 0)\n                candidateOffset[0] = 0;\n        }\n        else {\n            // Horizontal panning not needed\n            candidateOffset[0] = 0;\n        }\n\n        if(innerHeight > usableHeight) {\n            // Vertical panning needed\n            const fullLineHeight = this.textHelper.fullLineHeight;\n\n            if(fullLineHeight >= usableHeight) {\n                // Edge case - TextInput is not tall enough for a single line.\n                // Pan so that at least the bottom of the line is visible\n                candidateOffset[1] = cursorY + Math.max(this.textHelper.actualLineHeight - usableHeight, 0);\n            }\n            else {\n                const deadZone = usableHeight < 2 * fullLineHeight ? 0 : fullLineHeight / 2;\n                const top = candidateOffset[1] + deadZone;\n                const bottom = candidateOffset[1] + usableHeight - deadZone - fullLineHeight;\n\n                // Pan up or down\n                if(cursorY < top)\n                    candidateOffset[1] -= top - cursorY;\n                if(cursorY > bottom)\n                    candidateOffset[1] += cursorY - bottom;\n\n                // Clamp\n                if(candidateOffset[1] + usableHeight > innerHeight)\n                    candidateOffset[1] = innerHeight - usableHeight;\n                if(candidateOffset[1] < 0)\n                    candidateOffset[1] = 0;\n            }\n        }\n        else {\n            // Vertical panning not needed\n            candidateOffset[1] = 0;\n        }\n\n        this.offset = candidateOffset;\n\n        if(this.needsAutoScroll) {\n            this.needsAutoScroll = false;\n            this.root.dispatchEvent(new AutoScroll(this, this.caretBounds));\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Only expand to the needed dimensions, but take minimum width from\n        // theme into account\n        const padding = 2 * this.inputTextInnerPadding;\n        this.textHelper.maxWidth = this.wrapText ? Math.max(maxWidth - padding, 0) : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        const effectiveMinWidth = Math.min(Math.max(this.inputTextMinWidth, minWidth), maxWidth);\n        this.idealWidth = Math.min(Math.max(effectiveMinWidth, this.textHelper.width + padding), maxWidth);\n        this.idealHeight = Math.min(Math.max(minHeight, this.textHelper.height + padding), maxHeight);\n    }\n\n    /**\n     * The rectangle that the caret occupies, relative to the TextInput's\n     * top-left corner.\n     */\n    protected get caretRect(): Rect {\n        const padding = this.inputTextInnerPadding;\n        return [\n            padding + this.cursorOffset[0] - this.offset[0],\n            padding + this.cursorOffset[1] - this.offset[1],\n            this.cursorThickness,\n            this.textHelper.fullLineHeight,\n        ];\n    }\n\n    /** Similar to {@link TextInput#caretRect}, but uses absolute positions. */\n    protected get caretAbsoluteRect(): Rect {\n        const [x, y, w, h] = this.caretRect;\n        return [x + this.idealX, y + this.idealY, w, h];\n    }\n\n    /** Similar to {@link TextInput#caretRect}, but gets bounds instead. */\n    protected get caretBounds(): Bounds {\n        const [x, y, w, h] = this.caretRect;\n        return [x, x + w, y, y + h];\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Paint background\n        const ctx = this.viewport.context;\n        ctx.fillStyle = this.inputBackgroundFill;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n\n        // Start clipping\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(this.x, this.y, this.width, this.height);\n        ctx.clip();\n\n        // Paint background for selection if there is a selection\n        const padding = this.inputTextInnerPadding;\n        if(this.cursorPos !== this.selectPos) {\n            ctx.fillStyle = this.inputSelectBackgroundFill;\n            if(this.cursorOffset[1] === this.selectOffset[1]) {\n                // Same line\n                const left = Math.min(this.cursorOffset[0], this.selectOffset[0]);\n                const right = Math.max(this.cursorOffset[0], this.selectOffset[0]);\n                ctx.fillRect(\n                    this.idealX + padding + left - this.offset[0],\n                    this.idealY + padding + this.cursorOffset[1] - this.offset[1],\n                    right - left,\n                    this.textHelper.fullLineHeight,\n                );\n            }\n            else {\n                // Spans multiple lines\n                let topOffset: [number, number], bottomOffset: [number, number];\n                if(this.cursorOffset[1] < this.selectOffset[1]) {\n                    topOffset = this.cursorOffset;\n                    bottomOffset = this.selectOffset;\n                }\n                else {\n                    bottomOffset = this.cursorOffset;\n                    topOffset = this.selectOffset;\n                }\n\n                // Top line:\n                const fullLineHeight = this.textHelper.fullLineHeight;\n                const topWidth = this.idealWidth + this.offset[0] - topOffset[0] - padding;\n                if(topWidth > 0) {\n                    ctx.fillRect(\n                        this.idealX + padding + topOffset[0] - this.offset[0],\n                        this.idealY + padding + topOffset[1] - this.offset[1],\n                        topWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Bottom line:\n                const bottomWidth = bottomOffset[0] + padding - this.offset[0];\n                if(bottomWidth > 0) {\n                    ctx.fillRect(\n                        this.idealX,\n                        this.idealY + padding + bottomOffset[1] - this.offset[1],\n                        bottomWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Middle lines:\n                const middleYOffset = topOffset[1] + fullLineHeight;\n                const middleHeight = bottomOffset[1] - middleYOffset;\n                if(middleHeight > 0) {\n                    ctx.fillRect(\n                        this.idealX,\n                        this.idealY + padding + middleYOffset - this.offset[1],\n                        this.idealWidth,\n                        middleHeight,\n                    );\n                }\n            }\n        }\n\n        // Paint current text value\n        let fillStyle;\n        if(this._editingEnabled) {\n            if(this._valid)\n                fillStyle = this.inputTextFill;\n            else\n                fillStyle = this.inputTextFillInvalid;\n        }\n        else\n            fillStyle = this.inputTextFillDisabled;\n\n        this.textHelper.paint(\n            ctx, fillStyle,\n            this.idealX + padding - this.offset[0],\n            this.idealY + padding - this.offset[1],\n        );\n\n        // Paint blink\n        const blinkOn = this.blinkOn;\n        this.blinkWasOn = blinkOn;\n        if(blinkOn) {\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(...this.caretAbsoluteRect);\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n}\n", "import { MakeDefaultTextValidatorWithCallback } from '../state/DefaultTextValidator';\nimport type { VariableCallback } from '../state/VariableCallback';\nimport type { ThemeProperties } from \"../theme/ThemeProperties\";\nimport { TextInput } from \"./TextInput\";\n\n/**\n * A {@link TextInput} with an optional callback and no validation.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class BasicTextInput extends TextInput<string> {\n    /**\n     * Create a new BasicTextInput.\n     *\n     * Equivalent to creating a new {@link TextInput} instance with a validator\n     * created by {@link MakeDefaultTextValidatorWithCallback} and no input\n     * filter.\n     *\n     * @param callback - An optional callback called when the text changes. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<string> | null = null, initialValue = '', themeProperties?: ThemeProperties) {\n        const validator = MakeDefaultTextValidatorWithCallback(callback);\n        super(validator, null, initialValue, themeProperties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport type { Padding } from '../theme/Padding';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Container} with center alignment on both axes and no padding.\n *\n * Can be constrained to a specific type of children.\n *\n * Padding and alignment settings are applied via theme properties; if you pass\n * these two properties, they will be ignored in a clone of the theme\n * properties. If you want to override these two theme properties, then use\n * {@link Container} instead.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Center<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Center. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Center,\n        };\n        themePropertiesClone.containerPadding = <Padding>{\n            left: 0, right: 0, top: 0, bottom: 0,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import type { VariableCallback } from '../state/VariableCallback';\nimport { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { WatchableVariable } from '../state/WatchableVariable';\nimport { ClickState } from '../helpers/ClickState';\nimport type { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport { Widget } from './Widget';\n\n/**\n * A checkbox widget; can be ticked or unticked.\n *\n * @category Widget\n */\nexport class Checkbox extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /** The helper for keeping track of the checkbox value */\n    protected variable: WatchableVariable<boolean>;\n\n    /**\n     * Create a new Checkbox.\n     *\n     * @param callback - An optional callback called when the checkbox is ticked or unticked. If null, then no callback is called.\n     */\n    constructor(callback: VariableCallback<boolean> | null = null, initialValue = false, themeProperties?: ThemeProperties) {\n        // Checkboxes need a clear background, have no children and don't\n        // propagate events\n        super(true, false, themeProperties);\n\n        this.tabFocusable = true;\n        // Save callback and initial value\n        this.variable = new WatchableVariable<boolean>(initialValue);\n        if(callback)\n            this.variable.watch(callback);\n\n        // Setup click helper\n        this.clickHelper = new ButtonClickHelper(this);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'checkboxLength') {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundGlowFill' ||\n                property === 'backgroundFill' ||\n                property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'checkboxInnerPadding')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /** Is the checkbox checked? */\n    set checked(checked: boolean) {\n        this.variable.value = checked;\n    }\n\n    get checked(): boolean {\n        return this.variable.value;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(this.clickHelper.onFocusGrabbed(focusType))\n            this._dirty = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(this.clickHelper.onFocusDropped(focusType))\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        const x = this.idealX + this.offsetX;\n        const y = this.idealY + this.offsetY;\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event,\n            this.root,\n            true,\n            [x, x + this.actualLength, y, y + this.actualLength]\n        );\n\n        // Swap value if checkbox was clicked\n        if(wasClick)\n            this.checked = !this.checked;\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect). Toggle value if clicked\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return capture ? this : null;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Mark as dirty if variable is dirty\n        if(this.variable.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve width and height\n        const minLength = Math.min(this.checkboxLength, maxWidth, maxHeight);\n        this.idealWidth = minLength;\n        this.idealHeight = minLength;\n\n        if(this.idealWidth < minWidth)\n            this.idealWidth = minWidth;\n        if(this.idealHeight < minHeight)\n            this.idealHeight = minHeight;\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // Center checkbox\n        this.actualLength = Math.min(this.checkboxLength, this.width, this.height);\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of checkbox\n        const ctx = this.viewport.context;\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n\n        const checkboxX = this.offsetX + this.x;\n        const checkboxY = this.offsetY + this.y;\n        ctx.fillRect(\n            checkboxX, checkboxY, this.actualLength, this.actualLength,\n        );\n\n        // Draw checked part of checkbox\n        if(this.checked) {\n            if(useGlow)\n                ctx.fillStyle = this.accentFill;\n            else\n                ctx.fillStyle = this.primaryFill;\n\n            const innerPadding = this.checkboxInnerPadding;\n            const innerLength = this.actualLength - innerPadding * 2;\n\n            // Fall back to filling entire checkbox if there isn't enough space\n            // for padding\n            if(innerLength <= 0) {\n                ctx.fillRect(\n                    checkboxX,\n                    checkboxY,\n                    this.actualLength,\n                    this.actualLength,\n                );\n            }\n            else {\n                ctx.fillRect(\n                    checkboxX + innerPadding,\n                    checkboxY + innerPadding,\n                    innerLength,\n                    innerLength,\n                );\n            }\n        }\n    }\n}\n", "import { paintField, layoutField, paintLayoutArrayField } from '../decorators/FlagFields';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { Widget } from './Widget';\n\nconst videoRegex = /^.*\\.(webm|og[gv]|m(p4|4v|ov)|avi|qt)$/i;\n\n/**\n * A widget which displays a given image.\n *\n * @category Widget\n */\nexport class Icon extends Widget {\n    /** The current image/video used by the icon. */\n    private _image: HTMLImageElement | HTMLVideoElement;\n    /**\n     * The last source that the current image was using. Used for tracking if\n     * the image source changed and if the image is fully loaded. Only used if\n     * image is not a video.\n     */\n    private lastSrc: string | null = null;\n    /**\n     * The current image rotation in radians.\n     *\n     * @decorator `@paintField`\n     */\n    @paintField\n    rotation = 0;\n    /**\n     * The view box of this Icon, useful if the image used for the icon is a\n     * spritesheet. If null, the entire image will be used.\n     *\n     * @decorator `@paintLayoutArrayField(true)`\n     */\n    @paintLayoutArrayField(true)\n    viewBox: [number, number, number, number] | null;\n    /**\n     * The wanted width. If null, the image's width will be used, taking\n     * {@link Icon#viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageWidth: number | null = null;\n    /**\n     * The wanted height. If null, the image's height will be used, taking\n     * {@link Icon#viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageHeight: number | null = null;\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual image width */\n    private actualWidth = 0;\n    /** Actual image height */\n    private actualHeight = 0;\n    /**\n     * Listener for video loadedmetadata and canplay events. Saved so it can be\n     * removed when needed\n     */\n    private loadedmetadataListener: ((event: Event) => void) | null = null;\n    /**\n     * Listener for video canplay event. Saved so it can be removed when needed\n     */\n    private canplayListener: ((event: Event) => void) | null = null;\n    /**\n     * Used for requestVideoFrameCallback. If null, then callback is being done\n     * by setting _dirty to true every frame, which may be wasteful\n     */\n    private frameCallback: ((now: DOMHighResTimeStamp, metadata: unknown /* VideoFrameMetadata */) => void) | null = null;\n\n    /** Create a new Icon. */\n    constructor(image: HTMLImageElement | HTMLVideoElement | string, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, themeProperties?: ThemeProperties) {\n        // Icons need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        if(typeof image === 'string') {\n            if(videoRegex.test(image)) {\n                const videoElem = document.createElement('video');\n                videoElem.src = image;\n                // So that video poster shows. If you're passing your own video\n                // element then this won't be automatically set\n                videoElem.preload = 'auto';\n                image = videoElem;\n            }\n            else {\n                const imgElem = document.createElement('img');\n                imgElem.src = image;\n                image = imgElem;\n            }\n        }\n\n        this._image = image;\n        this.imageWidth = width;\n        this.imageHeight = height;\n        this.viewBox = viewBox;\n        this.setupVideoEvents();\n    }\n\n    /**\n     * Setup event listeners for video. Has no effect if {@link Icon#image} is\n     * not a video\n     */\n    private setupVideoEvents() {\n        if(this.image instanceof HTMLVideoElement) {\n            // Add event listeners\n            // loadedmetadata is so that we resize the widget when we know the\n            // video dimensions\n            this.loadedmetadataListener = _event => this._layoutDirty = true;\n            this.image.addEventListener('loadedmetadata', this.loadedmetadataListener);\n            // canplay is so that the first video frame is always displayed\n            this.canplayListener = _event => this._dirty = true;\n            this.image.addEventListener('canplay', this.canplayListener);\n\n            if('requestVideoFrameCallback' in this.image) {\n                console.warn('requestVideoFrameCallback available; if video playback is choppy or broken, please report it on Github');\n\n                const originalVideo = this.image;\n                this.frameCallback = (_now, _metadata) => {\n                    // Set dirty flag when a new frame is got so that it is\n                    // painted\n                    this._dirty = true;\n                    console.log('set dirty')\n\n                    if(this.image === originalVideo && this.frameCallback !== null) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (this.image as any).requestVideoFrameCallback(this.frameCallback);\n                    }\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (this.image as any).requestVideoFrameCallback(this.frameCallback)\n            } else {\n                console.warn('requestVideoFrameCallback not available; video will be played back on every frame when not paused');\n            }\n        }\n    }\n\n    /**\n     * The image or video used by this Icon.\n     *\n     * Sets {@link Icon#_image} if changed and sets {@link Icon#lastSrc} to null\n     * to mark the image as loading so that flickers are minimised.\n     *\n     * If getting, returns {@link Icon#_image}.\n     */\n    set image(image: HTMLImageElement | HTMLVideoElement) {\n        if(image !== this._image) {\n            if(this._image instanceof HTMLVideoElement) {\n                // Remove old event listeners in video. null checks aren't\n                // needed, but adding them anyways so that typescript doesn't\n                // complain\n                if(this.loadedmetadataListener !== null)\n                    this._image.removeEventListener('loadedmetadata', this.loadedmetadataListener);\n                if(this.canplayListener !== null)\n                    this._image.removeEventListener('canplay', this.canplayListener);\n            }\n\n            this._image = image;\n            this.lastSrc = null;\n            this.loadedmetadataListener = null;\n            this.canplayListener = null;\n            this.frameCallback = null;\n            this.setupVideoEvents();\n        }\n    }\n\n    get image(): HTMLImageElement | HTMLVideoElement {\n        return this._image;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Icons only needs to be re-drawn if image changed, which is tracked by\n        // the image setter, or if the source changed, but not if the icon isn't\n        // loaded yet. If this is a playing video, icon only needs to be\n        // re-drawn if video is playing\n        if(this._image instanceof HTMLVideoElement) {\n            if(!this._image.paused && this.frameCallback === null)\n                this._dirty = true;\n        }\n        else if(this._image?.src !== this.lastSrc && this._image?.complete) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find dimensions\n        let wantedWidth = this.imageWidth;\n        if(wantedWidth === null) {\n            if(this.viewBox === null) {\n                if(this._image instanceof HTMLVideoElement)\n                    wantedWidth = this._image.videoWidth;\n                else\n                    wantedWidth = this._image.naturalWidth;\n            }\n            else\n                wantedWidth = this.viewBox[2];\n        }\n\n        this.idealWidth = Math.max(Math.min(wantedWidth, maxWidth), minWidth);\n\n        let wantedHeight = this.imageHeight;\n        if(wantedHeight === null) {\n            if(this.viewBox === null) {\n                if(this._image instanceof HTMLVideoElement)\n                    wantedHeight = this._image.videoHeight;\n                else\n                    wantedHeight = this._image.naturalHeight;\n            }\n            else\n                wantedHeight = this.viewBox[3];\n        }\n\n        this.idealHeight = Math.max(Math.min(wantedHeight, maxHeight), minHeight);\n\n        // Find offset and actual image dimensions (preserving aspect ratio)\n        const widthRatio = this.idealWidth / wantedWidth;\n        const heightRatio = this.idealHeight / wantedHeight;\n        const scale = Math.min(widthRatio, heightRatio);\n        this.actualWidth = wantedWidth * scale;\n        this.actualHeight = wantedHeight * scale;\n        this.offsetX = (this.idealWidth - this.actualWidth) / 2;\n        this.offsetY = (this.idealHeight - this.actualHeight) / 2;\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Abort if icon isn't ready yet\n        if(this._image instanceof HTMLImageElement && !this._image?.complete) {\n            this.lastSrc = null;\n            return;\n        }\n\n        // Mark as not needing to be drawn by setting the source\n        this.lastSrc = this._image.src;\n\n        // Translate, rotate and clip if rotation is not 0\n        let tdx = this.x + this.offsetX, tdy = this.y + this.offsetY;\n        const rotated = this.rotation !== 0;\n        const ctx = this.viewport.context;\n        if(rotated) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n            ctx.translate(\n                this.x + this.offsetX + this.actualWidth / 2,\n                this.y + this.offsetY + this.actualHeight / 2,\n            );\n            tdx = -this.actualWidth / 2;\n            tdy = -this.actualHeight / 2;\n            ctx.rotate(this.rotation);\n        }\n\n        // Draw image, with viewBox if it is not null\n        if(this.viewBox === null) {\n            ctx.drawImage(\n                this._image,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n        else {\n            ctx.drawImage(\n                this._image, ...this.viewBox,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n\n        // Revert transformation\n        if(rotated)\n            ctx.restore();\n    }\n\n    override dryPaint(): void {\n        if(this._image instanceof HTMLImageElement && this._image?.complete)\n            this.lastSrc = this._image.src;\n        else\n            this.lastSrc = null;\n\n        super.dryPaint();\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { Button } from './Button';\nimport { Icon } from './Icon';\n\n/**\n * A {@link Button} with an {@link Icon}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class IconButton extends Button<Icon> {\n    /** Create a new IconButton. */\n    constructor(image: HTMLImageElement, width: number | null = null, height: number | null = null, viewBox: [number, number, number, number] | null = null, callback: (() => void) | null = null, themeProperties?: ThemeProperties) {\n        super(\n            new Icon(image, width, height, viewBox, themeProperties),\n            callback, themeProperties\n        );\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { Widget } from './Widget';\n\n/**\n * A widget with empty space.\n *\n * Will always try to expand if the layout is constrained, so make sure to set\n * flex or pass it along the constructor\n *\n * @category Widget\n */\nexport class Spacing extends Widget {\n    /** The minimum width this will try to expand */\n    minWidth: number;\n    /** The minimum height this will try to expand */\n    minHeight: number;\n\n    /** Create a new Spacing. */\n    constructor(flex = 1, minWidth = 0, minHeight = 0, themeProperties?: ThemeProperties) {\n        // Spacing needs clear, never has children and doesn't propagate events\n        super(true, false, themeProperties);\n\n        this.flex = flex;\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Try to expand each axis. If axis is not constrained (can't expand),\n        // then try to use the biggest minimum length\n        if(maxWidth !== Infinity)\n            this.idealWidth = maxWidth;\n        else\n            this.idealWidth = Math.max(minWidth, this.minWidth);\n\n        if(maxHeight !== Infinity)\n            this.idealHeight = maxHeight;\n        else\n            this.idealHeight = Math.max(minHeight, this.minHeight);\n    }\n}\n", "import type { VariableCallback } from '../state/VariableCallback';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { TextGetter } from './Label';\nimport { Checkbox } from './Checkbox';\nimport { Spacing } from './Spacing';\nimport { Label } from './Label';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a {@link Checkbox}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class LabelledCheckbox extends Row {\n    constructor(text: string | TextGetter, callback: VariableCallback<boolean> | null = null, initialValue = false, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        this.add([\n            new Label(text, themeProperties),\n            new Spacing(1, 0, 0, themeProperties),\n            new Checkbox(callback, initialValue, themeProperties),\n        ]);\n    }\n}\n", "import type { WatchableVariable } from '../state/WatchableVariable';\nimport { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { VariableCallback } from '../state/VariableCallback';\nimport { ClickState } from '../helpers/ClickState';\nimport type { FocusType } from '../core/FocusType';\nimport type { Viewport } from '../core/Viewport';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A radio button widget; used for selecting one of many options. Uses a shared\n * {@link Variable} instance and expects the creation of multiple RadioButton\n * instances.\n *\n * @typeParam V - The type stored in the {@link RadioButton#\"variable\"}; when a radio button is clicked, the value inside the variable has this type.\n *\n * @category Widget\n */\nexport class RadioButton<V> extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /** The shared {@link WatchableVariable} where the value is set */\n    protected variable: WatchableVariable<V>;\n    /**\n     * The value that will be used when the {@link RadioButton#\"variable\"} is\n     * set\n     */\n    protected value: V;\n    /**\n     * The callback used for the {@link RadioButton#\"variable\"}. This extra copy\n     * is kept so that there is a strong reference linked to the radio button's\n     * lifespan\n     */\n    private readonly callback: VariableCallback<V>;\n    /** Was the radio button selected in the last paint? */\n    private _wasSelected = false;\n\n    /**\n     * Create a new radio button.\n     *\n     * @param variable - The shared variable that radio buttons will save the value to when selected.\n     * @param value - The value that will be used to set the {@link RadioButton#\"variable\"} when the radio button is clicked\n     */\n    constructor(variable: WatchableVariable<V>, value: V, themeProperties?: ThemeProperties) {\n        // Radio buttons need a clear background, have no children and don't\n        // propagate events\n        super(true, false, themeProperties);\n\n        this.tabFocusable = true;\n        this.variable = variable;\n        this.value = value;\n        this.clickHelper = new ButtonClickHelper(this);\n        this.callback = this.handleChange.bind(this);\n        this._wasSelected = this.selected;\n    }\n\n    protected handleChange(_newValue: V): void {\n        if(this.selected !== this._wasSelected)\n            this._dirty = true;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'radioButtonLength') {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundGlowFill' ||\n                property === 'backgroundFill' ||\n                property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'radioButtonInnerPadding')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Select this radio button. Sets the value in\n     * {@link RadioButton#\"variable\"} to be {@link RadioButton#value}\n     */\n    select() {\n        this.variable.value = this.value;\n    }\n\n    /**\n     * Is the radio button selected? Equivalent to checking if the value in the\n     * {@link RadioButton#\"variable\"} is strictly equal to the\n     * {@link RadioButton#value}\n     */\n    get selected(): boolean {\n        return this.variable.value === this.value;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(this.clickHelper.onFocusGrabbed(focusType))\n            this._dirty = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(this.clickHelper.onFocusDropped(focusType))\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        const x = this.idealX + this.offsetX;\n        const y = this.idealY + this.offsetY;\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event,\n            this.root,\n            true,\n            [x, x + this.actualLength, y, y + this.actualLength]\n        );\n\n        // Select radio button if button was clicked\n        if(wasClick)\n            this.select();\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect). Toggle value if clicked\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return capture ? this : null;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve width and height\n        const minLength = Math.min(this.radioButtonLength, maxWidth, maxHeight);\n        this.idealWidth = minLength;\n        this.idealHeight = minLength;\n\n        if(this.idealWidth < minWidth)\n            this.idealWidth = minWidth;\n        if(this.idealHeight < minHeight)\n            this.idealHeight = minHeight;\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // Center checkbox\n        this.actualLength = Math.min(this.radioButtonLength, this.width, this.height);\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        this._wasSelected = this.selected;\n\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of radio button\n        const ctx = this.viewport.context;\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n\n        const halfLength = this.actualLength / 2;\n        const radioX = this.offsetX + this.x + halfLength;\n        const radioY = this.offsetY + this.y + halfLength;\n        this.paintCircle(radioX, radioY, halfLength);\n\n        // Draw checked part of checkbox\n        if(this.selected) {\n            if(useGlow)\n                ctx.fillStyle = this.accentFill;\n            else\n                ctx.fillStyle = this.primaryFill;\n\n            const innerLength = this.actualLength - this.radioButtonInnerPadding * 2;\n\n            // Fall back to filling entire radio button if there isn't enough\n            // space for padding\n            if(innerLength <= 0)\n                this.paintCircle(radioX, radioY, halfLength);\n            else {\n                const halfInnerLength = innerLength / 2;\n                this.paintCircle(radioX, radioY, halfInnerLength);\n            }\n        }\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n        this.variable.watch(this.callback);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n        this.variable.unwatch(this.callback);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { WatchableVariable } from '../state/WatchableVariable';\nimport { RadioButton } from './RadioButton';\nimport type { TextGetter } from './Label';\nimport { Spacing } from './Spacing';\nimport { Label } from './Label';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a\n * {@link RadioButton}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class LabelledRadioButton<V> extends Row {\n    constructor(text: string | TextGetter, variable: WatchableVariable<V>, value: V, themeProperties?: ThemeProperties) {\n        super(themeProperties);\n\n        this.add([\n            new Label(text, themeProperties),\n            new Spacing(1, 0, 0, themeProperties),\n            new RadioButton(variable, value, themeProperties),\n        ]);\n    }\n}\n", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { layoutField } from '../decorators/FlagFields';\nimport { AxisCoupling } from '../widgets/AxisCoupling';\nimport { PointerEvent } from '../events/PointerEvent';\nimport type { Bounds } from '../helpers/Bounds';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport { Viewport } from '../core/Viewport';\nimport type { Root } from '../core/Root';\nimport { Widget } from './Widget';\n\n/**\n * A type of container widget which is allowed to be bigger or smaller than its\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * Allows setting the offset of the child, automatically clips it if neccessary.\n * Otherwise acts like a {@link Container}. Implemented by force re-painting the\n * child and clipping it or, optionally, by using a {@link Viewport} to paint\n * the child widget to a dedicated canvas.\n *\n * @category Widget\n */\nexport class ViewportWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** See {@link ViewportWidget#widthCoupling}. For internal use only */\n    private _widthCoupling: AxisCoupling;\n    /** See {@link ViewportWidget#heightCoupling}. For internal use only */\n    private _heightCoupling: AxisCoupling;\n    /**\n     * The minimum width that this widget will try to expand to.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minWidth: number;\n    /**\n     * The minimum height that this widget will try to expand to.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minHeight: number;\n    /** The actual viewport object, or null if the child is just clipped. */\n    private internalViewport: Viewport | null;\n    /** See {@link ViewportWidget#offset}. For internal use only */\n    private _offset: [number, number] = [0, 0];\n    /**\n     * Child constraints for resolving layout. May be different than\n     * {@link ViewportWidget#internalViewport}'s constraints. By default, this\n     * is 0 minimum and Infinity maximum per axis.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     */\n    private _constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n    /** Force child re-layout? Only used when not using a Viewport */\n    protected forceReLayout = true;\n    /** Force child re-paint? Only used when not using a Viewport */\n    protected forceRePaint = true;\n\n    /** Create a new ViewportWidget. */\n    constructor(child: W, minWidth = 0, minHeight = 0, widthCoupling = AxisCoupling.None, heightCoupling = AxisCoupling.None, useViewport = false, themeProperties?: ThemeProperties) {\n        // Viewport clears its own background, has a single child and propagates\n        // events\n        super(child, false, true, themeProperties);\n\n        this.internalViewport = useViewport ? new Viewport(child) : null;\n        this.minWidth = minWidth;\n        this.minHeight = minHeight;\n        this._widthCoupling = widthCoupling;\n        this._heightCoupling = heightCoupling;\n        this._constraints = [0, Infinity, 0, Infinity];\n    }\n\n    /**\n     * Does this viewport widget use a Viewport, or does it just clip the child\n     * instead (default)?\n     *\n     * @returns Returns true if a {@link Viewport} is used; if {@link ViewportWidget#internalViewport} is not null\n     */\n    get usesViewport(): boolean {\n        return this.internalViewport !== null;\n    }\n\n    /**\n     * Offset of {@link SingleParent#child}. Positional events will take this\n     * into account, as well as rendering. Useful for implementing scrolling.\n     */\n    get offset(): [number, number] {\n        return [...this._offset];\n    }\n\n    set offset(offset: [number, number]) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._offset[0] !== offset[0] || this._offset[1] !== offset[1]) {\n            this._offset[0] = offset[0];\n            this._offset[1] = offset[1];\n            this._dirty = true;\n            this.correctChildPosition();\n        }\n    }\n\n    /**\n     * Accessor for {@link ViewportWidget#_constraints}. If using a\n     * {@link ViewportWidget#internalViewport | Viewport}, its constraints are\n     * also updated, but may be different due to\n     * {@link ViewportWidget#widthCoupling} or\n     * {@link ViewportWidget#heightCoupling}.\n     */\n    set constraints(constraints: LayoutConstraints) {\n        // Not using @flagArrayField because this also needs to set the\n        // viewport's constraints if set, although @watchArrayField could be\n        // used (TODO?)\n        if (constraints[0] !== this._constraints[0] ||\n            constraints[1] !== this._constraints[1] ||\n            constraints[2] !== this._constraints[2] ||\n            constraints[3] !== this._constraints[3])\n        {\n            // Update own constraints\n            this._constraints[0] = constraints[0];\n            this._constraints[1] = constraints[1];\n            this._constraints[2] = constraints[2];\n            this._constraints[3] = constraints[3];\n\n            // Update viewport's constaints or flag force layout\n            if(this.internalViewport === null)\n                this.forceReLayout = true;\n            else\n                this.internalViewport.constraints = constraints;\n        }\n    }\n\n    get constraints(): LayoutConstraints {\n        return [...this._constraints];\n    }\n\n    /**\n     * Is the width coupled to the child's? If not {@link AxisCoupling.None},\n     * width constraints will be ignored or augmented.\n     */\n    get widthCoupling(): AxisCoupling {\n        return this._widthCoupling;\n    }\n\n    set widthCoupling(widthCoupling: AxisCoupling) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._widthCoupling !== widthCoupling) {\n            this._widthCoupling = widthCoupling;\n            this._layoutDirty = true;\n            this.forceReLayout = true;\n        }\n    }\n\n    /**\n     * Is the height coupled to the child's? If not {@link AxisCoupling.None},\n     * height constraints will be ignored or augmented.\n     */\n    get heightCoupling(): AxisCoupling {\n        return this._heightCoupling;\n    }\n\n    set heightCoupling(heightCoupling: AxisCoupling) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._heightCoupling !== heightCoupling) {\n            this._heightCoupling = heightCoupling;\n            this._layoutDirty = true;\n            this.forceReLayout = true;\n        }\n    }\n\n    /**\n     * {@link ViewportWidget#minWidth}, but scaled according to\n     * {@link Root#resolution}\n     */\n    get scaledMinWidth(): number {\n        return this.minWidth * (this.root?.resolution ?? 1);\n    }\n\n    /**\n     * {@link ViewportWidget#minHeight}, but scaled according to\n     * {@link Root#resolution}\n     */\n    get scaledMinHeight(): number {\n        return this.minHeight * (this.root?.resolution ?? 1);\n    }\n\n    /**\n     * {@link ViewportWidget#constraints}, but scaled according to\n     * {@link Root#resolution}\n     */\n    get scaledConstraints(): [number, number, number, number] {\n        const res = this.root?.resolution ?? 1;\n        return [\n            this._constraints[0] * res,\n            this._constraints[1] * res,\n            this._constraints[2] * res,\n            this._constraints[3] * res,\n        ];\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'canvasFill')\n            this._dirty = true;\n    }\n\n    protected getBoundsOf(widget: Widget): Bounds {\n        const [width, height] = widget.idealDimensions;\n        const [x, y] = widget.idealPosition;\n        const [childX, childY] = this.child.idealPosition;\n        const left = this.idealX + this.offset[0] + x - childX;\n        const top = this.idealY + this.offset[1] + y - childY;\n        return [ left, left + width, top, top + height ];\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Drop event if it is a positional event with no target outside the\n        // child's viewport. Only correct position if using a Viewport\n        if(event instanceof PointerEvent) {\n            const [cl, cr, ct, cb] = this.getBoundsOf(this.child);\n\n            if(event.target === null) {\n                if(event.x < cl)\n                    return null;\n                if(event.x >= cr)\n                    return null;\n                if(event.y < ct)\n                    return null;\n                if(event.y >= cb)\n                    return null;\n            }\n\n            if(this.internalViewport !== null)\n                event = event.correctOffset(cl, ct);\n        }\n\n        // Dispatch event to child\n        return this.child.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        const child = this.child;\n\n        // Pre-layout update child\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty and at least one of the axes are coupled,\n        // propagate layout dirtiness. Try to resolve layout if no axis is\n        // coupled.\n        const coupled = this._widthCoupling !== AxisCoupling.None || this._heightCoupling !== AxisCoupling.None;\n        if(!coupled) {\n            if(this.internalViewport !== null) {\n                this.internalViewport.constraints = this.scaledConstraints;\n                this.internalViewport.resolveChildsLayout();\n            }\n            else if(child.layoutDirty || this.forceReLayout) {\n                child.resolveDimensionsAsTop(...this.scaledConstraints);\n                this.correctChildPosition();\n            }\n        }\n        else if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostFinalizeBounds(): void {\n        // postFinalizeBounds only needs to be called if a viewport is not being\n        // used. if it is being used, then it's called automatically by the\n        // {@link Viewport#resolveChildsLayout} method\n        if(this.internalViewport === null) {\n            const child = this.child;\n            child.postFinalizeBounds();\n\n            // If child's layout is dirty, set self's layout as dirty so that\n            // same-frame re-layouts are triggered\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        const child = this.child;\n        this.forceReLayout = false;\n\n        // Post-layout update child\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        const coupledWidth = this._widthCoupling !== AxisCoupling.None;\n        const coupledHeight = this._heightCoupling !== AxisCoupling.None;\n        let effectiveMinWidth = Math.min(Math.max(minWidth, this.scaledMinWidth), maxWidth);\n        let effectiveMinHeight = Math.min(Math.max(minHeight, this.scaledMinHeight), maxHeight);\n\n        // Expand to the needed dimensions\n        if(this._widthCoupling !== AxisCoupling.Bi) {\n            this.idealWidth = Math.min(effectiveMinWidth, maxWidth);\n\n            if(this._widthCoupling === AxisCoupling.Uni)\n                effectiveMinWidth = this.idealWidth;\n        }\n\n        if(this.idealWidth === 0 && this.minWidth === 0 && this._widthCoupling !== AxisCoupling.Bi)\n            console.warn('ViewportWidget has no minimum width and width isn\\'t bi-directionally coupled, therefore, it may be dimensionless. Set a minimum width and/or bi-directionally couple the width');\n\n        if(this._heightCoupling !== AxisCoupling.Bi) {\n            this.idealHeight = Math.min(effectiveMinHeight, maxHeight);\n\n            if(this._heightCoupling === AxisCoupling.Uni)\n                effectiveMinHeight = this.idealHeight;\n        }\n\n        if(this.idealHeight === 0 && this.minHeight === 0 && this._heightCoupling !== AxisCoupling.Bi)\n            console.warn('ViewportWidget has no minimum height and height isn\\'t bi-directionally coupled, therefore, it may be dimensionless. Set a minimum height and/or bi-directionally couple the height');\n\n        if(coupledWidth || coupledHeight) {\n            // Resolve child's layout\n            const constraints: LayoutConstraints = this.scaledConstraints;\n\n            if(coupledWidth) {\n                constraints[0] = effectiveMinWidth;\n\n                if(this._widthCoupling === AxisCoupling.Bi)\n                    constraints[1] = maxWidth;\n            }\n\n            if(coupledHeight) {\n                constraints[2] = effectiveMinHeight;\n\n                if(this._heightCoupling === AxisCoupling.Bi)\n                    constraints[3] = maxHeight;\n            }\n\n            const child = this.child;\n            if(this.internalViewport === null) {\n                child.resolveDimensionsAsTop(...constraints);\n                this.correctChildPosition();\n            }\n            else {\n                this.internalViewport.constraints = constraints;\n                this.internalViewport.resolveChildsLayout();\n            }\n\n            // Bi-couple wanted axes. Do regular layout for non-coupled axes.\n            if(this._widthCoupling === AxisCoupling.Bi)\n                this.idealWidth = child.idealDimensions[0];\n\n            if(this._heightCoupling === AxisCoupling.Bi)\n                this.idealHeight = child.idealDimensions[1];\n        }\n    }\n\n    protected override afterPositionResolved(): void {\n        this.correctChildPosition();\n\n        // If the viewport widget changes position, but the child doesn't, then\n        // previously clipped parts may become visible, so force repaint if not\n        // using a viewport\n        if(this.internalViewport === null)\n            this.forceRePaint = true;\n    }\n\n    override finalizeBounds(): void {\n        // HACK instead of letting the Parent class finalize the bounds of child\n        // widgets, finalize the viewport's own bounds and then only finalize\n        // the children's bounds if not using a viewport. this is done for\n        // optimisation purposes, otherwise, finalization is done twice when\n        // using a viewport\n        Widget.prototype.finalizeBounds.call(this);\n\n        if(this.internalViewport === null) {\n            for(const child of this.children)\n                child.finalizeBounds();\n        }\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        // HACK Parent#activate activates child widgets with this._viewport, but\n        // we want to use this.internalViewport\n        Widget.prototype.activate.call(this, root, viewport, parent);\n\n        const childViewport = this.internalViewport === null ? viewport : this.internalViewport;\n        for(const child of this.children)\n            child.activate(root, childViewport, parent);\n    }\n\n    private correctChildPosition(): void {\n        if(this.internalViewport !== null)\n            return;\n\n        // Correct child's position only if not using a Viewport\n        const [xOffset, yOffset] = this.offset;\n        this.child.resolvePosition(this.idealX + xOffset, this.idealY + yOffset);\n        this.child.finalizeBounds();\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Paint child to viewport's canvas\n        if(this.internalViewport !== null)\n            this.internalViewport.paintToCanvas(forced);\n\n        // Calculate child's source and destination\n        const [vpX, vpY, vpW, vpH] = this.rect;\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const [xOffset, yOffset] = this.offset;\n\n        // viewport right and bottom\n        const vpR = vpX + vpW;\n        const vpB = vpY + vpH;\n\n        // original child destination left and top\n        const origXDst = this.x + xOffset;\n        const origYDst = this.y + yOffset;\n\n        // clipped child destination left, top, width and height\n        const xDst = Math.min(Math.max(origXDst, vpX), vpR);\n        const yDst = Math.min(Math.max(origYDst, vpY), vpB);\n        const wClipped = Math.min(Math.max(origXDst + innerWidth, vpX), vpR) - xDst;\n        const hClipped = Math.min(Math.max(origYDst + innerHeight, vpY), vpB) - yDst;\n\n        // Abort if outside of bounds\n        if(wClipped === 0 || hClipped === 0) {\n            if(this.internalViewport === null)\n                this.child.dryPaint();\n\n            this.forceRePaint = false;\n            return;\n        }\n\n        // Clear background and paint canvas\n        const ctx = this.viewport.context;\n        this.clearStart();\n        ctx.rect(vpX, vpY, vpW, vpH);\n        ctx.clip();\n\n        if(this.internalViewport !== null) {\n            ctx.drawImage(\n                this.internalViewport.canvas,\n                xDst - origXDst,\n                yDst - origYDst,\n                wClipped,\n                hClipped,\n                xDst,\n                yDst,\n                wClipped,\n                hClipped,\n            );\n        }\n\n        ctx.rect(xDst, yDst, wClipped, hClipped);\n        this.clearEnd('evenodd');\n\n        if(this.internalViewport === null) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(xDst, yDst, wClipped, hClipped);\n            ctx.clip();\n            this.child.paint(forced || this.forceRePaint);\n            ctx.restore();\n        }\n\n        this.forceRePaint = false;\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport { AxisCoupling } from '../widgets/AxisCoupling';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { ClickHelper } from '../helpers/ClickHelper';\nimport { ClickState } from '../helpers/ClickState';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { ViewportWidget } from './ViewportWidget';\nimport { AutoScroll } from '../events/AutoScroll';\nimport type { Bounds } from '../helpers/Bounds';\nimport type { Event } from '../events/Event';\nimport { Leave } from '../events/Leave';\nimport type { Widget } from './Widget';\nimport { Root } from '../core/Root';\n\n/**\n * The mode for how a scrollbar is shown in a {@link ScrollableViewportWidget}.\n *\n * @category Widget\n */\nexport enum ScrollbarMode {\n    /** The scrollbar is an overlay and therefore only shown when needed */\n    Overlay,\n    /** The scrollbar is part of the layout and therefore always shown */\n    Layout,\n    /** The scrollbar is hidden, but the content can still be scrolled */\n    Hidden,\n}\n\n/**\n * A wrapper for a {@link ViewportWidget} with scrollbars.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ScrollableViewportWidget<W extends Widget = Widget> extends ViewportWidget<W> {\n    /**\n     * See {@link ScrollableViewportWidget#scrollbarMode}. For internal use only\n     */\n    private _scrollbarMode: ScrollbarMode;\n    /**\n     * The effective viewport width (ideal width not occupied by a non-overlay\n     * scrollbar), for scrollbar calculations. For internal use only.\n     */\n    private effectiveWidth = 0;\n    /**\n     * The effective viewport height (ideal height not occupied by a non-overlay\n     * scrollbar), for scrollbar calculations. For internal use only.\n     */\n    private effectiveHeight = 0;\n    /**\n     * ClickHelper used for checking if the horizontal scrollbar has been\n     * dragged\n     */\n    private horizontalClickHelper: ClickHelper;\n    /**\n     * ClickHelper used for checking if the vertical scrollbar has been dragged\n     */\n    private verticalClickHelper: ClickHelper;\n    /** Is the vertical scrollbar being dragged? If null, none is */\n    private verticalDragged: boolean | null = null;\n    /** What was the starting scroll value before dragging? */\n    private startingScroll = 0;\n    /** What was the normalised offset when starting drag? */\n    private startingOffset = 0;\n    /** When was the last scroll attempt in milliseconds since Unix epoch? */\n    private lastScroll = 0;\n    /** Was the horizontal scrollbar painted last frame? */\n    private horizWasPainted = false;\n    /** Was the vertical scrollbar painted last frame? */\n    private vertWasPainted = false;\n    /** The line height used for scrolling via wheel events. */\n    private _scrollLineHeight = 0;\n\n    /**\n     * Create a new ScrollableViewportWidget.\n     *\n     * If an axis is bi-coupled, that axis will not have a scrollbar.\n     */\n    constructor(child: W, minWidth = 0, minHeight = 0, widthCoupling = AxisCoupling.None, heightCoupling = AxisCoupling.None, scrollbarMode = ScrollbarMode.Overlay, useViewport = false, themeProperties?: ThemeProperties) {\n        super(child, minWidth, minHeight, widthCoupling, heightCoupling, useViewport, themeProperties);\n\n        this._scrollbarMode = scrollbarMode;\n        this.horizontalClickHelper = new ClickHelper(this);\n        this.verticalClickHelper = new ClickHelper(this);\n        this.updateScrollLineHeight();\n    }\n\n    /** The mode for how the scrollbar is shown. */\n    get scrollbarMode(): ScrollbarMode {\n        return this._scrollbarMode;\n    }\n\n    set scrollbarMode(scrollbarMode: ScrollbarMode) {\n        if(this._scrollbarMode !== scrollbarMode) {\n            const oldScroll = this.scroll;\n            this._scrollbarMode = scrollbarMode;\n            this.scroll = oldScroll;\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Offset of {@link SingleParent#child}. Positional events will take this\n     * into account, as well as rendering. Unlike {@link ViewportWidget#offset},\n     * this will clamp to possible scroll values to avoid issues.\n     */\n    override get offset(): [number, number] {\n        return super.offset;\n    }\n\n    override set offset(offset: [number, number]) {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        super.offset = [\n            -Math.max(Math.min(-offset[0], childWidth - this.effectiveWidth), 0),\n            -Math.max(Math.min(-offset[1], childHeight - this.effectiveHeight), 0),\n        ];\n    }\n\n    override get widthCoupling(): AxisCoupling {\n        return super.widthCoupling;\n    }\n\n    override set widthCoupling(widthCoupling: AxisCoupling) {\n        const oldScroll = this.scroll;\n        super.widthCoupling = widthCoupling;\n        this.scroll = oldScroll;\n    }\n\n    override get heightCoupling(): AxisCoupling {\n        return super.heightCoupling;\n    }\n\n    override set heightCoupling(heightCoupling: AxisCoupling) {\n        const oldScroll = this.scroll;\n        super.heightCoupling = heightCoupling;\n        this.scroll = oldScroll;\n    }\n\n    /**\n     * The current scroll values. Similar to\n     * {@link ScrollableViewportWidget#offset}, but with normalised values (from\n     * 0 to 1).\n     */\n    get scroll(): [number, number] {\n        const [offsetX, offsetY] = this.offset;\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const diffX = childWidth - this.effectiveWidth;\n        const diffY = childHeight - this.effectiveHeight;\n        return [\n            diffX === 0 ? 0 : Math.min(Math.max(-offsetX / diffX, 0), 1),\n            diffY === 0 ? 0 : Math.min(Math.max(-offsetY / diffY, 0), 1),\n        ];\n    }\n\n    set scroll(scroll: [number, number]) {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        this.offset = [\n            -scroll[0] * (childWidth - this.effectiveWidth),\n            -scroll[1] * (childHeight - this.effectiveHeight),\n        ];\n    }\n\n    /** Get the ClickHelper of a scrollbar */\n    private getClickHelper(vertical: boolean): ClickHelper {\n        if(vertical)\n            return this.verticalClickHelper;\n        else\n            return this.horizontalClickHelper;\n    }\n\n    /**\n     * Handle a pointer/leave event for a given scrollbar.\n     *\n     * @returns Returns true if the event was captured\n     */\n    private handleEventScrollbar(vertical: boolean, corner: boolean, event: Event, root: Root): boolean {\n        // Abort if the other scrollbar is being dragged\n        if(this.verticalDragged !== null && this.verticalDragged !== vertical)\n            return false;\n\n        // Get click area of scrollbar. If in overlay mode, use the filled part\n        // of the scrollbar as the click area since there is no background\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const clickRect = overlay ? fillRect : bgRect;\n        const clickArea: [number, number, number, number] = [\n            clickRect[0],\n            clickRect[0] + clickRect[2],\n            clickRect[1],\n            clickRect[1] + clickRect[3],\n        ];\n\n        // Handle click event\n        const clickHelper = this.getClickHelper(vertical);\n        clickHelper.handleClickEvent(event, root, clickArea);\n\n        const clickState = clickHelper.clickState;\n        const stateChanged = clickHelper.clickStateChanged;\n        if(stateChanged)\n            this._dirty = true;\n\n        if(clickState === ClickState.Hold) {\n            // Abort if state is not valid, but grab the event\n            if(clickHelper.pointerPos === null || !(event instanceof PointerEvent))\n                return true;\n\n            const axisIndex = vertical ? 1 : 0;\n            const scroll = this.scroll;\n\n            // Skip check if in overlay mode; can only scroll by dragging in\n            // this mode\n            let inFilledArea = overlay;\n            if(!inFilledArea) {\n                inFilledArea = clickHelper.isPointInRect(\n                    event.x,\n                    event.y,\n                    fillRect[0],\n                    fillRect[0] + fillRect[2],\n                    fillRect[1],\n                    fillRect[1] + fillRect[3],\n                );\n            }\n\n            // Find offset along scrollbar. Necessary for overlay mode since\n            // pointerPos is relative to the fillRect in that case, not bgRect\n            let thisOffset;\n            if(overlay) {\n                thisOffset = clickHelper.getNormalInRect(\n                    event.x,\n                    event.y,\n                    bgRect[0],\n                    bgRect[0] + bgRect[2],\n                    bgRect[1],\n                    bgRect[1] + bgRect[3],\n                )[axisIndex];\n            }\n            else\n                thisOffset = clickHelper.pointerPos[axisIndex];\n\n            if(stateChanged) {\n                // If this was outside the filled area, snap scrollbar\n                if(!inFilledArea) {\n                    const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                    const childLength = this.child.idealDimensions[axisIndex];\n                    const barLength = viewportLength / childLength;\n                    scroll[axisIndex] = (thisOffset - barLength / 2) / (1 - barLength);\n                    this.scroll = scroll;\n                }\n\n                // Drag start, save current scroll and set this scrollbar as\n                // being dragged\n                this.startingOffset = thisOffset;\n                this.startingScroll = scroll[axisIndex];\n                this.verticalDragged = vertical;\n            }\n            else {\n                // Drag continue, scroll\n                const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                const childLength = this.child.idealDimensions[axisIndex];\n                const barLength = viewportLength / childLength;\n                const dragDiff = thisOffset - this.startingOffset;\n                scroll[axisIndex] = this.startingScroll + dragDiff / (1 - barLength);\n                this.scroll = scroll;\n            }\n\n            return true;\n        }\n        else if(clickState === ClickState.Hover)\n            return true;\n        else if(stateChanged) {\n            // Release this scrollbar\n            this.verticalDragged = null;\n            return true;\n        }\n\n        return false;\n    }\n\n    /** Clamp offset in-place to valid scroll values. For internal use only. */\n    private clampOffset(offset: [number, number]): void {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        const minX = -(childWidth - this.effectiveWidth);\n        if(minX >= 0)\n            offset[0] = 0;\n        else if(offset[0] < minX)\n            offset[0] = minX;\n\n        const minY = -(childHeight - this.effectiveHeight);\n        if(minY >= 0)\n            offset[1] = 0;\n        else if(offset[1] < minY)\n            offset[1] = minY;\n    }\n\n    /**\n     * Handle a wheel scroll event. If scrolling fails due to being at the\n     * limit, this returns true if the last scroll attempt happened less than\n     * 200 milliseconds ago. This behaviour is disabled if\n     * {@link PointerWheel#fromDrag} is true.\n     *\n     * @returns Returns true if this changed scroll was successful\n     */\n    private handleWheelEvent(event: PointerWheel): boolean {\n        const offset = this.offset;\n        const [oldX, oldY] = offset;\n        const [dx, dy] = event.getDeltaPixels(true, this._scrollLineHeight, this.idealWidth, this.idealHeight);\n        offset[0] -= event.shift ? dy : dx;\n        offset[1] -= event.shift ? dx : dy;\n        this.clampOffset(offset);\n        this.offset = offset;\n        const [newX, newY] = this.offset;\n\n        const success = newX !== oldX || newY !== oldY;\n        const last = this.lastScroll;\n        const now = (new Date()).getTime();\n        this.lastScroll = now;\n\n        if(success)\n            return true;\n\n        if(event.fromDrag)\n            return false;\n\n        const elapsed = now - last;\n        return elapsed < 200;\n    }\n\n    protected updateScrollLineHeight(): void {\n        const textHelper = new TextHelper();\n        textHelper.font = this.bodyTextFont;\n        textHelper.lineHeight = this.bodyTextHeight;\n        textHelper.lineSpacing = this.bodyTextSpacing;\n        this._scrollLineHeight = textHelper.fullLineHeight;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFont' ||\n                property === 'bodyTextHeight' ||\n                property === 'bodyTextSpacing')\n            this.updateScrollLineHeight();\n        else if(property === 'scrollBarThickness')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundFill' ||\n                property === 'scrollBarMinPercent' ||\n                property === 'scrollBarMinPixels' ||\n                property === 'primaryFill' ||\n                property === 'accentFill' ||\n                property === 'backgroundGlowFill')\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Try to drag a scrollbar if this is a pointer or leave event with no\n        // target or target on this. Don't do this if the scrollbars are hidden\n        const widthBiCoupled = this.widthCoupling === AxisCoupling.Bi;\n        const heightBiCoupled = this.heightCoupling === AxisCoupling.Bi;\n\n        if(this._scrollbarMode !== ScrollbarMode.Hidden &&\n           (event instanceof Leave || event instanceof PointerEvent) &&\n           (event.target === null || event.target === this)) {\n            const [childWidth, childHeight] = this.child.idealDimensions;\n            const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n            const forceCorner = !overlay && (!widthBiCoupled && !heightBiCoupled);\n            const xNeeded = childWidth > this.idealWidth;\n            const yNeeded = childHeight > this.idealHeight;\n\n            let grabbedEvent = false;\n\n            // Only handle event in scrollbar if the scrollbar is shown and\n            // needed (layout mode shows unneeded scrollbars)\n            if(!widthBiCoupled && (xNeeded || !overlay) &&\n               this.handleEventScrollbar(false, yNeeded || forceCorner, event, this.root))\n                grabbedEvent = true;\n\n            if(!heightBiCoupled && (yNeeded || !overlay) &&\n               this.handleEventScrollbar(true, xNeeded || forceCorner, event, this.root))\n                grabbedEvent = true;\n\n            // If the event was grabbed by either scrollbar, capture it\n            if(grabbedEvent) {\n                // If this is a wheel event, handle it\n                if(event instanceof PointerWheel)\n                    this.handleWheelEvent(event);\n\n                return this;\n            }\n        }\n\n        // Pass event along\n        const capturer = super.handleEvent(event);\n\n        // If this is an auto-scroll event and it's been captured, then scroll\n        // to the capturer's wanted bounds, make the event relative to this\n        // scrollable viewport and re-capture it\n        if(capturer !== null && event instanceof AutoScroll) {\n            const reserve = this._scrollbarMode === ScrollbarMode.Layout;\n            const reserveX = reserve && !heightBiCoupled;\n            const reserveY = reserve && !widthBiCoupled;\n            let clearWidth = this.effectiveWidth;\n            let clearHeight = this.effectiveHeight;\n\n            if(!reserveX || !reserveY) {\n                const thickness = this.scrollBarThickness;\n                const [childWidth, childHeight] = this.child.idealDimensions;\n                const xNeeded = childWidth > this.idealWidth;\n                const yNeeded = childHeight > this.idealHeight;\n                const paintX = this.scrollbarNeedsPaint(false, xNeeded);\n                const paintY = this.scrollbarNeedsPaint(true, yNeeded);\n\n                // XXX don't trim clear space if scrollbars are hidden\n                if(this._scrollbarMode !== ScrollbarMode.Hidden) {\n                    if(!reserveX && paintY)\n                        clearWidth = Math.max(0, clearWidth - thickness);\n                    if(!reserveY && paintX)\n                        clearHeight = Math.max(0, clearHeight - thickness);\n                }\n            }\n\n            let [cx, cy] = capturer.idealPosition;\n\n            // XXX if a viewport is being used, then the child's coordinates are\n            // relative to the viewport widget. convert coordinates so that they\n            // are relative to the viewport widget's parent viewport\n            let [offsetX, offsetY] = this.offset;\n            const oldOffX = offsetX, oldOffY = offsetY;\n            if(this.usesViewport) {\n                cx += this.idealX + offsetX;\n                cy += this.idealY + offsetY;\n            }\n\n            let [cl, cr, ct, cb] = event.bounds;\n            cl += cx;\n            cr += cx;\n            ct += cy;\n            cb += cy;\n            const vpr = this.idealX + clearWidth;\n            const vpb = this.idealY + clearHeight;\n\n            // If a tab-selection event occurred, scroll so that widget that got\n            // selected is visible. Don't scroll if viewport is smaller than\n            // capturer and viewport is inside capturer. Don't scroll if\n            // capturer is smaller than viewport and capturer is inside viewport\n            const moveX = !widthBiCoupled && !(cl >= this.idealX && cr <= vpr) && !(this.idealX >= cl && vpr <= cr);\n            if(moveX) {\n                // If child rect is bigger than viewport, then align nearest\n                // child rect edge to farthest border of viewport\n                // If child rect is smaller than viewport, then align farthest\n                // child rect edge to nearest border of viewport\n                const rectBiggerThanViewport = cr - cl > clearWidth;\n                const rectBeforeViewport = cl < this.idealX;\n                const alignLeft = rectBiggerThanViewport !== rectBeforeViewport;\n                if(alignLeft)\n                    offsetX += this.idealX - cl;\n                else\n                    offsetX += vpr - cr;\n            }\n\n            const moveY = !heightBiCoupled && !(ct >= this.idealY && cb <= vpb) && !(this.idealY >= ct && vpb <= cb);\n            if(moveY) {\n                const rectBiggerThanViewport = cb - ct > clearHeight;\n                const rectBeforeViewport = ct < this.idealY;\n                const alignTop = rectBiggerThanViewport !== rectBeforeViewport;\n                if(alignTop)\n                    offsetY += this.idealY - ct;\n                else\n                    offsetY += vpb - cb;\n            }\n\n            if(moveX || moveY)\n                this.offset = [offsetX, offsetY];\n\n            // Correct event bounds to new offset\n            // XXX need to use getter instead of [offsetX, offsetY] because the\n            // setter clamps the values and therefore the offset may have\n            // changed\n            const [newOffX, newOffY] = this.offset;\n            const offDiffX = newOffX - oldOffX + cx - this.idealX;\n            const offDiffY = newOffY - oldOffY + cy - this.idealY;\n            event.bounds[0] += offDiffX;\n            event.bounds[1] += offDiffX;\n            event.bounds[2] += offDiffY;\n            event.bounds[3] += offDiffY;\n\n            return this;\n        }\n\n        // If this is a wheel event and nobody captured the event, try\n        // scrolling. If scrolling did indeed occur, then capture the event.\n        if(capturer === null && event instanceof PointerWheel && this.handleWheelEvent(event))\n            return this;\n\n        return capturer;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Check whether to reserve space or not\n        const thickness = this.scrollBarThickness;\n        const reserve = this._scrollbarMode === ScrollbarMode.Layout;\n        // is a vertical scrollbar always shown (does horizontal space need to\n        // be reserved?)\n        const reserveX = reserve && this.heightCoupling !== AxisCoupling.Bi;\n        // is a horizontal scrollbar always shown (does vertical space need to\n        // be reserved?)\n        const reserveY = reserve && this.widthCoupling !== AxisCoupling.Bi;\n\n        // If reserving space, further constrain dimensions\n        let rMinWidth, rMaxWidth, rMinHeight, rMaxHeight;\n        if(reserveX) {\n            rMaxWidth = Math.max(maxWidth - thickness, 0);\n            rMinWidth = Math.min(minWidth, rMaxWidth);\n        }\n        else {\n            rMaxWidth = maxWidth;\n            rMinWidth = minWidth;\n        }\n\n        if(reserveY) {\n            rMaxHeight = Math.max(maxHeight - thickness, 0);\n            rMinHeight = Math.min(minHeight, rMaxHeight);\n        }\n        else {\n            rMaxHeight = maxHeight;\n            rMinHeight = minHeight;\n        }\n\n        // Resolve dimensions\n        super.handleResolveDimensions(rMinWidth, rMaxWidth, rMinHeight, rMaxHeight);\n\n        // Save dimensions to effective dimensions\n        this.effectiveWidth = this.idealWidth;\n        this.effectiveHeight = this.idealHeight;\n\n        // Expand dimensions to fit scrollbars\n        if(reserveX)\n            this.idealWidth = Math.min(Math.max(this.idealWidth + thickness, minWidth), maxWidth);\n\n        if(reserveY)\n            this.idealHeight = Math.min(Math.max(this.idealHeight + thickness, minHeight), maxHeight);\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        super.handlePostLayoutUpdate();\n\n        // Keep scroll in bounds\n        const offset = this.offset;\n        this.clampOffset(offset);\n        this.offset = offset;\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Check which scrollbars need painting and update forceRePaint flag\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const xNeeded = childWidth > this.idealWidth;\n        const yNeeded = childHeight > this.idealHeight;\n        const paintX = this.scrollbarNeedsPaint(false, xNeeded);\n        const paintY = this.scrollbarNeedsPaint(true, yNeeded);\n\n        if(this.horizWasPainted !== paintX || this.vertWasPainted !== paintY) {\n            this.horizWasPainted = paintX;\n            this.vertWasPainted = paintY;\n            this.forceRePaint = true;\n        }\n        else if(this.scrollbarMode === ScrollbarMode.Overlay) {\n            // XXX overlay mode always needs the child widget to be repainted\n            // because the scrollbar could be semi-transparent. if the scrollbar\n            // is semi-transparent and the child is painted, then the scrollbar\n            // will also be painted, but it will be overpainted, resulting in\n            // accumulation of alpha, getting rid of the transparency over time\n            this.forceRePaint = true;\n        }\n\n        // Paint viewport\n        super.handlePainting(forced);\n\n        // Paint scrollbars\n        const forceCorner = this._scrollbarMode === ScrollbarMode.Layout &&\n                            (this.widthCoupling !== AxisCoupling.Bi\n                                && this.heightCoupling !== AxisCoupling.Bi);\n\n        if(paintX)\n            this.paintScrollbar(false, xNeeded, yNeeded || forceCorner);\n        if(paintY)\n            this.paintScrollbar(true, yNeeded, xNeeded || forceCorner);\n\n        // Paint corner if it is forced\n        if(forceCorner) {\n            const thickness = this.scrollBarThickness;\n            const ctx = this.viewport.context;\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(\n                this.x + this.width - thickness,\n                this.y + this.height - thickness,\n                thickness,\n                thickness,\n            );\n        }\n    }\n\n    /**\n     * Get the rectangles (filled and background) of a scrollbar\n     *\n     * @returns Returns a 2-tuple with 2 4-tuples. The first one is the scrollbar fill rectangle and the second one is the background fill rectangle. Each rectangle 4-tuple contains, respectively, horizontal offset, vertical offset, width and height\n     */\n    private getScrollbarRects(vertical: boolean, corner: boolean): [Bounds, Bounds] {\n        // Calculate basic scrollbar properties\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const axisIndex = vertical ? 1 : 0;\n        const percent = this.scroll[axisIndex];\n        const childLength = this.child.idealDimensions[axisIndex];\n        const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n        const thickness = this.scrollBarThickness;\n        const minPercent = this.scrollBarMinPercent;\n        const minPixels = this.scrollBarMinPixels;\n\n        let viewportLengthCorner = viewportLength;\n        if(overlay)\n            viewportLengthCorner -= (corner ? thickness : 0);\n\n        const length = Math.min(\n            // Make sure scrollbar fill isn't bigger than viewport\n            Math.max(\n                // Make sure that scrollbar respects the minimum pixel length\n                minPixels,\n                Math.max(\n                    // Make sure that scrollbar respects the minimum percent\n                    viewportLength / childLength,\n                    minPercent,\n                ) * viewportLengthCorner,\n            ),\n            viewportLengthCorner,\n        );\n\n        const offset = (viewportLengthCorner - length) * percent;\n\n        // Find rectangle where filled part of scrollbar will be painted\n        let sX, sY, sWidth, sHeight;\n        if(vertical) {\n            sX = this.idealX + this.idealWidth - thickness;\n            sY = this.idealY + offset;\n            sWidth = thickness;\n            sHeight = length;\n        }\n        else {\n            sX = this.idealX + offset;\n            sY = this.idealY + this.idealHeight - thickness;\n            sWidth = length;\n            sHeight = thickness;\n        }\n\n        // Find rectangle where background of scrollbar will be painted\n        let bgX, bgY, bgWidth, bgHeight;\n        if(vertical) {\n            bgX = sX;\n            bgY = this.idealY;\n            bgWidth = thickness;\n            bgHeight = viewportLengthCorner;\n        }\n        else {\n            bgX = this.idealX;\n            bgY = sY;\n            bgWidth = viewportLengthCorner;\n            bgHeight = thickness;\n        }\n\n        return [\n            [sX, sY, sWidth, sHeight],\n            [bgX, bgY, bgWidth, bgHeight],\n        ];\n    }\n\n    /** Check if a scrollbar needs to be painted */\n    private scrollbarNeedsPaint(vertical: boolean, needed: boolean): boolean {\n        if(this._scrollbarMode === ScrollbarMode.Hidden)\n            return false;\n\n        if(!needed && this._scrollbarMode === ScrollbarMode.Overlay)\n            return false;\n\n        if(vertical)\n            return this.heightCoupling !== AxisCoupling.Bi;\n        else\n            return this.widthCoupling !== AxisCoupling.Bi;\n    }\n\n    /** Paint a scrollbar. For internal use only */\n    private paintScrollbar(vertical: boolean, needed: boolean, corner: boolean): void {\n        // Get rectangles\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n\n        // Paint background if not in overlay mode\n        const ctx = this.viewport.context;\n        if(this._scrollbarMode !== ScrollbarMode.Overlay) {\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(...bgRect);\n        }\n\n        // Paint filled part of scrollbar\n        if(needed) {\n            const clickHelper = this.getClickHelper(vertical);\n            switch(clickHelper.clickState) {\n                case ClickState.Released:\n                    ctx.fillStyle = this.primaryFill;\n                    break;\n                case ClickState.Hover:\n                case ClickState.Hold:\n                    ctx.fillStyle = this.accentFill;\n                    break;\n            }\n        }\n        else\n            ctx.fillStyle = this.backgroundGlowFill;\n\n        ctx.fillRect(...fillRect);\n    }\n}", "import type { VariableCallback } from '../state/VariableCallback';\nimport type { ThemeProperties } from '../theme/ThemeProperties';\nimport { WatchableVariable } from '../state/WatchableVariable';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { paintField } from '../decorators/FlagFields';\nimport { ClickHelper } from '../helpers/ClickHelper';\nimport { ClickState } from '../helpers/ClickState';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport { KeyEvent } from '../events/KeyEvent';\nimport type { Event } from '../events/Event';\nimport { Leave } from '../events/Leave';\nimport { Widget } from './Widget';\n\n/**\n * A slider flexbox widget; can slide a numeric value from an inclusive minimum\n * value to an inclusive maximum value, with optional snapping along set\n * increments.\n *\n * Note that sliders can only be horizontal.\n *\n * @category Widget\n */\nexport class Slider extends Widget {\n    /** The slider's minimum value. */\n    private minValue: number;\n    /** The slider's maximum value. */\n    private maxValue: number;\n    /**\n     * The increments in which the slider changes value. If 0, there are no\n     * fixed increments.\n     */\n    private snapIncrement: number;\n    /** The helper for handling pointer clicks/drags */\n    protected clickHelper: ClickHelper;\n    /** The helper for keeping track of the slider's value */\n    protected variable: WatchableVariable<number>;\n    /** Is this a vertical slider? */\n    protected readonly vertical: boolean;\n    /** The horizontal offset of the slider */\n    private offsetX = 0;\n    /** The vertical offset of the slider */\n    private offsetY = 0;\n    /** The actual width of the slider */\n    private actualWidth = 0;\n    /** The actual height of the slider */\n    private actualHeight = 0;\n    /** Is the keyboard focusing this widget? */\n    @paintField\n    private keyboardFocused = false;\n\n    /** Create a new Slider */\n    constructor(callback: VariableCallback<number> | null = null, minValue = 0, maxValue = 1, snapIncrement = 0, initialValue = 0, vertical = false, themeProperties?: ThemeProperties) {\n        // Sliders need a clear background, have no children and don't propagate\n        // events\n        super(true, false, themeProperties);\n\n        if(maxValue < minValue)\n            throw new Error('Slider max value can\\'t be smaller than minimum value');\n        if(!isFinite(minValue) || isNaN(minValue))\n            throw new Error('Slider min value must be a valid finite number');\n        if(!isFinite(maxValue) || isNaN(maxValue))\n            throw new Error('Slider max value must be a valid finite number');\n        if(!isFinite(snapIncrement) || isNaN(snapIncrement))\n            throw new Error('Slider increment value must be a valid finite number');\n        if(snapIncrement < 0)\n            throw new Error('Slider increment value must be greater or equal to zero');\n\n        this.clickHelper = new ClickHelper(this);\n        this.variable = new WatchableVariable(this.clamp(initialValue));\n        if(callback)\n            this.variable.watch(callback);\n\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n        this.snapIncrement = snapIncrement;\n        this.vertical = vertical;\n        this.tabFocusable = true;\n    }\n\n    /** The slider's value */\n    set value(value: number) {\n        this.setValue(value);\n    }\n\n    get value(): number {\n        return this.variable.value;\n    }\n\n    /** Clamp a value to this slider's min and max values */\n    protected clamp(value: number): number {\n        if(value < this.minValue)\n            value = this.minValue;\n        else if(value > this.maxValue)\n            value = this.maxValue;\n\n        return value;\n    }\n\n    /** Set the slider's value, optionally disabling callback */\n    setValue(value: number, doCallback = true): void {\n        // Snap to increments if needed\n        if(this.snapIncrement > 0)\n            value = Math.round(value / this.snapIncrement) * this.snapIncrement;\n\n        // Update value in variable\n        this.variable.setValue(this.clamp(value), doCallback);\n    }\n\n    protected stepValue(add: boolean, incMul: number): void {\n        // Get snap increment. If the increment is not set, default to 1% of the\n        // value range\n        let effectiveIncrement = this.snapIncrement;\n        if(effectiveIncrement === 0)\n            effectiveIncrement = 0.01 * (this.maxValue - this.minValue);\n\n        // Multiply increment (for holding shift)\n        effectiveIncrement *= incMul;\n\n        // Step value in increment\n        const delta = add ? 1 : -1;\n        this.value = this.clamp((Math.round(this.value / effectiveIncrement) + delta) * effectiveIncrement);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'sliderThickness' ||\n                property === 'sliderMinLength')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'backgroundFill')\n            this._dirty = true;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(focusType === FocusType.Keyboard)\n            this.keyboardFocused = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(focusType === FocusType.Keyboard)\n            this.keyboardFocused = false;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        // Ignore unhandled events\n        if(event instanceof PointerWheel || !(event instanceof PointerEvent || event instanceof KeyEvent || event instanceof Leave))\n            return null;\n\n        // Ignore tab key presses so tab selection works, and escape so widget\n        // unfocusing works\n        if(event instanceof KeyPress && (event.key === 'Tab' || event.key === 'Escape'))\n            return null;\n\n        // Handle key presses\n        if(event instanceof KeyEvent) {\n            if(event instanceof KeyPress) {\n                const incMul = event.shift ? 10 : 1;\n                if(event.key === 'ArrowLeft' || event.key === 'ArrowDown')\n                    this.stepValue(false, incMul);\n                else if(event.key === 'ArrowRight' || event.key === 'ArrowUp')\n                    this.stepValue(true, incMul);\n            }\n\n            return this;\n        }\n\n        // Handle click event\n        const x = this.idealX + this.offsetX;\n        const y = this.idealY + this.offsetY;\n        this.clickHelper.handleClickEvent(event, this.root, [\n            x, x + this.actualWidth, y, y + this.actualHeight,\n        ]);\n\n        // If this was a click or the slider is currently being held, update\n        // value\n        if(((this.clickHelper.clickStateChanged && this.clickHelper.wasClick) || this.clickHelper.clickState == ClickState.Hold)\n            && this.clickHelper.pointerPos !== null) {\n            // Interpolate value\n            const percent = this.clickHelper.pointerPos[0];\n            this.value = this.minValue + percent * (this.maxValue - this.minValue);\n        }\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect)\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return this;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Mark as dirty if variable is dirty\n        if(this.variable.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get theme properties\n        const thickness = this.sliderThickness;\n        const minLength = this.sliderMinLength;\n\n        // Fully expand along main axis if constrained and center along cross\n        // axis\n        if(this.vertical) {\n            // Main axis\n            if(maxHeight != Infinity)\n                this.idealHeight = maxHeight;\n            else\n                this.idealHeight = Math.max(minLength, minHeight);\n\n            // Cross axis\n            this.idealWidth = Math.min(Math.max(thickness, minWidth), maxWidth);\n\n        }\n        else {\n            // Main axis\n            if(maxWidth != Infinity)\n                this.idealWidth = maxWidth;\n            else\n                this.idealWidth = Math.max(minLength, minWidth);\n\n            // Cross axis\n            this.idealHeight = Math.min(Math.max(thickness, minHeight), maxHeight);\n        }\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // cache centered position and dimensions\n        if(this.vertical) {\n            this.actualWidth = Math.min(this.width, this.sliderThickness);\n            this.actualHeight = this.height;\n            this.offsetX = (this.width - this.actualWidth) / 2;\n            this.offsetY = 0;\n        }\n        else {\n            this.actualWidth = this.width;\n            this.actualHeight = Math.min(this.height, this.sliderThickness);\n            this.offsetX = 0;\n            this.offsetY = (this.height - this.actualHeight) / 2;\n        }\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Correct position with offset\n        const x = this.x + this.offsetX;\n        const y = this.y + this.offsetY;\n\n        // Draw filled part of slider. Use accent colour if hovering or holding\n        const ctx = this.viewport.context;\n        const useGlow = this.keyboardFocused || this.clickHelper.clickState === ClickState.Hover || this.clickHelper.clickState === ClickState.Hold;\n        if(useGlow)\n            ctx.fillStyle = this.accentFill;\n        else\n            ctx.fillStyle = this.primaryFill;\n        const fullWidth = this.actualWidth * (this.value - this.minValue) / (this.maxValue - this.minValue);\n        ctx.fillRect(x, y, fullWidth, this.actualHeight);\n\n        // Draw empty part of slider\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n        const emptyWidth = this.actualWidth - fullWidth;\n        ctx.fillRect(x + fullWidth, y, emptyWidth, this.actualHeight);\n    }\n}\n", "import { ScrollableViewportWidget, ScrollbarMode } from \"./ScrollableViewportWidget\";\nimport type { ThemeProperties } from \"../theme/ThemeProperties\";\nimport { AxisCoupling } from \"../widgets/AxisCoupling\";\nimport { TextValidator } from \"../state/Validator\";\nimport { TextInput } from \"./TextInput\";\n\n/**\n * A {@link ScrollableViewportWidget} with a {@link TextInput}. Meant to be used\n * as an analogue to the HTML textarea. Allows tab typing by default.\n *\n * Using uni-directional coupling with\n * {@link ScrollbarMode.Hidden | hidden scrollbars} (the default) is\n * recommended. However, if the scrollbars need to be visible, then\n * {@link ScrollbarMode.Layout | layout scrollbars} are recommended since\n * {@link ScrollbarMode.Overlay | overlay scrollbars} will hide text near the\n * borders.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class TextArea<V> extends ScrollableViewportWidget<TextInput<V>> {\n    constructor(validator: TextValidator<V>, inputFilter: ((input: string) => boolean) | null = null, initialValue = '', minWidth = 0, minHeight = 0, scrollbarMode = ScrollbarMode.Hidden, useViewport = false, themeProperties?: ThemeProperties) {\n        super(new TextInput(validator, inputFilter, initialValue, themeProperties), minWidth, minHeight, AxisCoupling.Uni, AxisCoupling.Uni, scrollbarMode, useViewport)\n\n        // enable tab typing by default\n        this.child.typeableTab = true;\n    }\n\n    /**\n     * Get the {@link TextInput} of this TextArea. Equivalent to\n     * {@link TextArea#child}.\n     */\n    get textInput() {\n        return this.child;\n    }\n}", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Margin} which stretches on the vertical axis. Useful for\n * horizontally centering labels without making them look weird if they are in\n * a row.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class TextMargin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new TextMargin. */\n    constructor(child: W, themeProperties?: ThemeProperties) {\n        const themePropertiesClone: ThemeProperties = {...themeProperties};\n\n        themePropertiesClone.containerAlignment = <Alignment2D>{\n            horizontal: Alignment.Center, vertical: Alignment.Stretch,\n        };\n\n        super(child, themePropertiesClone);\n    }\n}\n", "import { PassthroughWidget } from './PassthroughWidget';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which changes the theme of its child and\n * completely ignores inherited themes.\n *\n * Can be constrained to a specific type of children.\n *\n * Since the new theme replaces the inherited theme, children of the child will\n * also inherit this theme since inherited themes are propagated down the widget\n * tree.\n *\n * @category Widget\n */\nexport class ThemeScope<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** The theme used for the child. */\n    private scopeTheme: Theme;\n\n    /** Create a new ThemeScope. */\n    constructor(child: W, themeOverride: Theme) {\n        super(child);\n        this.scopeTheme = themeOverride;\n    }\n\n    override set inheritedTheme(_theme: Theme | undefined) {\n        super.inheritedTheme = this.scopeTheme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.scopeTheme;\n    }\n}"],
  "mappings": "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",
  "names": []
}
