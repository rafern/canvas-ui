{
  "version": 3,
  "sources": ["../src/core/Strings.ts", "../src/decorators/FlagFields.ts", "../src/events/Event.ts", "../src/events/ModifierEvent.ts", "../src/events/PointerEvent.ts", "../src/core/BaseViewport.ts", "../src/helpers/roundToPower2.ts", "../src/helpers/isPower2.ts", "../src/core/CanvasViewport.ts", "../src/core/ClippedViewport.ts", "../src/theme/FlexAlignment.ts", "../src/theme/Alignment.ts", "../src/events/AutoScroll.ts", "../src/events/TabSelect.ts", "../src/helpers/measureTextDims.ts", "../src/helpers/TextHelper.ts", "../src/theme/BaseTheme.ts", "../src/widgets/Widget.ts", "../src/widgets/Parent.ts", "../src/widgets/MultiParent.ts", "../src/widgets/MultiContainer.ts", "../src/widgets/SingleParent.ts", "../src/widgets/BaseContainer.ts", "../src/core/FocusType.ts", "../src/events/PointerWheel.ts", "../src/events/KeyEvent.ts", "../src/events/KeyPress.ts", "../src/events/Leave.ts", "../src/theme/Theme.ts", "../src/core/Root.ts", "../src/core/DebugInjector.ts", "../src/core/DefaultTextInputHandler.ts", "../src/events/TextPasteEvent.ts", "../src/core/DOMRoot.ts", "../src/widgets/PassthroughWidget.ts", "../src/widgets/ArtificialConstraint.ts", "../src/widgets/Label.ts", "../src/helpers/ClickState.ts", "../src/helpers/CompoundClickHelper.ts", "../src/helpers/GenericClickHelper.ts", "../src/events/KeyRelease.ts", "../src/events/PointerButtonEvent.ts", "../src/events/PointerRelease.ts", "../src/events/PointerPress.ts", "../src/helpers/ClickHelper.ts", "../src/helpers/ButtonClickHelper.ts", "../src/widgets/Button.ts", "../src/widgets/FilledButton.ts", "../src/widgets/TextButton.ts", "../src/widgets/VirtualKeyboard/VirtualKey.ts", "../src/widgets/VirtualKeyboard/GlyphVirtualKey.ts", "../src/widgets/Row.ts", "../src/widgets/VirtualKeyboard/VirtualKeyRow.ts", "../src/widgets/VirtualKeyboard/BasicVirtualKey.ts", "../src/widgets/VirtualKeyboard/BackspaceKey.ts", "../src/widgets/VirtualKeyboard/EscapeKey.ts", "../src/widgets/VirtualKeyboard/EnterKey.ts", "../src/widgets/VirtualKeyboard/ShiftKey.ts", "../src/widgets/VirtualKeyboard/SpaceKey.ts", "../src/widgets/Column.ts", "../src/widgets/VirtualKeyboard/VirtualKeyboard.ts", "../src/widgets/Container.ts", "../src/widgets/Margin.ts", "../src/core/DOMVirtualKeyboardRoot.ts", "../src/core/VirtualKeyboardRoot.ts", "../src/drivers/KeyboardDriver.ts", "../src/drivers/DOMKeyboardDriver.ts", "../src/helpers/getPointerEventNormPos.ts", "../src/events/PointerMove.ts", "../src/drivers/PointerHint.ts", "../src/drivers/PointerDriver.ts", "../src/drivers/DOMPointerDriver.ts", "../src/drivers/RayPointerDriver.ts", "../src/state/Variable.ts", "../src/state/ValidatedVariable.ts", "../src/theme/DebugTheme.ts", "../src/widgets/VirtualKeyboard/AltKey.ts", "../src/widgets/VirtualKeyboard/ControlKey.ts", "../src/widgets/AxisCoupling.ts", "../src/widgets/Center.ts", "../src/widgets/Checkbox.ts", "../src/widgets/Icon.ts", "../src/widgets/IconButton.ts", "../src/widgets/Spacing.ts", "../src/widgets/LabelledCheckbox.ts", "../src/widgets/RadioButton.ts", "../src/widgets/LabelledRadioButton.ts", "../src/widgets/ViewportWidget.ts", "../src/widgets/ScrollableViewportWidget.ts", "../src/widgets/Slider.ts", "../src/widgets/TextInput.ts", "../src/widgets/TextArea.ts", "../src/widgets/TextMargin.ts", "../src/widgets/ThemeScope.ts"],
  "sourcesContent": ["const baseCanvasContextMsg = 'Failed to get DOM canvas context. Make sure the 2D canvas context is supported';\nconst badTextImpl = 'Text render group generation is incorrectly implemented. Please report this bug if you are not responsible for text rendering for this Widget.';\n\n/**\n * Standard static console messages.\n *\n * @category Core\n */\nexport const Msg = {\n    CANVAS_CONTEXT: `${baseCanvasContextMsg}.`,\n    REUSABLE_CANVAS_CONTEXT: `${baseCanvasContextMsg} and the canvas is not being reused with a different rendering context.`,\n    NEGATIVE_TEXT_GROUP: `Unexpected text render group with negative width detected. ${badTextImpl}`,\n    EMPTY_LINE_RANGE: `Unexpected line range without any text render groups. Empty lines must contain a zero-width text render group. ${badTextImpl}`,\n    ROGUE_NEWLINE: `Unexpected line range with newline character in the middle of the range instead of at the end. Text after newline character was ignored. ${badTextImpl}`,\n    VIDEO_API_AVAILABLE: 'HTMLVideoElement.requestVideoFrameCallback is available and will be used; if video playback is choppy or broken, please report it on Github',\n    DIMENSIONLESS_CANVAS: 'Canvas has 0 width or height. Are you using an empty Root? If not, make sure to not over-constrain the Widgets.',\n    NON_POW2_CANVAS: 'Canvas has a width or height that is not a power of 2, which may create mipmapping issues for 3D engines. Make sure to use power of 2 starting and maximum canvas dimensions.',\n    DOM_DRIVER_REBIND: 'Re-binding DOM driver. Are you calling bindDOMElem with the same HTML element multiple times?',\n    PARENTLESS_CLIPVP: 'Attempt to use ClippedViewport without a parent. If you are implementing a custom Root subclass, keep in mind that a Viewport with a rendering context must be used; ClippedViewport can\\'t be used because it inherits a parent Viewport\\'s rendering context.',\n};\n\nfunction propStr(name: string | symbol): string {\n    if(typeof name === 'string')\n        return name;\n    else\n        return '<Symbol()>';\n}\n\nfunction valueStr(value: unknown): string {\n    if(typeof value === 'string')\n        return `\"${value}\"`;\n    else\n        return String(value);\n}\n\nconst fpCause = 'This may be caused by floating pointer precision errors.';\n\n/**\n * Standard dynamic console messages.\n *\n * @category Core\n */\nexport const DynMsg = {\n    INVALID_BACKGROUND_FILL: (backgroundProperty: string | symbol) => `Unknown theme property: ${propStr(backgroundProperty)}. Valid background fill theme properties: \"primaryFill\", \"accentFill\", \"backgroundGlowFill\" and \"backgroundFill\".`,\n    SWAPPED_MIN_MAX_NAMED: (minValue: unknown, maxValue: unknown, minName: string | symbol, maxName: string | symbol) => `${propStr(maxName)} value (${valueStr(maxValue)}) can't be smaller than ${propStr(minName)} value (${valueStr(minValue)}).`,\n    SWAPPED_MIN_MAX: (minValue: unknown, maxValue: unknown) => DynMsg.SWAPPED_MIN_MAX_NAMED(minValue, maxValue, 'Minimum', 'Maximum'),\n    INVALID_VALUE: (name: string | symbol, value: unknown, nonNegative = false) => `${propStr(name)} value (${valueStr(value)}) must be a valid${nonNegative ? ' non-negative' : ''} finite number. Make sure that it's not infinite and not NaN.`,\n    NEGATIVE_VALUE: (name: string | symbol, value: unknown) => `${propStr(name)} value (${valueStr(value)}) must be greater or equal to zero.`,\n    NON_ARRAY_VALUE: (name: string | symbol, value: unknown) => `${propStr(name)} value (${valueStr(value)}) must be an array.`,\n    INVALID_MIN: (value: unknown) => DynMsg.INVALID_VALUE('Minimum', value),\n    INVALID_MAX: (value: unknown) => DynMsg.INVALID_VALUE('Maximum', value),\n    INVALID_INC: (value: unknown) => DynMsg.INVALID_VALUE('Increment', value),\n    NEGATIVE_INC: (value: unknown) => DynMsg.NEGATIVE_VALUE('Increment', value),\n    SWAPPED_MIN_MAX_DIMS: (minValue: unknown, maxValue: unknown, minName: string | symbol, maxName: string | symbol) => `${DynMsg.SWAPPED_MIN_MAX_NAMED(minValue, maxValue, minName, maxName)} Set ${propStr(minName)} to ${propStr(maxName)}. ${fpCause}`,\n    NEGATIVE_DIMS: (value: unknown, name: string | symbol) => `${DynMsg.NEGATIVE_VALUE(name, value)} Set ${propStr(name)} to 0. ${fpCause}`,\n    BROKEN_CONSTRAINTS: (value: unknown, limit: unknown, horizontal: boolean, overflow: boolean) => `${horizontal ? 'Horizont' : 'Vertic'}al ${overflow ? 'ov' : 'und'}erflow in Widget; Limit: ${limit}, actual value: ${value}.`,\n    INVALID_DIMS: (horizontal: boolean, value: unknown) => DynMsg.INVALID_VALUE(horizontal ? 'Width' : 'Height', value, true),\n    INACTIVE_WIDGET: (name: string) => `Cannot get ${name} property; Widget is not active. Make sure the Widget is in a UI tree and to never directly call Widget update, layout resolution or painting methods.`,\n    INVALID_ACTIVATION: (activating: boolean) => `Attempt to ${activating ? '' : 'de'}activate ${activating ? '' : 'in'}active Widget. Make sure the Widget is not being reused in another Root without first removing it from the first Root.`,\n    INVALID_KB_ROW_TEMPLATE: (entry: unknown) => `Unknown virtual key row template format for entry: ${entry}. A key row template must either be a function that returns a VirtualKey instance, or a pair of symbols.`,\n    INVALID_ENUM: (value: unknown, enumName: string, variableName: string) => `Unknown ${enumName} value: ${value}. Make sure ${variableName} is being passed as an enum value instead of its corresponding hardcoded value; this value may have become invalid due to an update.`,\n    OVERCAPTURING_WIDGET: (capturer: object) => `TabSelect event captured by widget (${capturer.constructor.name}), but reachedRelative was false; a widget type is probably capturing events by default. Make sure to only capture events that you need so that other Widgets aren't broken.`,\n    MAYBE_DIMENSIONLESS: (axisName: string) => `ViewportWidget has no minimum ${axisName} and ${axisName} isn't bi-directionally coupled, therefore, it may be dimensionless. Set a minimum ${axisName} and/or bi-directionally couple the ${axisName}.`,\n    UNTARGETABLE_EVENT: (eventName: string) => `${eventName} events cannot be targetted to a specific widget. Target ignored`,\n};\n\n/**\n * Print a stack trace inside a collapsed group to the console.\n *\n * @category Core\n */\nexport function groupedStackTrace() {\n    console.groupCollapsed('Stack trace');\n    console.trace();\n    console.groupEnd();\n}\n", "import { DynMsg } from \"../core/Strings\";\n\n/**\n * A decorator for a public field which sets calls a callback if the property's\n * value is changed.\n *\n * @typeParam V - The type of the field being watched\n * @param callback - The callback to call if the value changes. `this` is bound.\n * @category Decorator\n */\nexport function watchField<V>(callback: (oldValue: V) => void): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return function(target: Object, propertyKey: string | symbol): void {\n        const curValues = new WeakMap();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value) {\n                const oldValue = curValues.get(this);\n                if(value !== oldValue) {\n                    curValues.set(this, value);\n                    callback.call(this, oldValue);\n                }\n            },\n            get: function() {\n                return curValues.get(this);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchField} which sets a given flag to true.\n *\n * @param flagKey - The key of the flag property to set to true\n * @category Decorator\n */\nexport function flagField(flagKey: string | symbol): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchField(function(this: Object, _oldValue) {\n        (this as Record<string | symbol, unknown>)[flagKey] = true;\n    });\n}\n\n/**\n * A {@link flagField} where the flag key is `_dirty`.\n *\n * @category Decorator\n */\nexport const paintField = flagField('_dirty');\n\n/**\n * A {@link flagField} where the flag key is `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const layoutField = flagField('_layoutDirty');\n\n/**\n * A {@link watchField} which sets a given array of flags to true.\n *\n * @param flagKeys - An array containing the keys of each flag property to set to true\n * @category Decorator\n */\nexport function multiFlagField(flagKeys: Array<string | symbol>): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchField(function(this: Object, _oldValue) {\n        for(const flagKey of flagKeys)\n            (this as Record<string | symbol, unknown>)[flagKey] = true;\n    });\n}\n\n/**\n * A {@link multiFlagField} where the flag keys are `_dirty` and `_layoutDirty`.\n *\n * @category Decorator\n */\nexport const paintLayoutField = multiFlagField(['_dirty', '_layoutDirty']);\n\n/**\n * Similar to {@link watchField}, but for array fields, like tuples. Getting the\n * property returns a shallow copy of the tuple, setting the value uses a\n * shallow copy of the input value if the current value is not an array. If both\n * the new value and the current value are arrays, then the current value's\n * members are updated; no shallow copy is created.\n *\n * @param callback - The callback to call if the value changes. `this` is bound.\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function watchArrayField(callback: () => void, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return function(target: Object, propertyKey: string | symbol): void {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const curValues = new WeakMap<Object, unknown | Array<unknown>>();\n        Object.defineProperty(target, propertyKey, {\n            set: function(value: unknown | Array<unknown>) {\n                if(Array.isArray(value)) {\n                    const curTuple = curValues.get(this);\n                    if(Array.isArray(curTuple)) {\n                        if(value.length !== curTuple.length) {\n                            curTuple.length = value.length;\n                            for(let i = 0; i < value.length; i++)\n                                curTuple[i] = value[i];\n\n                            callback.call(this);\n                        }\n                        else {\n                            for(let i = 0; i < value.length; i++) {\n                                if(curTuple[i] !== value[i]) {\n                                    for(let j = 0; j < value.length; j++)\n                                        curTuple[j] = value[j];\n\n                                    callback.call(this);\n\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        curValues.set(this, [...value]);\n                        callback.call(this);\n                    }\n                }\n                else {\n                    if(allowNonArrays) {\n                        curValues.set(this, value);\n                        callback.call(this);\n                    }\n                    else\n                        throw new Error(DynMsg.NON_ARRAY_VALUE(propertyKey, value));\n                }\n            },\n            get: function() {\n                const curTuple = curValues.get(this);\n                if(!Array.isArray(curTuple))\n                    return curTuple;\n\n                return [...curTuple];\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    }\n}\n\n/**\n * A {@link watchArrayField} which sets a given flag to true.\n *\n * @param flagKey - The key of the flag property to set to true\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function flagArrayField(flagKey: string, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchArrayField(function(this: Object) {\n        (this as Record<string | symbol, unknown>)[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_dirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintArrayField(allowNonArrays = false): PropertyDecorator {\n    return flagArrayField('_dirty', allowNonArrays);\n}\n\n/**\n * A {@link flagArrayField} where the flag key is `_layoutDirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function layoutArrayField(allowNonArrays = false): PropertyDecorator {\n    return flagArrayField('_layoutDirty', allowNonArrays);\n}\n\n/**\n * A {@link watchArrayField} which sets a given array of flags to true.\n *\n * @param flagKeys - An array containing the keys of each flag property to set to true\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function multiFlagArrayField(flagKeys: Array<string>, allowNonArrays = false): PropertyDecorator {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return watchArrayField(function(this: Object) {\n        for(const flagKey of flagKeys)\n            (this as Record<string | symbol, unknown>)[flagKey] = true;\n    }, allowNonArrays);\n}\n\n/**\n * A {@link multiFlagArrayField} where the flag keys are `_dirty` and\n * `_layoutDirty`.\n *\n * @param allowNonArrays - Allow values which are not arrays to be used?\n * @category Decorator\n */\nexport function paintLayoutArrayField(allowNonArrays = false): PropertyDecorator {\n    return multiFlagArrayField(['_dirty', '_layoutDirty'], allowNonArrays);\n}\n", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\n\n/**\n * A generic event. This is an abstract class and must be implemented in child\n * classes.\n *\n * @category Event\n */\nexport abstract class Event {\n    /** The target of this event. Can be null */\n    readonly target: Widget | null;\n    /**\n     * The focus type of this event. Can be null.\n     *\n     * If null, this event cannot be focused, since events are focused by their\n     * {@link FocusType} as a group.\n     */\n    readonly focusType: FocusType | null;\n    /** Can this event be dispatched without a target? */\n    readonly needsFocus: boolean;\n    /** Is this event dispatched in reverse-order? */\n    readonly reversed: boolean;\n\n    /** Create a new Event. */\n    constructor(target: Widget | null, focusType: FocusType | null, needsFocus: boolean, reversed = false) {\n        this.target = target;\n        this.focusType = focusType;\n        this.needsFocus = needsFocus;\n        this.reversed = reversed;\n    }\n\n    /**\n     * Create a new Event with the same properties as this, except with a new\n     * given target.\n     */\n    abstract cloneWithTarget(target: Widget | null): Event;\n}", "import type { FocusType } from '../core/FocusType';\nimport type { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * An event which contains the state of modifier keys. This is an abstract class\n * and must be implemented in child classes.\n *\n * @category Event\n */\nexport abstract class ModifierEvent extends Event {\n    /** Is shift being pressed? */\n    readonly shift: boolean;\n    /** Is control being pressed? */\n    readonly ctrl: boolean;\n    /** Is alt being pressed? */\n    readonly alt: boolean;\n\n    /** Create a new ModifierEvent. */\n    constructor(shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null, focusType: FocusType | null, needsFocus: boolean) {\n        super(target, focusType, needsFocus);\n        this.shift = shift;\n        this.ctrl = ctrl;\n        this.alt = alt;\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A pointer {@link Event}.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerEvent extends ModifierEvent {\n    /** Pointer event position's X coordinate in pixels. Not an integer. */\n    readonly x: number;\n    /** Pointer event position's Y coordinate in pixels. Not an integer. */\n    readonly y: number;\n\n    /** Create a new PointerEvent. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(shift, ctrl, alt, target, focusType, false);\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Create a new PointerEvent event with the same properties as this, except\n     * with new {@link PointerEvent#x} and {@link PointerEvent#y} values\n     * corrected for a given offset.\n     */\n    abstract correctOffset(xOffset: number, yOffset: number): PointerEvent;\n}\n", "import type { LayoutConstraints } from \"./LayoutConstraints\";\nimport { watchArrayField } from \"../decorators/FlagFields\";\nimport { PointerEvent } from \"../events/PointerEvent\";\nimport type { FillStyle } from \"../theme/FillStyle\";\nimport type { Widget } from \"../widgets/Widget\";\nimport type { Event } from \"../events/Event\";\nimport type { Rect } from \"../helpers/Rect\";\nimport type { Viewport } from \"./Viewport\";\n\n/**\n * The base implementation of the {@link Viewport} interface. See\n * {@link CanvasViewport} and {@link ClippedViewport}.\n *\n * @category Core\n */\nexport abstract class BaseViewport implements Viewport {\n    readonly relativeCoordinates: boolean;\n    readonly child: Widget;\n    abstract readonly context: CanvasRenderingContext2D;\n    @watchArrayField(BaseViewport.prototype.forceLayoutDirty)\n    constraints: LayoutConstraints;\n    @watchArrayField(BaseViewport.prototype.updateEverything)\n    rect: Rect;\n    abstract get effectiveScale(): [scaleX: number, scaleY: number];\n    parent: Viewport | null = null;\n    @watchArrayField(BaseViewport.prototype.updateChildPos)\n    offset: [x: number, y: number];\n\n    /** Has the warning for dimensionless canvases been issued? */\n    protected static dimensionlessWarned = false;\n    /** Has the warning for non-power of 2 dimensions been issued? */\n    protected static powerOf2Warned = false;\n    /**\n     * The maximum retries allowed for\n     * {@link Viewport#resolveLayout | resolving the layout}. The first attempt\n     * is not counted. Only retries that exceed this limit are discarded; if\n     * maxRelayout is 4, then the 5th retry will be discarded.\n     */\n    protected static maxRelayout = 4;\n\n    protected constructor(child: Widget, relativeCoordinates: boolean) {\n        this.child = child;\n        this.relativeCoordinates = relativeCoordinates;\n        this.constraints = [0, Infinity, 0, Infinity];\n        this.rect = [0, 0, 0, 0];\n        this.offset = [0, 0];\n    }\n\n    /**\n     * Force-marks all flags as dirty in {@link BaseViewport#child} and calls\n     * {@link BaseViewport#updateChildPos}. Used as a callback for the\n     * {@link BaseViewport#rect} field watcher.\n     */\n    private updateEverything() {\n        this.child.forceDirty();\n        this.updateChildPos();\n    }\n\n    /**\n     * Force-marks all flags as dirty in {@link BaseViewport#child}. Used as a\n     * callback for the {@link BaseViewport#constraints} field watcher.\n     */\n    private forceLayoutDirty() {\n        this.child.forceDirty();\n    }\n\n\n    /**\n     * Resolves the position of the child and finalizes its bounds. This\n     * effectively updates the position of the child in an out-of-order fashion\n     * (doesn't wait for the proper stage of the layout resolution). Used as a\n     * callback for the {@link BaseViewport#offset} field watcher.\n     */\n    private updateChildPos() {\n        if(!this.relativeCoordinates && this.child.active) {\n            const [l, t, _w, _h] = this.rect;\n            const [ox, oy] = this.offset;\n            const newX = l + ox;\n            const newY = t + oy;\n            const [oldX, oldY] = this.child.position;\n\n            if(newX !== oldX || newY !== oldY) {\n                this.child.resolvePosition(newX, newY);\n                this.child.finalizeBounds();\n            }\n        }\n    }\n\n    /**\n     * Resolves the given child's layout by calling\n     * {@link Widget#resolveDimensionsAsTop} with the current\n     * {@link Viewport#constraints}, {@link Widget#resolvePosition} and\n     * {@link Widget#finalizeBounds}.\n     *\n     * Handles both relative and absolute coordinates. The previous position is\n     * used.\n     *\n     * @returns Returns true if the child was resized, else, false.\n     */\n    resolveLayout(): boolean {\n        if(!this.child.layoutDirty)\n            return false;\n\n        // Resolve child's layout\n        const [oldWidth, oldHeight] = this.child.dimensions;\n\n        this.child.resolveDimensionsAsTop(...this.constraints);\n\n        if(this.relativeCoordinates)\n            this.child.resolvePosition(0, 0);\n        else\n            this.child.resolvePosition(...this.child.idealPosition);\n\n        this.child.finalizeBounds();\n\n        const [newWidth, newHeight] = this.child.dimensions;\n        return newWidth !== oldWidth || newHeight !== oldHeight;\n    }\n\n    abstract paint(force: boolean, backgroundFillStyle: FillStyle): boolean;\n\n    dispatchEvent(event: Event): Widget | null {\n        // Drop event if it is a positional event with no target outside the\n        // child's viewport\n        if(event instanceof PointerEvent) {\n            const [cl, ct, cw, ch] = this.rect;\n            const cr = cl + cw;\n            const cb = ct + ch;\n\n            if(event.target === null) {\n                if(event.x < cl)\n                    return null;\n                if(event.x >= cr)\n                    return null;\n                if(event.y < ct)\n                    return null;\n                if(event.y >= cb)\n                    return null;\n            }\n\n            // Correct position of pointer event if this viewport has relative\n            // positions.\n            if(this.relativeCoordinates) {\n                const [ox, oy] = this.offset;\n                const x = cl + ox;\n                const y = ct + oy;\n\n                if(x !== 0 || y !== 0)\n                    event = event.correctOffset(x, y);\n            }\n        }\n\n        return this.child.dispatchEvent(event);\n    }\n\n    /**\n     * Get the rect of the child alongside more extra information,\n     * clipped/clamped to the bounds of the viewport. For internal use only.\n     */\n    protected getClippedViewport(): [vpX: number, vpY: number, vpW: number, vpH: number, origXDst: number, origYDst: number, xDst: number, yDst: number, wClipped: number, hClipped: number] {\n        // Calculate child's source and destination\n        const [vpX, vpY, vpW, vpH] = this.rect;\n        const [innerWidth, innerHeight] = this.child.dimensions;\n        const [xOffset, yOffset] = this.offset;\n\n        // viewport right and bottom\n        const vpR = vpX + vpW;\n        const vpB = vpY + vpH;\n\n        // original child destination left and top\n        const origXDst = vpX + xOffset;\n        const origYDst = vpY + yOffset;\n\n        // clipped child destination left, top, width and height\n        const xDst = Math.min(Math.max(origXDst, vpX), vpR);\n        const yDst = Math.min(Math.max(origYDst, vpY), vpB);\n        const wClipped = Math.min(Math.max(origXDst + innerWidth, vpX), vpR) - xDst;\n        const hClipped = Math.min(Math.max(origYDst + innerHeight, vpY), vpB) - yDst;\n\n        return [vpX, vpY, vpW, vpH, origXDst, origYDst, xDst, yDst, wClipped, hClipped];\n    }\n}", "/**\n * Rounds a given number up or down to a power of 2. Useful for working with\n * textures.\n *\n * @param number - The number to round\n * @param roundUp - If true, rounds the number to the smallest power of 2 greater\n * or equal to the input, else, rounds the number to the greatest power of 2\n * smaller or equal to the input.\n *\n * @returns Returns the rounded number\n *\n * @category Helper\n */\nexport function roundToPower2(number: number, roundUp = true): number {\n    const roundFun = roundUp ? Math.ceil : Math.floor;\n    return Math.pow(2, roundFun(Math.log2(number)));\n}", "/**\n * Checks whether a given number is a power of 2 greater than 0.\n *\n * @param number - The number to check\n * @returns Returns true if the number is a power of 2 greater than 0\n * @category Helper\n */\nexport function isPower2(number: number): boolean {\n    return (number & (number - 1)) === 0;\n}", "import { flagField, paintField } from '../decorators/FlagFields';\nimport { roundToPower2 } from '../helpers/roundToPower2';\nimport type { FillStyle } from '../theme/FillStyle';\nimport type { Widget } from '../widgets/Widget';\nimport { isPower2 } from '../helpers/isPower2';\nimport { BaseViewport } from './BaseViewport';\nimport { Msg } from './Strings';\n\n/**\n * A {@link Viewport} with an internal canvas, where the rendering context used\n * for the Viewport is the internal canvas' context instead of an inherited\n * context from a parent Viewport.\n *\n * Mostly used as the top-most Viewport, such as the Viewport in a {@link Root}.\n *\n * Coordinates are relative to the internal canvas, instead of absolute. Because\n * of this, viewport contents may be blurred if the position of the viewport is\n * fractional.\n *\n * @category Core\n */\nexport class CanvasViewport extends BaseViewport {\n    readonly context: CanvasRenderingContext2D;\n\n    /** The internal canvas. Widgets are painted to this */\n    readonly canvas: HTMLCanvasElement;\n    /**\n     * The maximum width the {@link CanvasViewport#canvas} can have. If the\n     * layout exceeds this width, then the content will be scaled to fit the\n     * canvas\n     */\n    @paintField\n    maxCanvasWidth = 16384;\n    /**\n     * The maximum height the {@link CanvasViewport#canvas} can have. If the\n     * layout exceeds this height, then the content will be scaled to fit the\n     * canvas\n     */\n    @paintField\n    maxCanvasHeight = 16384;\n    /**\n     * The resolution of the canvas. If possible, the canvas will be scaled by\n     * this amount.\n     */\n    @flagField('_forceResize')\n    resolution: number;\n    /** Does the canvas size need to be updated? For internal use only. */\n    protected _forceResize = true;\n    /** Previous horizontal effective scale. For internal use only. */\n    private _prevESX = 1;\n    /** Previous vertical effective scale. For internal use only. */\n    private _prevESY = 1;\n\n    /**\n     * Create a new CanvasViewport.\n     *\n     * Creates a new canvas with a starting width and height, setting\n     * {@link CanvasViewport#canvas} and {@link Viewport#context}. Failure to\n     * get a canvas context results in an exception.\n     */\n    constructor(child: Widget, resolution = 1, startingWidth = 64, startingHeight = 64) {\n        super(child, true);\n\n        this.resolution = resolution;\n\n        // Create internal canvas\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = startingWidth;\n        this.canvas.height = startingHeight;\n\n        // Get context out of canvas\n        const context = this.canvas.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error(Msg.CANVAS_CONTEXT);\n\n        this.context = context;\n        this.child.forceDirty();\n    }\n\n    /**\n     * The current dimensions of the\n     * {@link CanvasViewport#canvas | internal canvas}\n     */\n    get canvasDimensions(): [number, number] {\n        return [this.canvas.width, this.canvas.height];\n    }\n\n    /**\n     * Resolves the Viewport child's layout (including position) in one call,\n     * using the previous position.\n     *\n     * May resize or rescale the canvas.\n     *\n     * Expands {@link CanvasViewport#canvas} if the new layout is too big for\n     * the current canvas. Expansion is done in powers of 2 to avoid issues with\n     * external 3D libraries.\n     *\n     * @returns Returns true if the widget or canvas were resized, or the canvas rescaled, else, false.\n     */\n    override resolveLayout(): boolean {\n        let wasResized = super.resolveLayout();\n\n        // Re-scale canvas if neccessary.\n        if(wasResized || this._forceResize) {\n            this._forceResize = false;\n\n            // Canvas dimensions are rounded to the nearest power of 2, favoring\n            // bigger powers. This is to avoid issues with mipmapping, which\n            // requires texture sizes to be powers of 2. Make sure that the\n            // maximum canvas dimensions aren't exceeded\n            const [newUnscaledWidth, newUnscaledHeight] = this.child.dimensions;\n            const newWidth = newUnscaledWidth * this.resolution;\n            const newHeight = newUnscaledHeight * this.resolution;\n            const newCanvasWidth = Math.min(Math.max(roundToPower2(newWidth), this.canvas.width), this.maxCanvasWidth);\n            const newCanvasHeight = Math.min(Math.max(roundToPower2(newHeight), this.canvas.height), this.maxCanvasHeight);\n\n            if(newCanvasWidth === 0 || newCanvasHeight === 0) {\n                if(!BaseViewport.dimensionlessWarned) {\n                    BaseViewport.dimensionlessWarned = true;\n                    console.warn(Msg.DIMENSIONLESS_CANVAS);\n                }\n            }\n            else if(!isPower2(newCanvasWidth) || !isPower2(newCanvasHeight)) {\n                if(!BaseViewport.powerOf2Warned) {\n                    BaseViewport.powerOf2Warned = true;\n                    console.warn(Msg.NON_POW2_CANVAS);\n                }\n            }\n\n            // XXX force-mark child as dirty if the canvas was resized with a\n            // new scale. when copying using different scales, some artifacts\n            // are introduced. fix this by re-painting everything. since we're\n            // re-painting, theres no need to copy the old canvas contents\n            const oldCanvasWidth = this.canvas.width;\n            const oldCanvasHeight = this.canvas.height;\n            const [newESX, newESY] = this.effectiveScale;\n            let needsCopying = oldCanvasWidth !== 0 && oldCanvasHeight !== 0;\n            if(newESX !== this._prevESX || newESY !== this._prevESY) {\n                this._prevESX = newESX;\n                this._prevESY = newESY;\n                needsCopying = false;\n                wasResized = true;\n                this.child.forceDirty(false);\n                // bounds need to be finalized again because the scale just\n                // changed and so the ideal dimensions need to be re-rounded\n                this.child.finalizeBounds();\n            }\n\n            if(newCanvasWidth !== oldCanvasWidth || newCanvasHeight !== oldCanvasHeight) {\n                // Resizing a canvas clears its contents. To mitigate this, copy\n                // the canvas contents to a new canvas, resize the canvas and\n                // copy the contents back. To avoid unnecessary copying, the\n                // canvas will not be copied if the old dimensions of the child\n                // were 0x0\n                // TODO resizing is kinda expensive. maybe find a better way?\n                wasResized = true;\n                let copyCanvas = null;\n\n                if(needsCopying) {\n                    copyCanvas = document.createElement('canvas');\n                    copyCanvas.width = oldCanvasWidth;\n                    copyCanvas.height = oldCanvasHeight;\n\n                    const copyCtx = copyCanvas.getContext('2d');\n                    if(copyCtx === null)\n                        throw new Error(Msg.CANVAS_CONTEXT);\n\n                    copyCtx.globalCompositeOperation = 'copy';\n                    copyCtx.drawImage(\n                        this.canvas,\n                        0, 0, oldCanvasWidth, oldCanvasHeight,\n                        0, 0, oldCanvasWidth, oldCanvasHeight,\n                    );\n                }\n\n                this.canvas.width = newCanvasWidth;\n                this.canvas.height = newCanvasHeight;\n\n                if(copyCanvas !== null) {\n                    this.context.globalCompositeOperation = 'copy';\n                    this.context.drawImage(\n                        copyCanvas,\n                        0, 0, copyCanvas.width, copyCanvas.height,\n                        0, 0, Math.min(copyCanvas.width, this.maxCanvasWidth), Math.min(copyCanvas.height, this.maxCanvasHeight),\n                    );\n                    this.context.globalCompositeOperation = 'source-over';\n                }\n            }\n        }\n\n        return wasResized;\n    }\n\n    get effectiveScale(): [scaleX: number, scaleY: number] {\n        const [width, height] = this.child.dimensions;\n\n        return [\n            Math.min(this.maxCanvasWidth / width, this.resolution),\n            Math.min(this.maxCanvasHeight / height, this.resolution)\n        ];\n    }\n\n    /**\n     * Implements {@link Viewport#paint}, but only paints to the\n     * {@link CanvasViewport#canvas | internal canvas}. Call this instead of\n     * {@link Viewport#paint} if you are using this Viewport's canvas as the\n     * output canvas (such as in the {@link Root}).\n     */\n    paintToInternal(force: boolean): boolean {\n        // Paint child\n        const wasDirty = this.child.dirty;\n\n        // scale canvas if child dimensions exceed maximum canvas dimensions\n        const [scaleX, scaleY] = this.effectiveScale;\n        const needsScale = scaleX !== 1 || scaleY !== 1;\n        if(needsScale) {\n            this.context.save();\n            this.context.scale(scaleX, scaleY);\n        }\n\n        this.child.paint(force);\n\n        if(needsScale)\n            this.context.restore();\n\n        return wasDirty;\n    }\n\n    paint(force: boolean, backgroundFillStyle: FillStyle): boolean {\n        const wasDirty = this.paintToInternal(force);\n\n        // Paint to parent viewport, if any\n        if(this.parent !== null) {\n            const [vpX, vpY, vpW, vpH, origXDst, origYDst, xDst, yDst, wClipped, hClipped] = this.getClippedViewport();\n            const ctx = this.parent.context;\n\n            ctx.save();\n            ctx.globalCompositeOperation = 'copy';\n            ctx.fillStyle = backgroundFillStyle;\n            ctx.beginPath();\n            ctx.rect(vpX, vpY, vpW, vpH);\n            ctx.clip();\n\n            // Don't paint if outside of bounds\n            if(wClipped !== 0 && hClipped !== 0) {\n                const [esx, esy] = this.effectiveScale;\n\n                ctx.drawImage(\n                    this.canvas,\n                    (xDst - origXDst) * esx,\n                    (yDst - origYDst) * esy,\n                    wClipped * esx,\n                    hClipped * esy,\n                    xDst,\n                    yDst,\n                    wClipped,\n                    hClipped,\n                );\n            }\n\n            ctx.rect(xDst, yDst, wClipped, hClipped);\n            ctx.clip('evenodd');\n            ctx.fill();\n            ctx.restore();\n        }\n\n        return wasDirty;\n    }\n}", "import type { FillStyle } from '../theme/FillStyle';\nimport type { Widget } from \"../widgets/Widget\";\nimport { BaseViewport } from \"./BaseViewport\";\nimport { Msg } from './Strings';\n\n/**\n * A {@link Viewport} which inherits a rendering context from the closest parent\n * Viewport and paints {@link Widget | Widgets} by clipping them to the\n * Viewport's rectangle.\n *\n * @category Core\n */\nexport class ClippedViewport extends BaseViewport {\n    get context(): CanvasRenderingContext2D {\n        if(this.parent === null)\n            throw Msg.PARENTLESS_CLIPVP;\n\n        return this.parent.context;\n    }\n\n    get effectiveScale(): [scaleX: number, scaleY: number] {\n        if(this.parent === null)\n            throw Msg.PARENTLESS_CLIPVP;\n\n        return this.parent.effectiveScale;\n    }\n\n    constructor(child: Widget) {\n        super(child, false);\n    }\n\n    paint(force: boolean, backgroundFillStyle: FillStyle): boolean {\n        const wasDirty = this.child.dirty;\n\n        const [vpX, vpY, vpW, vpH, _origXDst, _origYDst, xDst, yDst, wClipped, hClipped] = this.getClippedViewport();\n        const ctx = this.context;\n\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = backgroundFillStyle;\n        ctx.beginPath();\n        ctx.rect(vpX, vpY, vpW, vpH);\n        ctx.clip();\n        ctx.rect(xDst, yDst, wClipped, hClipped);\n        ctx.clip('evenodd');\n        ctx.fill();\n        ctx.restore();\n\n        // Abort if outside of bounds\n        if(wClipped === 0 || hClipped === 0) {\n            this.child.dryPaint();\n            return wasDirty;\n        }\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(vpX, vpY, vpW, vpH);\n        ctx.clip();\n        this.child.paint(force);\n        ctx.restore();\n\n        return wasDirty;\n    }\n}", "/**\n * Alignment of multi-container contents along the main axis. Used for when\n * {@link MultiContainer} has unused space, even after distribution. Similar to\n * {@link Alignment}.\n *\n * @category Theme\n */\nexport const enum FlexAlignment {\n    /** Distribute unused space between each child. */\n    SpaceBetween = 'between',\n    /** Distribute unused space between each child and at start and end. */\n    SpaceAround = 'around',\n    /**\n     * Align the children to the start of the container, having the extra space\n     * at the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the children to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the children to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "/**\n * Alignment of container contents. Used for when {@link Container} has too much\n * space.\n *\n * @category Theme\n */\nexport const enum Alignment {\n    /** Give the extra space to the child, potentially stretching it. */\n    Stretch = 'stretch',\n    /**\n     * Align the child to the start of the container, having the extra space at\n     * the end. Equivalent to using a ratio of 0.\n     */\n    Start = 0,\n    /**\n     * Align the child to the center of the container, having the extra space\n     * split equally to both the start and the end. Equivalent to using a ratio\n     * of 0.5.\n     */\n    Center = 0.5,\n    /**\n     * Align the child to the end of the container, having the extra space at\n     * the start. Equivalent to using a ratio of 1.\n     */\n    End = 1,\n}\n", "import type { Bounds } from '../helpers/Bounds';\nimport { Widget } from '../widgets/Widget';\nimport { DynMsg } from '../core/Strings';\nimport { Event } from './Event';\n\n/**\n * An auto-scroll {@link Event}. Dispatched when a widget (or part of a widget)\n * wants to be visible to the user, such as the current caret position when\n * typing a character.\n *\n * This event is not static. As the event propagates in the UI tree, it will be\n * updated so that the wanted bounds are up-to-date.\n *\n * Note that this event is handled via {@link Widget#dispatchEvent} in a special\n * case; widgets will auto-capture the event if they are\n * {@link AutoScroll#originallyRelativeTo}, and {@link Widget#handleEvent} will\n * only be called if {@link Widget#propagatesEvents} is true. The event must be\n * re-captured by scrollable containers if a child of those containers captured\n * the event, and {@link AutoScroll#bounds} must be updated accordingly. See\n * {@link ScrollableViewportWidget#handleEvent} for an example of this.\n *\n * Has no focus type and does not need focus. Cannot be targetted.\n *\n * @category Event\n */\nexport class AutoScroll extends Event {\n    /**\n     * The widget that the auto-scroll {@link AutoScroll#bounds} will be\n     * relative to.\n     */\n    readonly originallyRelativeTo: Widget;\n    /**\n     * The portion of {@link AutoScroll#originallyRelativeTo} that needs to be\n     * in view. For example, if a 5x10 rectangle at the top-left of the widget\n     * needs to be selected, with a horizontal and vertical offset of 2, then\n     * the bounds would be [2, 2, 7, 12].\n     *\n     * Note that this is initially relative to originallyRelativeTo when the\n     * event is created, but the bounds must be relative to the capturer instead\n     * after the event is first captured.\n     *\n     * Can be changed by event handlers; typically it's changed to a scrollable\n     * container after the container is scrolled so that there are no issues\n     * with nested scrollable containers.\n     */\n    bounds: Bounds;\n\n    /**  Create a new AutoScroll. */\n    constructor(originallyRelativeTo: Widget, bounds: Bounds) {\n        super(null, null, false);\n\n        this.originallyRelativeTo = originallyRelativeTo;\n        this.bounds = [...bounds];\n    }\n\n    cloneWithTarget(target: Widget | null): AutoScroll {\n        if(target !== null && !AutoScroll.targetWarned) {\n            AutoScroll.targetWarned = true;\n            console.warn(DynMsg.UNTARGETABLE_EVENT('AutoScroll'));\n        }\n\n        const event = new AutoScroll(this.originallyRelativeTo, this.bounds);\n        return event;\n    }\n\n    static targetWarned = false;\n}", "import { Widget } from '../widgets/Widget';\nimport { DynMsg } from '../core/Strings';\nimport { Event } from './Event';\n\n/**\n * A tab selection {@link Event}. Dispatched when tab is pressed and either the\n * keyboard-focused widget doesn't capture the event, or when manually\n * dispatched.\n *\n * Has no focus type and does not need focus. Cannot be targetted.\n *\n * For internal use only. Do not use this event unless you know what you're\n * doing.\n *\n * @category Event\n */\nexport class TabSelect extends Event {\n    /** The widget that the tab selected will be done relative to. */\n    readonly relativeTo: Widget | null;\n    /**\n     * A working value; has the widget that this event is relative to been\n     * reached?\n     *\n     * If false, then the {@link Root} should be searched until\n     * {@link TabSelect#relativeTo} is reached, then, set this to true. If true,\n     * then the next visited widget that has a {@link Widget#tabFocusable} value\n     * of true will be focused.\n     *\n     * Note that if {@link TabSelect#relativeTo} is null, then this will be true by\n     * default.\n     */\n    reachedRelative: boolean;\n\n    /**  Create a new TabSelect. */\n    constructor(relativeTo: Widget | null, reversed: boolean) {\n        super(null, null, false, reversed);\n\n        this.relativeTo = relativeTo;\n        this.reachedRelative = relativeTo === null;\n    }\n\n    cloneWithTarget(target: Widget | null): TabSelect {\n        if(target !== null && !TabSelect.targetWarned) {\n            TabSelect.targetWarned = true;\n            console.warn(DynMsg.UNTARGETABLE_EVENT('TabSelect'));\n        }\n\n        const event = new TabSelect(this.relativeTo, this.reversed);\n        event.reachedRelative = this.reachedRelative;\n        return event;\n    }\n\n    static targetWarned = false;\n}\n", "import { Msg } from \"../core/Strings\";\n\n/** The rendering context used for measuring text. */\nlet measureContext: CanvasRenderingContext2D | null = null;\n\n/**\n * An LFU cache entry for `measureCache`. `font` and `text` are the paramenters\n * passed to `measureTextDims`, while `metrics` is the output of that function\n * for these inputs. `hits` is the total amount of cache hits that the cache\n * entry has had in total. `lastHit` is the timestamp of the last cache hit this\n * entry has had; this is for preventing a heavy burst of text measurements for\n * the same text/font from monopolising the entire cache and slowing everything\n * down. When there is no space in the cache, expired entries (too old) will be\n * removed first, even if they have a large amount of hits. If there are no\n * expired entries, the last entry (least total hits) is removed instead.\n */\ntype CacheEntry = [font: string, text: string, metrics: TextMetrics, hits: number, lastHit: number];\n\n/**\n * The LFU cache of measured text. Contains a limited amount of text\n * measurements ordered by most to least frequently used.\n */\nconst measureCache: Array<CacheEntry> = [];\n\n/** The size limit for the LFU cache (`measureCache`) */\nconst measureCacheLimit = 64;\n\n/**\n * The minimum amount of time since the last hit for a cache entry to be\n * considered as expired, in milliseconds.\n */\nconst expiryThreshold = 10000;\n\n/**\n * Measures the dimensions of a given string of text with a given font.\n *\n * Note that the first time calling this function is slower than subsequent\n * calls because a dedicated canvas context must be created.\n *\n * @returns Returns a the TextMetrics of the measured text.\n *\n * @category Helper\n */\nexport function measureTextDims(text: string, font: string): TextMetrics {\n    const measureTime = (new Date()).getTime();\n\n    // Get cached value\n    let cacheHit: CacheEntry | null = null;\n    let cacheHitIdx = -1;\n    let removalIdx = measureCache.length - 1;\n    for(let i = 0; i < measureCache.length; i++) {\n        const cacheVal = measureCache[i];\n        if(cacheVal[0] === font && cacheVal[1] === text) {\n            cacheHit = cacheVal;\n            cacheHitIdx = i;\n            break;\n        }\n\n        // Mark last expired cache entry for removal. If none is found, the last\n        // entry in the cache (even if not expired) is marked for removal.\n        if(measureTime - cacheVal[4] > expiryThreshold)\n            removalIdx = i;\n    }\n\n    // If there was a cache hit, increment hits, update last hit time, bump in\n    // cache and return cached metrics\n    if(cacheHit) {\n        const newFreq = ++cacheHit[3];\n        cacheHit[4] = measureTime;\n\n        if(cacheHitIdx > 0) {\n            let candidateIdx = 0;\n            for(; candidateIdx < cacheHitIdx; candidateIdx++) {\n                if(measureCache[candidateIdx][3] <= newFreq)\n                    break;\n            }\n\n            if(candidateIdx !== cacheHitIdx) {\n                measureCache.splice(cacheHitIdx, 1);\n                measureCache.splice(candidateIdx, 0, cacheHit);\n            }\n        }\n\n        return cacheHit[2];\n    }\n\n    // Get canvas context if not yet got\n    if(measureContext === null) {\n        const tempCanvas = document.createElement('canvas');\n        measureContext = tempCanvas.getContext('2d');\n        if(measureContext === null)\n            throw new Error(Msg.CANVAS_CONTEXT);\n    }\n\n    // Set font\n    measureContext.font = font;\n\n    // Measure text\n    const metrics = measureContext.measureText(text);\n\n    // Cache metrics. Remove least frequently used text entry if cache size\n    // exceeded.\n    if(measureCacheLimit > 0) {\n        if(measureCache.length === measureCacheLimit)\n            measureCache.splice(removalIdx, 1);\n\n        let candidateIdx = 0;\n        for(; candidateIdx < measureCache.length; candidateIdx++) {\n            if(measureCache[candidateIdx][3] <= 1)\n                break;\n        }\n\n        measureCache.splice(candidateIdx, 0, [font, text, metrics, 1, measureTime]);\n    }\n\n    return metrics;\n}\n", "import { measureTextDims } from '../helpers/measureTextDims';\nimport { multiFlagField } from '../decorators/FlagFields';\nimport { FillStyle } from '../theme/FillStyle';\nimport { Msg } from '../core/Strings';\n\nconst WIDTH_OVERRIDING_CHARS = new Set(['\\n', '\\t']);\n\n/**\n * A text render group. Contains all neccessary information to position a piece\n * of text.\n *\n * A 4-tuple containing, respectively, the inclusive index where the piece of\n * text starts, the exclusive index where the piece of text ends (including\n * characters that aren't rendered, such as newlines), the right horizontal\n * offset of the piece of text and whether the piece of text overrides width or\n * not.\n *\n * For characters that override width, the text range should have a length of 1\n * and will not be merged with other text render groups, else, it is a hint\n * containing the pre-measured size, for optimisation reasons, and may be merged\n * with other text render groups. Width-overidding groups where the text range\n * length is greater than 1 will have the length of each individual character as\n * an interpolation of the total length, where each character has equal width,\n * which is cheap, but innacurate; this is the reason why it is preferred to\n * have length 1 text range for width-overriding groups although you may still\n * want this for specific reasons (such as trailing space removal).\n * Width-overriding groups are also only meant to be used for whitespaces and\n * will therefore not be painted.\n *\n * Note that 0-width text render groups are valid and used for empty lines.\n *\n * @category Helper\n */\nexport type TextRenderGroup = [rangeStart: number, rangeEnd: number, right: number, overridesWidth: boolean];\n\n/**\n * A line range. Contains all neccessary information to render a line of text.\n * An array of text render groups.\n *\n * @category Helper\n */\nexport type LineRange = Array<TextRenderGroup>;\n\n/**\n * The mode to use for text wrapping in {@link TextHelper}.\n *\n * @category Helper\n */\nexport enum WrapMode {\n    /**\n     * Whitespaces always have width. The default wrapping mode for input\n     * widgets\n     */\n    Normal,\n    /**\n     * Whitespaces at the end of a line which result in an overflow have no\n     * width. The default wrapping mode for widgets that display text, since\n     * spaces at the beginning of a line due to wrapping looks weird in\n     * {@link Label | labels}. Whitespaces at the beginning of a new line are\n     * still kept, as they are deliberate.\n     */\n    Shrink,\n}\n\n/**\n * The mode to use for text alignment in {@link TextHelper}.\n *\n * @category Helper\n */\nexport enum TextAlignMode {\n    /** Align to the start of the line. Equivalent to a ratio of 0. */\n    Start = 0,\n    /** Align to the center of the line. Equivalent to a ratio of 0.5. */\n    Center = 0.5,\n    /** Align to the end of the line. Equivalent to a ratio of 0.5. */\n    End = 1,\n}\n\nconst CHARSET = '~!@#$%^&*()_+`1234567890-=qwertyuiop[]\\\\QWERTYUIOP{}|asdfghjkl;\\'ASDFGHJKL:\"zxcvbnm,./ZXCVBNM<>?';\n\n/**\n * An aggregate helper class for widgets that contain text.\n *\n * Contains utilities for measuring text dimensions, converting between offsets\n * in pixels and text indices and painting.\n *\n * @category Helper\n */\nexport class TextHelper {\n    /**\n     * The current string of text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    text = '';\n    /**\n     * The current font used for rendering text.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty', 'tabWidthDirty'])\n    font = '';\n    /**\n     * The current maximum text width. If not Infinite, then text will be\n     * wrapped and width will be set to maxWidth.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'maxWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'maxWidthDirty'])\n    maxWidth = Infinity;\n    /**\n     * The height of each line of text when wrapped. If null, then the helper\n     * will try to automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineHeight: number | null = null;\n    /**\n     * The amount of spacing between lines. If null, then the helper will try to\n     * automatically detect it.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'lineHeightSpacingDirty'])\n    lineSpacing: number | null = null;\n    /**\n     * The amount of spaces that each tab character is equivalent to. By\n     * default, it is equivalent to 4 spaces.\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty', 'tabWidthDirty'])\n    tabWidth = 4;\n    /**\n     * The mode for text wrapping\n     *\n     * @decorator `@multiFlagField(['_dirty', 'measureDirty'])`\n     */\n    @multiFlagField(['_dirty', 'measureDirty'])\n    wrapMode: WrapMode = WrapMode.Normal;\n    /**\n     * The text alignment mode. Can also be a ratio.\n     *\n     * Note that this only aligns text in the text's width. If you have wrapping\n     * disabled (maxWidth === Infinity), then you may still need to align the\n     * widget that uses this text helper with a {@link BaseContainer}.\n     */\n    @multiFlagField(['_dirty'])\n    alignMode: TextAlignMode | number = TextAlignMode.Start;\n\n    /** The current largest text width. May be outdated. */\n    private _width = 0;\n    /** The current total text height. May be outdated. */\n    private _height = 0;\n    /** The current {@link TextHelper#lineHeight}. May be outdated */\n    private _lineHeight = 0;\n    /** The current {@link TextHelper#lineSpacing}. May be outdated */\n    private _lineSpacing = 0;\n    /** The actual {@link TextHelper#tabWidth} in pixels. May be outdated */\n    private _tabWidth = 0;\n\n    /** Does the text need to be re-measured? */\n    private measureDirty = true;\n    /** Has the maximum width been changed? */\n    private maxWidthDirty = false;\n    /** Does the line height or spacing need to be re-measured? */\n    private lineHeightSpacingDirty = true;\n    /** Does the tab width need to be re-measured? */\n    private tabWidthDirty = true;\n    /** Has the text (or properties associated with it) changed? */\n    private _dirty = false;\n    /** See {@link TextHelper#lineRanges}. For internal use only. */\n    private _lineRanges: Array<LineRange> = [];\n    /** Are any of the lines wrapped? For internal use only. */\n    private hasWrappedLines = false;\n\n    /**\n     * Has the text (or properties associated with it) changed? Resets\n     * {@link TextHelper#_dirty} to false\n     */\n    get dirty(): boolean {\n        const wasDirty = this._dirty;\n        this._dirty = false;\n        return wasDirty;\n    }\n\n    /**\n     * Measure a slice of text taking left offset into account. If left offset\n     * is 0, then this will also add the left bounding box overhang. If not,\n     * then it will just return the width.\n     *\n     * Only for slices of text which have no width-overriding characters, else,\n     * you will get wrong measurements.\n     *\n     * @returns Returns the new horizontal offset\n     */\n    private measureTextSlice(left: number, start: number, end: number): number {\n        const metrics = measureTextDims(this.text.slice(start, end), this.font);\n        if(left === 0)\n            return metrics.width + Math.max(0, metrics.actualBoundingBoxLeft);\n        else\n            return left + metrics.width;\n    }\n\n    /**\n     * Get width from line range start to index. Handles out of bounds indices,\n     * but keeps them in the same line\n     */\n    private getLineRangeWidthUntil(range: LineRange, index: number): number {\n        // If before or at first group's start index, 0 width\n        if(index <= range[0][0])\n            return 0;\n\n        // Find text render group that this index belongs to\n        let groupIndex = 0;\n        for(; groupIndex < range.length; groupIndex++) {\n            // If index is at this group's end, return group's right value.\n            // Most width-overriding groups have a length of 1 and therefore\n            // just stop here\n            const group = range[groupIndex];\n            const groupEnd = group[1];\n            if(index == groupEnd)\n                return group[2];\n            else if(index >= group[0] && index < groupEnd)\n                break;\n        }\n\n        // If index was after line end, pick end of last group\n        if(groupIndex === range.length)\n            return range[groupIndex - 1][2];\n\n        // Find left value\n        let left = 0;\n        if(groupIndex > 0)\n            left = range[groupIndex - 1][2];\n\n        // Measure the slice of text. Interpolate if it's a width-overidding\n        // group\n        const group = range[groupIndex];\n        if(group[3])\n            return left + group[2] * (index - group[0]) / (group[1] - group[0]);\n        else\n            return this.measureTextSlice(left, group[0], index);\n    }\n\n    /**\n     * Similar to {@link measureTextDims}, but uses text render groups for\n     * optimisation purposes and for the ability of individual characters to\n     * override their natively measured size; tabs having a dynamic size that\n     * aligns them to multiples of a value and newlines having no length.\n     *\n     * @param start - The inclusive index to start measuring at. If there are render groups and unmeasured text before this index, then this value will be overridden to include the unmeasured text. Render groups will also be merged if they don't override width.\n     * @param end - The exclusive index to stop measuring at.\n     * @param lineRange - The current text render groups for this line of text. This will be updated in place.\n     * @param maxWidth - The maximum width of a line of text. If the line contains a single character, this will be ignored.\n     * @returns Returns true if the line range was modified and it fit into the maximum width\n     */\n    private measureText(start: number, end: number, maxWidth: number, lineRange: LineRange): boolean {\n        // Remove render groups that intersect the range that will be measured.\n        // Removing a group means that the group will have to be re-measured and\n        // therefore start is overridden\n        let wantedGroups = 0;\n        for(; wantedGroups < lineRange.length; wantedGroups++) {\n            const group: TextRenderGroup = lineRange[wantedGroups];\n            if(start >= group[0] && start < group[1]) {\n                start = group[0];\n                break;\n            }\n        }\n\n        // Correct start value; attempt to merge with previous groups or expand\n        // the measurement to include previous parts of text that haven't been\n        // measured yet\n        if(wantedGroups > 0) {\n            let lastGroup: TextRenderGroup | null = lineRange[wantedGroups - 1];\n            if(lastGroup[1] !== start) {\n                start = lastGroup[1];\n\n                if(--wantedGroups > 0)\n                    lastGroup = lineRange[wantedGroups];\n                else\n                    lastGroup = null;\n            }\n\n            if(lastGroup !== null && !lastGroup[3] && !WIDTH_OVERRIDING_CHARS.has(this.text[start])) {\n                start = lastGroup[0];\n                wantedGroups--;\n            }\n        }\n\n        // Find left horizontal offset\n        let left = 0;\n        if(wantedGroups > 0)\n            left = lineRange[wantedGroups - 1][2];\n\n        // Measure range of text, potentially splitting it into render groups\n        let groupStart = start;\n        const addedGroups: Array<TextRenderGroup> = [];\n        while(groupStart < end) {\n            if(this.text[groupStart] === '\\t') {\n                // Align to tab width\n                const tabWidth = this.actualTabWidth;\n                left = (Math.floor(left / tabWidth) + 1) * tabWidth;\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n            }\n            else if(this.text[groupStart] === '\\n') {\n                // Make it 0-width and ignore all other text\n                addedGroups.push([groupStart, ++groupStart, left, true]);\n\n                if(groupStart < end)\n                    console.warn(Msg.ROGUE_NEWLINE);\n\n                break;\n            }\n            else {\n                // Find group end index; at next width-overriding character or\n                // at end\n                let nextNewline = this.text.indexOf('\\n', groupStart + 1);\n                if(nextNewline === -1)\n                    nextNewline = Infinity;\n\n                let nextTab = this.text.indexOf('\\t', groupStart + 1);\n                if(nextTab === -1)\n                    nextTab = Infinity;\n\n                const groupEnd = Math.min(nextNewline, nextTab, end);\n\n                // Measure group\n                left = this.measureTextSlice(left, groupStart, groupEnd);\n                addedGroups.push([groupStart, groupEnd, left, false]);\n\n                groupStart = groupEnd;\n            }\n        }\n\n        // Check if this fits in maximum width\n        const groupCount = wantedGroups + addedGroups.length;\n        const lastGroup = addedGroups[addedGroups.length - 1]\n                            ?? lineRange[wantedGroups - 1]\n                            ?? null;\n\n        if(lastGroup === null) {\n            // Lines ranges must have at least one group\n            lineRange.length = 0;\n            lineRange.push([start, start, 0, false]);\n            return true;\n        }\n        else if((groupCount === 1 && (lastGroup[1] - lastGroup[0]) <= 1) ||\n                lastGroup[2] <= maxWidth) {\n            lineRange.length = wantedGroups;\n            lineRange.push(...addedGroups);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Update {@link TextHelper#_width}, {@link TextHelper#_lineHeight} and\n     * {@link TextHelper#_lineSpacing}. Sets {@link TextHelper#measureDirty} to\n     * false. Does nothing if measurement is not needed.\n     */\n    private updateTextDims(): void {\n        // Update line height or line spacing if needed\n        if(this.lineHeightSpacingDirty) {\n            this.lineHeightSpacingDirty = false;\n\n            const oldLineHeight = this._lineHeight;\n            const oldLineSpacing = this._lineSpacing;\n\n            if(this.lineHeight === null || this.lineSpacing === null) {\n                const metrics = measureTextDims(CHARSET, this.font);\n\n                if(this.lineHeight === null)\n                    this._lineHeight = metrics.actualBoundingBoxAscent;\n                else\n                    this._lineHeight = this.lineHeight;\n\n                if(this.lineSpacing === null)\n                    this._lineSpacing = metrics.actualBoundingBoxDescent;\n                else\n                    this._lineSpacing = this.lineSpacing;\n            }\n            else {\n                this._lineHeight = this.lineHeight;\n                this._lineSpacing = this.lineSpacing;\n            }\n\n            // If line height or spacing changed, text needs to be re-measured\n            if(oldLineHeight !== this._lineHeight || oldLineSpacing !== this._lineSpacing)\n                this.measureDirty = true;\n        }\n\n        // If maximum width changed, check if text needs to be re-measured\n        if(this.maxWidthDirty) {\n            this.maxWidthDirty = false;\n\n            if(this.maxWidth === Infinity) {\n                // No wrapping, but some lines were wrapped. Must re-measure\n                // text\n                if(this.hasWrappedLines)\n                    this.measureDirty = true;\n            }\n            else {\n                // Wrapping, but no lines were wrapped and maxWidth is smaller\n                // than previous width. Must re-measure text. If lines were\n                // wrapped, must also re-measure\n                if(this.hasWrappedLines || this._width > this.maxWidth)\n                    this.measureDirty = true;\n            }\n        }\n\n        // Update tab width if needed\n        if(this.tabWidthDirty) {\n            this.tabWidthDirty = false;\n            this._tabWidth = measureTextDims(' ', this.font).width * this.tabWidth;\n        }\n\n        // Abort if measurement not needed\n        if(!this.measureDirty)\n            return;\n\n        // Mark as clean\n        this.measureDirty = false;\n        this.hasWrappedLines = false;\n\n        const fullLineHeight = this._lineHeight + this._lineSpacing;\n\n        if(this.text.length === 0) {\n            // Special case for empty string; set height to height of single\n            // line and width to 0 if maxWidth is not set or maxWidth if set\n            this._height = fullLineHeight;\n            this._width = this.maxWidth === Infinity ? 0 : this.maxWidth;\n            this._lineRanges.length = 1;\n            this._lineRanges[0] = [[0, 0, 0, false]];\n        }\n        else if(this.maxWidth === Infinity) {\n            // Don't wrap text, but split lines when there's a newline character\n            this._lineRanges.length = 0;\n            let lineStart = 0;\n            this._height = 0;\n            this._width = 0;\n\n            const text = this.text;\n            // eslint-disable-next-line no-constant-condition\n            while(true) {\n                // Where is the next newline?\n                const newline = this.text.indexOf('\\n', lineStart);\n                const atEnd = newline === -1;\n                const end = atEnd ? text.length : (newline + 1);\n\n                // Measure this block of text and add it to the line ranges\n                const range: LineRange = [];\n                this.measureText(lineStart, end, Infinity, range);\n                this._lineRanges.push(range);\n\n                this._height += fullLineHeight;\n                const width = range[range.length - 1][2];\n                if(width > this._width)\n                    this._width = width;\n\n                // At end, abort\n                if(atEnd)\n                    break;\n\n                // Set start of next line\n                lineStart = end;\n            }\n        }\n        else {\n            // Wrap text\n            this._lineRanges.length = 0;\n            let range: LineRange = [];\n            const text = this.text;\n            const spaceRegex = /\\s/;\n            let wordStart = -1;\n\n            for(let i = 0; i <= text.length;) {\n                const isSpace = spaceRegex.test(text[i]);\n                const atEnd = i === text.length;\n\n                // If this is a whitespace, wrap the previous word and check\n                // where this character fits\n                if(isSpace || atEnd) {\n                    // Try fitting word if any\n                    if(wordStart >= 0 && !this.measureText(wordStart, i, this.maxWidth, range)) {\n                        // Overflow, check if word fits in new line\n                        this.hasWrappedLines = true;\n                        const newRange: LineRange = [];\n                        if(this.measureText(wordStart, i, this.maxWidth, newRange)) {\n                            // Fits in new line. Push old line to line ranges if\n                            // it had any text render groups\n                            if(range.length === 0)\n                                throw new Error(Msg.EMPTY_LINE_RANGE);\n\n                            this._lineRanges.push(range);\n                            range = newRange;\n                        }\n                        else {\n                            // Doesn't fit in new line. Fit as much as possible\n                            // in current line and move rest to new line by\n                            // backtracking to where the split occurs. Don't\n                            // reverse this loop; although it may seem more\n                            // efficient, it breaks when the word is broken\n                            // across more than 2 lines\n                            let j = wordStart;\n                            for(; j < i - 1; j++) {\n                                if(!this.measureText(j, j + 1, this.maxWidth, range))\n                                    break;\n                            }\n                            this._lineRanges.push(range);\n                            range = newRange;\n\n                            i = j;\n                            wordStart = j;\n                            continue;\n                        }\n                    }\n\n                    wordStart = -1;\n\n                    // End line\n                    if(atEnd) {\n                        // If there isn't a render group in the line range yet,\n                        // add it. Use last group's position. If there isn't a\n                        // last group, default to the very beginning\n                        if(range.length === 0) {\n                            const lastLineRange = this._lineRanges[this._lineRanges.length - 1];\n                            if(lastLineRange === undefined)\n                                range.push([0, 0, 0, false]);\n                            else {\n                                const lastGroup = lastLineRange[lastLineRange.length - 1];\n                                if(lastGroup === undefined)\n                                    range.push([0, 0, 0, false]);\n                                else\n                                    range.push([lastGroup[1], lastGroup[1], 0, false]);\n                            }\n                        }\n\n                        this._lineRanges.push(range);\n                        break;\n                    }\n\n                    // Try fitting whitespace character\n                    if(text[i] === '\\n') {\n                        // Newline character. Break line, but measure text\n                        // anyways to update line range\n                        this.measureText(i, i + 1, Infinity, range);\n                        this._lineRanges.push(range);\n                        range = [];\n                    }\n                    else if(!this.measureText(i, i + 1, this.maxWidth, range)) {\n                        // Regular whitespace character overflow: put whitespace\n                        // in next line but measure it anyways to update line\n                        // range. If in the shrink wrap mode, then group up as\n                        // many whitespaces as possible and make a zero-width\n                        // group out of them\n                        if(this.wrapMode === WrapMode.Shrink) {\n                            const spaceGroupStart = i;\n                            do {\n                                i++;\n                            } while(text[i] !== '\\n' && spaceRegex.test(text[i]));\n\n                            const lastGroup = range[range.length - 1];\n                            range.push([\n                                spaceGroupStart,\n                                i,\n                                lastGroup !== undefined ? lastGroup[2] : 0,\n                                true,\n                            ]);\n                            this._lineRanges.push(range);\n                            range = [];\n                            continue;\n                        }\n                        else {\n                            this.hasWrappedLines = true;\n                            this._lineRanges.push(range);\n                            range = [];\n                            this.measureText(i, i + 1, Infinity, range);\n                        }\n                    }\n                }\n                else if(wordStart === -1)\n                    wordStart = i;\n\n                // Incrementing down here so that we don't have to do i = j - 1\n                // when splitting words\n                i++;\n            }\n\n            // Calculate dimensions\n            this._width = this.maxWidth;\n            this._height = fullLineHeight * this._lineRanges.length;\n        }\n    }\n\n    /**\n     * Paint a single text render group with a given offset and left value for\n     * checking if the group is zero-width. left value must not be shifted.\n     *\n     * Used mainly for injecting debug code; you won't get much use out of this\n     * method unless you have a very specific need.\n     */\n    paintGroup(ctx: CanvasRenderingContext2D, group: TextRenderGroup, left: number, x: number, y: number): void {\n        // Skip width-overidding or zero-width render groups\n        if(!group[3] && group[2] > left)\n            ctx.fillText(this.text.slice(group[0], group[1]), x, y);\n    }\n\n    /** Paint all line ranges. */\n    paint(ctx: CanvasRenderingContext2D, fillStyle: FillStyle, x: number, y: number): void {\n        // Clip\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(x, y, this.width, this.height);\n        ctx.clip();\n\n        // Apply fill style and font\n        ctx.font = this.font;\n        ctx.fillStyle = fillStyle;\n        ctx.textBaseline = 'alphabetic';\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // Paint line (or lines) of text\n        const fullLineHeight = this.fullLineHeight;\n        let yOffset = y + this._lineHeight;\n        for(let line = 0; line < this._lineRanges.length; line++) {\n            let left = 0;\n            const shift = this.getLineShift(line);\n            for(const group of this._lineRanges[line]) {\n                this.paintGroup(ctx, group, left, x + left + shift, yOffset);\n                left = group[2];\n            }\n\n            yOffset += fullLineHeight;\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the beginning of a character at\n     * a given index.\n     *\n     * See {@link TextHelper#findIndexOffsetFromOffset} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the offset, in pixels. Vertical offset in the tuple is at the top of the character. Note that this is not neccessarily an integer.\n     */\n    findOffsetFromIndex(index: number): [x: number, yTop: number] {\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // If index is 0, an invalid negative number or there are no lines, it\n        // is at the beginning\n        if(index <= 0 || this._lineRanges.length === 0)\n            return [this.getLineShift(0), 0];\n\n        // Check which line the index is in\n        let line = 0;\n        for(const range of this._lineRanges) {\n            if(index < range[range.length - 1][1])\n                break;\n\n            line++;\n        }\n\n        // Special case; the index is after the end, pick the end of the text\n        if(line >= this._lineRanges.length) {\n            line = this._lineRanges.length - 1;\n            index = this.text.length;\n        }\n\n        // Get horizontal offset\n        return [\n            this.getLineRangeWidthUntil(this._lineRanges[line], index) + this.getLineShift(line),\n            line * this.fullLineHeight,\n        ];\n    }\n\n    /**\n     * Get the index and horizontal offset, in pixels, of the beginning of a\n     * character at a given offset.\n     *\n     * See {@link TextHelper#findOffsetFromIndex} for the opposite.\n     *\n     * @returns Returns a 2-tuple containing the index of the character at the offset and a 2-tuple containing the offset, in pixels. Note that this is not neccessarily an integer. Note that the returned offset is not the same as the input offset. The returned offset is exactly at the beginning of the character. This is useful for implementing selectable text.\n     */\n    findIndexOffsetFromOffset(offset: [number, number]): [number, [number, number]] {\n        // If offset is before or at first character, text is empty or there are\n        // no lines, default to index 0\n        const fullLineHeight = this.fullLineHeight;\n        const firstShift = this.getLineShift(0);\n        if(this.text === '' || (offset[0] <= firstShift && offset[1] < fullLineHeight) || offset[1] < 0)\n            return [0, [firstShift, 0]];\n\n        // Find line being selected\n        const line = Math.floor(offset[1] / fullLineHeight);\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        // If this is beyond the last line, pick the last character\n        if(line >= this._lineRanges.length) {\n            const index = this.text.length;\n            return [index, this.findOffsetFromIndex(index)];\n        }\n\n        // If this is an empty line, stop\n        const yOffset = line * fullLineHeight;\n        const range = this._lineRanges[line];\n        const shift = this.getLineShift(line);\n        if(range.length === 1 && range[0][0] === range[0][1])\n            return [range[0][0], [range[0][2] + shift, yOffset]];\n\n        // For each character, find index at which offset is smaller than\n        // total length minus half length of current character\n        const lineStart = range[0][0];\n\n        // Special case; if line range ends with a newline, ignore last\n        // character\n        let lineEnd = range[range.length - 1][1];\n        if(this.text[lineEnd - 1] === '\\n')\n            lineEnd--;\n\n        let closestNext = -1;\n        let closestNextLen = 0;\n        const xOffsetUnshifted = offset[0] - shift;\n        let start = lineStart, end = lineEnd + 1, iLast = 0, lenLast = 0;\n        do {\n            // Measure length from the line start to the end of the current\n            // character\n            const i = start + Math.floor((end - start) / 2);\n            const len = this.getLineRangeWidthUntil(range, i);\n\n            if(len >= xOffsetUnshifted) {\n                end = i;\n                closestNext = i;\n                closestNextLen = len;\n            }\n            else {\n                start = i + 1;\n                iLast = i;\n                lenLast = len;\n            }\n        } while(start !== end);\n\n        // If cursor is after halfway point of character, use next character\n        // instead\n        if(iLast < lineEnd) {\n            const iNext = iLast + 1;\n            let lenNext = closestNextLen;\n            if(closestNext !== iNext)\n                lenNext = this.getLineRangeWidthUntil(range, iNext);\n\n            const mid = lenLast + (lenNext - lenLast) / 2;\n            if(xOffsetUnshifted >= mid)\n                return [iNext, [lenNext + shift, yOffset]];\n        }\n\n        return [iLast, [lenLast + shift, yOffset]];\n    }\n\n    /**\n     * Get a line number from a given cursor index. If out of bounds, returns\n     * nearest in-bounds line. Line numbers start at 0.\n     */\n    getLine(index: number): number {\n        if(index <= 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        for(let line = 0; line < this._lineRanges.length; line++) {\n            const lineRange = this._lineRanges[line];\n            const lastGroup = lineRange[lineRange.length - 1];\n            if(index < lastGroup[1])\n                return line;\n        }\n\n        return this._lineRanges.length - 1;\n    }\n\n    /**\n     * Get the index of the start of a line. If out of bounds, returns the\n     * nearest in-bounds index\n     */\n    getLineStart(line: number): number {\n        if(line <= 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line >= this._lineRanges.length) {\n            const lastLine = this._lineRanges[this._lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        return this._lineRanges[line][0][0];\n    }\n\n    /**\n     * Get the index of the end of a line.\n     *\n     * @param includeNewlines - If false, newline characters will be ignored and the end will be at their index, instead of after their index\n     */\n    getLineEnd(line: number, includeNewlines = true): number {\n        if(line < 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line >= this._lineRanges.length) {\n            const lastLine = this._lineRanges[this._lineRanges.length - 1];\n            return lastLine[lastLine.length - 1][1];\n        }\n\n        const lineRange = this._lineRanges[line];\n        const lastGroup = lineRange[lineRange.length - 1];\n        const lastIndex = lastGroup[1];\n        if(!includeNewlines && lastIndex > 0 &&\n           this.text[lastIndex - 1] === '\\n' && lastGroup[0] !== lastGroup[1])\n            return lastIndex - 1;\n        else\n            return lastIndex;\n    }\n\n    /**\n     * Get the horizontal offset, in pixels, of the start of a line. Takes text\n     * wrapping into account. Line indices before first line will be treated as\n     * the first line, after the last line will be treated as a new empty line.\n     */\n    getLineShift(line: number): number {\n        // No need to do any logic if aligned to the start\n        const ratio: number = this.alignMode;\n        if(ratio === 0)\n            return 0;\n\n        // Update line ranges if needed\n        this.updateTextDims();\n\n        if(line < 0)\n            line = 0;\n        else if(line >= this._lineRanges.length)\n            return this.width * ratio;\n\n        const lineRange = this._lineRanges[line];\n        return (this.width - lineRange[lineRange.length - 1][2]) * ratio;\n    }\n\n    /** The current text width. Re-measures text if neccessary. */\n    get width(): number {\n        this.updateTextDims();\n        return this._width;\n    }\n\n    /** The current total text height. Re-measures text if neccessary. */\n    get height(): number {\n        this.updateTextDims();\n        return this._height;\n    }\n\n    /**\n     * Which range of text indices are used for each line.\n     *\n     * If there is no text wrapping (maxWidth is Infinity), then this will\n     * contain a single tuple containing [0, (text length)].\n     *\n     * If there is text wrapping, then this will be an array where each member\n     * is a tuple containing the starting index of a line of text and the ending\n     * index (exclusive) of a line of text.\n     */\n    get lineRanges(): Array<LineRange> {\n        this.updateTextDims();\n        return [...this._lineRanges];\n    }\n\n    /**\n     * Get the current line height, even if {@link TextHelper#lineHeight} is\n     * null. Re-measures line height if neccessary.\n     */\n    get actualLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight;\n    }\n\n    /**\n     * Get the current line spacing, even if {@link TextHelper#lineSpacing} is\n     * null. Re-measures line spacing if neccessary.\n     */\n    get actualLineSpacing(): number {\n        this.updateTextDims();\n        return this._lineSpacing;\n    }\n\n    /** Get the current tab width in pixels. Re-measures if neccessary */\n    get actualTabWidth(): number {\n        this.updateTextDims();\n        return this._tabWidth;\n    }\n\n    /**\n     * Get the height between the start of each line; the full line height.\n     *\n     * Equivalent to the sum of {@link TextHelper#actualLineHeight} and\n     * {@link TextHelper#actualLineSpacing}\n     */\n    get fullLineHeight(): number {\n        this.updateTextDims();\n        return this._lineHeight + this._lineSpacing;\n    }\n}\n", "import type { FlexAlignment2D } from './FlexAlignment2D';\nimport type { ThemeProperties } from './ThemeProperties';\nimport { TextAlignMode } from '../helpers/TextHelper';\nimport type { Alignment2D } from './Alignment2D';\nimport { FlexAlignment } from './FlexAlignment';\nimport type { FillStyle } from './FillStyle';\nimport type { Padding } from './Padding';\nimport { Alignment } from './Alignment';\nimport type { Theme } from './Theme';\n\n/**\n * The base class for {@link Widget} and {@link Theme}. The backbone of the\n * theming system.\n *\n * @category Theme\n */\nexport class BaseTheme implements ThemeProperties {\n    /** See {@link BaseTheme#fallbackTheme} */\n    private _fallbackTheme?: Theme;\n    /** Listener for theme fallback */\n    private listener: ((property: string | null) => void) | null = null;\n\n    /**\n     * The fallback theme. If this theme has a missing property, the fallback\n     * theme's property will be used instead. This will automatically\n     * (un)subscribe to/from the fallback theme.\n     */\n    protected get fallbackTheme(): Theme | undefined {\n        return this._fallbackTheme;\n    }\n\n    protected set fallbackTheme(newTheme: Theme | undefined) {\n        if(this._fallbackTheme === newTheme)\n            return;\n\n        // Unsubscribe from old theme\n        const oldTheme = this._fallbackTheme;\n        if(typeof oldTheme !== 'undefined' && this.listener !== null)\n            oldTheme.unsubscribe(this.listener);\n\n        // Subscribe to new theme\n        if(typeof newTheme !== 'undefined') {\n            this.listener = (property: string | null) => this.onThemeUpdated(property);\n            newTheme.subscribe(this.listener);\n        }\n\n        // Set theme\n        this._fallbackTheme = newTheme;\n\n        // Notify that the fallback theme has changed\n        this.onThemeUpdated();\n    }\n\n    /**\n     * Called when the fallback theme changes. Does nothing by default.\n     *\n     * @param property - The property name of the theme property that was updated. If a general theme update, then this will be null and all theme properties should be treated as changed.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    protected onThemeUpdated(property: string | null = null): void {}\n\n    /** Create a new BaseTheme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        this._fallbackTheme = fallbackTheme;\n\n        if(typeof properties === 'undefined')\n            return;\n\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE START\n        this._canvasFill = properties.canvasFill;\n        this._containerPadding = properties.containerPadding;\n        this._containerAlignment = properties.containerAlignment;\n        this._multiContainerSpacing = properties.multiContainerSpacing;\n        this._multiContainerAlignment = properties.multiContainerAlignment;\n        this._primaryFill = properties.primaryFill;\n        this._accentFill = properties.accentFill;\n        this._backgroundFill = properties.backgroundFill;\n        this._backgroundGlowFill = properties.backgroundGlowFill;\n        this._sliderMinLength = properties.sliderMinLength;\n        this._sliderThickness = properties.sliderThickness;\n        this._bodyTextFont = properties.bodyTextFont;\n        this._bodyTextFill = properties.bodyTextFill;\n        this._bodyTextHeight = properties.bodyTextHeight;\n        this._bodyTextSpacing = properties.bodyTextSpacing;\n        this._bodyTextAlign = properties.bodyTextAlign;\n        this._checkboxLength = properties.checkboxLength;\n        this._checkboxInnerPadding = properties.checkboxInnerPadding;\n        this._inputBackgroundFill = properties.inputBackgroundFill;\n        this._inputSelectBackgroundFill = properties.inputSelectBackgroundFill;\n        this._inputTextFont = properties.inputTextFont;\n        this._inputTextFill = properties.inputTextFill;\n        this._inputTextFillDisabled = properties.inputTextFillDisabled;\n        this._inputTextFillInvalid = properties.inputTextFillInvalid;\n        this._inputTextHeight = properties.inputTextHeight;\n        this._inputTextSpacing = properties.inputTextSpacing;\n        this._inputTextInnerPadding = properties.inputTextInnerPadding;\n        this._inputTextMinWidth = properties.inputTextMinWidth;\n        this._inputTextAlign = properties.inputTextAlign;\n        this._blinkRate = properties.blinkRate;\n        this._cursorThickness = properties.cursorThickness;\n        this._scrollBarThickness = properties.scrollBarThickness;\n        this._scrollBarMinPercent = properties.scrollBarMinPercent;\n        this._scrollBarMinPixels = properties.scrollBarMinPixels;\n        this._radioButtonLength = properties.radioButtonLength;\n        this._radioButtonInnerPadding = properties.radioButtonInnerPadding;\n        // XXX BASETHEME CTOR AUTO-GENERATED CODE END\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE START\n    /** See {@link BaseTheme#canvasFill}. For internal use only. */\n    private _canvasFill?: FillStyle;\n\n    get canvasFill(): FillStyle {\n        return this._canvasFill ?? this._fallbackTheme?.canvasFill ?? 'rgba(0,0,0,0.5)';\n    }\n\n    set canvasFill(value: FillStyle | undefined) {\n        if(this._canvasFill !== value) {\n            this._canvasFill = value;\n            this.onThemeUpdated('canvasFill');\n        }\n    }\n\n    /** See {@link BaseTheme#containerPadding}. For internal use only. */\n    private _containerPadding?: Padding;\n\n    get containerPadding(): Padding {\n        return this._containerPadding ?? this._fallbackTheme?.containerPadding ?? <Padding>{left: 4, right: 4, top: 4, bottom: 4};\n    }\n\n    set containerPadding(value: Padding | undefined) {\n        if(this._containerPadding !== value) {\n            this._containerPadding = value;\n            this.onThemeUpdated('containerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#containerAlignment}. For internal use only. */\n    private _containerAlignment?: Alignment2D;\n\n    get containerAlignment(): Alignment2D {\n        return this._containerAlignment ?? this._fallbackTheme?.containerAlignment ?? <Alignment2D>{horizontal: Alignment.Start, vertical: Alignment.Start};\n    }\n\n    set containerAlignment(value: Alignment2D | undefined) {\n        if(this._containerAlignment !== value) {\n            this._containerAlignment = value;\n            this.onThemeUpdated('containerAlignment');\n        }\n    }\n\n    /** See {@link BaseTheme#multiContainerSpacing}. For internal use only. */\n    private _multiContainerSpacing?: number;\n\n    get multiContainerSpacing(): number {\n        return this._multiContainerSpacing ?? this._fallbackTheme?.multiContainerSpacing ?? 4;\n    }\n\n    set multiContainerSpacing(value: number | undefined) {\n        if(this._multiContainerSpacing !== value) {\n            this._multiContainerSpacing = value;\n            this.onThemeUpdated('multiContainerSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#multiContainerAlignment}. For internal use only. */\n    private _multiContainerAlignment?: FlexAlignment2D;\n\n    get multiContainerAlignment(): FlexAlignment2D {\n        return this._multiContainerAlignment ?? this._fallbackTheme?.multiContainerAlignment ?? <FlexAlignment2D>{main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch};\n    }\n\n    set multiContainerAlignment(value: FlexAlignment2D | undefined) {\n        if(this._multiContainerAlignment !== value) {\n            this._multiContainerAlignment = value;\n            this.onThemeUpdated('multiContainerAlignment');\n        }\n    }\n\n    /** See {@link BaseTheme#primaryFill}. For internal use only. */\n    private _primaryFill?: FillStyle;\n\n    get primaryFill(): FillStyle {\n        return this._primaryFill ?? this._fallbackTheme?.primaryFill ?? 'rgb(0,127,255)';\n    }\n\n    set primaryFill(value: FillStyle | undefined) {\n        if(this._primaryFill !== value) {\n            this._primaryFill = value;\n            this.onThemeUpdated('primaryFill');\n        }\n    }\n\n    /** See {@link BaseTheme#accentFill}. For internal use only. */\n    private _accentFill?: FillStyle;\n\n    get accentFill(): FillStyle {\n        return this._accentFill ?? this._fallbackTheme?.accentFill ?? 'rgb(0,195,255)';\n    }\n\n    set accentFill(value: FillStyle | undefined) {\n        if(this._accentFill !== value) {\n            this._accentFill = value;\n            this.onThemeUpdated('accentFill');\n        }\n    }\n\n    /** See {@link BaseTheme#backgroundFill}. For internal use only. */\n    private _backgroundFill?: FillStyle;\n\n    get backgroundFill(): FillStyle {\n        return this._backgroundFill ?? this._fallbackTheme?.backgroundFill ?? 'rgb(32,32,32)';\n    }\n\n    set backgroundFill(value: FillStyle | undefined) {\n        if(this._backgroundFill !== value) {\n            this._backgroundFill = value;\n            this.onThemeUpdated('backgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#backgroundGlowFill}. For internal use only. */\n    private _backgroundGlowFill?: FillStyle;\n\n    get backgroundGlowFill(): FillStyle {\n        return this._backgroundGlowFill ?? this._fallbackTheme?.backgroundGlowFill ?? 'rgb(48,48,48)';\n    }\n\n    set backgroundGlowFill(value: FillStyle | undefined) {\n        if(this._backgroundGlowFill !== value) {\n            this._backgroundGlowFill = value;\n            this.onThemeUpdated('backgroundGlowFill');\n        }\n    }\n\n    /** See {@link BaseTheme#sliderMinLength}. For internal use only. */\n    private _sliderMinLength?: number;\n\n    get sliderMinLength(): number {\n        return this._sliderMinLength ?? this._fallbackTheme?.sliderMinLength ?? 100;\n    }\n\n    set sliderMinLength(value: number | undefined) {\n        if(this._sliderMinLength !== value) {\n            this._sliderMinLength = value;\n            this.onThemeUpdated('sliderMinLength');\n        }\n    }\n\n    /** See {@link BaseTheme#sliderThickness}. For internal use only. */\n    private _sliderThickness?: number;\n\n    get sliderThickness(): number {\n        return this._sliderThickness ?? this._fallbackTheme?.sliderThickness ?? 10;\n    }\n\n    set sliderThickness(value: number | undefined) {\n        if(this._sliderThickness !== value) {\n            this._sliderThickness = value;\n            this.onThemeUpdated('sliderThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextFont}. For internal use only. */\n    private _bodyTextFont?: string;\n\n    get bodyTextFont(): string {\n        return this._bodyTextFont ?? this._fallbackTheme?.bodyTextFont ?? '1rem sans-serif';\n    }\n\n    set bodyTextFont(value: string | undefined) {\n        if(this._bodyTextFont !== value) {\n            this._bodyTextFont = value;\n            this.onThemeUpdated('bodyTextFont');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextFill}. For internal use only. */\n    private _bodyTextFill?: FillStyle;\n\n    get bodyTextFill(): FillStyle {\n        return this._bodyTextFill ?? this._fallbackTheme?.bodyTextFill ?? 'white';\n    }\n\n    set bodyTextFill(value: FillStyle | undefined) {\n        if(this._bodyTextFill !== value) {\n            this._bodyTextFill = value;\n            this.onThemeUpdated('bodyTextFill');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextHeight}. For internal use only. */\n    private _bodyTextHeight?: number | null;\n\n    get bodyTextHeight(): number | null {\n        return this._bodyTextHeight ?? this._fallbackTheme?.bodyTextHeight ?? null;\n    }\n\n    set bodyTextHeight(value: number | null | undefined) {\n        if(this._bodyTextHeight !== value) {\n            this._bodyTextHeight = value;\n            this.onThemeUpdated('bodyTextHeight');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextSpacing}. For internal use only. */\n    private _bodyTextSpacing?: number | null;\n\n    get bodyTextSpacing(): number | null {\n        return this._bodyTextSpacing ?? this._fallbackTheme?.bodyTextSpacing ?? null;\n    }\n\n    set bodyTextSpacing(value: number | null | undefined) {\n        if(this._bodyTextSpacing !== value) {\n            this._bodyTextSpacing = value;\n            this.onThemeUpdated('bodyTextSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#bodyTextAlign}. For internal use only. */\n    private _bodyTextAlign?: TextAlignMode | number;\n\n    get bodyTextAlign(): TextAlignMode | number {\n        return this._bodyTextAlign ?? this._fallbackTheme?.bodyTextAlign ?? TextAlignMode.Start;\n    }\n\n    set bodyTextAlign(value: TextAlignMode | number | undefined) {\n        if(this._bodyTextAlign !== value) {\n            this._bodyTextAlign = value;\n            this.onThemeUpdated('bodyTextAlign');\n        }\n    }\n\n    /** See {@link BaseTheme#checkboxLength}. For internal use only. */\n    private _checkboxLength?: number;\n\n    get checkboxLength(): number {\n        return this._checkboxLength ?? this._fallbackTheme?.checkboxLength ?? 12;\n    }\n\n    set checkboxLength(value: number | undefined) {\n        if(this._checkboxLength !== value) {\n            this._checkboxLength = value;\n            this.onThemeUpdated('checkboxLength');\n        }\n    }\n\n    /** See {@link BaseTheme#checkboxInnerPadding}. For internal use only. */\n    private _checkboxInnerPadding?: number;\n\n    get checkboxInnerPadding(): number {\n        return this._checkboxInnerPadding ?? this._fallbackTheme?.checkboxInnerPadding ?? 2;\n    }\n\n    set checkboxInnerPadding(value: number | undefined) {\n        if(this._checkboxInnerPadding !== value) {\n            this._checkboxInnerPadding = value;\n            this.onThemeUpdated('checkboxInnerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#inputBackgroundFill}. For internal use only. */\n    private _inputBackgroundFill?: FillStyle;\n\n    get inputBackgroundFill(): FillStyle {\n        return this._inputBackgroundFill ?? this._fallbackTheme?.inputBackgroundFill ?? 'white';\n    }\n\n    set inputBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputBackgroundFill !== value) {\n            this._inputBackgroundFill = value;\n            this.onThemeUpdated('inputBackgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputSelectBackgroundFill}. For internal use only. */\n    private _inputSelectBackgroundFill?: FillStyle;\n\n    get inputSelectBackgroundFill(): FillStyle {\n        return this._inputSelectBackgroundFill ?? this._fallbackTheme?.inputSelectBackgroundFill ?? 'rgb(0,195,255)';\n    }\n\n    set inputSelectBackgroundFill(value: FillStyle | undefined) {\n        if(this._inputSelectBackgroundFill !== value) {\n            this._inputSelectBackgroundFill = value;\n            this.onThemeUpdated('inputSelectBackgroundFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFont}. For internal use only. */\n    private _inputTextFont?: string;\n\n    get inputTextFont(): string {\n        return this._inputTextFont ?? this._fallbackTheme?.inputTextFont ?? '1rem monospace';\n    }\n\n    set inputTextFont(value: string | undefined) {\n        if(this._inputTextFont !== value) {\n            this._inputTextFont = value;\n            this.onThemeUpdated('inputTextFont');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFill}. For internal use only. */\n    private _inputTextFill?: FillStyle;\n\n    get inputTextFill(): FillStyle {\n        return this._inputTextFill ?? this._fallbackTheme?.inputTextFill ?? 'black';\n    }\n\n    set inputTextFill(value: FillStyle | undefined) {\n        if(this._inputTextFill !== value) {\n            this._inputTextFill = value;\n            this.onThemeUpdated('inputTextFill');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFillDisabled}. For internal use only. */\n    private _inputTextFillDisabled?: FillStyle;\n\n    get inputTextFillDisabled(): FillStyle {\n        return this._inputTextFillDisabled ?? this._fallbackTheme?.inputTextFillDisabled ?? 'grey';\n    }\n\n    set inputTextFillDisabled(value: FillStyle | undefined) {\n        if(this._inputTextFillDisabled !== value) {\n            this._inputTextFillDisabled = value;\n            this.onThemeUpdated('inputTextFillDisabled');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextFillInvalid}. For internal use only. */\n    private _inputTextFillInvalid?: FillStyle;\n\n    get inputTextFillInvalid(): FillStyle {\n        return this._inputTextFillInvalid ?? this._fallbackTheme?.inputTextFillInvalid ?? 'red';\n    }\n\n    set inputTextFillInvalid(value: FillStyle | undefined) {\n        if(this._inputTextFillInvalid !== value) {\n            this._inputTextFillInvalid = value;\n            this.onThemeUpdated('inputTextFillInvalid');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextHeight}. For internal use only. */\n    private _inputTextHeight?: number | null;\n\n    get inputTextHeight(): number | null {\n        return this._inputTextHeight ?? this._fallbackTheme?.inputTextHeight ?? null;\n    }\n\n    set inputTextHeight(value: number | null | undefined) {\n        if(this._inputTextHeight !== value) {\n            this._inputTextHeight = value;\n            this.onThemeUpdated('inputTextHeight');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextSpacing}. For internal use only. */\n    private _inputTextSpacing?: number | null;\n\n    get inputTextSpacing(): number | null {\n        return this._inputTextSpacing ?? this._fallbackTheme?.inputTextSpacing ?? null;\n    }\n\n    set inputTextSpacing(value: number | null | undefined) {\n        if(this._inputTextSpacing !== value) {\n            this._inputTextSpacing = value;\n            this.onThemeUpdated('inputTextSpacing');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextInnerPadding}. For internal use only. */\n    private _inputTextInnerPadding?: number;\n\n    get inputTextInnerPadding(): number {\n        return this._inputTextInnerPadding ?? this._fallbackTheme?.inputTextInnerPadding ?? 2;\n    }\n\n    set inputTextInnerPadding(value: number | undefined) {\n        if(this._inputTextInnerPadding !== value) {\n            this._inputTextInnerPadding = value;\n            this.onThemeUpdated('inputTextInnerPadding');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextMinWidth}. For internal use only. */\n    private _inputTextMinWidth?: number;\n\n    get inputTextMinWidth(): number {\n        return this._inputTextMinWidth ?? this._fallbackTheme?.inputTextMinWidth ?? 100;\n    }\n\n    set inputTextMinWidth(value: number | undefined) {\n        if(this._inputTextMinWidth !== value) {\n            this._inputTextMinWidth = value;\n            this.onThemeUpdated('inputTextMinWidth');\n        }\n    }\n\n    /** See {@link BaseTheme#inputTextAlign}. For internal use only. */\n    private _inputTextAlign?: TextAlignMode | number;\n\n    get inputTextAlign(): TextAlignMode | number {\n        return this._inputTextAlign ?? this._fallbackTheme?.inputTextAlign ?? TextAlignMode.Start;\n    }\n\n    set inputTextAlign(value: TextAlignMode | number | undefined) {\n        if(this._inputTextAlign !== value) {\n            this._inputTextAlign = value;\n            this.onThemeUpdated('inputTextAlign');\n        }\n    }\n\n    /** See {@link BaseTheme#blinkRate}. For internal use only. */\n    private _blinkRate?: number;\n\n    get blinkRate(): number {\n        return this._blinkRate ?? this._fallbackTheme?.blinkRate ?? 0.8;\n    }\n\n    set blinkRate(value: number | undefined) {\n        if(this._blinkRate !== value) {\n            this._blinkRate = value;\n            this.onThemeUpdated('blinkRate');\n        }\n    }\n\n    /** See {@link BaseTheme#cursorThickness}. For internal use only. */\n    private _cursorThickness?: number;\n\n    get cursorThickness(): number {\n        return this._cursorThickness ?? this._fallbackTheme?.cursorThickness ?? 1;\n    }\n\n    set cursorThickness(value: number | undefined) {\n        if(this._cursorThickness !== value) {\n            this._cursorThickness = value;\n            this.onThemeUpdated('cursorThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarThickness}. For internal use only. */\n    private _scrollBarThickness?: number;\n\n    get scrollBarThickness(): number {\n        return this._scrollBarThickness ?? this._fallbackTheme?.scrollBarThickness ?? 8;\n    }\n\n    set scrollBarThickness(value: number | undefined) {\n        if(this._scrollBarThickness !== value) {\n            this._scrollBarThickness = value;\n            this.onThemeUpdated('scrollBarThickness');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarMinPercent}. For internal use only. */\n    private _scrollBarMinPercent?: number;\n\n    get scrollBarMinPercent(): number {\n        return this._scrollBarMinPercent ?? this._fallbackTheme?.scrollBarMinPercent ?? 0.1;\n    }\n\n    set scrollBarMinPercent(value: number | undefined) {\n        if(this._scrollBarMinPercent !== value) {\n            this._scrollBarMinPercent = value;\n            this.onThemeUpdated('scrollBarMinPercent');\n        }\n    }\n\n    /** See {@link BaseTheme#scrollBarMinPixels}. For internal use only. */\n    private _scrollBarMinPixels?: number;\n\n    get scrollBarMinPixels(): number {\n        return this._scrollBarMinPixels ?? this._fallbackTheme?.scrollBarMinPixels ?? 20;\n    }\n\n    set scrollBarMinPixels(value: number | undefined) {\n        if(this._scrollBarMinPixels !== value) {\n            this._scrollBarMinPixels = value;\n            this.onThemeUpdated('scrollBarMinPixels');\n        }\n    }\n\n    /** See {@link BaseTheme#radioButtonLength}. For internal use only. */\n    private _radioButtonLength?: number;\n\n    get radioButtonLength(): number {\n        return this._radioButtonLength ?? this._fallbackTheme?.radioButtonLength ?? 12;\n    }\n\n    set radioButtonLength(value: number | undefined) {\n        if(this._radioButtonLength !== value) {\n            this._radioButtonLength = value;\n            this.onThemeUpdated('radioButtonLength');\n        }\n    }\n\n    /** See {@link BaseTheme#radioButtonInnerPadding}. For internal use only. */\n    private _radioButtonInnerPadding?: number;\n\n    get radioButtonInnerPadding(): number {\n        return this._radioButtonInnerPadding ?? this._fallbackTheme?.radioButtonInnerPadding ?? 2;\n    }\n\n    set radioButtonInnerPadding(value: number | undefined) {\n        if(this._radioButtonInnerPadding !== value) {\n            this._radioButtonInnerPadding = value;\n            this.onThemeUpdated('radioButtonInnerPadding');\n        }\n    }\n\n    // XXX BASETHEME AUTO-GENERATED CODE END\n}\n", "import { ThemeProperties } from \"../theme/ThemeProperties\";\nimport { PointerEvent } from '../events/PointerEvent';\nimport { AutoScroll } from '../events/AutoScroll';\nimport type { Viewport } from '../core/Viewport';\nimport { TabSelect } from '../events/TabSelect';\nimport type { Bounds } from '../helpers/Bounds';\nimport { BaseTheme } from '../theme/BaseTheme';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Theme } from '../theme/Theme';\nimport type { Rect } from '../helpers/Rect';\nimport type { Root } from '../core/Root';\nimport { DynMsg } from '../core/Strings';\n\nconst twoPi = Math.PI * 2;\n\n/**\n * Optional Widget constructor properties.\n *\n * @category Widget\n */\nexport interface WidgetProperties extends ThemeProperties {\n    /** Sets {@link Widget#enabled}. */\n    enabled?: boolean;\n    /** Sets {@link Widget#flex}. */\n    flex?: number;\n}\n\n/**\n * A generic widget. All widgets extend this class. All widgets extend\n * {@link BaseTheme} so that the theme in use can be overridden.\n *\n * @category Widget\n */\nexport abstract class Widget extends BaseTheme {\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist,\n     * but will still be present in the UI tree.\n     */\n    private _enabled;\n    /** Widget will only be painted if dirty is true. */\n    protected _dirty = true;\n    /**\n     * If this is true, widget needs their layout resolved. If implementing a\n     * container, propagate this up.\n     */\n    protected _layoutDirty = true;\n    /**\n     * Widget will have its background automatically cleared when painting if\n     * needsClear is true. The background fill style used is\n     * {@link BaseTheme#canvasFill}.\n     */\n    readonly needsClear: boolean;\n    /**\n     * Widget will get targetted events even if the target is not itself if it\n     * this is true. Useful for implementing container widgets.\n     */\n    readonly propagatesEvents: boolean;\n    /** Width of widget in pixels. */\n    protected width = 0;\n    /** Height of widget in pixels. */\n    protected height = 0;\n    /** Absolute horizontal offset of widget in pixels. */\n    protected x = 0;\n    /** Absolute vertical offset of widget in pixels. */\n    protected y = 0;\n    /**\n     * The ideal width of the widget in pixels; if non-integer widget dimensions\n     * were allowed, the widget would have this size. Use this for layout\n     * calculations, but never use this for painting so that subpixel issues are\n     * avoided.\n     */\n    protected idealWidth = 0;\n    /** The ideal height of the widget in pixels. See {@link Widget#width}. */\n    protected idealHeight = 0;\n    /**\n     * The ideal absolute horizontal offset of the widget in pixels; if\n     * non-integer positions were allowed, the widget would have this position.\n     * Use this for layout calculations, but never use this for painting so that\n     * subpixel issues are avoided.\n     */\n    protected idealX = 0;\n    /**\n     * The ideal absolute vertical offset of the widget in pixels. See\n     * {@link Widget#x}.\n     */\n    protected idealY = 0;\n    /** {@link Widget#flex} but for internal use. */\n    protected _flex;\n    /**\n     * The {@link Root} that this widget is currently inside.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null.\n     */\n    protected _root: Root | null = null;\n    /**\n     * The {@link Viewport} that this widget is currently painting to. A UI tree\n     * can have multiple Viewports due to {@link ViewportWidget}, so this is not\n     * equivalent to {@link Root#viewport}.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null.\n     */\n    protected _viewport: Viewport | null = null;\n    /**\n     * The parent {@link Widget} of this widget.\n     *\n     * Widgets not attached to a UI tree (widgets which are not\n     * {@link Widget#active}) will have this property set to null, but root\n     * widgets will also have a null parent.\n     */\n    protected _parent: Widget | null = null;\n    /** Can this widget be focused by pressing tab? */\n    protected tabFocusable = false;\n\n    /**\n     * How much this widget will expand relative to other widgets in a flexbox\n     * container. If changed, sets {@link Widget#_layoutDirty} to true.\n     */\n    get flex(): number {\n        return this._flex;\n    }\n\n    set flex(flex: number) {\n        if(flex !== this._flex) {\n            this._flex = flex;\n            this._layoutDirty = true;\n        }\n    }\n\n    /** Create a new Widget. */\n    constructor(needsClear: boolean, propagatesEvents: boolean, properties?: Readonly<WidgetProperties>) {\n        super(properties);\n\n        this.needsClear = needsClear;\n        this.propagatesEvents = propagatesEvents;\n\n        this._enabled = properties?.enabled ?? true;\n        this._flex = properties?.flex ?? 0;\n    }\n\n    /**\n     * Is this widget enabled? If it isn't, it will act as if it doesn't exist.\n     *\n     * If changed, calls {@link Widget#forceDirty}\n     *\n     * If getting, {@link Widget#_enabled} is returned.\n     */\n    set enabled(enabled: boolean) {\n        if(enabled === this._enabled)\n            return;\n\n        this._enabled = enabled;\n        this.forceDirty();\n    }\n\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    /**\n     * The inherited theme of this widget. Sets {@link BaseTheme#fallbackTheme}.\n     */\n    set inheritedTheme(theme: Theme | undefined) {\n        this.fallbackTheme = theme;\n    }\n\n    get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(this.needsClear && (property === null || property === 'canvasFill'))\n            this._dirty = true;\n    }\n\n    /**\n     * Get the resolved dimensions. Returns a 2-tuple containing\n     * {@link Widget#width} and {@link Widget#height}.\n     *\n     * Use {@link Widget#idealDimensions} for layout calculations.\n     */\n    get dimensions(): [number, number] {\n        return [this.width, this.height];\n    }\n\n    /**\n     * Get the resolved ideal dimensions. Returns a 2-tuple containing\n     * {@link Widget#idealWidth} and {@link Widget#idealHeight}.\n     *\n     * Use this for layout calculations, and {@link Widget#dimensions} for\n     * painting.\n     */\n    get idealDimensions(): [number, number] {\n        return [this.idealWidth, this.idealHeight];\n    }\n\n    /**\n     * Get the resolved position. Returns a 2-tuple containing {@link Widget#x}\n     * and {@link Widget#y}.\n     *\n     * Use {@link Widget#idealPosition} for layout calculations.\n     */\n    get position(): [number, number] {\n        return [this.x, this.y];\n    }\n\n    /**\n     * Get the resolved ideal position. Returns a 2-tuple containing\n     * {@link Widget#idealX} and {@link Widget#idealY}.\n     *\n     * Use this for layout calculations, and {@link Widget#position} for\n     * painting.\n     */\n    get idealPosition(): [number, number] {\n        return [this.idealX, this.idealY];\n    }\n\n    /** Get the rectangle bounds (left, right, top, bottom) of this widget. */\n    get bounds(): Bounds {\n        const x = this.x;\n        const y = this.y;\n        return [x, x + this.width, y, y + this.height];\n    }\n\n    /** Similar to {@link Widget#bounds}, but uses ideal values */\n    get idealBounds(): Bounds {\n        const x = this.idealX;\n        const y = this.idealY;\n        return [x, x + this.idealWidth, y, y + this.idealHeight];\n    }\n\n    /** Get the rectangle (x, y, width, height) of this widget. */\n    get rect(): Rect {\n        return [this.x, this.y, this.width, this.height];\n    }\n\n    /** Similar to {@link Widget#rect}, but uses ideal values */\n    get idealRect(): Rect {\n        return [this.idealX, this.idealY, this.idealWidth, this.idealHeight];\n    }\n\n    /**\n     * Check if the widget is dirty. Returns {@link Widget#_dirty}, as long as\n     * {@link Widget#dimensionless} is not true.\n     */\n    get dirty(): boolean {\n        return this._dirty && !this.dimensionless;\n    }\n\n    /**\n     * Check if the widget's layout is dirty. Returns\n     * {@link Widget#_layoutDirty}.\n     */\n    get layoutDirty(): boolean {\n        return this._layoutDirty;\n    }\n\n    /**\n     * Check if the widget has zero width or height.\n     *\n     * If true, {@link Widget#paint} will do nothing and {@link Widget#dirty}\n     * will be false even if {@link Widget#_dirty} is true.\n     *\n     * Usually becomes true when containers overflow.\n     */\n    get dimensionless(): boolean {\n        return this.width == 0 || this.height == 0;\n    }\n\n    /**\n     * Called when a focus type has been grabbed by this Widget. Does nothing by\n     * default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    onFocusGrabbed(focusType: FocusType): void {}\n\n    /**\n     * Called when a focus type owned by this Widget has been dropped. Does\n     * nothing by default. Can be overridden.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    onFocusDropped(focusType: FocusType): void {}\n\n    /**\n     * Widget event handling callback. If the event is to be captured, the\n     * capturer is returned, else, null.\n     *\n     * By default, this will do nothing and capture the event if it is targetted\n     * at itself.\n     *\n     * If overriding, return the widget that has captured the event (could be\n     * `this`, for example, or a child widget if implementing a container), or\n     * null if no widget captured the event. Make sure to not capture any events\n     * that you do not need, or you may have unexpected results; for example, if\n     * you capture all dispatched events indiscriminately, a {@link TabSelect}\n     * event may be captured and result in weird behaviour when the user\n     * attempts to use tab to select another widget.\n     */\n    protected handleEvent(event: Event): Widget | null {\n        if(event.target === this)\n            return this;\n        else\n            return null;\n    }\n\n    /**\n     * Called when an event is passed to the Widget. Checks if the target\n     * matches the Widget, unless the Widget propagates events, or if the event\n     * is a {@link PointerEvent} and is in the bounds of the Widget. If neither\n     * of the conditions are true, the event is not captured (null is returned),\n     * else, the {@link Widget#handleEvent} method is called and its result is\n     * returned. Must not be overridden.\n     *\n     * @returns Returns the widget that captured the event or null if none captured the event.\n     */\n    dispatchEvent(event: Event): Widget | null {\n        if(!this._enabled)\n            return null;\n\n        if(event.target === null) {\n            if(event instanceof PointerEvent) {\n                if(event.x < this.x || event.y < this.y || event.x >= this.x + this.width || event.y >= this.y + this.height)\n                    return null;\n            }\n            else if(event instanceof AutoScroll) {\n                if(event.originallyRelativeTo === this)\n                    return this;\n                else if(!this.propagatesEvents)\n                    return null;\n            }\n        }\n        else if(event.target !== this && !this.propagatesEvents)\n            return null;\n\n        let capturer = null;\n        if(event.reversed)\n            capturer = this.handleEvent(event);\n\n        if(event instanceof TabSelect) {\n            if(event.reachedRelative) {\n                if(this.tabFocusable && (capturer === this || capturer === null))\n                    return this;\n            }\n            else if(event.relativeTo === this)\n                event.reachedRelative = true;\n        }\n\n        if(!event.reversed)\n            capturer = this.handleEvent(event);\n\n        return capturer;\n    }\n\n    /**\n     * Generic update method which is called before layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePreLayoutUpdate(): void {}\n\n    /**\n     * Generic update method which is called before layout is resolved. Calls\n     * {@link Widget#handlePreLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    preLayoutUpdate(): void {\n        if(this._enabled)\n            this.handlePreLayoutUpdate();\n    }\n\n    /**\n     * Resolve dimensions of this widget. Must be implemented; set\n     * {@link Widget#width} and {@link Widget#height}.\n     */\n    protected abstract handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void;\n\n    /**\n     * Wrapper for {@link Widget#handleResolveDimensions}. Does nothing if\n     * {@link Widget#_enabled} is false. If the resolved dimensions change,\n     * {@link Widget#_dirty} is set to true. {@link Widget#_layoutDirty} is set\n     * to false. If the widget is not loose and the layout has non-infinite max\n     * constraints, then the widget is stretched to fit max constraints. Must\n     * not be overridden.\n     */\n    resolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Return early if disabled; make widget dimensionless and clear layout\n        // dirty flag\n        if(!this._enabled) {\n            this.width = 0;\n            this.height = 0;\n            this.idealWidth = 0;\n            this.idealHeight = 0;\n            this._layoutDirty = false;\n            return;\n        }\n\n        // Validate constraints\n        if(minWidth == Infinity)\n            throw new Error(DynMsg.INVALID_VALUE('minWidth', minWidth));\n        if(minWidth > maxWidth) {\n            // Not throwing here because floating pointer precision errors\n            // sometimes trigger this due to tight constraints\n            console.warn(DynMsg.SWAPPED_MIN_MAX_DIMS(minWidth, maxWidth, 'minWidth', 'maxWidth'));\n            minWidth = maxWidth;\n        }\n        if(minWidth < 0) {\n            console.warn(DynMsg.NEGATIVE_DIMS(minWidth, 'minWidth'));\n            minWidth = 0;\n        }\n\n        if(minHeight == Infinity)\n            throw new Error(DynMsg.INVALID_VALUE('minHeight', minHeight));\n        if(minHeight > maxHeight) {\n            console.warn(DynMsg.SWAPPED_MIN_MAX_DIMS(minHeight, maxHeight, 'minHeight', 'maxHeight'));\n            minHeight = maxHeight;\n        }\n        if(minHeight < 0) {\n            console.warn(DynMsg.NEGATIVE_DIMS(minHeight, 'minHeight'));\n            minHeight = 0;\n        }\n\n        // Keep track of old dimensions to compare later\n        const oldWidth = this.idealWidth;\n        const oldHeight = this.idealHeight;\n\n        // Resolve dimensions\n        this.handleResolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Validate resolved dimensions, handling overflows, underflows and\n        // invalid dimensions\n        if(this.idealWidth < minWidth) {\n            this.idealWidth = minWidth;\n            console.error(DynMsg.BROKEN_CONSTRAINTS(this.idealWidth, minWidth, true, false));\n        }\n        else if(this.idealWidth > maxWidth) {\n            this.idealWidth = maxWidth;\n            console.error(DynMsg.BROKEN_CONSTRAINTS(this.idealWidth, maxWidth, true, true));\n        }\n\n        if(this.idealWidth < 0 || !isFinite(this.idealWidth) || isNaN(this.idealWidth))\n            throw new Error(DynMsg.INVALID_DIMS(true, this.idealWidth));\n\n        if(this.idealHeight < minHeight) {\n            this.idealHeight = minHeight;\n            console.error(DynMsg.BROKEN_CONSTRAINTS(this.idealHeight, minHeight, false, false));\n        }\n        else if(this.idealHeight > maxHeight) {\n            this.idealHeight = maxHeight;\n            console.error(DynMsg.BROKEN_CONSTRAINTS(this.idealHeight, maxHeight, false, true));\n        }\n\n        if(this.idealHeight < 0 || !isFinite(this.idealHeight) || isNaN(this.idealHeight))\n            throw new Error(DynMsg.INVALID_DIMS(false, this.idealHeight));\n\n        // Clear layout dirty flag\n        this._layoutDirty = false;\n\n        // If dimensions changed (compare with tracked old dimensions), then set\n        // dirty flag\n        if(oldWidth !== this.idealWidth || oldHeight !== this.idealHeight)\n            this._dirty = true;\n    }\n\n    /**\n     * Like {@link Widget#resolveDimensions} but for widgets at the top of the\n     * widget tree (the child of the {@link Root}). This retries dimension\n     * resolving if there is at least one unconstrained axis so that flex layout\n     * works even in infinite layout.\n     */\n    resolveDimensionsAsTop(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Resolve dimensions again, now with maximum constraints. This is so\n        // that widgets that depend on max constraints, such as containers that\n        // handle flexbox layout, work properly. Only do this if constraints\n        // don't already have maximum dimensions.\n        if(maxWidth === Infinity || maxHeight === Infinity) {\n            this.resolveDimensions(\n                minWidth,\n                maxWidth === Infinity ? this.idealWidth : maxWidth,\n                minHeight,\n                maxHeight === Infinity ? this.idealHeight : maxHeight,\n            );\n        }\n    }\n\n    /**\n     * Set the ideal position of this widget ({@link Widget#idealX} and\n     * {@link Widget#idealY}). Does not set any flags of the widget.\n     *\n     * Can be overridden, but `super.resolvePosition` must always be called, and\n     * the arguments must be preserved. Container widgets should override this\n     * method such that `resolvePosition` is called for each child of the\n     * container.\n     */\n    resolvePosition(x: number, y: number): void {\n        // Set position\n        this.idealX = x;\n        this.idealY = y;\n    }\n\n    /**\n     * Sets {@link Widget#x}, {@link Widget#y}, {@link Widget#width} and\n     * {@link Widget#y} from {@link Widget#idealX}, {@link Widget#idealY},\n     * {@link Widget#idealWidth} and {@link Widget#idealHeight} by rounding\n     * them. If the final values have changed, {@link Widget#_dirty} is set to\n     * true.\n     *\n     * Can be overridden, but `super.finalizeBounds` must still be called; if\n     * you have parts of the widget that can be pre-calculated when the layout\n     * is known, such as the length and offset of a {@link Checkbox}, or\n     * non-default dirty flags, such as {@link MultiContainer#backgroundDirty},\n     * then this is the perfect method to override, since it's only called after\n     * the layout is resolved to final (non-ideal) values, is only called if\n     * needed (unlike {@link postLayoutUpdate}, which is always called after the\n     * layout phase) and can be used to compare old and new positions and\n     * dimensions.\n     *\n     * Abstract container widgets such as {@link Parent} must always override\n     * this and call `finalizeBounds` on each child widget.\n     */\n    finalizeBounds(): void {\n        // Round bounds\n        const [scaleX, scaleY] = this.viewport.effectiveScale;\n        const newX = Math.floor(this.idealX * scaleX) / scaleX;\n        const newY = Math.floor(this.idealY * scaleY) / scaleY;\n        const newWidth = Math.ceil((this.idealX + this.idealWidth) * scaleX) / scaleX - newX;\n        const newHeight = Math.ceil((this.idealY + this.idealHeight) * scaleY) / scaleY - newY;\n\n        // Mark as dirty if bounds have changed\n        if(newX !== this.x || newY !== this.y || newWidth !== this.width || newHeight !== this.height)\n            this._dirty = true;\n\n        // Set final bounds\n        this.x = newX;\n        this.y = newY;\n        this.width = newWidth;\n        this.height = newHeight;\n    }\n\n    /**\n     * Generic update method which is called after layout is resolved. Does\n     * nothing by default. Should be implemented.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    protected handlePostLayoutUpdate(): void {}\n\n    /**\n     * Generic update method which is called after layout is resolved. Calls\n     * {@link Widget#handlePostLayoutUpdate} if widget is enabled. Must not be\n     * overridden.\n     */\n    postLayoutUpdate(): void {\n        if(this._enabled)\n            this.handlePostLayoutUpdate();\n    }\n\n    /**\n     * Paiting utility: clears background of widget. Should not be overridden.\n     *\n     * Rounds to nearest pixels; no subpixel clearing.\n     *\n     * The background fill style used is {@link ThemeProperties#canvasFill}.\n     *\n     * @param fillStyle - The fill style to use for clearing. If null (default), then the value of {@link ThemeProperties#canvasFill} is used\n     */\n    protected clear(x: number, y: number, width: number, height: number, fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        const ctx = this.viewport.context;\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n        // These are rounded because clipping and filling doesn't\n        // work properly with decimal points\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Paiting utility: start a clear operation with no clipping path, the user\n     * has to add their own paths to the context. Should not be overridden.\n     *\n     * @param fillStyle - The fill style to use for clearing. If null (default), then the value of {@link ThemeProperties#canvasFill} is used\n     */\n    protected clearStart(fillStyle: string | CanvasGradient | CanvasPattern | null = null): void {\n        const ctx = this.viewport.context;\n        ctx.save();\n        ctx.globalCompositeOperation = 'copy';\n        ctx.fillStyle = fillStyle ?? this.canvasFill;\n        ctx.beginPath();\n    }\n\n    /**\n     * Paiting utility: end a clear operation (from {@link Widget#clearStart}). Should\n     * not be overridden.\n     *\n     * @param fillRule - The canvas fill rule for clipping. See the {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip#parameters | canvas clip documentation}\n     */\n    protected clearEnd(fillRule: CanvasFillRule = 'nonzero'): void {\n        const ctx = this.viewport.context;\n        ctx.clip(fillRule);\n        ctx.fill();\n        ctx.restore();\n    }\n\n    /**\n     * Painting utility: paints a circle. Should not be overridden. Coordinates\n     * are relative to the center of the circle. Uses ctx's current fillStyle.\n     * Does not restore the context state after finishing.\n     */\n    protected paintCircle(x: number, y: number, radius: number): void {\n        const ctx = this.viewport.context;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, twoPi);\n        ctx.fill();\n    }\n\n    /**\n     * Widget painting callback. By default does nothing. Do painting logic here\n     * when extending Widget. Even if {@link Widget#_dirty} is false, if this\n     * method is called, then the widget must still be painted. Should be\n     * overridden.\n     *\n     * @param forced - Was this widget force-painted? If calling a child's paint method, propagate this value\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n    protected handlePainting(forced: boolean): void {}\n\n    /**\n     * Called when the Widget is dirty and the Root is being rendered. Does\n     * nothing if dirty flag is not set, else, clears the background if\n     * {@link Widget#needsClear} is true, calls the\n     * {@link Widget#handlePainting} method and unsets the dirty flag.\n     * Automatically calls {@link Widget#dryPaint} if\n     * {@link Widget#dimensionless} is true. Must not be overridden.\n     *\n     * @param force - Force re-paint even if {@link Widget#_dirty} is false\n     */\n    paint(force = false): void {\n        if(this.dimensionless)\n            return this.dryPaint();\n\n        if(!this._dirty && !force)\n            return;\n\n        if(this._enabled) {\n            if(this.needsClear)\n                this.clear(this.x, this.y, this.width, this.height);\n\n            const ctx = this.viewport.context;\n            ctx.save();\n            this.handlePainting(force);\n            ctx.restore();\n        }\n\n        this._dirty = false;\n    }\n\n    /**\n     * Unset this widget's dirty flag. Call this when painting a child that you\n     * know will not be visible, such as if clipping and the child is out of\n     * bounds. If implementing a container widget, override this so that each\n     * child widget's dryPaint method is called.\n     */\n    dryPaint(): void {\n        this._dirty = false;\n    }\n\n    /**\n     * Force the widget to be fully re-painted and (by default) have layout\n     * resolved. For internal use only or for use by {@link Parent} widgets so\n     * that children get properly marked as dirty when added to a new container\n     * after reuse.\n     *\n     * Should be overridden if the derived Widget has more dirty flags other\n     * than the default ones (such as {@link MultiContainer#backgroundDirty}),\n     * but `super.forceDirty` must be called.\n     */\n    forceDirty(markLayout = true): void {\n        this._dirty = true;\n\n        if(markLayout)\n            this._layoutDirty = true;\n    }\n\n    /**\n     * Check if this Widget is active (is in a UI tree). If not, then this\n     * Widget must not be used. Must not be overridden.\n     */\n    get active(): boolean {\n        return this._root !== null;\n    }\n\n    /**\n     * Similar to {@link Widget#_root}, but throws an error if the widget is not\n     * {@link Widget#active}.\n     */\n    get root(): Root {\n        if(!this.active)\n            throw new Error(DynMsg.INACTIVE_WIDGET('root'));\n\n        // XXX active makes sure that _root is not null, but typescript doesn't\n        // detect this. force the type system to treat it as non-null\n        return this._root as Root;\n    }\n\n    /**\n     * Similar to {@link Widget#_viewport}, but throws an error if the widget is\n     * not {@link Widget#active}.\n     */\n    get viewport(): Viewport {\n        if(!this.active)\n            throw new Error(DynMsg.INACTIVE_WIDGET('viewport'));\n\n        // XXX active makes sure that _viewport is not null, but typescript\n        // doesn't detect this. force the type system to treat it as non-null\n        return this._viewport as Viewport;\n    }\n\n    /**\n     * Similar to {@link Widget#_parent}, but throws an error if the widget is\n     * not {@link Widget#active}.\n     */\n    get parent(): Widget | null {\n        if(!this.active)\n            throw new Error(DynMsg.INACTIVE_WIDGET('parent'));\n\n        return this._parent;\n    }\n\n    /**\n     * Called when the Widget is added to a UI tree. Should be overridden for\n     * resource management, but `super.activate` must be called.\n     *\n     * If the widget is already in a UI tree (already has a {@link parent} or is\n     * the {@link Root#child | root Widget}, both checked via\n     * {@link Widget#active}), then this method will throw an exception; a\n     * Widget cannot be in multiple UI trees.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param root - The {@link Root} of the UI tree\n     * @param viewport - The {@link Viewport} in this part of the UI tree. A UI tree can have multiple nested Viewports due to {@link ViewportWidget}\n     * @param parent - The new parent of this Widget. If `null`, then this Widget has no parent and is the {@link Root#child | root Widget}\n     */\n    activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        if(this.active)\n            throw new Error(DynMsg.INVALID_ACTIVATION(true));\n\n        this._root = root;\n        this._viewport = viewport;\n        this._parent = parent;\n        this.forceDirty();\n    }\n\n    /**\n     * Called when the Widget is removed from a UI tree. Should be overridden\n     * for resource management, but `super.deactivate` must be called.\n     *\n     * Sets {@link Widget#_root}, {@link Widget#_viewport} and\n     * {@link Widget#_parent} to null.\n     *\n     * If the widget was not in a UI tree, then an exception is thrown.\n     */\n    deactivate(): void {\n        if(!this.active)\n            throw new Error(DynMsg.INVALID_ACTIVATION(false));\n\n        this._root = null;\n        this._viewport = null;\n        this._parent = null;\n    }\n\n    /**\n     * {@link AutoScroll | Auto-scroll} to this widget. Uses the whole widget as\n     * the {@link AutoScroll#bounds | auto-scroll bounds}.\n     */\n    autoScroll(): void {\n        this.root.dispatchEvent(new AutoScroll(this, [0, this.idealWidth, 0, this.idealHeight]));\n    }\n}", "import { Widget, WidgetProperties } from '../widgets/Widget';\nimport type { Viewport } from '../core/Viewport';\nimport type { Theme } from '../theme/Theme';\nimport type { Root } from '../core/Root';\n\n/**\n * A class for widgets which may have children.\n *\n * Overrides the {@link Widget#inheritedTheme} accessor so that inherited themes\n * are propagated to children, and {@link Widget#dryPaint} so that dry painting\n * this parent also dry paints the children. Also provides utilities for getting\n * the amount of children, a public iterator for children and a protected child\n * list. This way, widgets that extend this class can decide if modifying the\n * list of children should be public or not.\n *\n * Can be constrained to a specific type of children.\n *\n * See {@link MultiParent} and {@link SingleParent} for more specialised\n * versions.\n *\n * @category Widget\n */\nexport abstract class Parent<W extends Widget = Widget> extends Widget {\n    /**\n     * This widget's children. Note that this is marked as readonly so that it\n     * cannot be accidentally replaced with a new array. This way, references to\n     * this array are always valid. If you want to clear this array, set the\n     * length to zero instead of creating a new instance. readonly still means\n     * that you can add/remove elements to/from the array.\n     *\n     * See {@link Parent#children} for the public iterator getter.\n     */\n    protected readonly _children: Array<W>;\n\n    /**\n     * Create a new Parent. Automatically adds all widgets in the input array\n     * to {@link Parent#_children}.\n     */\n    constructor(children: Array<W>, needsClear: boolean, propagatesEvents: boolean, properties?: Readonly<WidgetProperties>) {\n        super(needsClear, propagatesEvents, properties);\n\n        this._children = [...children];\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        super.inheritedTheme = theme;\n        for(const child of this.children)\n            child.inheritedTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return super.inheritedTheme;\n    }\n\n    override dryPaint(): void {\n        super.dryPaint();\n\n        for(const child of this.children)\n            child.dryPaint();\n    }\n\n    override forceDirty(markLayout = true): void {\n        super.forceDirty(markLayout);\n\n        for(const child of this.children)\n            child.forceDirty(markLayout);\n    }\n\n    /** Get amount of children of this parent widget. */\n    get childCount(): number {\n        return this._children.length;\n    }\n\n    /**\n     * Get iterator for children of this parent widget. Cannot modify list of\n     * children via this iterator; for read-only purposes only.\n     */\n    get children(): Iterable<W> {\n        return this._children.values();\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n\n        for(const child of this.children)\n            child.activate(root, viewport, this);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n\n        for(const child of this.children)\n            child.deactivate();\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        for(const child of this.children)\n            child.finalizeBounds();\n    }\n}", "import type { Widget } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} class for parents with any amount\n * of children and public access to modifying this list of children.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport abstract class MultiParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Add child(ren) to this widget.\n     *\n     * {@link Widget#_layoutDirty} and {@link Widget#_dirty} are set to true and\n     * each child's {@link Widget#inheritedTheme} is set so that new children\n     * inherit this widget's theme.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param children - If this is a widget, then it is pushed to {@link Parent#_children}. If this is an array of widgets, then each widget is pushed to {@link Parent#_children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    add(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            const isActive = this.active;\n\n            for(const child of children) {\n                this._children.push(child);\n                child.inheritedTheme = this.inheritedTheme;\n\n                if(isActive)\n                    child.activate(this.root, this.viewport, this);\n            }\n        }\n        else {\n            this._children.push(children);\n            children.inheritedTheme = this.inheritedTheme;\n\n            if(this.active)\n                children.activate(this.root, this.viewport, this);\n        }\n\n        this.forceDirty();\n        return this;\n    }\n\n    /**\n     * Remove child(ren) from this widget.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @param children - If this is a widget, then it is removed from {@link Parent#_children}. If this is an array of widgets, then each widget is removed from {@link Parent#_children}.\n     * @returns Returns this so that the method is chainable.\n     */\n    remove(children: W | Array<W>): this {\n        if(Array.isArray(children)) {\n            const isActive = this.active;\n\n            for(const child of children) {\n                const pos = this._children.indexOf(child);\n\n                if(pos !== -1)\n                    this._children.splice(pos, 1);\n                if(isActive)\n                    child.deactivate();\n            }\n        }\n        else {\n            const pos = this._children.indexOf(children);\n\n            if(pos !== -1)\n                this._children.splice(pos, 1);\n            if(this.active)\n                children.deactivate();\n        }\n\n        this.forceDirty();\n        return this;\n    }\n\n    /**\n     * Remove all children from this widget.\n     *\n     * Calls {@link Widget#forceDirty}.\n     *\n     * @returns Returns this so that the method is chainable.\n     */\n    clearChildren(): this {\n        if(this.active) {\n            for(const child of this._children)\n                child.deactivate();\n        }\n\n        this._children.length = 0;\n        this.forceDirty();\n        return this;\n    }\n}", "import { FlexAlignment } from '../theme/FlexAlignment';\nimport { Widget, WidgetProperties } from './Widget';\nimport { Alignment } from '../theme/Alignment';\nimport type { Event } from '../events/Event';\nimport { MultiParent } from './MultiParent';\n\n/**\n * A {@link MultiParent} which automatically paints children, adds spacing,\n * propagates events and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * Note that there is no padding. Put this inside a {@link Margin} if padding is\n * needed.\n *\n * @category Widget\n */\nexport class MultiContainer<W extends Widget = Widget> extends MultiParent<W> {\n    /** Is the container's background dirty? */\n    private backgroundDirty = true;\n    /** Is this container vertical? */\n    private vertical: boolean;\n    /** The unused space along the main axis after resolving dimensions */\n    private unusedSpace = 0;\n    /** The number of enabled children in this container */\n    private enabledChildCount = 0;\n\n    /** Create a MultiContainer. */\n    constructor(vertical: boolean, properties?: Readonly<WidgetProperties>) {\n        // MultiContainers clear their own background, have children and\n        // propagate events\n        super([], false, true, properties);\n\n        this.vertical = vertical;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'multiContainerAlignment')\n            this._layoutDirty = true;\n        else if(property === 'multiContainerSpacing')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Reverse children if necessary\n        let children = this.children;\n        if(event.reversed)\n            children = Array.from(children).reverse();\n\n        // Find which widget the event should go to\n        for(const child of children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Stop if event was captured\n            const captured = child.dispatchEvent(event);\n            if(captured !== null)\n                return captured;\n        }\n\n        // Event wasn't dispatched to any child\n        return null;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update children\n        for(const child of this.children) {\n            child.preLayoutUpdate();\n\n            // If child's layout is dirty, set own layoutDirty flag\n            if(child.layoutDirty)\n                this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update children\n        for(const child of this.children) {\n            child.postLayoutUpdate();\n\n            // If child is dirty, set own dirty flag\n            if(child.dirty)\n                this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve children's layout with loose constraints along the main axis\n        // to get their wanted dimensions and calculate total flex ratio\n        let totalFlex = 0, crossLength = 0, minCrossAxis = 0;\n        const maxLength = this.vertical ? maxHeight : maxWidth;\n\n        const alignment = this.multiContainerAlignment;\n        if(alignment.cross === Alignment.Stretch) {\n            minCrossAxis = this.vertical ? maxWidth : maxHeight;\n            if(minCrossAxis == Infinity)\n                minCrossAxis = this.vertical ? minWidth : minHeight;\n        }\n\n        this.enabledChildCount = 0;\n        for(const child of this.children) {\n            // Resolve dimensions of disabled children with zero-width\n            // constraints just so layout dirty flag is cleared\n            if(!child.enabled) {\n                child.resolveDimensions(0, 0, 0, 0);\n                continue;\n            }\n\n            this.enabledChildCount++;\n\n            const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n\n            if(this.vertical)\n                child.resolveDimensions(minCrossAxis, maxWidth, 0, Infinity);\n            else\n                child.resolveDimensions(0, Infinity, minCrossAxis, maxHeight);\n\n            const [childWidth, childHeight] = child.idealDimensions;\n\n            totalFlex += child.flex;\n            crossLength = Math.max(this.vertical ? childWidth : childHeight, crossLength);\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Clamp cross length\n        const minCrossLength = this.vertical ? minWidth : minHeight;\n        if(crossLength < minCrossLength)\n            crossLength = minCrossLength;\n\n        // Get free space\n        const spacing = this.multiContainerSpacing;\n        let usedSpace = Math.max(this.enabledChildCount - 1, 0) * spacing;\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            usedSpace += this.vertical ? child.idealDimensions[1] : child.idealDimensions[0];\n        }\n\n        const freeSpace = maxLength - usedSpace;\n\n        // Don't do flexbox calculations if free space is infinite\n        // (unconstrained main axis) or if there isn't any free space.\n        if(freeSpace == Infinity || freeSpace <= 0) {\n            const oldWidth = this.idealWidth;\n            const oldHeight = this.idealHeight;\n\n            if(this.vertical) {\n                this.idealWidth = crossLength;\n                this.idealHeight = Math.min(usedSpace, maxHeight);\n            }\n            else {\n                this.idealWidth = Math.min(usedSpace, maxWidth);\n                this.idealHeight = crossLength;\n            }\n\n            // Mark background as dirty if dimensions changed\n            if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight)\n                this.backgroundDirty = true;\n\n            // Set unused space to 0; no alignment should be done\n            this.unusedSpace = 0;\n\n            // Resolve children's layout, but now with strict constraints so\n            // that they stretch properly and shrink children if neccessary (on\n            // overflow)\n            let spaceLeft = maxLength;\n            for(const child of this.children) {\n                // Ignore disabled children\n                if(!child.enabled)\n                    continue;\n\n                const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n\n                if(this.vertical) {\n                    const wantedLength = Math.min(spaceLeft, oldChildHeight);\n                    child.resolveDimensions(minCrossAxis, maxWidth, wantedLength, wantedLength);\n                }\n                else {\n                    const wantedLength = Math.min(spaceLeft, oldChildWidth);\n                    child.resolveDimensions(wantedLength, wantedLength, minCrossAxis, maxHeight);\n                }\n\n                const [childWidth, childHeight] = child.idealDimensions;\n\n                // Mark background as dirty if child's dimensions changed\n                if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                    this.backgroundDirty = true;\n\n                const childLength = this.vertical ? oldChildHeight\n                                                  : oldChildWidth;\n                spaceLeft = Math.max(0, spaceLeft - childLength - spacing);\n            }\n\n            return;\n        }\n\n        // Resolve children's layout with constraints restricted to distributed\n        // free space. Calculate used space after flexbox calculations.\n        let usedSpaceAfter = 0;\n        let freeSpacePerFlex = 0;\n        if(totalFlex > 0)\n            freeSpacePerFlex = freeSpace / totalFlex;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            // Add spacing to used space if this is not the first widget\n            if(usedSpaceAfter !== 0)\n                usedSpaceAfter += spacing;\n\n            const dedicatedSpace = freeSpacePerFlex * child.flex;\n            const [oldChildWidth, oldChildHeight] = child.idealDimensions;\n            if(this.vertical) {\n                const wantedLength = dedicatedSpace + oldChildHeight;\n                child.resolveDimensions(\n                    minCrossAxis, maxWidth,\n                    wantedLength, wantedLength,\n                );\n            }\n            else {\n                const wantedLength = dedicatedSpace + oldChildWidth;\n                child.resolveDimensions(\n                    wantedLength, wantedLength,\n                    minCrossAxis, maxHeight,\n                );\n            }\n\n            const [childWidth, childHeight] = child.idealDimensions;\n            usedSpaceAfter += this.vertical ? childHeight : childWidth;\n\n            // Mark background as dirty if child's dimensions changed\n            if(childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n                this.backgroundDirty = true;\n        }\n\n        // Resolve width and height\n        const oldWidth = this.idealWidth;\n        const oldHeight = this.idealHeight;\n\n        let length;\n        if(this.vertical) {\n            length = maxHeight;\n            this.idealWidth = crossLength;\n            this.idealHeight = length;\n        }\n        else {\n            length = maxWidth;\n            this.idealWidth = length;\n            this.idealHeight = crossLength;\n        }\n\n        // Mark background as dirty if dimensions changed\n        if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight)\n            this.backgroundDirty = true;\n\n        // Calculate final unused space; used for alignment. Clamp to zero just\n        // in case XXX is that neccessary?\n        this.unusedSpace = Math.max(length - usedSpaceAfter, 0);\n    }\n\n    override resolvePosition(x: number, y: number): void {\n        super.resolvePosition(x, y);\n\n        // Align children\n        const alignment = this.multiContainerAlignment;\n        const around = alignment.main === FlexAlignment.SpaceAround;\n        const between = alignment.main === FlexAlignment.SpaceBetween || around;\n        const mainRatio = (between ? 0 : alignment.main as number);\n        const crossRatio = (alignment.cross === Alignment.Stretch ? 0 : alignment.cross);\n        const effectiveChildren = this.enabledChildCount - 1 + (around ? 2 : 0);\n        let extraSpacing;\n        if(effectiveChildren <= 0)\n            extraSpacing = 0;\n        else\n            extraSpacing = this.unusedSpace / effectiveChildren;\n\n        let spacing = this.multiContainerSpacing;\n        if(between)\n            spacing += extraSpacing;\n\n        let mainOffset = (this.vertical ? y : x) + mainRatio * this.unusedSpace;\n        if(around)\n            mainOffset += extraSpacing;\n\n        for(const child of this.children) {\n            // Ignore disabled children\n            if(!child.enabled)\n                continue;\n\n            const [oldChildX, oldChildY] = child.idealPosition;\n            const [childWidth, childHeight] = child.idealDimensions;\n\n            if(this.vertical) {\n                child.resolvePosition(x + crossRatio * (this.idealWidth - childWidth), mainOffset);\n                mainOffset += childHeight + spacing;\n            }\n            else {\n                child.resolvePosition(mainOffset, y + crossRatio * (this.idealHeight - childHeight));\n                mainOffset += childWidth + spacing;\n            }\n\n            const [childX, childY] = child.idealPosition;\n\n            // Mark background as dirty if child's position changed\n            if(childX !== oldChildX || childY !== oldChildY)\n                this.backgroundDirty = true;\n        }\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Paint children and build clipping region if background is dirty\n        const clipRects: [number, number, number, number][] = [];\n        for(const child of this.children) {\n            // Paint child\n            child.paint(forced);\n\n            // Add to clipping region if needed. Don't add disabled children to\n            // clipping region\n            if(child.enabled && (this.backgroundDirty || forced))\n                clipRects.push(child.rect);\n        }\n\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart();\n            const ctx = this.viewport.context;\n            ctx.rect(...this.rect);\n            for(const clipRect of clipRects)\n                ctx.rect(...clipRect);\n            this.clearEnd('evenodd');\n        }\n\n        this.backgroundDirty = false;\n    }\n\n    override dryPaint(): void {\n        this.backgroundDirty = false;\n        super.dryPaint();\n    }\n\n    override forceDirty(markLayout = true): void {\n        super.forceDirty(markLayout);\n        this.backgroundDirty = true;\n    }\n}\n", "import type { Widget, WidgetProperties } from '../widgets/Widget';\nimport { Parent } from './Parent';\n\n/**\n * A specialised version of the {@link Parent} class for parents with a single\n * mandatory child.\n *\n * @category Widget\n */\nexport abstract class SingleParent<W extends Widget = Widget> extends Parent<W> {\n    /**\n     * Create a new SingleParent instance.\n     *\n     * @param child - The mandatory single child of this widget. Cannot be changed later, unless {@link Parent#_children} is changed directly via the widget using this mixin.\n     */\n    constructor(child: W, needsClear: boolean, propagatesEvents: boolean, properties?: Readonly<WidgetProperties>) {\n        super([child], needsClear, propagatesEvents, properties);\n    }\n\n    /** This widget's child. */\n    get child(): W {\n        return this._children[0];\n    }\n}", "import { Widget, WidgetProperties } from './Widget';\nimport { FillStyle } from '../theme/FillStyle';\nimport { Alignment } from '../theme/Alignment';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\n\n/**\n * A {@link SingleParent} which contains a single child and automatically paints\n * the child, adds padding, propagates events (if enabled) and handles layout.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport abstract class BaseContainer<W extends Widget = Widget> extends SingleParent<W> {\n    /** Does the background need to be cleared? */\n    protected backgroundDirty = true;\n\n    /** Create a new BaseContainer. */\n    constructor(child: W, propagateEvents: boolean, properties?: Readonly<WidgetProperties>) {\n        // Containers clear their own background, have a child and may propagate\n        // events\n        super(child, false, propagateEvents, properties);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n        }\n        else if(property === 'canvasFill')\n            this.backgroundDirty = true;\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n\n        // If background is dirty, set self as dirty\n        if(this.backgroundDirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get padding\n        const padding = this.containerPadding;\n        const hPadding = padding.left + padding.right;\n        const vPadding = padding.top + padding.bottom;\n        let childMaxWidth = maxWidth - hPadding;\n        let childMaxHeight = maxHeight - vPadding;\n\n        // If there isn't enough space for padding, resolve child's layout with\n        // a tight fit of 0 for axis with lack of space\n        if(childMaxWidth < 0)\n            childMaxWidth = 0;\n        if(childMaxHeight < 0)\n            childMaxHeight = 0;\n\n        // Provide minimum constraints if using stretch alignment, correcting\n        // for padding. If maximum constraints are available (not infinite), use\n        // those instead\n        const alignment = this.containerAlignment;\n        let childMinWidth = 0;\n        if(alignment.horizontal === Alignment.Stretch) {\n            if(childMaxWidth !== Infinity)\n                childMinWidth = childMaxWidth;\n            else\n                childMinWidth = Math.max(minWidth - hPadding, 0);\n        }\n\n        let childMinHeight = 0;\n        if(alignment.vertical === Alignment.Stretch) {\n            if(childMaxHeight !== Infinity)\n                childMinHeight = childMaxHeight;\n            else\n                childMinHeight = Math.max(minHeight - vPadding, 0);\n        }\n\n        // Resolve child's dimensions\n        const [oldChildWidth, oldChildHeight] = this.child.idealDimensions;\n        this.child.resolveDimensions(childMinWidth, childMaxWidth, childMinHeight, childMaxHeight);\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        // Resolve own dimensions\n        const [oldWidth, oldHeight] = [this.idealWidth, this.idealHeight];\n        this.idealWidth = Math.max(minWidth, childWidth + hPadding);\n        this.idealHeight = Math.max(minHeight, childHeight + vPadding);\n\n        // Mark background as dirty if own size or child's size changed\n        if(this.idealWidth !== oldWidth || this.idealHeight !== oldHeight ||\n           childWidth !== oldChildWidth || childHeight !== oldChildHeight)\n            this.backgroundDirty = true;\n    }\n\n    override resolvePosition(x: number, y: number): void {\n        super.resolvePosition(x, y);\n\n        // Get padding and alignment\n        const padding = this.containerPadding;\n        const alignment = this.containerAlignment;\n\n        // Calculate used space\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const usedWidth = childWidth + padding.left + padding.right;\n        const usedHeight = childHeight + padding.top + padding.bottom;\n\n        // Horizontal offset\n        let childX = x + padding.left;\n        if(alignment.horizontal !== Alignment.Stretch) {\n            // Get free space for this axis\n            const freeSpace = this.idealWidth - usedWidth;\n\n            // Ignore if free space is negative or zero, as in, the child didn't\n            // even get the space they requested or just enough space. If there\n            // is free space, distribute free space according to chosen\n            // alignment ratio\n            if(freeSpace > 0)\n                childX += freeSpace * alignment.horizontal;\n        }\n\n        // Vertical offset\n        let childY = y + padding.top;\n        if(alignment.vertical !== Alignment.Stretch) {\n            // Same logic as above, but for vertical axis\n            const freeSpace = this.idealHeight - usedHeight;\n\n            if(freeSpace > 0)\n                childY += freeSpace * alignment.vertical;\n        }\n\n        // Resolve child's position\n        const [oldChildX, oldChildY] = this.child.idealPosition;\n        this.child.resolvePosition(childX, childY);\n\n        // If child's position changed, mark background as dirty\n        if(oldChildX !== childX || oldChildY !== childY)\n            this.backgroundDirty = true;\n    }\n\n    /**\n     * Implementation of handlePainting; separate from handlePainting so that\n     * the fillStyle for the background clear can be overridden.\n     */\n    protected handleBaseContainerPainting(forced: boolean, fillStyle: FillStyle | null = null): void {\n        // Clear background if needed\n        if(this.backgroundDirty || forced) {\n            this.clearStart(fillStyle);\n            const ctx = this.viewport.context;\n            ctx.rect(...this.rect);\n            ctx.rect(...this.child.rect);\n            this.clearEnd('evenodd');\n\n            this.backgroundDirty = false;\n        }\n\n        // Paint child\n        this.child.paint(forced);\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        this.handleBaseContainerPainting(forced);\n    }\n\n    override dryPaint(): void {\n        this.backgroundDirty = false;\n        super.dryPaint();\n    }\n\n    override forceDirty(markLayout = true): void {\n        super.forceDirty(markLayout);\n        this.backgroundDirty = true;\n    }\n}\n", "/**\n * The focus type of an {@link Event}. Used to categorise events when focusing\n * {@link Widget | widgets} in {@link Root | roots}.\n *\n * @category Core\n */\nexport enum FocusType {\n    /** Used for widgets that need pointer input, such as {@link Button} */\n    Pointer = 0,\n    /** Used for widgets that need text input, such as {@link TextInput} */\n    Keyboard = 1,\n    /**\n     * Similar to keyboard focus, but used for checking whether a widget has\n     * been tabbed into (focused by pressing the tab key).\n     *\n     * If a widget gains a tab focus, then it also gain a keyboard focus. If a\n     * widgets gains a keyboard focus, then it also gains a tab focus. However,\n     * losing the tab focus doesn't automatically lose the keyboard focus, and\n     * losing the keyboard focus doesn't automatically lose the tab focus.\n     *\n     * This focus should only be used internally. Do not manually request tab\n     * focus unless you know what you are doing.\n     */\n    Tab = 2,\n}\n", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\nimport { DynMsg } from '../core/Strings';\n\n/**\n * The scrolling mode that determines how the {@link PointerWheel#deltaX},\n * {@link PointerWheel#deltaY} and {@link PointerWheel#deltaZ} values are\n * interpreted.\n */\nexport enum PointerWheelMode {\n    /** In this mode, delta values are measured in pixels. */\n    Pixel,\n    /**\n     * In this mode, delta values are measured in line heights. The height of a\n     * line is supplied as an argument to the\n     * {@link PointerWheel#getDeltaPixels} method.\n     */\n    Line,\n    /**\n     * In this mode, delta values are measured in {@link Widget} dimensions,\n     * minus {@link PointerWheel.PageLinesError | a few lines} or\n     * {@link PointerWheel.PagePercentError | a percentage of the dimensions},\n     * whichever is smaller. Both line height and dimensions are supplied as\n     * arguments to the {@link PointerWheel#getDeltaPixels} method.\n     */\n    Page,\n}\n\n/**\n * Convert DOM WheelEvent.deltaMode to {@link PointerWheelMode}, or null if the\n * DOM delta mode is unknown.\n */\nexport function parseDOMDeltaMode(domDeltaMode: number): PointerWheelMode | null {\n    switch(domDeltaMode) {\n        case 0:\n            return PointerWheelMode.Pixel;\n        case 1:\n            return PointerWheelMode.Line;\n        case 2:\n            return PointerWheelMode.Page;\n        default:\n            return null;\n    }\n}\n\n/**\n * A pointer wheel {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerWheel extends PointerEvent {\n    /**\n     * Wheel event horizontal scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaX: number;\n    /**\n     * Wheel event vertical scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaY: number;\n    /**\n     * Wheel event depth scroll amount. Not an integer. The value's\n     * interpretation depends on {@link PointerWheel#deltaMode}.\n     */\n    readonly deltaZ: number;\n    /**\n     * The mode of the delta values; how the delta values should be\n     * interpreted. See {@link PointerWheelMode}\n     */\n    readonly deltaMode: PointerWheelMode;\n    /** Was this wheel event created from a pointer drag? */\n    readonly fromDrag: boolean;\n\n    /** The amount of lines to remove from a page scroll */\n    static readonly PageLinesError = 3;\n    /** The percentage of a page to remove from a page scroll */\n    static readonly PagePercentError = 0.1;\n\n    /** Create a new PointerWheel. */\n    constructor(x: number, y: number, deltaX: number, deltaY: number, deltaZ: number, deltaMode: PointerWheelMode, fromDrag: boolean, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n        this.deltaX = deltaX;\n        this.deltaY = deltaY;\n        this.deltaZ = deltaZ;\n        this.deltaMode = deltaMode;\n        this.fromDrag = fromDrag;\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerWheel {\n        return new PointerWheel(this.x - xOffset, this.y - yOffset, this.deltaX, this.deltaY, this.deltaZ, this.deltaMode, this.fromDrag, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerWheel {\n        return new PointerWheel(this.x, this.y, this.deltaX, this.deltaY, this.deltaZ, this.deltaMode, this.fromDrag, this.shift, this.ctrl, this.alt, target);\n    }\n\n    /**\n     * Get the scroll delta in pixels, even if the\n     * {@link PointerWheel#deltaMode} is not {@link PointerWheelMode.Pixel}.\n     *\n     * @param forceLimit - Should the delta be limited by {@link PointerWheel.PageLinesError} and {@link PointerWheel.PagePercentError}, if {@link PointerWheel#deltaMode} is not {@link PointerWheelMode.Page}?\n     * @param lineHeight - The full height (line height with spacing) of a line, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerWidth - The width of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerHeight - The height of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta\n     * @param containerDepth - The depth of the container, used for page {@link PointerWheel#deltaMode}, or for limiting the delta. Only used for custom containers/widgets with a Z-axis\n     * @returns Returns a 3-tuple containing the x, y and z components, repectively, of the wheel event in pixels.\n     */\n    getDeltaPixels(forceLimit: boolean, lineHeight: number, containerWidth: number, containerHeight: number, containerDepth = 0): [x: number, y: number, z: number] {\n        let limitX = Infinity, limitY = Infinity, limitZ = Infinity;\n        if(forceLimit || this.deltaMode !== PointerWheelMode.Page) {\n            const linesError = lineHeight * PointerWheel.PageLinesError;\n            limitX = containerWidth - Math.min(containerWidth * PointerWheel.PagePercentError, linesError);\n            limitY = containerHeight - Math.min(containerHeight * PointerWheel.PagePercentError, linesError);\n            limitZ = containerDepth - Math.min(containerDepth * PointerWheel.PagePercentError, linesError);\n        }\n\n        switch(this.deltaMode) {\n            case PointerWheelMode.Pixel:\n                return [\n                    Math.min(limitX, Math.abs(this.deltaX)) * Math.sign(this.deltaX),\n                    Math.min(limitY, Math.abs(this.deltaY)) * Math.sign(this.deltaY),\n                    Math.min(limitZ, Math.abs(this.deltaZ)) * Math.sign(this.deltaZ)\n                ];\n            case PointerWheelMode.Line:\n                return [\n                    Math.min(limitX, Math.abs(this.deltaX) * lineHeight) * Math.sign(this.deltaX),\n                    Math.min(limitY, Math.abs(this.deltaY) * lineHeight) * Math.sign(this.deltaY),\n                    Math.min(limitZ, Math.abs(this.deltaZ) * lineHeight) * Math.sign(this.deltaZ)\n                ];\n            case PointerWheelMode.Page:\n            {\n                const linesError = lineHeight * PointerWheel.PageLinesError;\n                return [\n                    (Math.abs(this.deltaX) * containerWidth - Math.min(containerWidth * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaX),\n                    (Math.abs(this.deltaY) * containerHeight - Math.min(containerHeight * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaY),\n                    (Math.abs(this.deltaZ) * containerDepth - Math.min(containerDepth * PointerWheel.PagePercentError, linesError)) * Math.sign(this.deltaZ)\n                ];\n            }\n            default:\n                throw new Error(DynMsg.INVALID_ENUM(this.deltaMode, 'PointerWheelMode', 'deltaMode'));\n        }\n    }\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { ModifierEvent } from './ModifierEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A keyboard {@link ModifierEvent}. This is an abstract class and is\n * implemented in the child classes {@link KeyPress} and {@link KeyRelease}.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport abstract class KeyEvent extends ModifierEvent {\n    /**\n     * This event's key. Uses the same values as the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key}\n     * Web API.\n     */\n    readonly key: string;\n\n    /** Create a new KeyEvent. */\n    constructor(key: string, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null) {\n        super(shift, ctrl, alt, target, FocusType.Keyboard, true);\n        this.key = key;\n    }\n}\n", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key press {@link KeyEvent} (key down). Also dispatched on key repeats.\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyPress extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyPress {\n        return new KeyPress(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { FocusType} from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\nimport { Event } from './Event';\n\n/**\n * A leave {@link Event}. Dispatched when the pointer leaves the root or the\n * focus capturer changes to another widget.\n *\n * Has a focus type of {@link FocusType.Pointer} and needs focus.\n *\n * @category Event\n */\nexport class Leave extends Event {\n    /**\n     * Create a new KeyEvent. Sets {@link Event#target}, {@link Event#focusType}\n     * to {@link FocusType.Pointer} and {@link Event#needsFocus} to true.\n     */\n    constructor(target: Widget | null = null) {\n        super(target, FocusType.Pointer, true);\n    }\n\n    cloneWithTarget(target: Widget | null): Leave {\n        return new Leave(target);\n    }\n}\n", "import type { ThemeProperties } from './ThemeProperties';\nimport { BaseTheme } from './BaseTheme';\n\n/**\n * Provides styling for {@link Widget | Widgets}.\n *\n * @category Theme\n */\nexport class Theme extends BaseTheme {\n    /** Listeners that are listening for changes in this theme (or fallback) */\n    protected subscribers: Set<(property: string | null) => void>;\n\n    /** Create a new Theme */\n    constructor(properties?: ThemeProperties, fallbackTheme?: Theme) {\n        super(properties, fallbackTheme);\n        this.subscribers = new Set();\n    }\n\n    override get fallbackTheme(): Theme | undefined {\n        return super.fallbackTheme;\n    }\n\n    override set fallbackTheme(newTheme: Theme | undefined) {\n        super.fallbackTheme = newTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        // Notify all subscribers\n        for(const listener of this.subscribers)\n            listener(property);\n    }\n\n    /**\n     * Subscribe to this theme. When a change occurs in the theme, the passed\n     * listener callback will be called. The argument used for the callback will\n     * be null if the theme's fallback has changed and therefore all properties\n     * are to be assumed as changed, else, the argument will be a string\n     * containing the name of the theme property that changed.\n     */\n    subscribe(listener: (property: string | null) => void): void {\n        this.subscribers.add(listener);\n    }\n\n    /**\n     * Unsubscribe from this theme; removes the listener callback from the list\n     * of subscribers.\n     */\n    unsubscribe(listener: (property: string | null) => void): void {\n        this.subscribers.delete(listener);\n    }\n}", "import type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { LayoutConstraints } from './LayoutConstraints';\nimport type { TextInputHandler } from './TextInputHandler';\nimport { DynMsg, groupedStackTrace } from './Strings';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { CanvasViewport } from './CanvasViewport';\nimport type { Widget } from '../widgets/Widget';\nimport { TabSelect } from '../events/TabSelect';\nimport { KeyPress } from '../events/KeyPress';\nimport type { Event } from '../events/Event';\nimport { FocusType } from './FocusType';\nimport { Leave } from '../events/Leave';\nimport type { Driver } from './Driver';\nimport { Theme } from '../theme/Theme';\n\n/**\n * A Root is the parent of all widgets, but not a widget itself. It contains a\n * single child and manages dimensions and input handling\n *\n * @category Core\n */\nexport class Root {\n    /** The internal viewport. Manages drawing */\n    protected viewport: CanvasViewport;\n    /** The list of drivers registered to this root */\n    protected drivers: Set<Driver> = new Set();\n    /**\n     * Is the Root enabled? For internal use only.\n     *\n     * See {@link Root#enabled}\n     */\n    protected _enabled = true;\n    /**\n     * The pointer style this root wants. Will be set on\n     * {@link Root#postLayoutUpdate} by {@link Root#pointerStyleHandler}\n     */\n    pointerStyle = 'default';\n    /**\n     * The actual current pointer style.\n     *\n     * For internal use only.\n     *\n     * See {@link Root#pointerStyle}\n     */\n    protected _currentPointerStyle = 'default';\n    /**\n     * Pointer style handler, decides how to show the given pointer style.\n     * Normally a function which sets the CSS cursor style of the Root's canvas\n     */\n    pointerStyleHandler: PointerStyleHandler | null;\n    /**\n     * Current component foci (event targets for each focus type).\n     *\n     * For internal use only.\n     *\n     * See {@link Root#requestFocus}, {@link Root#dropFocus},\n     * {@link Root#clearFocus} and {@link Root#getFocus}\n     */\n    protected _foci: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n        [FocusType.Tab, null],\n    ]);\n    /**\n     * Last capturer of each component focus (event targets for each focus\n     * type).\n     *\n     * For internal use only.\n     *\n     * See {@link Root#getFocusCapturer}\n     */\n    protected _fociCapturers: Map<FocusType, Widget | null> = new Map([\n        [FocusType.Keyboard, null],\n        [FocusType.Pointer, null],\n        [FocusType.Tab, null],\n    ]);\n    /**\n     * Handler for mobile-friendly text input. If not null, widgets that need\n     * text may call this to get a string.\n     *\n     * See {@link Root#hasMobileTextInput}, {@link Root#usingMobileTextInput}\n     * and {@link Root#getTextInput}\n     */\n    textInputHandler: TextInputHandler | null = null;\n    /**\n     * Is the mobile-friendly text input in use?\n     *\n     * For internal use only.\n     *\n     * See {@link Root#hasMobileTextInput}, {@link Root#usingMobileTextInput}\n     * and {@link Root#getTextInput}\n     */\n    protected _mobileTextInUse = false;\n    /** Has the warning for poorly captured TabSelect events been issued? */\n    private static badTabCaptureWarned = false;\n\n    /**\n     * Creates a new Root.\n     *\n     * Sets {@link Root#child}, {@link Root#pointerStyleHandler} and\n     * {@link Root#child}'s {@link Widget#inheritedTheme | inherited theme}.\n     *\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(child: Widget, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        this.viewport = new CanvasViewport(child);\n        this.pointerStyleHandler = pointerStyleHandler;\n        this.child.inheritedTheme = theme;\n        this.child.activate(this, this.viewport, null);\n    }\n\n    /** The {@link Root#viewport}'s {@link Viewport#constraints | constraints} */\n    get constraints(): LayoutConstraints {\n        return this.viewport.constraints;\n    }\n\n    set constraints(constraints: LayoutConstraints) {\n        this.viewport.constraints = constraints;\n    }\n\n    /**\n     * The {@link Root#viewport}'s\n     * {@link CanvasViewport#canvasDimensions | canvasDimensions}\n     */\n    get canvasDimensions(): [number, number] {\n        return this.viewport.canvasDimensions;\n    }\n\n    /**\n     * The {@link Root#child}'s {@link Widget#dimensions | dimensions}\n     */\n    get dimensions(): [number, number] {\n        return this.child.dimensions;\n    }\n\n    /**\n     * Is this root enabled? If not enabled, painting, updating or resolving\n     * layout will do nothing. {@link Root#drivers | Drivers} will also be\n     * notified by calling {@link Driver#onEnable} or {@link Driver#onDisable},\n     * pointer style will be reset ({@link Root#updatePointerStyle} called with\n     * 'default') and all {@link Root#_foci | foci} will be cleared\n     * ({@link Root#clearFocus}).\n     *\n     * See {@link Root#_enabled}\n     */\n    get enabled(): boolean {\n        return this._enabled;\n    }\n\n    set enabled(newEnabled: boolean) {\n        const oldEnabled = this._enabled;\n\n        if(oldEnabled !== newEnabled) {\n            this._enabled = newEnabled;\n\n            // Call driver hooks, reset pointer style and release foci if UI\n            // disabled\n            if(newEnabled) {\n                for(const driver of this.drivers)\n                    driver.onEnable(this);\n            }\n            else {\n                for(const driver of this.drivers)\n                    driver.onDisable(this);\n\n                this.updatePointerStyle('default');\n\n                for(const focus of this._foci.keys())\n                    this.clearFocus(focus);\n            }\n        }\n    }\n\n\n    /**\n     * The {@link Root#viewport}'s {@link CanvasViewport#canvas | canvas}\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.viewport.canvas;\n    }\n\n    /**\n     * Resolve the layout of this root. Does nothing if root is disabled.\n     *\n     * Calls {@link Root#viewport}'s {@link Viewport#resolveLayout} with\n     * {@link Root#child}\n     *\n     * Call this before calling {@link Root#postLayoutUpdate} and after calling\n     * {@link Root#preLayoutUpdate}\n     *\n     * @returns Returns true if the viewport was resized or re-scaled\n     */\n    resolveLayout(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.resolveLayout();\n    }\n\n    /**\n     * Paint this root's next frame if needed. Does nothing if root is disabled.\n     *\n     * Calls {@link Root#viewport}'s {@link Viewport#paint} with\n     * {@link Root#child}.\n     *\n     * Call this after calling {@link Root#postLayoutUpdate}.\n     *\n     * @returns Returns whether the child was dirty or not. Use this to tell an external 3D library whether to update a mesh's texture or not.\n     */\n    paint(): boolean {\n        // Don't do anything if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        return this.viewport.paintToInternal(false);\n    }\n\n    /**\n     * Dispatches an {@link Event} to this root's {@link Root#child} by calling\n     * {@link Widget#dispatchEvent}. Updates\n     * {@link Root#_fociCapturers | foci capturers} and notifies\n     * {@link Root#drivers} by calling {@link Driver#onFocusCapturerChanged} if\n     * the capturer changes. Does nothing if root is disabled.\n     *\n     * Note that if an event with a focus is dispatched and no widget captures\n     * the event due to the widget not existing anymore or being disabled, the\n     * focus type of the event will be cleared in the root with\n     * {@link Root#clearFocus}.\n     *\n     * @returns Returns true if the event was captured\n     */\n    dispatchEvent(event: Event): boolean {\n        // Ignore event if Root is disabled\n        if(!this.enabled)\n            return false;\n\n        // If event is focusable and is missing a target...\n        if(event.focusType !== null && event.target === null) {\n            // Ignore event if it needs a focus but there is no component\n            // focused in the needed focus\n            let focus = this._foci.get(event.focusType);\n            if(typeof focus === 'undefined')\n                focus = null;\n\n            if(event.needsFocus && focus === null) {\n                // special case for tab key with no currently focused widget;\n                // try to do tab selection\n                if(event instanceof KeyPress && event.key === 'Tab')\n                    this.dispatchEvent(new TabSelect(this.getFocus(FocusType.Tab), event.shift));\n\n                return false;\n            }\n\n            // Set event target\n            event = event.cloneWithTarget(focus);\n        }\n\n        // Clear pointer style. This will be set by children if neccessary\n        if((event instanceof PointerEvent && !(event instanceof PointerWheel)) || event instanceof Leave)\n            this.pointerStyle = 'default';\n\n        // Pass event down to internal Container\n        let captured = this.child.dispatchEvent(event);\n        if(captured === null) {\n            if(event instanceof KeyPress) {\n                if(event.key === 'Tab') {\n                    // special case for tab key; try to do tab selection\n                    this.dispatchEvent(new TabSelect(this.getFocus(FocusType.Tab), event.shift));\n                }\n                else if(event.key === 'Escape') {\n                    // special case for escape key; clear keyboard focus\n                    this.clearFocus(FocusType.Keyboard);\n                }\n            }\n\n            // If this was a tab selection relative to a widget, but the widget\n            // was not found, try again but with no relative widget. This\n            // happens when a removed widget still has tab focus\n            if(event instanceof TabSelect && event.relativeTo !== null) {\n                event = new TabSelect(null, event.reversed);\n                captured = this.child.dispatchEvent(event);\n            }\n        }\n\n        if(event instanceof TabSelect) {\n            if(event.reachedRelative && captured === null) {\n                // If the tab selection failed even though the relative widget\n                // was reached, then the end of the search was likely reached.\n                // Try to start from the beginning again\n                captured = this.child.dispatchEvent(event);\n            }\n\n            if(captured) {\n                if(!event.reachedRelative && !Root.badTabCaptureWarned) {\n                    Root.badTabCaptureWarned = true;\n                    console.warn(DynMsg.OVERCAPTURING_WIDGET(captured));\n                    groupedStackTrace();\n                }\n\n                // Request tab focus if tab select event was captured\n                this.requestFocus(FocusType.Tab, captured);\n            }\n        }\n\n        // Update focus capturer if it changed\n        if(event.focusType === null)\n            return captured !== null;\n\n        const oldCapturer = this.getFocusCapturer(event.focusType);\n        if(oldCapturer === captured)\n            return captured !== null;\n\n        // Special case: when the pointer focus capturer changes, dispatch a\n        // leave event to the last capturer\n        if(event.focusType === FocusType.Pointer && oldCapturer !== null)\n            this.child.dispatchEvent(new Leave(oldCapturer));\n\n        this._fociCapturers.set(event.focusType, captured);\n        for(const driver of this.drivers)\n            driver.onFocusCapturerChanged(this, event.focusType, oldCapturer, captured);\n\n        return captured !== null;\n    }\n\n    /**\n     * Do a pre-layout update; calls {@link Root#drivers}' {@link Driver#update}\n     * and {@link Root#child}'s {@link Widget#preLayoutUpdate}. Does nothing if\n     * root is disabled.\n     *\n     * Call this before calling {@link Root#resolveLayout}\n     */\n    preLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Update drivers\n        for(const driver of this.drivers)\n            driver.update(this);\n\n        // Pre-layout update child\n        this.child.preLayoutUpdate();\n    }\n\n\n    /**\n     * Do a post-layout update; calls {@link Root#child}'s\n     * {@link Widget#postLayoutUpdate} and {@link Root#updatePointerStyle}. Does\n     * nothing if root is disabled.\n     *\n     * Call this before calling {@link Root#paint} and after calling\n     * {@link Root#resolveLayout}\n     */\n    postLayoutUpdate(): void {\n        // Skip if UI is disabled\n        if(!this.enabled)\n            return;\n\n        // Post-layout update child\n        this.child.postLayoutUpdate();\n\n        // Update pointer style\n        this.updatePointerStyle();\n    }\n\n    /**\n     * Calls {@link Root#pointerStyleHandler} if the {@link Root#pointerStyle}\n     * has changed (checked by comparing with\n     * {@link Root#_currentPointerStyle}). Also updates\n     * {@link Root#_currentPointerStyle}. Can also be optionally supplied a new\n     * pointer style.\n     */\n    updatePointerStyle(newStyle: string | null = null): void {\n        if(newStyle !== null)\n            this.pointerStyle = newStyle;\n\n        if(this.pointerStyle !== this._currentPointerStyle) {\n            this._currentPointerStyle = this.pointerStyle;\n            if(this.pointerStyleHandler !== null)\n                this.pointerStyleHandler(this._currentPointerStyle);\n        }\n    }\n\n    /**\n     * Sets the current {@link Root#_foci | focus} of a given type to a given\n     * widget. If the focus changes, {@link Root#clearFocus} is called and\n     * {@link Root#drivers} are notified by calling\n     * {@link Driver#onFocusChanged}.\n     */\n    requestFocus(focusType: FocusType, widget: Widget): void {\n        if(widget !== null) {\n            // Replace focus if current focus is not the desired one\n            const currentFocus = this._foci.get(focusType);\n            if(widget !== currentFocus) {\n                this.clearFocus(focusType);\n                this._foci.set(focusType, widget);\n                widget.onFocusGrabbed(focusType);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, focusType, widget);\n            }\n\n            // special cases for keyboard and tab foci, since they are\n            // usually together. a focus that is implied by another focus is\n            // called a partner focus\n            let partnerFocus = null;\n            if(focusType === FocusType.Keyboard)\n                partnerFocus = FocusType.Tab;\n            if(focusType === FocusType.Tab)\n                partnerFocus = FocusType.Keyboard;\n\n            if(partnerFocus !== null && widget !== this._foci.get(partnerFocus)) {\n                this.clearFocus(partnerFocus);\n                this._foci.set(partnerFocus, widget);\n                widget.onFocusGrabbed(partnerFocus);\n                for(const driver of this.drivers)\n                    driver.onFocusChanged(this, partnerFocus, widget);\n            }\n        }\n    }\n\n    /**\n     * Clears the current {@link Root#_foci | focus} of a given type if it is\n     * currently set to a given widget. Achieved by calling\n     * {@link Root#clearFocus}.\n     */\n    dropFocus(focusType: FocusType, widget: Widget): void {\n        // NOTE: Use this instead of clearFocus if your intent is to make sure a\n        // SPECIFIC COMPONENT is no longer focused, NOT ANY COMPONENT\n        const currentFocus = this._foci.get(focusType);\n        if(widget === currentFocus)\n            this.clearFocus(focusType);\n    }\n\n    /**\n     * Clears the current {@link Root#_foci | focus} of a given type. If there\n     * was a focus set, {@link Root#drivers} are notified by calling\n     * {@link Driver#onFocusChanged}.\n     */\n    clearFocus(focusType: FocusType): void {\n        const currentFocus = this._foci.get(focusType);\n        if(currentFocus) {\n            currentFocus.onFocusDropped(focusType);\n\n            this._foci.set(focusType, null);\n            for(const driver of this.drivers)\n                driver.onFocusChanged(this, focusType, null);\n\n            // XXX no special case for clearing keyboard/tab focus. keyboard\n            // implies tab and vice-versa, but lack of keyboard does not imply\n            // lack of tab and vice-versa\n        }\n    }\n\n    /**\n     * Gets the current {@link Root#_foci | focus} of a given type.\n     */\n    getFocus(focusType: FocusType): Widget | null {\n        return this._foci.get(focusType) ?? null;\n    }\n\n    /**\n     * Gets the last {@link Root#_fociCapturers | focus capturer} of a given\n     * type.\n     */\n    getFocusCapturer(focusType: FocusType): Widget | null {\n        return this._fociCapturers.get(focusType) ?? null;\n    }\n\n    /**\n     * Registers a {@link Driver} to the root, adding it to the\n     * {@link Root#drivers} list and calling {@link Driver#onEnable}. If the\n     * driver was already registered, nothing happens.\n     */\n    registerDriver(driver: Driver): void {\n        // If driver is not registered, register it\n        if(this.drivers.has(driver))\n            return;\n\n        this.drivers.add(driver);\n        if(this._enabled && driver.onEnable)\n            driver.onEnable(this);\n    }\n\n    /**\n     * Unregisters a {@link Driver} from the root, removing it from the\n     * {@link Root#drivers} list and calling {@link Driver#onDisable}. If the\n     * driver was not registered, nothing happens.\n     */\n    unregisterDriver(driver: Driver): void {\n        // If driver is registered, unregister it\n        if(!this.drivers.delete(driver))\n            return;\n\n        if(this._enabled && driver.onDisable)\n            driver.onDisable(this);\n    }\n\n    /**\n     * Unregisters all {@link Root#drivers} from the root, by calling\n     * {@link Root#unregisterDriver}.\n     */\n    clearDrivers(): void {\n        // Unregister all drivers\n        for(const driver of this.drivers)\n            this.unregisterDriver(driver);\n    }\n\n    /**\n     * Can {@link Root#getTextInput} be called? True if\n     * {@link Root#textInputHandler} is not null and\n     * {@link Root#usingMobileTextInput} is false.\n     */\n    get hasMobileTextInput(): boolean {\n        return this.textInputHandler !== null && !this._mobileTextInUse;\n    }\n\n    /**\n     * Is {@link Root#getTextInput} in use?\n     *\n     * See {@link Root#_mobileTextInUse}.\n     */\n    get usingMobileTextInput(): boolean {\n        return this._mobileTextInUse;\n    }\n\n    /**\n     * Get text input from the user. Used for mobile where keyboard events are\n     * hard to get.\n     *\n     * @returns If this is already in use ({@link Root#usingMobileTextInput}), returns null, else, returns a string typed by the user.\n     */\n    async getTextInput(initialInput = ''): Promise<string | null> {\n        // Only get if text input is currently available\n        // XXX even though this if statement is equivalent to\n        // hasMobileTextInput, typescript type inference is bad and only works\n        // if its done this way, else it thinks that textInputHandler may be\n        // null and throws an error when compiling\n        if(this.textInputHandler !== null && !this._mobileTextInUse) {\n            // Flag text input as in-use\n            this._mobileTextInUse = true;\n\n            // Get input from handler\n            const newInput = await this.textInputHandler(initialInput);\n\n            // Flag text input as not in-use\n            this._mobileTextInUse = false;\n\n            // Return new value\n            return newInput;\n        }\n\n        return null;\n    }\n\n    /**\n     * Shortcut for {@link Root#viewport}'s {@link CanvasViewport#resolution}\n     * property.\n     *\n     * Note that, although the resolution is part of the {@link CanvasViewport}\n     * API, widgets will treat the resolution property as being per-Root, not\n     * per-Viewport (hence the lack of a Viewport.resolution property). The\n     * resolution property is part of the CanvasViewport class so that\n     * CanvasViewport is not circularly dependent on the Root class.\n     */\n    get resolution(): number {\n        return this.viewport.resolution;\n    }\n\n    set resolution(resolution: number) {\n        this.viewport.resolution = resolution;\n    }\n\n    /**\n     * Shortcut for {@link Root#viewport}'s\n     * {@link CanvasViewport#maxCanvasWidth} property\n     */\n    get maxCanvasWidth(): number {\n        return this.viewport.maxCanvasWidth;\n    }\n\n    set maxCanvasWidth(maxCanvasWidth: number) {\n        this.viewport.maxCanvasWidth = maxCanvasWidth;\n    }\n\n    /**\n     * Shortcut for {@link Root#viewport}'s\n     * {@link CanvasViewport#maxCanvasHeight} property\n     */\n    get maxCanvasHeight(): number {\n        return this.viewport.maxCanvasHeight;\n    }\n\n    set maxCanvasHeight(maxCanvasHeight: number) {\n        this.viewport.maxCanvasHeight = maxCanvasHeight;\n    }\n\n    /**\n     * Get the scale used for the {@link Root#viewport}. The horizontal and/or\n     * vertical scale may not be 1 if {@link Root#maxCanvasWidth} or\n     * {@link Root#maxCanvasHeight} are exceeded.\n     *\n     * Note that this is only valid after resolving {@link Root#child}'s layout.\n     *\n     * Equivalent to getting {@link Viewport#effectiveScale} on\n     * {@link Root#viewport}.\n     */\n    get effectiveScale(): [scaleX: number, scaleY: number] {\n        return this.viewport.effectiveScale;\n    }\n\n    /**\n     * The root widget of this UI tree. Equivalent to getting\n     * {@link Root#viewport}.{@link Viewport#child}.\n     */\n    get child(): Widget {\n        return this.viewport.child;\n    }\n}\n", "// Need to use unsafe code which abuses the any type\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { TextRenderGroup } from '../helpers/TextHelper';\nimport { MultiContainer } from '../widgets/MultiContainer';\nimport { BaseContainer } from '../widgets/BaseContainer';\nimport type { FillStyle } from '../theme/FillStyle';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { BaseTheme } from '../theme/BaseTheme';\nimport { Widget } from '../widgets/Widget';\nimport { Msg } from './Strings';\nimport { Root } from './Root';\n\nconst features: Map<string, [enabled: boolean, description: string]> = new Map();\n\n/**\n * Check if a debug feature is enabled.\n *\n * @param debugFeature - The debug feature name, for example, \"watchflag.Widget._dirty\"\n * @returns Returns true if the debug feature is enabled. If the feature doesn't exist or ins't enabled, returns false.\n */\nexport function isDebugFeatureEnabled(debugFeature: string): boolean {\n    const featureConfig = features.get(debugFeature);\n    if(featureConfig === undefined) {\n        console.warn(`Unknown debug feature \"${debugFeature}\"; defaulting to not enabled`);\n        return false;\n    }\n\n    return featureConfig[0];\n}\n\n/**\n * Enable or disable a debug feature.\n *\n * @param debugFeature - The debug feature name, for example, \"watchflag.Widget._dirty\"\n * @param enabled - Should the feature be enabled or disabled? If undefined, toggles the feature\n */\nexport function toggleDebugFeature(debugFeature: string, enabled?: boolean): void {\n    const featureConfig = features.get(debugFeature);\n    if(featureConfig === undefined) {\n        console.warn(`Unknown debug feature \"${debugFeature}\"; ignored`);\n        return;\n    }\n\n    const [wasEnabled, _description] = featureConfig;\n\n    if(enabled === undefined)\n        enabled = !wasEnabled;\n\n    if(wasEnabled !== enabled) {\n        featureConfig[0] = enabled;\n        console.info(`[canvas-ui] ${enabled ? 'En' : 'Dis'}abled \"${debugFeature}\" debug feature`);\n    }\n}\n\n/** List all debug features in the console. */\nexport function listDebugFeatures(): void {\n    for(const [feature, featureConfig] of features)\n        console.info(`[canvas-ui] \"${feature}\" (${featureConfig[0] ? 'en' : 'dis'}abled): ${featureConfig[1]}`);\n}\n\n/**\n * Inject code for a new debug feature that watches when a class' property is\n * set to true and prints to the console.\n *\n * @param classObj - The class. Widget for example\n * @param flagKey - The key of the property to watch. \"_dirty\" for example\n */\nexport function injectWatchflagFeature(classObj: any, flagKey: string): void {\n    const propertyPath = `${classObj.name}.${flagKey}`;\n    const featureName = `watchflag.${propertyPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const featureNameStrace = `watchflag.${propertyPath}.strace`;\n    if(features.has(featureNameStrace)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureNameStrace}; ignored`);\n        return;\n    }\n\n    const valueMap: WeakMap<any, boolean> = new WeakMap();\n    Object.defineProperty(classObj.prototype, flagKey, {\n        get() {\n            return valueMap.get(this);\n        },\n        set(newValue) {\n            if(isDebugFeatureEnabled(featureName)) {\n                const oldVal = valueMap.get(this);\n                if(!oldVal && newValue) {\n                    const msg = `[canvas-ui ${featureName}] ${this.constructor.name}.${flagKey} set to true`;\n                    if(isDebugFeatureEnabled(featureNameStrace)) {\n                        console.groupCollapsed(msg);\n                        console.trace();\n                        console.groupEnd();\n                    }\n                    else\n                        console.debug(msg);\n                }\n            }\n\n            valueMap.set(this, newValue);\n        },\n    });\n\n    features.set(featureName, [false, `Show when ${propertyPath} is set to true`]);\n    features.set(featureNameStrace, [false, `Print stack trace when ${featureName} shows that a flag has been set`]);\n}\n\n/**\n * Inject code for a new debug feature that traces when a class' method is\n * called, if the class calls the same method for other objects (prints tree)\n * and how long each call took in milliseconds.\n *\n * @param classObj - The class. Widget for example\n * @param methodKey - The key of the property to watch. \"paint\" for example\n * @param messageGenerator - A function that returns a string with extra information about the function call. For example, a function which returns \" (forced)\" if Widget.paint is called with forced set to true\n */\nexport function injectTraceFeature(classObj: any, methodKey: string, messageGenerator: ((...args: any[]) => string) | null = null): void {\n    const methodPath = `${classObj.name}.${methodKey}`;\n    const featureName = `trace.${methodPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const msgStack: Array<string> = [];\n    const msgIndices: Map<any, number> = new Map();\n    const methodOrig = classObj.prototype[methodKey];\n    let traceLevel = 0;\n\n    function logMsgStack(): void {\n        if(traceLevel === 0) {\n            if(isDebugFeatureEnabled(featureName))\n                console.debug(`[canvas-ui ${featureName}] Trace:\\n${msgStack.join('\\n')}`);\n\n            traceLevel = 0;\n            msgStack.length = 0;\n            msgIndices.clear();\n        }\n    }\n\n    classObj.prototype[methodKey] = function(...args: any[]) {\n        traceLevel++;\n        let msgIndex = msgIndices.get(this);\n\n        if(msgIndex === undefined) {\n            msgIndex = msgStack.length;\n            msgIndices.set(this, msgIndex);\n            let prefix;\n            if(traceLevel > 1)\n                prefix = '  '.repeat(traceLevel - 2) + '> ';\n            else\n                prefix = '';\n\n            msgStack.push(`${prefix}${this.constructor.name}`);\n        }\n        else\n            msgStack[msgIndex] += ', recall';\n\n        if(messageGenerator !== null)\n            msgStack[msgIndex] += messageGenerator.apply(this, args);\n\n        const startTime = (new Date()).getTime();\n\n        try {\n            const returnVal = methodOrig.apply(this, args);\n            msgStack[msgIndex] += ` <${(new Date()).getTime() - startTime} ms>`;\n            return returnVal;\n        }\n        catch(e) {\n            msgStack[msgIndex] += ' <exception thrown>';\n            throw e;\n        }\n        finally {\n            traceLevel--;\n            logMsgStack();\n        }\n    }\n\n    features.set(featureName, [false, `Trace ${methodPath} method calls`]);\n}\n\n/**\n * Inject code for a new debug feature that returns a random fill colour in a\n * given property when enabled.\n *\n * EPILEPSY WARNING: This debug feature may trigger epileptic seizures when\n * enabled, especially for widgets that frequently update.\n *\n * @param classObj - The class. BaseTheme for example\n * @param themePropertyKey - The key of the property to override. \"canvasFill\" for example\n */\nexport function injectRandomFillFeature(classObj: any, themePropertyKey: string): void {\n    const propertyPath = `${classObj.name}.${themePropertyKey}`;\n    const featureName = `randomfill.${propertyPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const propertyOrig = Object.getOwnPropertyDescriptor(classObj.prototype, themePropertyKey);\n    Object.defineProperty(classObj.prototype, themePropertyKey, {\n        get() {\n            if(isDebugFeatureEnabled(featureName))\n                return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n            else if(propertyOrig?.get !== undefined)\n                return propertyOrig.get.apply(this);\n        },\n        set(newValue) {\n            if(propertyOrig?.set !== undefined)\n                propertyOrig.set.apply(this, [newValue]);\n        },\n    });\n\n    features.set(featureName, [false, `(EPILEPSY WARNING) Override the ${propertyPath} theme property with a new random colour every time the theme property's value is fetched. Useful for visualising widget painting`]);\n}\n\n/**\n * Inject code for a new debug feature that calls console.trace when a specific\n * method is called and this feature is enabled.\n *\n * @param classObj - The class. Widget for example\n * @param methodKey - The key of the property to watch. \"paint\" for example\n */\nexport function injectStackTraceFeature(classObj: any, methodKey: string): void {\n    const methodPath = `${classObj.name}.${methodKey}`;\n    const featureName = `stacktrace.${methodPath}`;\n    if(features.has(featureName)) {\n        console.warn(`[canvas-ui] Already injected debug feature with name ${featureName}; ignored`);\n        return;\n    }\n\n    const methodOrig = classObj.prototype[methodKey];\n    classObj.prototype[methodKey] = function(...args: any[]) {\n        if(isDebugFeatureEnabled(featureName)) {\n            console.groupCollapsed(`[canvas-ui ${featureName}] ${classObj.name}.${methodKey} called`);\n            console.trace();\n            console.groupEnd();\n        }\n\n        return methodOrig.apply(this, args);\n    }\n\n    features.set(featureName, [false, `Print stack trace when ${methodPath} is called`]);\n}\n\n/**\n * Check if a given number is whole, given a minimum distance from the nearest\n * whole number. If sensitivity is 0, then the number must be an integer. If\n * not, the it can be near an integer and still count as whole.\n */\nfunction isWhole(val: number, sensitivity: number) {\n    const clamped = Math.abs(val) % 1;\n    if(clamped < sensitivity)\n        return true;\n    else if(clamped > 1 - sensitivity)\n        return true;\n    else\n        return false;\n}\n\nlet injected = false;\n\n/**\n * Inject all default debug code. Call this before doing anything if you want to\n * enable debugging. Has no effect when called more than once.\n */\nexport function injectDebugCode(): void {\n    if(injected) {\n        console.warn('[canvas-ui] Already injected debug code; ignored');\n        return;\n    }\n\n    injected = true;\n\n    // trace.Widget.paint\n    injectTraceFeature(Widget, 'paint', (forced) => {\n        return forced ? ' (forced)' : '';\n    });\n    // trace.Widget.resolveDimensions\n    injectTraceFeature(Widget, 'resolveDimensions', (minWidth, maxWidth, minHeight, maxHeight) => {\n        return ` (${minWidth}, ${maxWidth}, ${minHeight}, ${maxHeight})`;\n    });\n    // trace.Widget.resolvePosition\n    injectTraceFeature(Widget, 'resolvePosition', (x, y) => {\n        return ` (${x}, ${y})`;\n    });\n    // trace.Widget.dispatchEvent\n    injectTraceFeature(Widget, 'dispatchEvent', (event) => {\n        return ` (${event.constructor.name})`;\n    });\n    // stacktrace.Root.resolveLayout\n    injectStackTraceFeature(Root, 'resolveLayout');\n    // stacktrace.Root.paint\n    injectStackTraceFeature(Root, 'paint');\n    // stacktrace.Root.dispatchEvent\n    injectStackTraceFeature(Root, 'dispatchEvent');\n    // stacktrace.Root.preLayoutUpdate\n    injectStackTraceFeature(Root, 'preLayoutUpdate');\n    // stacktrace.Root.postLayoutUpdate\n    injectStackTraceFeature(Root, 'postLayoutUpdate');\n    // stacktrace.Root.updatePointerStyle\n    injectStackTraceFeature(Root, 'updatePointerStyle');\n    // stacktrace.Root.requestFocus\n    injectStackTraceFeature(Root, 'requestFocus');\n    // stacktrace.Root.dropFocus\n    injectStackTraceFeature(Root, 'dropFocus');\n    // stacktrace.Root.clearFocus\n    injectStackTraceFeature(Root, 'clearFocus');\n    // stacktrace.Root.getFocus\n    injectStackTraceFeature(Root, 'getFocus');\n    // stacktrace.Root.getFocusCapturer\n    injectStackTraceFeature(Root, 'getFocusCapturer');\n    // stacktrace.Root.registerDriver\n    injectStackTraceFeature(Root, 'registerDriver');\n    // stacktrace.Root.unregisterDriver\n    injectStackTraceFeature(Root, 'unregisterDriver');\n    // stacktrace.Root.clearDrivers\n    injectStackTraceFeature(Root, 'clearDrivers');\n    // stacktrace.Root.getTextInput\n    injectStackTraceFeature(Root, 'getTextInput');\n    // stacktrace.Widget.onThemeUpdated\n    injectStackTraceFeature(Widget, 'onThemeUpdated');\n    // stacktrace.Widget.onFocusDropped\n    injectStackTraceFeature(Widget, 'onFocusDropped');\n    // stacktrace.Widget.handleEvent\n    injectStackTraceFeature(Widget, 'handleEvent');\n    // stacktrace.Widget.dispatchEvent\n    injectStackTraceFeature(Widget, 'dispatchEvent');\n    // stacktrace.Widget.handlePreLayoutUpdate\n    injectStackTraceFeature(Widget, 'handlePreLayoutUpdate');\n    // stacktrace.Widget.preLayoutUpdate\n    injectStackTraceFeature(Widget, 'preLayoutUpdate');\n    // stacktrace.Widget.handleResolveDimensions\n    injectStackTraceFeature(Widget, 'handleResolveDimensions');\n    // stacktrace.Widget.resolveDimensions\n    injectStackTraceFeature(Widget, 'resolveDimensions');\n    // stacktrace.Widget.resolveDimensionsAsTop\n    injectStackTraceFeature(Widget, 'resolveDimensionsAsTop');\n    // stacktrace.Widget.resolvePosition\n    injectStackTraceFeature(Widget, 'resolvePosition');\n    // stacktrace.Widget.handlePostLayoutUpdate\n    injectStackTraceFeature(Widget, 'handlePostLayoutUpdate');\n    // stacktrace.Widget.postLayoutUpdate\n    injectStackTraceFeature(Widget, 'postLayoutUpdate');\n    // stacktrace.Widget.clear\n    injectStackTraceFeature(Widget, 'clear');\n    // stacktrace.Widget.clearStart\n    injectStackTraceFeature(Widget, 'clearStart');\n    // stacktrace.Widget.clearEnd\n    injectStackTraceFeature(Widget, 'clearEnd');\n    // stacktrace.Widget.roundRect\n    injectStackTraceFeature(Widget, 'roundRect');\n    // stacktrace.Widget.handlePainting\n    injectStackTraceFeature(Widget, 'handlePainting');\n    // stacktrace.Widget.paint\n    injectStackTraceFeature(Widget, 'paint');\n    // stacktrace.Widget.dryPaint\n    injectStackTraceFeature(Widget, 'dryPaint');\n    // stacktrace.Widget.forceDirty\n    injectStackTraceFeature(Widget, 'forceDirty');\n    // stacktrace.Widget.scaleFont\n    injectStackTraceFeature(Widget, 'scaleFont');\n    // watchflag.Widget._dirty\n    injectWatchflagFeature(Widget, '_dirty');\n    // watchflag.Widget._layoutDirty\n    injectWatchflagFeature(Widget, '_layoutDirty');\n    // watchflag.BaseContainer.backgroundDirty\n    injectWatchflagFeature(BaseContainer, 'backgroundDirty');\n    // watchflag.MultiContainer.backgroundDirty\n    injectWatchflagFeature(MultiContainer, 'backgroundDirty');\n    // randomfill.BaseTheme.canvasFill\n    injectRandomFillFeature(BaseTheme, 'canvasFill');\n    // randomfill.BaseTheme.primaryFill\n    injectRandomFillFeature(BaseTheme, 'primaryFill');\n    // randomfill.BaseTheme.accentFill\n    injectRandomFillFeature(BaseTheme, 'accentFill');\n    // randomfill.BaseTheme.backgroundFill\n    injectRandomFillFeature(BaseTheme, 'backgroundFill');\n    // randomfill.BaseTheme.backgroundGlowFill\n    injectRandomFillFeature(BaseTheme, 'backgroundGlowFill');\n    // randomfill.BaseTheme.bodyTextFill\n    injectRandomFillFeature(BaseTheme, 'bodyTextFill');\n    // randomfill.BaseTheme.inputBackgroundFill\n    injectRandomFillFeature(BaseTheme, 'inputBackgroundFill');\n    // randomfill.BaseTheme.inputSelectBackgroundFill\n    injectRandomFillFeature(BaseTheme, 'inputSelectBackgroundFill');\n    // randomfill.BaseTheme.inputTextFill\n    injectRandomFillFeature(BaseTheme, 'inputTextFill');\n    // randomfill.BaseTheme.inputTextFillDisabled\n    injectRandomFillFeature(BaseTheme, 'inputTextFillDisabled');\n    // randomfill.BaseTheme.inputTextFillInvalid\n    injectRandomFillFeature(BaseTheme, 'inputTextFillInvalid');\n\n    // textrendergroups; special debug feature for TextRenderGroup\n    features.set(\n        'textrendergroups',\n        [\n            false,\n            `Draw text render groups in a TextHelper with alternating background colours (green and red). Width overriding groups have a blue background and zero-width groups have a black background. Throws an exception on negative width groups`,\n        ]\n    );\n\n    const textHelperAlternate: WeakMap<TextHelper, boolean> = new Map();\n    const textHelperPaintOrig = TextHelper.prototype.paint;\n    TextHelper.prototype.paint = function(ctx: CanvasRenderingContext2D, fillStyle: FillStyle, x: number, y: number): void {\n        textHelperAlternate.set(this, false);\n        textHelperPaintOrig.apply(this, [ctx, fillStyle, x, y]);\n    };\n\n    const textHelperPaintGroupOrig = TextHelper.prototype.paintGroup;\n    TextHelper.prototype.paintGroup = function(ctx: CanvasRenderingContext2D, group: TextRenderGroup, left: number, x: number, y: number): void {\n        if(isDebugFeatureEnabled('textrendergroups')) {\n            const origFillStyle = ctx.fillStyle;\n            const height = this.actualLineHeight;\n            const fullHeight = this.fullLineHeight;\n            if(!group[3] && group[2] > left) {\n                const alternate = textHelperAlternate.get(this);\n                ctx.fillStyle = alternate ? 'rgba(255, 0, 0, 0.5)'\n                                          : 'rgba(0, 255, 0, 0.5)';\n                ctx.fillRect(x, y - height, group[2] - left, fullHeight);\n                textHelperAlternate.set(this, !alternate);\n                ctx.fillStyle = origFillStyle;\n            }\n            else {\n                let debugWidth = group[2] - left;\n                ctx.fillStyle = debugWidth > 0 ? 'rgba(0, 0, 255, 0.5)'\n                                               : 'rgba(0, 0, 0, 0.5)';\n                if(debugWidth == 0)\n                    debugWidth = 4;\n                else if(debugWidth < 0)\n                    throw new Error(Msg.NEGATIVE_TEXT_GROUP);\n\n                ctx.fillRect(x, y - height, debugWidth, fullHeight);\n            }\n        }\n\n        textHelperPaintGroupOrig.apply(this, [ctx, group, left, x, y]);\n    };\n\n    // warnsubpixels; special debug feature for Widget\n    features.set(\n        'warnsubpixels',\n        [\n            false,\n            `Print a console warning whenever a Widget is detected to have non-integer width, height, x or y. Only warned once per Widget type`,\n        ]\n    );\n\n    const warnedSubX: Set<string> = new Set();\n    const warnedSubY: Set<string> = new Set();\n    const warnedSubWidth: Set<string> = new Set();\n    const warnedSubHeight: Set<string> = new Set();\n    const msgLeft = '[canvas-ui warnsubpixels] Widget type \"';\n    const msgMid = '\" has a non-integer ';\n    const msgRight = ', which will create clipping issues due to subpixels. This message won\\'t be shown again for this widget type';\n\n    const finalizeBoundsOrig = Widget.prototype.finalizeBounds;\n    Widget.prototype.finalizeBounds = function(): void {\n        finalizeBoundsOrig.apply(this);\n        const typeName = this.constructor.name;\n\n        if(isDebugFeatureEnabled('warnsubpixels')) {\n            const [scaleX, scaleY] = this.root.effectiveScale;\n            const [x, y] = this.position;\n            if(!isWhole(x * scaleX, 1e-10) && !warnedSubX.has(typeName)) {\n                warnedSubX.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}X coordinate (${x})${msgRight}`);\n            }\n\n            if(!isWhole(y * scaleY, 1e-10) && !warnedSubY.has(typeName)) {\n                warnedSubY.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}Y coordinate (${y})${msgRight}`);\n            }\n\n            const [width, height] = this.dimensions;\n            if(!isWhole(width * scaleX, 1e-10) && !warnedSubWidth.has(typeName)) {\n                warnedSubWidth.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}width (${width})${msgRight}`);\n            }\n\n            if(!isWhole(height * scaleY, 1e-10) && !warnedSubHeight.has(typeName)) {\n                warnedSubHeight.add(typeName);\n                console.warn(`${msgLeft}${typeName}${msgMid}height (${height})${msgRight}`);\n            }\n        }\n    };\n\n    // Make debug functions available in global scope\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (window as any).canvasDebug = {\n        enabled: isDebugFeatureEnabled,\n        toggle: toggleDebugFeature,\n        list: listDebugFeatures,\n    };\n\n    console.info('[canvas-ui] Injected debug code; the library will be slower');\n    console.info('[canvas-ui] Check if a debug feature is enabled in the console with canvasDebug.enabled(debugFeature: string)');\n    console.info('[canvas-ui] Enable a debug feature in the console with canvasDebug.toggle(debugFeature: string, enabled?: boolean)');\n    console.info('[canvas-ui] List debug features in the console with canvasDebug.list()');\n}", "/**\n * The default implementation of {@link TextInputHandler}.\n *\n * Creates a new popup div with a CSS ID of 'textInputHandler' and an overlay\n * div with CSS ID 'textInputHandlerOverlay', adding both to the HTML body.\n * Resolves the promise once user input is finished by clicking the OK or Cancel\n * buttons.\n *\n * @category Core\n */\nexport function DefaultTextInputHandler(initialInput: string): Promise<string> {\n    return new Promise((accept, _reject) => {\n        function closePopup() {\n            // Close text input popup\n            document.body.removeChild(overlayElem);\n        }\n\n        function cancelHandler() {\n            // Click cancel; close popup and accept with initial input string\n            closePopup();\n            accept(initialInput);\n        }\n\n        function okHandler() {\n            // Click OK; close popup and accept with new input string\n            closePopup();\n            accept(inElem.value);\n        }\n\n        // Create overlay\n        const overlayElem = document.createElement('div');\n        overlayElem.id = 'textInputHandlerOverlay';\n\n        // Create container\n        const containerElem = document.createElement('div');\n        containerElem.id = 'textInputHandler';\n\n        // Create text element\n        const textElem = document.createElement('p');\n        textElem.textContent = 'Change text:';\n\n        // Create input element\n        const inElem = document.createElement('textarea');\n        inElem.value = initialInput;\n\n        // Create button row element\n        const buttonRowElem = document.createElement('div');\n\n        // Create cancel button element\n        const cancelButtonElem = document.createElement('button');\n        cancelButtonElem.addEventListener('click', cancelHandler);\n        cancelButtonElem.textContent = 'Cancel';\n\n        // Create OK button element\n        const okButtonElem = document.createElement('button');\n        okButtonElem.addEventListener('click', okHandler);\n        okButtonElem.textContent = 'OK';\n\n        // Add to row\n        buttonRowElem.appendChild(cancelButtonElem);\n        buttonRowElem.appendChild(okButtonElem);\n\n        // Add to container\n        containerElem.appendChild(textElem);\n        containerElem.appendChild(inElem);\n        containerElem.appendChild(buttonRowElem);\n\n        // Add overlay and container to body\n        overlayElem.appendChild(containerElem);\n        document.body.appendChild(overlayElem);\n\n        // Focus input\n        inElem.focus({ preventScroll: false });\n    });\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport { Event } from './Event';\n\n/**\n * An event which contains text pasted by the clipboard.\n *\n * Has a focus type of {@link FocusType.Keyboard} and does not need focus.\n *\n * @category Event\n */\nexport class TextPasteEvent extends Event {\n    /** The pasted text */\n    readonly text: string;\n\n    /** Create a new Event. */\n    constructor(text: string, target: Widget | null = null) {\n        super(target, FocusType.Keyboard, false);\n        this.text = text;\n    }\n\n    cloneWithTarget(target: Widget | null): TextPasteEvent {\n        return new TextPasteEvent(this.text, target);\n    }\n}", "import { TextPasteEvent } from '../events/TextPasteEvent';\nimport type { Widget } from '../widgets/Widget';\nimport { Theme } from '../theme/Theme';\nimport { Msg } from './Strings';\nimport { Root } from './Root';\n\n/**\n * Like Root, but for easy use in an HTML page.\n *\n * Instead of calling each individual update method, simply call\n * {@link DOMRoot#update} on every animation frame. {@link Driver | Drivers}\n * still need to be manually registered.\n *\n * @category Core\n */\nexport class DOMRoot extends Root {\n    /** This root's canvas element. Add this to the HTML body */\n    readonly domElem: HTMLCanvasElement;\n    /** This root's canvas element's context. Used for painting */\n    private domCanvasContext: CanvasRenderingContext2D;\n\n    /**\n     * Create a new DOMRoot.\n     *\n     * Sets {@link Root#child} and {@link Root#child}'s\n     * {@link Widget#inheritedTheme | inherited theme}. Also sets up a\n     * {@link Root#pointerStyleHandler} which simply sets the CSS cursor style\n     * of {@link DOMRoot#domElem}. Creates {@link DOMRoot#domElem} and\n     * {@link DOMRoot#domCanvasContext}.\n     *\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(child: Widget, theme: Theme = new Theme()) {\n        super(child, null, theme);\n\n        // Make DOM element, which is a canvas, and get a 2D context for it\n        this.domElem = document.createElement('canvas');\n        this.domElem.tabIndex = 1;\n        this.updateDOMDims();\n\n        const context = this.domElem.getContext('2d', { alpha: true });\n        if(context === null)\n            throw new Error(Msg.REUSABLE_CANVAS_CONTEXT);\n\n        this.domCanvasContext = context;\n\n        // Setup pointer style handler\n        this.pointerStyleHandler = (newPointerStyle: string): void => {\n            this.domElem.style.cursor = newPointerStyle;\n        };\n\n        // Listen to paste events\n        this.domElem.addEventListener('paste', event => {\n            event.preventDefault();\n            if(event.clipboardData !== null)\n                this.dispatchEvent(new TextPasteEvent(event.clipboardData.getData('text')));\n        });\n        this.domElem.contentEditable = 'true';\n\n        // Remove styling added by contenteditable\n        this.domElem.style.outline = '0px solid transparent';\n        this.domElem.style.caretColor = 'transparent';\n        this.domElem.style.cursor = 'default';\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link DOMRoot#domElem}'s display style is set to\n     * 'none', hiding it.\n     *\n     * Calls {@link Root#preLayoutUpdate}, {@link Root#resolveLayout},\n     * {@link Root#postLayoutUpdate} and {@link Root#paint}.\n     */\n    update(): void {\n        if(!this.enabled) {\n            this.domElem.style.display = 'none';\n            return;\n        }\n        else\n            this.domElem.style.removeProperty('display');\n\n        this.preLayoutUpdate();\n        if(this.resolveLayout()) {\n            this.updateDOMDims();\n            this.autoScale();\n        }\n        this.postLayoutUpdate();\n        if(this.paint()) {\n            this.domCanvasContext.globalCompositeOperation = 'copy';\n            this.domCanvasContext.drawImage(this.canvas, 0, 0);\n        }\n    }\n\n    /** Update the width and height of {@link DOMRoot#domElem} */\n    private updateDOMDims(): void {\n        const [scaleX, scaleY] = this.effectiveScale;\n        const [dimsX, dimsY] = this.dimensions;\n        // XXX canvas width/height is auto-truncated, so manually round it\n        // so that values such as 99.9997 don't get turned into 99 instead\n        // of 100\n        this.domElem.width = Math.round(dimsX * scaleX);\n        this.domElem.height = Math.round(dimsY * scaleY);\n    }\n\n    /**\n     * Counter Root viewport scaling with an opposite CSS scale (via width and\n     * height, not CSS transforms).\n     */\n    private autoScale(): void {\n        const [scaleX, scaleY] = this.effectiveScale;\n        this.domElem.style.width = (this.domElem.width / scaleX).toString() + 'px';\n        this.domElem.style.height = (this.domElem.height / scaleY).toString() + 'px';\n    }\n}", "import { Widget, WidgetProperties } from './Widget';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\n\n/**\n * A {@link SingleParent} which contains a single child and does nothing,\n * passing all events through to its child. Useful for widgets that are only\n * used for logic, like {@link ThemeScope}.\n *\n * Can be constrained to a specific type of children.\n *\n * Since this does nothing on its own, it should not be used on its own.\n * Instead, extend this class if you are looking for a way to do wrapper widgets\n * that provide extra logic.\n *\n * @category Widget\n */\nexport class PassthroughWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, properties?: Readonly<WidgetProperties>) {\n        // Passthrough widgets dont need a clear background, have a child and\n        // propagate events\n        super(child, false, true, properties);\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Dispatch event to child\n        return this.child.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve child's dimensions and set own resolved dimensions to be\n        // equal to the child's\n        const child = this.child;\n        child.resolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n        [this.idealWidth, this.idealHeight] = child.idealDimensions;\n    }\n\n    override resolvePosition(x: number, y: number): void {\n        super.resolvePosition(x, y);\n\n        // Resolve child's position to be the same as this widget's position\n        this.child.resolvePosition(x, y);\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Paint child\n        this.child.paint(forced);\n    }\n}", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport { layoutArrayField } from '../decorators/FlagFields';\nimport type { Widget, WidgetProperties } from './Widget';\nimport { PassthroughWidget } from './PassthroughWidget';\n\n/**\n * A {@link PassthroughWidget} which imposes further layout constraints onto a\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ArtificialConstraint<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /**\n     * The further constraints given to the child. A 4-tuple containing,\n     * respectively, minimum width, maximum width, minimum height and maximum\n     * height. Changing this sets {@link Widget#_layoutDirty} to true.\n     * Constraints are only applied if they are more restrictive than the\n     * original constraints.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutArrayField()`\n     */\n    @layoutArrayField()\n    constraints: LayoutConstraints;\n\n    /** Create a new PassthroughWidget. */\n    constructor(child: W, constraints: LayoutConstraints, properties?: Readonly<WidgetProperties>) {\n        super(child, properties);\n\n        this.constraints = [...constraints];\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Further restrict constraints if possible\n        let newMinWidth = Math.min(Math.max(this.constraints[0], minWidth), maxWidth);\n        let newMinHeight = Math.min(Math.max(this.constraints[2], minHeight), maxHeight);\n        const newMaxWidth = Math.min(Math.max(this.constraints[1], minWidth), maxWidth);\n        const newMaxHeight = Math.min(Math.max(this.constraints[3], minHeight), maxHeight);\n\n        if(newMinWidth > newMaxWidth)\n            newMinWidth = newMaxWidth;\n\n        if(newMinHeight > newMaxHeight)\n            newMinHeight = newMaxHeight;\n\n        // Resolve dimensions\n        super.handleResolveDimensions(newMinWidth, newMaxWidth, newMinHeight, newMaxHeight);\n    }\n}", "import { TextHelper, WrapMode } from '../helpers/TextHelper';\nimport { layoutField } from '../decorators/FlagFields';\nimport { Widget, WidgetProperties } from './Widget';\n\n/**\n * Optional TextInput constructor properties.\n *\n * @category Widget\n */\nexport interface LabelProperties extends WidgetProperties {\n    /** Sets {@link Label#wrapText}. */\n    wrapText?: boolean,\n}\n\n/**\n * A widget which displays a line of text.\n *\n * @category Widget\n */\nexport class Label extends Widget {\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /**\n     * Is text wrapping enabled? If not, text will clipped on overflow\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText = true;\n\n    /**\n     * Create a new Label.\n     *\n     * @param text - The text of the label. Has the same behaviour as setting {@link Label#text}.\n     */\n    constructor(text = '', properties?: Readonly<LabelProperties>) {\n        // Labels need a clear background, have no children and don't propagate\n        // events\n        super(true, false, properties);\n\n        this.textHelper = new TextHelper();\n        this.textHelper.wrapMode = WrapMode.Shrink;\n        this.text = text;\n\n        this.wrapText = properties?.wrapText ?? true;\n    }\n\n    /** The current text value. */\n    set text(text: string) {\n        this.textHelper.text = text;\n    }\n\n    get text(): string {\n        return this.textHelper.text;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFont' ||\n                property === 'labelMinWidth' ||\n                property === 'labelMinAscent' ||\n                property === 'labelMinDescent')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFill')\n            this._dirty = true;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Update text helper variables\n        this.textHelper.font = this.bodyTextFont;\n        this.textHelper.lineHeight = this.bodyTextHeight;\n        this.textHelper.lineSpacing = this.bodyTextSpacing;\n        this.textHelper.alignMode = this.bodyTextAlign;\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        this.textHelper.maxWidth = this.wrapText ? maxWidth : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        this.idealWidth = Math.max(Math.min(this.textHelper.width, maxWidth), minWidth);\n        this.idealHeight = Math.max(Math.min(this.textHelper.height, maxHeight), minHeight);\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Start clipping if text wrapping is disabled\n        const ctx = this.viewport.context;\n        if(!this.wrapText) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n        }\n\n        // Paint text\n        this.textHelper.paint(ctx, this.bodyTextFill, this.idealX, this.idealY);\n\n        // Stop clipping if text wrapping is disabled\n        if(!this.wrapText)\n            ctx.restore();\n    }\n}\n", "/**\n * The current state of a {@link BaseClickHelper}\n *\n * @category Helper\n */\nexport enum ClickState {\n    /** No pointer is hovering over this clickable widget */\n    Released = 0,\n    /** A pointer is hovering over this clickable widget */\n    Hover = 1,\n    /** A pointer's button is being held down over this clickable widget */\n    Hold = 2,\n}", "import { GenericClickHelper } from \"./GenericClickHelper\";\nimport { BaseClickHelper } from \"./BaseClickHelper\";\nimport { ClickState } from \"./ClickState\";\n\n/**\n * A class that mixes multiple {@link GenericClickHelper} instances into one.\n * Useful if you want a widget to be both clickable by a pointer and by the\n * enter key\n *\n * @category Helper\n */\nexport class CompoundClickHelper implements BaseClickHelper {\n    /** The {@link GenericClickHelper} instances being mixed */\n    private clickHelpers: GenericClickHelper[];\n\n    constructor(clickHelpers: GenericClickHelper[]) {\n        this.clickHelpers = clickHelpers;\n    }\n\n    get lastClickState(): ClickState {\n        let highestState = ClickState.Released;\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.lastClickState > highestState)\n                highestState = clickHelper.lastClickState;\n        }\n\n        return highestState;\n    }\n\n    get clickState(): ClickState {\n        let highestState = ClickState.Released;\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.clickState > highestState)\n                highestState = clickHelper.clickState;\n        }\n\n        return highestState;\n    }\n\n    /**\n     * See {@link BaseClickHelper#clickStateChanged}.\n     *\n     * Note that this does not check if the combined state has changed, it only\n     * check if any of the states in {@link CompoundClickHelper#clickHelpers}\n     * has changed, meaning that this can be true while\n     * {@link CompoundClickHelper#clickState} is equal to\n     * {@link CompoundClickHelper#lastClickState}. To check whether the combined\n     * state changed, compare the aforementioned values. This is the default\n     * behaviour so that clicks aren't dropped.\n     */\n    get clickStateChanged(): boolean {\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.clickStateChanged)\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Similar to {@link BaseClickHelper#wasClick}, except that the wasClick\n     * property for each click helper is only true if the\n     * {@link BaseClickHelper#clickStateChanged} property is also true.\n     */\n    get wasClick(): boolean {\n        for(const clickHelper of this.clickHelpers) {\n            if(clickHelper.wasClick && clickHelper.clickStateChanged)\n                return true;\n        }\n\n        return false;\n    }\n}", "import { BaseClickHelper } from './BaseClickHelper';\nimport { Widget } from '../widgets/Widget';\nimport { ClickState } from './ClickState';\n\n/**\n * An aggregate helper class for widgets that can be clicked, in the general\n * sense that the widget is/has a button or is clickable. This does not mean\n * that the widget is only clickable with a pointer; it could also be \"clicked\"\n * with a keyboard.\n *\n * Keeps its current click state as well as its last click state, and whether\n * the last click state change resulted in an actual click.\n *\n * @category Helper\n */\nexport class GenericClickHelper implements BaseClickHelper {\n    /** Last click state */\n    lastClickState: ClickState = ClickState.Released;\n    /** The current click state */\n    clickState: ClickState = ClickState.Released;\n    /** Did the last click event handle result in a click state change? */\n    clickStateChanged = false;\n    /** Did the last click state change result in a click? */\n    wasClick = false;\n    /** The Widget aggregating this helper */\n    protected widget: Widget;\n\n    /**\n     * Create a new GenericClickHelper\n     *\n     * @param widget - The Widget aggregating this helper\n     */\n    constructor(widget: Widget) {\n        this.widget = widget;\n    }\n\n    /**\n     * Set {@link GenericClickHelper#clickState} and update\n     * {@link GenericClickHelper#lastClickState} if current one differs. Updates\n     * {@link GenericClickHelper#wasClick} and\n     * {@link GenericClickHelper#clickStateChanged} flags.\n     */\n    setClickState(clickState: ClickState, inside: boolean): void {\n        if(this.clickState !== clickState) {\n            this.lastClickState = this.clickState;\n            this.clickState = clickState;\n\n            // If last state was a hold and pointer is still inside click\n            // area, this was a click\n            this.wasClick = inside && this.lastClickState === ClickState.Hold;\n            this.clickStateChanged = true;\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}", "import { Widget } from '../widgets/Widget';\nimport { KeyEvent } from './KeyEvent';\n\n/**\n * A key release {@link KeyEvent} (key up).\n *\n * Has a focus type of {@link FocusType.Keyboard} and needs focus.\n *\n * @category Event\n */\nexport class KeyRelease extends KeyEvent {\n    cloneWithTarget(target: Widget | null): KeyRelease {\n        return new KeyRelease(this.key, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import type { Widget } from '../widgets/Widget';\nimport { PointerEvent } from './PointerEvent';\nimport { FocusType } from '../core/FocusType';\n\n/**\n * A {@link PointerEvent} for button presses/releases, containing helpers for\n * checking whether it was the left/primary button, right/secondary button or\n * middle/tertiary button. Always take the button ID into account when handling\n * this event as you get a pair of {@link PointerPress} and\n * {@link PointerRelease} events per button ID.\n *\n * Has a focus type decided by the child classes and does not need focus.\n *\n * @category Event\n */\nexport abstract class PointerButtonEvent extends PointerEvent {\n    /**\n     * The ID of the button affected.\n     *\n     * 0: left/primary button.\n     * 1: right/secondary button.\n     * 2: middle/tertiary button.\n     * etc...\n     */\n    readonly button: number;\n\n    /** Create a new PointerButtonEvent. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null, focusType: FocusType | null = null) {\n        super(x, y, shift, ctrl, alt, target, focusType);\n        this.button = button;\n    }\n\n    /** Is the button affected the left/primary button? */\n    get isLeft(): boolean {\n        return this.button === 0;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isLeft} */\n    get isPrimary(): boolean {\n        return this.isLeft;\n    }\n\n    /** Is the button affected the right/secondary button? */\n    get isRight(): boolean {\n        return this.button === 1;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isRight} */\n    get isSecondary(): boolean {\n        return this.isRight;\n    }\n\n    /** Is the button affected the middle/tertiary button? */\n    get isMiddle(): boolean {\n        return this.button === 2;\n    }\n\n    /** Alias for {@link PointerButtonEvent#isMiddle} */\n    get isTertiary(): boolean {\n        return this.isMiddle;\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { FocusType } from '../core/FocusType';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer release {@link PointerButtonEvent} (pointer button up).\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerRelease extends PointerButtonEvent {\n    /** Create a new PointerRelease. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerRelease {\n        return new PointerRelease(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerRelease {\n        return new PointerRelease(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "import { PointerButtonEvent } from './PointerButtonEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer press {@link PointerButtonEvent} (pointer button down).\n *\n * Has no focus type and does not need focus.\n *\n * @category Event\n */\nexport class PointerPress extends PointerButtonEvent {\n    /** Create a new PointerPress. */\n    constructor(x: number, y: number, button: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, button, shift, ctrl, alt, target);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerPress {\n        return new PointerPress(this.x - xOffset, this.y - yOffset, this.button, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerPress {\n        return new PointerPress(this.x, this.y, this.button, this.shift, this.ctrl, this.alt, target);\n    }\n}\n\n", "import { PointerRelease } from '../events/PointerRelease';\nimport { GenericClickHelper } from './GenericClickHelper';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport { ClickState } from './ClickState';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\nimport type { Bounds } from './Bounds';\n\n/**\n * An aggregate helper class for widgets that can be clicked.\n *\n * Keeps its current click state as well as its last click state, last pointer\n * position and whether the last click state change resulted in an actual click.\n *\n * @category Helper\n */\nexport class ClickHelper extends GenericClickHelper {\n    /**\n     * Last pointer position in normalised coordinates ([0,0] to [1,1]). If\n     * there is no last pointer position, such as after a leave event, this will\n     * be null. If pointer position was outside box, it will be beyond the [0,0]\n     * to [1,1] range.\n     */\n    pointerPos: [number, number] | null = null;\n    /**\n     * Like {@link ClickHelper#pointerPos}, but only updated when a hold state\n     * begins.\n     *\n     * Useful for implementing draggable widgets.\n     */\n    startingPointerPos: [number, number] | null = null;\n    /** Which pointer button should count as a click? Left button by default */\n    pointerButton = 0;\n\n    /**\n     * Normalise pointer coordinates inside a rectangle\n     *\n     * @param pX - Pointer X coordinate, in pixels\n     * @param pY - Pointer Y coordinate, in pixels\n     * @param rLeft - Rectangle's left coordinate, in pixels\n     * @param rRight - Rectangle's right coordinate, in pixels\n     * @param rTop - Rectangle's top coordinate, in pixels\n     * @param rBottom - Rectangle's bottom coordinate, in pixels\n     * @returns Returns normalised coordinates\n     */\n    getNormalInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): [number, number] {\n        return [(pX - rLeft) / (rRight - rLeft), (pY - rTop) / (rBottom - rTop)];\n    }\n\n    /**\n     * Check if a point, in pixels, is inside a rectangle.\n     *\n     * @param pX - Pointer X coordinate, in pixels\n     * @param pY - Pointer Y coordinate, in pixels\n     * @param rLeft - Rectangle's left coordinate, in pixels\n     * @param rRight - Rectangle's right coordinate, in pixels\n     * @param rTop - Rectangle's top coordinate, in pixels\n     * @param rBottom - Rectangle's bottom coordinate, in pixels\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isPointInRect(pX: number, pY: number, rLeft: number, rRight: number, rTop: number, rBottom: number): boolean {\n        return pX >= rLeft && pX < rRight && pY >= rTop && pY < rBottom;\n    }\n\n    /**\n     * Check if a normalised point is inside a rectangle.\n     *\n     * Since the coordinates are normalised, you don't have to define the\n     * coordinates of the rectangle, which may seem counterintuitive.\n     *\n     * @param pX - Pointer X coordinate, normalised\n     * @param pY - Pointer Y coordinate, normalised\n     * @returns Returns true if [pX, pY] is inside the rectangle, else, false\n     */\n    isNormalInRect(pX: number, pY: number): boolean {\n        return pX >= 0 && pX < 1 && pY >= 0 && pY < 1;\n    }\n\n    /**\n     * Updates the current {@link GenericClickHelper#clickState} given an event,\n     * as well as {@link Root#_foci | focus}, {@link Root#pointerStyle},\n     * {@link GenericClickHelper#wasClick} and\n     * {@link GenericClickHelper#clickStateChanged} flags.\n     *\n     * @param bounds - A 4-tuple containing, respectively, left coordinate, right coordinate, top coordinate and bottom coordinate of clickable area, in pixels\n     */\n    handleClickEvent(event: Event, root: Root, bounds: Bounds): void {\n        if(event instanceof Leave) {\n            // Drop focus on this widget if this is a leave event\n            root.dropFocus(FocusType.Pointer, this.widget);\n            this.pointerPos = null;\n            return this.setClickState(ClickState.Released, false);\n        }\n        else if(event instanceof PointerEvent) {\n            // Normalise pointer coordinates in click area\n            this.pointerPos = this.getNormalInRect(event.x, event.y, ...bounds);\n\n            // If pointer is over the clickable rectangle, then change the\n            // pointer style, else, if not targetted, drop focus\n            const inside = this.isNormalInRect(...this.pointerPos);\n            if(inside)\n                root.pointerStyle = 'pointer';\n            else if(event.target === null) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Released, false);\n            }\n\n            // If this is a press event, request focus and set starting\n            // pointer coordinates. Ignore if wrong button\n            if(event instanceof PointerPress && event.button === this.pointerButton) {\n                this.startingPointerPos = this.pointerPos;\n                root.requestFocus(FocusType.Pointer, this.widget);\n                return this.setClickState(ClickState.Hold, inside);\n            }\n\n            // If this is a release event, drop focus. Ignore if wrong button\n            if(event instanceof PointerRelease && event.button === this.pointerButton) {\n                root.dropFocus(FocusType.Pointer, this.widget);\n                if(inside)\n                    return this.setClickState(ClickState.Hover, inside);\n                else\n                    return this.setClickState(ClickState.Released, inside);\n            }\n\n            // If event was focused, then it's a hold, else, it's a hover\n            if(event.target === null)\n                return this.setClickState(ClickState.Hover, inside);\n            else\n                return this.setClickState(ClickState.Hold, inside);\n        }\n        else\n            this.clickStateChanged = false;\n    }\n}", "import { CompoundClickHelper } from \"./CompoundClickHelper\";\nimport { GenericClickHelper } from \"./GenericClickHelper\";\nimport { PointerEvent } from \"../events/PointerEvent\";\nimport { PointerWheel } from \"../events/PointerWheel\";\nimport { KeyRelease } from \"../events/KeyRelease\";\nimport type { Widget } from \"../widgets/Widget\";\nimport { KeyEvent } from \"../events/KeyEvent\";\nimport { KeyPress } from \"../events/KeyPress\";\nimport { FocusType } from \"../core/FocusType\";\nimport type { Event } from \"../events/Event\";\nimport { ClickHelper } from \"./ClickHelper\";\nimport { ClickState } from \"./ClickState\";\nimport type { Root } from \"../core/Root\";\nimport { Leave } from \"../events/Leave\";\nimport type { Bounds } from \"./Bounds\";\n\n/**\n * A {@link CompoundClickHelper} specialised for {@link Button}-like widgets.\n * Handles pointer clicks and enter key-presses if the widget has a keyboard\n * focus.\n *\n * {@link GenericClickHelper} methods are still available, however, calls to the\n * new methods provided by this class are preferrable; mostly they implement\n * {@link Widget} methods.\n *\n * @category Helper\n */\nexport class ButtonClickHelper extends CompoundClickHelper {\n    /** The helper for handling pointer clicks */\n    protected pointerClickHelper: ClickHelper;\n    /** The helper for handling enter key presses */\n    protected keyboardClickHelper: GenericClickHelper;\n    /** The widget that will be auto-scrolled when keyboard focused */\n    private widget: Widget;\n\n    constructor(widget: Widget) {\n        const pointerClickHelper = new ClickHelper(widget);\n        const keyboardClickHelper = new GenericClickHelper(widget);\n        super([pointerClickHelper, keyboardClickHelper])\n\n        this.pointerClickHelper = pointerClickHelper;\n        this.keyboardClickHelper = keyboardClickHelper;\n        this.widget = widget;\n    }\n\n    /**\n     * Handle focus grabbing from {@link Widget#onFocusGrabbed}. If keyboard\n     * focus is gained, then the button is hovered via the\n     * {@link ButtonClickHelper#keyboardClickHelper} click helper\n     *\n     * @param focusType - The focus type from {@link Widget#onFocusGrabbed}\n     * @returns Returns true if the focus type was the keyboard focus (and therefore the button probably needs to be re-painted)\n     */\n    onFocusGrabbed(focusType: FocusType): boolean {\n        if(focusType === FocusType.Keyboard) {\n            this.keyboardClickHelper.setClickState(ClickState.Hover, true);\n            this.widget.autoScroll();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle focus dropping from {@link Widget#onFocusDropped}. If keyboard\n     * focus is dropped, then the button is released via the\n     * {@link ButtonClickHelper#keyboardClickHelper} click helper\n     *\n     * @param focusType - The focus type from {@link Widget#onFocusDropped}\n     * @returns Returns true if the focus type was the keyboard focus (and therefore the button probably needs to be re-painted)\n     */\n    onFocusDropped(focusType: FocusType): boolean {\n        if(focusType === FocusType.Keyboard) {\n            this.keyboardClickHelper.setClickState(ClickState.Released, false);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Handle event from {@link Widget#handleEvent}. Does most of the button\n     * logic.\n     *\n     * @param event - The event from {@link Widget#handleEvent}\n     * @param root - The root from {@link Widget#handleEvent}\n     * @param enabled - Is the button being clicked enabled? If not, then the click state will remain unchanged, but the event will be captured\n     * @param bounds - The bounding box to be used for detecting pointer clicks\n     * @returns Returns a 2-tuple containing, respective, whether a click occurred, and whether the event should be captured\n     */\n    handleEvent(event: Event, root: Root, enabled: boolean, bounds: Bounds): [wasClick: boolean, capture: boolean] {\n        if(event instanceof PointerWheel) {\n            // Ignore wheel events\n            return [false, false];\n        }\n        else if(event instanceof KeyEvent) {\n            // Discard non-enter key events\n\n            // don't capture non-enter presses so that tab selection works\n            if(event.key !== 'Enter')\n                return [false, false];\n        }\n        else if(!(event instanceof PointerEvent || event instanceof Leave)) {\n            // Discard unhandled events\n            return [false, false];\n        }\n\n        // Abort if not enabled, but still absorb events\n        if(!enabled) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.clickStateChanged = false;\n            return [false, true];\n        }\n\n        // Update button state\n        if(event instanceof KeyPress) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.setClickState(ClickState.Hold, true);\n            this.widget.autoScroll();\n        }\n        else if(event instanceof KeyRelease) {\n            this.pointerClickHelper.clickStateChanged = false;\n            this.keyboardClickHelper.setClickState(ClickState.Hover, true);\n        }\n        else {\n            this.keyboardClickHelper.clickStateChanged = false;\n            this.pointerClickHelper.handleClickEvent(event, root, bounds);\n        }\n\n        // Check if button was pressed and call callback if so\n        return [\n            this.clickStateChanged && this.wasClick,\n            true\n        ];\n    }\n}", "import { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport type { Widget, WidgetProperties } from './Widget';\nimport type { FocusType } from '../core/FocusType';\nimport { BaseContainer } from './BaseContainer';\nimport type { Event } from '../events/Event';\n\n/**\n * A {@link BaseContainer} which can be {@link ClickHelper | clicked} as a\n * button. Since the button grabs all events, no events are propagated to the\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class Button<W extends Widget = Widget> extends BaseContainer<W> {\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /**\n     * The callback for clicking this button. If null, the button is not\n     * clickable but will still absorb events.\n     */\n    callback: (() => void) | null;\n\n    /** Create a new Button. */\n    constructor(child: W, callback: (() => void) | null, properties?: Readonly<WidgetProperties>) {\n        super(child, false, properties);\n\n        this.clickHelper = new ButtonClickHelper(this);\n        this.callback = callback;\n        this.tabFocusable = true;\n    }\n\n    /**\n     * Click the button. If there is a callback, then the callback will be\n     * called\n     */\n    click(): void {\n        if(this.callback !== null) {\n            try {\n                this.callback();\n            }\n            catch(e) {\n                console.error('Exception in Icon callback:', e);\n            }\n        }\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        this.clickHelper.onFocusGrabbed(focusType);\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        this.clickHelper.onFocusDropped(focusType);\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event, this.root, this.callback !== null, this.bounds\n        );\n\n        if(wasClick)\n            this.click();\n\n        return capture ? this : null;\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Widget, WidgetProperties } from './Widget';\nimport { watchField } from '../decorators/FlagFields';\nimport { ClickState } from '../helpers/ClickState';\nimport { FillStyle } from '../theme/FillStyle';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport { DynMsg } from '../core/Strings';\nimport { Theme } from '../theme/Theme';\nimport { Button } from './Button';\n\n/**\n * Optional FilledButton constructor properties.\n *\n * @category Widget\n */\nexport interface FilledButtonProperties extends WidgetProperties {\n    /** Sets {@link FilledButton#forced}. */\n    forced?: boolean;\n}\n\n/**\n * A {@link Button} which overrides the canvas colour, meaning that it has a\n * filled background.\n *\n * Can be constrained to a specific type of children.\n *\n * This button version can also be \"forced down\"; the button becomes similar to\n * being pressed, visually. Useful for implementing widgets such as\n * {@link ShiftKey}.\n *\n * @category Widget\n */\nexport class FilledButton<W extends Widget = Widget> extends Button<W> {\n    /** Theme property used for overriding the canvas colour. */\n    private backgroundProperty = 'backgroundFill';\n    /**\n     * Is the button currently forced down?\n     *\n     * @decorator `@watchField(FilledButton.prototype.updateBackground)`\n     */\n    @watchField(FilledButton.prototype.updateBackground)\n    forced;\n    /** The inherited theme for the child */\n    private childTheme: Theme;\n\n    /** Create a new FilledButton. */\n    constructor(child: W, callback: (() => void) | null = null, properties?: Readonly<FilledButtonProperties>) {\n        super(child, callback, properties);\n\n        this.forced = properties?.forced ?? false;\n\n        // Make theme that will be inherited by child. Later, this theme's\n        // canvasFill property will be changed, notifying the child. Make the\n        // child inherit the theme. fallbackTheme is also later set when this\n        // widget inherits a theme\n        this.childTheme = new Theme(<ThemeProperties>{\n            canvasFill: this.getBackgroundFill(),\n        });\n        this.child.inheritedTheme = this.childTheme;\n    }\n\n    /**\n     * Update the background fill.\n     *\n     * Sets {@link FilledButton#backgroundProperty} depending on\n     * {@link FilledButton#forced} and {@link ButtonClickHelper#clickState},\n     * sets {@link FilledButton#childTheme}.{@link Theme#canvasFill} and flags\n     * {@link FilledButton#backgroundDirty} as true.\n     */\n    private updateBackground(): void {\n        const oldProperty = this.backgroundProperty;\n\n        if(this.forced)\n            this.backgroundProperty = 'primaryFill';\n        else {\n            switch(this.clickHelper.clickState) {\n            case ClickState.Hold:\n                this.backgroundProperty = 'accentFill';\n                break;\n            case ClickState.Hover:\n                this.backgroundProperty = 'backgroundGlowFill';\n                break;\n            default:\n                this.backgroundProperty = 'backgroundFill';\n                break;\n            }\n        }\n\n        // Update canvasFill property of child's theme\n        if(oldProperty !== this.backgroundProperty) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n    }\n\n    private getBackgroundFill(): FillStyle {\n        switch(this.backgroundProperty) {\n            case 'primaryFill':\n                return this.primaryFill;\n            case 'accentFill':\n                return this.accentFill;\n            case 'backgroundGlowFill':\n                return this.backgroundGlowFill;\n            case 'backgroundFill':\n                return this.backgroundFill;\n            default:\n                throw new Error(DynMsg.INVALID_BACKGROUND_FILL(this.backgroundProperty));\n        }\n    }\n\n    override set inheritedTheme(theme: Theme | undefined) {\n        if(theme === this.fallbackTheme)\n            return;\n\n        this.fallbackTheme = theme;\n        this.childTheme.fallbackTheme = theme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.fallbackTheme;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        if(property === null) {\n            this._layoutDirty = true;\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === this.backgroundProperty) {\n            this.backgroundDirty = true;\n            this.childTheme.canvasFill = this.getBackgroundFill();\n        }\n        else if(property === 'containerPadding')\n            this._layoutDirty = true;\n        else if(property === 'containerAlignment')\n            this._layoutDirty = true;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        super.onFocusGrabbed(focusType);\n\n        if(focusType === FocusType.Keyboard)\n            this.updateBackground();\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        super.onFocusDropped(focusType);\n\n        if(focusType === FocusType.Keyboard)\n            this.updateBackground();\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        const capturer = super.handleEvent(event);\n\n        if(this.clickHelper.clickStateChanged)\n            this.updateBackground();\n\n        return capturer;\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        this.handleBaseContainerPainting(forced, this.getBackgroundFill());\n    }\n}\n", "import type { Alignment2D } from '../theme/Alignment2D';\nimport { TextAlignMode } from '../helpers/TextHelper';\nimport { Label, LabelProperties } from './Label';\nimport { Alignment } from '../theme/Alignment';\nimport { FilledButton } from './FilledButton';\n\n/**\n * A {@link FilledButton} with a {@link Label}. Alignment is forced to be\n * horizontally centered and vertically stretching like in {@link TextMargin}.\n * Text-wrapping is disabled so that text is centered properly.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class TextButton extends FilledButton<Label> {\n    /** Create a new TextButton. */\n    constructor(text: string, callback: (() => void) | null = null, properties?: Readonly<LabelProperties>) {\n        // default properties\n        properties = {\n            containerAlignment: <Alignment2D>{\n                horizontal: Alignment.Center, vertical: Alignment.Stretch,\n            },\n            bodyTextAlign: TextAlignMode.Center,\n            wrapText: false,\n            ...properties\n        };\n\n        super(new Label(text, properties), callback, properties);\n    }\n}\n", "import { ArtificialConstraint } from '../ArtificialConstraint';\nimport type { WidgetProperties } from '../Widget';\nimport { TextButton } from '../TextButton';\n\n/**\n * An {@link ArtificialConstraint} with a {@link TextButton} which calls a given\n * callback and displays a given text source.\n *\n * For now there's nothing special about this class; it's just a common base\n * class for virtual keyboard key widgets.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class VirtualKey extends ArtificialConstraint<TextButton> {\n    /**\n     * Create a new VirtualKey.\n     *\n     * @param text - The text to display in the virtual key.\n     * @param callback - The callback called when the button is pressed.\n     * @param minWidth - Minimum width constraint. Will be passed to ArtificialConstraint base class.\n     * @param minHeight - Minimum width constraint. Will be passed to ArtificialConstraint base class.\n     */\n    constructor(text: string, callback: () => void, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            new TextButton(text, callback, properties),\n            [minWidth, Infinity, minHeight, Infinity],\n            properties,\n        );\n    }\n}\n", "import type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which emits key presses for a given glyph (character),\n * handling alternative versions of the glyph when shift is held down, such as\n * uppercase variants, or exclamation marks for ones.\n *\n * For other specific keys, see {@link BasicVirtualKey}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class GlyphVirtualKey extends VirtualKey {\n    readonly glyph: string;\n    readonly altGlyph: string;\n    readonly keyContext: Readonly<KeyContext>;\n\n    /**\n     * Create a new GlyphVirtualKey.\n     *\n     * @param glyph - The glyph to emit/show when shift is not held.\n     * @param altGlyph - The alternative glyph to emit/show when shift is held. Will be equal to glyph if set to null.\n     * @param keyContext - The {@link KeyContext} shared by other keys to tell when shift is being held in a virtual keyboard.\n     */\n    constructor(glyph: string, altGlyph: string | null, keyContext: Readonly<KeyContext>, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            '', () => keyContext.callback(this.currentGlyph),\n            minWidth, minHeight, properties,\n        );\n\n        this.glyph = glyph;\n        this.altGlyph = altGlyph === null ? glyph : altGlyph;\n        this.keyContext = keyContext;\n        this.child.child.text = this.currentGlyph;\n    }\n\n    override handlePreLayoutUpdate(): void {\n        this.child.child.text = this.currentGlyph;\n\n        super.handlePreLayoutUpdate();\n    }\n\n    get currentGlyph() {\n        if(this.keyContext.shift)\n            return this.altGlyph;\n        else\n            return this.glyph;\n    }\n}\n", "import type { Widget, WidgetProperties } from './Widget';\nimport { MultiContainer } from './MultiContainer';\n\n/**\n * A horizontal {@link MultiContainer}.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Row<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Row. */\n    constructor(properties?: Readonly<WidgetProperties>) {\n        super(false, properties);\n    }\n}\n", "import { GlyphVirtualKey } from './GlyphVirtualKey';\nimport type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport type { VirtualKey } from './VirtualKey';\nimport { DynMsg } from '../../core/Strings';\nimport { Row } from '../Row';\n\n/**\n * A template for a single virtual keyboard key. A function that, when called\n * given a {@link KeyContext} and theme override, returns a {@link VirtualKey}\n * which can be used as a virtual keyboard key widget.\n *\n * Example:\n * ```typescript\n * const template: VirtualKeyTemplate = (keyContext, properties) => new BackspaceKey(keyContext, properties);\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyTemplate = (keyContext: KeyContext, properties?: Readonly<WidgetProperties>) => VirtualKey;\n\n/**\n * A template for multiple {@link GlyphVirtualKey} virtual keyboard keys. A\n * 2-tuple of strings, where each string has the same length. Each character of\n * the string represents a glyph to add to a keyboard row. The first string of\n * the tuple has the regular glyphs, while the second string string of the tuple\n * has the alternative glyphs.\n *\n * Example:\n * ```typescript\n * const template: GlyphVirtualKeysTemplate = ['qwertyuiop', 'QWERTYUIOP'];\n * ```\n *\n * @category Widget\n */\nexport type GlyphVirtualKeysTemplate = [string, string];\n\n/**\n * A template for a single row of virtual keyboard keys. An array of\n * {@link GlyphVirtualKeysTemplate} and {@link VirtualKeyTemplate}.\n *\n * Example:\n * ```typescript\n * const backspaceTemplate: VirtualKeyTemplate = (keyContext, themeProperties) => new BackspaceKey(keyContext, themeProperties);\n * const rowTemplate: VirtualKeyRowTemplate = [['`1234567890-=', '~!@#$%^&*()_+'], backspaceTemplate];\n * ```\n *\n * @category Widget\n */\nexport type VirtualKeyRowTemplate = Array<GlyphVirtualKeysTemplate | VirtualKeyTemplate>;\n\n/**\n * A {@link Row} of {@link VirtualKey | virtual keys}. Generates given a\n * template.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class VirtualKeyRow extends Row<VirtualKey> {\n    /**\n     * Create a new VirtualKeyRow.\n     *\n     * @param rowTemplate - Template for this row of virtual keys.\n     * @param keyContext - The {@link KeyContext} to be shared among all virtual keys in this row.\n     * @param minWidth - The minWidth to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}.\n     * @param minHeight - The minHeight to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}.\n     */\n    constructor(rowTemplate: VirtualKeyRowTemplate, keyContext: KeyContext, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(properties);\n\n        for(const entry of rowTemplate) {\n            if(typeof entry === 'function') {\n                // Entry is in template function format\n                const templateFunction = entry;\n                this.add(templateFunction(keyContext, properties));\n            }\n            else if(typeof entry[0] === 'string' && typeof entry[1] === 'string') {\n                // Entry is in multiple glyphs format\n                const glyphs = entry[0];\n                const altGlyphs = entry[1];\n                for(let i = 0; i < glyphs.length; i++) {\n                    let altGlyph = null;\n                    if(i < altGlyphs.length)\n                        altGlyph = altGlyphs[i];\n\n                    this.add(new GlyphVirtualKey(\n                        glyphs[i],\n                        altGlyph,\n                        keyContext,\n                        minWidth,\n                        minHeight,\n                        properties,\n                    ));\n                }\n            }\n            else {\n                throw new Error(DynMsg.INVALID_KB_ROW_TEMPLATE(entry));\n            }\n        }\n    }\n}", "import type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which emits key presses of a given key code.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class BasicVirtualKey extends VirtualKey {\n    /**\n     * Create a new BasicVirtualKey.\n     *\n     * @param text - The text to display in the virtual key.\n     * @param keyCode - The {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | key code} to emit in the keyContext's callback when the virtual key is pressed\n     * @param keyContext - The {@link KeyContext} shared by other virtual keyboard key widgets.\n     */\n    constructor(text: string, keyCode: string, keyContext: KeyContext, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            text,\n            () => keyContext.callback(keyCode),\n            minWidth,\n            minHeight,\n            properties,\n        );\n    }\n}\n", "import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Backspace' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class BackspaceKey extends BasicVirtualKey {\n    /** Create a new BackspaceKey. */\n    constructor(keyContext: KeyContext, minWidth = 60, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super('Backspace', 'Backspace', keyContext, minWidth, minHeight, properties);\n    }\n}\n", "import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Escape' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class EscapeKey extends BasicVirtualKey {\n    /** Create a new EscapeKey. */\n    constructor(keyContext: KeyContext, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super('Esc', 'Escape', keyContext, minWidth, minHeight, properties);\n    }\n}\n", "import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits 'Enter' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class EnterKey extends BasicVirtualKey {\n    /** Create a new EnterKey. */\n    constructor(keyContext: KeyContext, minWidth = 72, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super('Enter', 'Enter', keyContext, minWidth, minHeight, properties);\n    }\n}\n", "import type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a shift key; toggles\n * {@link KeyContext#shift} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class ShiftKey extends VirtualKey {\n    /** Create a new ShiftKey. */\n    constructor(keyContext: KeyContext, minWidth = 84, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            'Shift',\n            () => {\n                keyContext.shift = !keyContext.shift;\n                this.child.forced = keyContext.shift;\n                keyContext.callback('Shift');\n            },\n            minWidth,\n            minHeight,\n            properties,\n        );\n\n        this.child.forced = keyContext.shift;\n    }\n}\n", "import { BasicVirtualKey } from './BasicVirtualKey';\nimport type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\n\n/**\n * A {@link BasicVirtualKey} which emits ' ' key presses.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class SpaceKey extends BasicVirtualKey {\n    /** Create a new SpaceKey. */\n    constructor(keyContext: KeyContext, minWidth = 84, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        properties = {\n            flex: 1,\n            ...properties\n        };\n\n        super('Space', ' ', keyContext, minWidth, minHeight, properties);\n    }\n}\n", "import type { Widget, WidgetProperties } from './Widget';\nimport { MultiContainer } from './MultiContainer';\n\n/**\n * A vertical {@link MultiContainer}.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Column<W extends Widget = Widget> extends MultiContainer<W> {\n    /** Create a new Column. */\n    constructor(properties?: Readonly<WidgetProperties>) {\n        super(true, properties);\n    }\n}\n", "import type { KeyboardDriver } from '../../drivers/KeyboardDriver';\nimport type { FlexAlignment2D } from '../../theme/FlexAlignment2D';\nimport type { VirtualKeyRowTemplate } from './VirtualKeyRow';\nimport { FlexAlignment } from '../../theme/FlexAlignment';\nimport type { WidgetProperties } from '../Widget';\nimport { Alignment } from '../../theme/Alignment';\nimport { VirtualKeyRow } from './VirtualKeyRow';\nimport type { KeyContext } from './KeyContext';\nimport { BackspaceKey } from './BackspaceKey';\nimport { EscapeKey } from './EscapeKey';\nimport { EnterKey } from './EnterKey';\nimport { ShiftKey } from './ShiftKey';\nimport { SpaceKey } from './SpaceKey';\nimport { Column } from '../Column';\n\n/**\n * A template for the keys in a {@link VirtualKeyboard}. Each member of the\n * array contains the template for a row of keys, from top to bottom.\n *\n * @category Widget\n */\nexport type VirtualKeyboardTemplate = Array<VirtualKeyRowTemplate>;\n\nfunction EnterKeyTemplate(keyContext: KeyContext, properties?: Readonly<WidgetProperties>): EnterKey {\n    return new EnterKey(\n        keyContext, undefined, undefined, properties,\n    );\n}\n\nfunction ShiftKeyTemplate(keyContext: KeyContext, properties?: Readonly<WidgetProperties>): ShiftKey {\n    return new ShiftKey(\n        keyContext, undefined, undefined, properties,\n    );\n}\n\nfunction BackspaceKeyTemplate(keyContext: KeyContext, properties?: Readonly<WidgetProperties>): BackspaceKey {\n    return new BackspaceKey(\n        keyContext, undefined, undefined, properties,\n    );\n}\n\nfunction SpaceKeyTemplate(keyContext: KeyContext, properties?: Readonly<WidgetProperties>): SpaceKey {\n    return new SpaceKey(\n        keyContext, undefined, undefined, properties,\n    );\n}\n\nfunction EscapeKeyTemplate(keyContext: KeyContext, properties?: Readonly<WidgetProperties>): EscapeKey {\n    return new EscapeKey(\n        keyContext, undefined, undefined, properties,\n    );\n}\n\n/**\n * The default template for the keys in a {@link VirtualKeyboard}; A QWERTY\n * keyboard with US layout.\n *\n * @category Widget\n */\nexport const defaultVirtualKeyboardTemplate: VirtualKeyboardTemplate = [\n    // First row\n    [['`1234567890-=', '~!@#$%^&*()_+']],\n    // Second row\n    [['qwertyuiop[]\\\\', 'QWERTYUIOP{}|']],\n    // Third row\n    [['asdfghjkl;\\'', 'ASDFGHJKL:\"'], EnterKeyTemplate],\n    // Fourth row\n    [ShiftKeyTemplate, ['zxcvbnm,./', 'ZXCVBNM<>?']],\n    // Fifth row\n    [BackspaceKeyTemplate, SpaceKeyTemplate, EscapeKeyTemplate],\n];\n\n/**\n * A virtual keyboard widget.\n *\n * Needs a {@link KeyboardDriver} so that key events can be queued.\n *\n * Equivalent to creating a {@link Column} of {@link VirtualKeyRow} with a shared\n * {@link KeyContext}. Key rows will be created with SpaceBetween main alignment\n * and Stretch cross alignment.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class VirtualKeyboard extends Column {\n    /**\n     * Create a new VirtualKeyboard.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}.\n     * @param minWidth - The minWidth to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}.\n     * @param minHeight - The minHeight to use when creating {@link GlyphVirtualKey | GlyphVirtualKeys}.\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, minWidth = 24, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        properties = {\n            multiContainerAlignment: <FlexAlignment2D>{\n                main: FlexAlignment.SpaceBetween, cross: Alignment.Stretch,\n            },\n            ...properties\n        };\n\n        super(properties);\n\n        // Make context\n        const keyContext = <KeyContext>{\n            callback: (key: string) => {\n                keyboardDriver.keyPress(\n                    key,\n                    keyContext.shift,\n                    keyContext.ctrl,\n                    keyContext.alt,\n                );\n            },\n            shift: false,\n            ctrl: false,\n            alt: false,\n        };\n\n        for(const rowTemplate of keyboardTemplate) {\n            this.add(new VirtualKeyRow(\n                rowTemplate, keyContext, minWidth, minHeight,\n                properties,\n            ));\n        }\n    }\n}\n", "import type { Widget, WidgetProperties } from './Widget';\nimport { BaseContainer } from './BaseContainer';\n\n/**\n * A {@link BaseContainer} which always propagates events. Use this widget if\n * you are not sure what that means.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Container<W extends Widget = Widget> extends BaseContainer<W> {\n    /** Create a new Container. */\n    constructor(child: W, properties?: Readonly<WidgetProperties>) {\n        super(child, true, properties);\n    }\n}\n", "import type { ThemeProperties } from '../theme/ThemeProperties';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link Container} with center alignment on both axes and default padding,\n * similar to {@link Center}.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Margin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Margin. */\n    constructor(child: W, properties?: Readonly<ThemeProperties>) {\n        properties = {\n            containerAlignment: <Alignment2D>{\n                horizontal: Alignment.Center, vertical: Alignment.Center,\n            },\n            ...properties\n        };\n\n        super(child, properties);\n    }\n}\n", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { DOMRoot } from './DOMRoot';\n\n/**\n * A {@link DOMRoot} with similar functionality to {@link VirtualKeyboardRoot}.\n * In this version {@link VirtualKeyboardRoot#updateVisibility} doesn't exist.\n * Instead, just call {@link DOMVirtualKeyboardRoot#update} like in DOMRoot.\n *\n * @category Core\n */\nexport class DOMVirtualKeyboardRoot extends DOMRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link Root#child} to a new {@link Margin} containing a\n     * {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template} and\n     * {@link Root#child}'s {@link Widget#inheritedTheme | inherited theme}.\n     * Also sets up a {@link Root#pointerStyleHandler} which simply sets the CSS\n     * cursor style of {@link DOMRoot#domElem}. Creates {@link DOMRoot#domElem}\n     * and {@link DOMRoot#domCanvasContext}.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update DOMRoot.\n     *\n     * If root is disabled, {@link DOMRoot#domElem}'s display style is set to\n     * 'none', hiding it.\n     *\n     * Calls {@link Root#preLayoutUpdate}, {@link Root#resolveLayout},\n     * {@link Root#postLayoutUpdate} and {@link Root#paint}.\n     *\n     * Also updates the visibility of this root; if the keyboard driver has no\n     * focused root, then the root is disabled, else, it is enabled.\n     */\n    override update(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.needsInput;\n\n        // Update normally\n        super.update();\n    }\n}", "import { VirtualKeyboard, defaultVirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { VirtualKeyboardTemplate } from '../widgets/VirtualKeyboard/VirtualKeyboard';\nimport type { PointerStyleHandler } from './PointerStyleHandler';\nimport type { KeyboardDriver } from '../drivers/KeyboardDriver';\nimport { Margin } from '../widgets/Margin';\nimport { Theme } from '../theme/Theme';\nimport { Root } from './Root';\n\n/**\n * A {@link Root} containing a single {@link VirtualKeyboard} widget inside a\n * {@link Margin}. Automatically disables itself if not needed, but\n * {@link VirtualKeyboardRoot#updateVisibility} must be called every frame for\n * this behaviour to occur.\n *\n * @category Core\n */\nexport class VirtualKeyboardRoot extends Root {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Creates a new VirtualKeyboardRoot.\n     *\n     * Sets {@link VirtualKeyboardRoot#child} to a new {@link Margin} containing\n     * a {@link VirtualKeyboard} with the given keyboard and\n     * {@link VirtualKeyboardTemplate | keyboard template},\n     * {@link VirtualKeyboardRoot#pointerStyleHandler} and\n     * {@link VirtualKeyboardRoot#child}'s\n     * {@link Widget#inheritedTheme | inherited theme}.\n     *\n     * @param keyboardTemplate - By default, the virtual keyboard template is {@link defaultVirtualKeyboardTemplate}\n     * @param theme - If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(keyboardDriver: KeyboardDriver, keyboardTemplate: VirtualKeyboardTemplate = defaultVirtualKeyboardTemplate, pointerStyleHandler: PointerStyleHandler | null = null, theme: Theme = new Theme()) {\n        super(\n            new Margin(\n                new VirtualKeyboard(keyboardDriver, keyboardTemplate),\n            ),\n            pointerStyleHandler, theme,\n        );\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Update the visibility of this root; if the keyboard driver has no focused\n     * root, then the root is disabled, else, it is enabled. Call this method\n     * on every frame to automatically enable/disable the root if needed\n     */\n    updateVisibility(): void {\n        // Update visibility of root by enabling/disabling it\n        this.enabled = this.keyboardDriver.needsInput;\n    }\n}", "import type { KeyEvent } from '../events/KeyEvent';\nimport { KeyRelease } from '../events/KeyRelease';\nimport type { Widget } from '../widgets/Widget';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Root } from '../core/Root';\n\n/**\n * A generic keyboard {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending keyboard events to\n * registered roots.\n *\n * @category Driver\n */\nexport class KeyboardDriver implements Driver {\n    /** The list of key down/up events that haven't been dispatched yet. */\n    private eventQueues: Map<Root, Array<KeyEvent>> = new Map();\n    /** A set containing the keys currently down. */\n    private keysDown: Set<string> = new Set();\n    /** The currently focused root. New keyboard events will go to this root */\n    private focus: Root | null = null;\n    /**\n     * The last {@link Root} that had \"activity\"; the last Root where any focus\n     * was grabbed. Used as a fallback when there is no focus. If this is null,\n     * then a root from {@link KeyboardDriver#eventQueues} is picked; this\n     * fallback of a fallback may result in weird behaviour if there are more\n     * than 1 Roots, since eventQueues is a Map, and Map iteration is not\n     * guaranteed to be in the same order\n     */\n    private lastActivity: Root | null = null;\n\n    /**\n     * Get the {@link KeyboardDriver#eventQueues | event queue} of a given root.\n     * If this driver is not registered to the given root or the given root is\n     * disabled, making it not present in eventQueues, then null is returned.\n     */\n    private getEventQueue(root: Root | null): Array<KeyEvent> | null {\n        if(root === null)\n            return null;\n\n        const eventQueue = this.eventQueues.get(root);\n        if(typeof eventQueue === 'undefined')\n            return null;\n\n        return eventQueue;\n    }\n\n    /**\n     * Changes the current {@link KeyboardDriver#focus | root focus}.\n     *\n     * If there was a previous root focus, that root's {@link Root#clearFocus}\n     * is called with {@link FocusType#Keyboard}.\n     *\n     * {@link KeyboardDriver#keysDown} is cleared.\n     */\n    protected changeFocusedRoot(root: Root | null): void {\n        if(this.focus === root)\n            return;\n\n        if(this.focus !== null)\n            this.focus.clearFocus(FocusType.Keyboard);\n\n        this.focus = root;\n        this.keysDown.clear();\n    }\n\n    /**\n     * Get the current {@link KeyboardDriver#focus | root focus}.\n     *\n     * @returns Returns {@link KeyboardDriver#focus}\n     */\n    getFocusedRoot(): Root | null {\n        return this.focus;\n    }\n\n    /**\n     * Similar to {@link KeyboardDriver#getFocusedRoot}, but can fall back to\n     * {@link KeyboardDriver#lastActivity} if {@link KeyboardDriver#focus} is\n     * null, or a {@link Root} in {@link KeyboardDriver#eventQueues} if\n     * lastActivity is also null.\n     */\n    getEffectiveFocusedRoot(): Root | null {\n        if(this.focus)\n            return this.focus;\n        else if(this.lastActivity)\n            return this.lastActivity;\n        else if(this.eventQueues.size > 0)\n            return this.eventQueues.keys().next().value;\n        else\n            return null;\n    }\n\n    /**\n     * Clear the current {@link KeyboardDriver#focus | root focus}. Calls\n     * {@link KeyboardDriver#changeFocusedRoot} with null.\n     */\n    clearFocus(): void {\n        this.changeFocusedRoot(null);\n    }\n\n    /**\n     * Push a new {@link KeyPress} event to {@link KeyboardDriver#eventQueues}.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyDown(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        this.keysDown.add(key);\n        const eventQueue = this.getEventQueue(this.getEffectiveFocusedRoot());\n        if(eventQueue !== null)\n            eventQueue.push(new KeyPress(key, shift, ctrl, alt, null));\n    }\n\n    /**\n     * Push a new {@link KeyRelease} event to {@link KeyboardDriver#eventQueues}.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyUp(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        if(this.keysDown.delete(key)) {\n            const eventQueue = this.getEventQueue(this.getEffectiveFocusedRoot());\n            if(eventQueue !== null)\n                eventQueue.push(new KeyRelease(key, shift, ctrl, alt, null));\n        }\n    }\n\n    /**\n     * Calls {@link KeyboardDriver#keyDown} followed by\n     * {@link KeyboardDriver#keyUp}. If the key was already down before calling\n     * ({@link KeyboardDriver#isKeyDown}), keyUp is not called.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    keyPress(key: string, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const wasDown = this.isKeyDown(key);\n        this.keyDown(key, shift, ctrl, alt);\n        if(!wasDown)\n            this.keyUp(key, shift, ctrl, alt);\n    }\n\n    /**\n     * Check if a key is pressed.\n     *\n     * @param key - Must follow the {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values | KeyboardEvent.key} Web API.\n     *\n     * @returns Returns true if key was in {@link KeyboardDriver#keysDown}\n     */\n    isKeyDown(key: string): boolean {\n        return this.keysDown.has(key);\n    }\n\n    /**\n     * Adds enabled root to {@link KeyboardDriver#eventQueues}.\n     */\n    onEnable(root: Root): void {\n        if(!this.eventQueues.has(root))\n            this.eventQueues.set(root, []);\n    }\n\n    /**\n     * Removes disabled root from {@link KeyboardDriver#eventQueues}. If the\n     * root was the {@link KeyboardDriver#focus}, then\n     * {@link KeyboardDriver#clearFocus | the focus is cleared }.\n     */\n    onDisable(root: Root): void {\n        if(this.eventQueues.has(root)) {\n            this.eventQueues.delete(root);\n            if(root === this.focus)\n                this.clearFocus();\n        }\n    }\n\n    /**\n     * Dispatches all {@link KeyboardDriver#eventQueues | queued events } for\n     * the root and clears its event queue\n     */\n    update(root: Root): void {\n        const eventQueue = this.getEventQueue(root);\n        if(eventQueue === null)\n            return;\n\n        // Dispatch queued keyboard events\n        for(const event of eventQueue)\n            root.dispatchEvent(event);\n\n        // Clear event queue\n        eventQueue.length = 0;\n    }\n\n    /**\n     * Does nothing if the new focus type is not a {@link FocusType.Keyboard}.\n     * If the focus comes from a root which is not the\n     * {@link KeyboardDriver#focus | root focus}, then the root focus is\n     * {@link KeyboardDriver#changeFocusedRoot | changed to the new root}. If\n     * there is no new focused widget (the root's keyboard focus was cleared),\n     * then nothing happens.\n     *\n     * This behaviour is confusing, however, it's required so that the keyboard\n     * focus \"lingers\" for future tab key presses; this way, pressing tab can do\n     * tab selection even when there is no widget that wants keyboard input.\n     * When a focus is lingering, then it means that key events are still being\n     * dispatched to the last focused root, but they don't have a target. This\n     * way, most events get dropped, but tab key events are used for tab\n     * selection.\n     */\n    onFocusChanged(root: Root, focusType: FocusType, newFocus: Widget | null): void {\n        if(newFocus !== null)\n            this.lastActivity = root;\n\n        if(focusType !== FocusType.Keyboard)\n            return;\n\n        if(root !== this.focus && newFocus !== null)\n            this.changeFocusedRoot(root);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n\n    /**\n     * Check if the currently focused root needs keyboard input. Virtual\n     * keyboard should query this property to know when to show themselves.\n     */\n    get needsInput(): boolean {\n        return this.focus !== null && this.focus.getFocus(FocusType.Keyboard) !== null;\n    }\n}\n", "import { KeyboardDriver } from './KeyboardDriver';\nimport { FocusType } from '../core/FocusType';\nimport { Msg } from '../core/Strings';\n\n/**\n * The set of keys that will call preventDefault if captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_KEYS = new Set([\n    'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'End', 'Home',\n    'PageDown', 'PageUp', 'Tab', ' ',\n]);\n\n/**\n * The set of keys that will call preventDefault when holding ctrl if captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_CTRL_KEYS = new Set([\n    'a', 'A',\n]);\n\n/**\n * The set of keys that will call preventDefault, even if not captured.\n *\n * @category Driver\n */\nconst PREVENT_DEFAULT_FORCE_KEYS = new Set([\n    'Tab'\n]);\n\n/**\n * Unpack a KeyboardEvent into a 4-tuple containing the event's key and modifier\n * key state. The 4-tuple contains, respectively, the key\n * {@link https://developer.mozilla.org/docs/Web/API/KeyboardEvent/key | KeyboardEvent.key}\n * of the event, whether shift is being held, whether ctrl is being held, and\n * whether alt is being held\n *\n * @category Driver\n */\nfunction unpackKeyboardEvent(event: KeyboardEvent): [key: string, shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.key, event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A container which has all the event listeners for a {@link Root} DOM bind to\n * a {@link DOMKeyboardDriver}; a link between a DOM element and an existing\n * Root.\n *\n * @category Driver\n */\nexport interface DOMKeyboardDriverBind {\n    blurListen: ((this: HTMLElement, event: FocusEvent) => void) | null,\n    keydownListen: ((this: HTMLElement, event: KeyboardEvent) => void) | null,\n    keyupListen: ((this: HTMLElement, event: KeyboardEvent) => void) | null\n}\n\n/**\n * A {@link KeyboardDriver} which listens for key events from HTML DOM elements.\n *\n * Note that if a DOM element is unfocused in the DOM to an unbound DOM element,\n * the root focus is cleared. If this creates issues, other DOM elements can be\n * bound without listening for key events.\n *\n * @category Driver\n */\nexport class DOMKeyboardDriver extends KeyboardDriver {\n    /**\n     * The list of HTML DOM elements bound to this keyboard driver and their\n     * event listeners\n     */\n    private domElems: Map<HTMLElement, DOMKeyboardDriverBind> = new Map();\n\n    /** Calls preventDefault on a keyboard event if needed. */\n    maybePreventDefault(event: KeyboardEvent): void {\n        if(PREVENT_DEFAULT_KEYS.has(event.key) || (PREVENT_DEFAULT_CTRL_KEYS.has(event.key) && event.ctrlKey)) {\n            if(PREVENT_DEFAULT_FORCE_KEYS.has(event.key))\n                event.preventDefault();\n            else {\n                const currentFocus = this.getFocusedRoot()?.getFocus(FocusType.Keyboard) ?? null;\n                if(currentFocus !== null)\n                    event.preventDefault();\n            }\n        }\n    }\n\n    /**\n     * Bind an HTML DOM element to this keyboard driver.\n     *\n     * If the root was already bound,\n     * {@link DOMKeyboardDriver#removeListeners} is called, replacing the old\n     * listeners. Populates {@link DOMKeyboardDriver#domElems} with the new\n     * bind.\n     *\n     * @param listenToKeys - If true, event listeners will be added to listen for keys. blur event listeners are always added no matter what.\n     */\n    bindDOMElem(domElem: HTMLElement, listenToKeys = true): void {\n        let bind = this.domElems.get(domElem);\n        if(bind !== undefined) {\n            console.warn(Msg.DOM_DRIVER_REBIND);\n            this.removeListeners(domElem, bind);\n        }\n        else {\n            bind = <DOMKeyboardDriverBind>{\n                blurListen: null,\n                keydownListen: null,\n                keyupListen: null\n            };\n            this.domElems.set(domElem, bind);\n        }\n\n        this.addListeners(domElem, bind, listenToKeys);\n    }\n\n    /**\n     * Unbind an HTML DOM element from this keyboard driver. Removes all used\n     * listeners.\n     */\n    unbindDOMElem(domElem: HTMLElement): void {\n        const bind = this.domElems.get(domElem);\n        if(bind === undefined)\n            return;\n\n        this.removeListeners(domElem, bind);\n        this.domElems.delete(domElem);\n    }\n\n    /** Add pointer event listeners to DOM element. */\n    private addListeners(domElem: HTMLElement, bind: DOMKeyboardDriverBind, listenToKeys = true): void {\n        // Listen for keyboard events, filling event queue, and blur event for\n        // clearing keyboard focus\n        bind.blurListen = (event) => {\n            // XXX should the HTMLElement cast be done?\n            if(this.shouldClearFocus(event.relatedTarget as HTMLElement))\n                this.clearFocus();\n        };\n\n        domElem.addEventListener('blur', bind.blurListen);\n\n        if(listenToKeys) {\n            bind.keydownListen = (event) => {\n                this.maybePreventDefault(event);\n                this.keyDown(...unpackKeyboardEvent(event));\n            };\n\n            bind.keyupListen = (event) => {\n                this.maybePreventDefault(event);\n                this.keyUp(...unpackKeyboardEvent(event));\n            };\n\n            domElem.addEventListener('keydown', bind.keydownListen);\n            domElem.addEventListener('keyup', bind.keyupListen);\n        }\n    }\n\n    /**\n     * Remove event listeners from DOM element and unset tracked listeners in\n     * bind.\n     */\n    private removeListeners(domElem: HTMLElement, bind: DOMKeyboardDriverBind): void {\n        if(bind.blurListen) {\n            domElem.removeEventListener('blur', bind.blurListen);\n            bind.blurListen = null;\n        }\n\n        if(bind.keydownListen) {\n            domElem.removeEventListener('keydown', bind.keydownListen);\n            bind.keydownListen = null;\n        }\n\n        if(bind.keyupListen) {\n            domElem.removeEventListener('keyup', bind.keyupListen);\n            bind.keyupListen = null;\n        }\n    }\n\n    /**\n     * Check if the {@link KeyboardDriver#focus | root focus} should be cleared\n     * given that the HTML DOM focus has been lost to another HTML DOM element\n     *\n     * @param newTarget - The HTML DOM element to which the focus has been lost to\n     */\n    shouldClearFocus(newTarget: HTMLElement | null): boolean {\n        return newTarget === null || !this.domElems.has(newTarget);\n    }\n}\n", "/**\n * Extracts the position of a DOM MouseEvent and normalises it. Useful for\n * implementing mouse input.\n *\n * @returns Returns a 2-tuple containing the normalised coordinates; the first\n * element contains the normalised x axis, and the second element contains the\n * normalised y axis\n *\n * @category Helper\n */\nexport function getPointerEventNormPos(event: MouseEvent, domElem: HTMLElement): [number, number] {\n    const rect = domElem.getBoundingClientRect();\n    return [\n        (event.clientX - rect.left) / rect.width,\n        (event.clientY - rect.top) / rect.height,\n    ];\n}", "import { FocusType } from '../core/FocusType';\nimport { PointerEvent } from './PointerEvent';\nimport { Widget } from '../widgets/Widget';\n\n/**\n * A pointer move {@link PointerEvent}.\n *\n * Has a focus type of {@link FocusType.Pointer} and does not need focus.\n *\n * @category Event\n */\nexport class PointerMove extends PointerEvent {\n    /** Create a new PointerMove. */\n    constructor(x: number, y: number, shift: boolean, ctrl: boolean, alt: boolean, target: Widget | null = null) {\n        super(x, y, shift, ctrl, alt, target, FocusType.Pointer);\n    }\n\n    correctOffset(xOffset: number, yOffset: number): PointerMove {\n        return new PointerMove(this.x - xOffset, this.y - yOffset, this.shift, this.ctrl, this.alt, this.target);\n    }\n\n    cloneWithTarget(target: Widget | null): PointerMove {\n        return new PointerMove(this.x, this.y, this.shift, this.ctrl, this.alt, target);\n    }\n}\n", "/**\n * A {@link PointerDriver}'s pointer hint; each registered pointer has a pointer\n * hint which tracks whether the pointer is not in use, hovering a root or\n * pressing a root. Useful for styling pointers depending on if they are\n * hovering/pressing a root or not.\n *\n * @category Driver\n */\nexport enum PointerHint {\n    /** The pointer is currently not hovering any root. */\n    None,\n    /** The pointer is currently hovering a root. */\n    Hovering,\n    /** The pointer is currently hovering and pressing a root. */\n    Pressing,\n}", "import { PointerWheel, PointerWheelMode } from '../events/PointerWheel';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerMove } from '../events/PointerMove';\nimport type { Widget } from '../widgets/Widget';\nimport { FocusType } from '../core/FocusType';\nimport type { Driver } from '../core/Driver';\nimport type { Event } from '../events/Event';\nimport { PointerHint } from './PointerHint';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\n/**\n * A container which has the state associated with a specific {@link Root} for\n * use in a {@link PointerDriver}.\n *\n * @category Driver\n */\nexport interface PointerDriverState {\n    eventQueue: Array<Event>;\n    pointer: number | null;\n    pressing: number;\n    hovering: boolean;\n    dragLast: [number, number] | null;\n    dragOrigin: [number, number];\n}\n\n/**\n * A generic pointer {@link Driver | driver}.\n *\n * Does nothing on its own, but provides an API for sending pointer events to\n * registered roots and (un)registering pointers.\n *\n * @category Driver\n */\nexport class PointerDriver implements Driver {\n    /**\n     * The current state for each registered and enabled root. Contains whether\n     * each root is pressing, hovering, which pointer is bound to it and its\n     * event queue\n     */\n    protected states: Map<Root, PointerDriverState> = new Map();\n    /**\n     * The next available pointer ID. See {@link PointerDriver#registerPointer}\n     */\n    private nextPointerID = 0;\n    /**\n     * The {@link PointerHint | hints} for each pointer. The keys are pointer\n     * IDs, while the values are that pointer's hint.\n     *\n     * See {@link PointerDriver#getPointerHint}\n     */\n    protected hints: Map<number, PointerHint> = new Map();\n    /**\n     * The dragToScroll value of every pointer ID. See\n     * {@link PointerDriver#registerPointer}.\n     */\n    private dragToScroll: Map<number, boolean> = new Map();\n\n    /** Unassign a pointer from a given root and its state. */\n    private unassignPointer(root: Root, state: PointerDriverState) {\n        // Clear pointer state\n        if(state.pointer !== null)\n            this.setPointerHint(state.pointer, PointerHint.None);\n\n        // Clear state\n        state.pointer = null;\n        if(state.hovering) {\n            // Queue up Leave event if hovering\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n        }\n        state.hovering = false;\n        state.pressing = 0;\n        state.dragLast = null;\n    }\n\n    /**\n     * Register a new pointer.\n     *\n     * @param dragToScroll - If true, then dragging will result in PointerWheel events if no widget captures the events.\n     * @returns Returns {@link PointerDriver#nextPointerID} and increments it\n     */\n    registerPointer(dragToScroll = false): number {\n        const newID = this.nextPointerID++;\n        this.setPointerHint(newID, PointerHint.None);\n        this.dragToScroll.set(newID, dragToScroll);\n        return newID;\n    }\n\n    /**\n     * Unregister a pointer.\n     *\n     * If a root has this pointer bound to it, the pointer is unbound from the\n     * root, a Leave event is queued to the root and the hovering and pressing\n     * state of the root is set to false.\n     */\n    unregisterPointer(pointer: number): void {\n        for(const [root, state] of this.states) {\n            // Unassign pointer if unregistered pointer was assigned to root\n            if(state.pointer === pointer)\n                this.unassignPointer(root, state);\n        }\n\n        this.hints.delete(pointer);\n        this.dragToScroll.delete(pointer);\n    }\n\n    /**\n     * Check if a given pointer can queue an event to a given root. Also\n     * automatically assigns pointer to root if possible. For internal use only.\n     *\n     * @param state - The root's state. Although the function could technically get the state itself, it's passed to avoid repetition since you will need the state yourself\n     * @param givingActiveInput - Is the pointer giving active input (pressing button or scrolling)? If so, then it can auto-assign if the root is not being pressed by another pointer\n     */\n    private canQueueEvent(root: Root, pointer: number, state: PointerDriverState, givingActiveInput: boolean): boolean {\n        // If there is no pointer assigned, assign this one\n        const firstAssign = state.pointer === null;\n        if(firstAssign)\n            state.pointer = pointer;\n\n        // If pointer is entering this root for the first time, then find which\n        // root the pointer was assigned to and queue a leave event\n        const pointerMatches = state.pointer === pointer;\n        if(!pointerMatches || firstAssign) {\n            for(const [otherRoot, otherState] of this.states) {\n                // Ignore if its this root\n                if(otherRoot === root)\n                    continue;\n\n                // If other root has this pointer assigned, unassign it\n                if(otherState.pointer === pointer)\n                    this.unassignPointer(otherRoot, otherState);\n            }\n        }\n\n        // Ignore if pointer is not the assigned one and not giving active input\n        // or being pressed by the assigned pointer\n        if(!pointerMatches && (!givingActiveInput || state.pressing > 0))\n            return false;\n        else {\n            // Replace assigned pointer and clear old assigned pointer's hint if\n            // pointer changed and giving active input\n            if(givingActiveInput && state.pointer !== pointer) {\n                this.unassignPointer(root, state);\n                state.pointer = pointer;\n            }\n\n            return true;\n        }\n    }\n\n    /** Denormalise normalised pointer coordinates. Internal use only. */\n    private denormaliseCoords(root: Root, xNorm: number, yNorm: number): [number, number] {\n        const [width, height] = root.dimensions;\n        return [xNorm * width, yNorm * height];\n    }\n\n    /**\n     * Queue up a pointer event to a given root. The type of\n     * {@link PointerEvent} is decided automatically based on the root's state\n     * and whether its pressing or not.\n     *\n     * @param pointer - The registered pointer ID\n     * @param xNorm - The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm - The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param pressing - Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     *\n     * If null, the last pressing state is used, meaning that the pressing state\n     * has not changed. Useful if getting pointer movement in an event based\n     * environment where you only know when a pointer press occurs, but not if\n     * the pointer is pressed or not\n     */\n    movePointer(root: Root, pointer: number, xNorm: number, yNorm: number, pressing: number | null, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // If press state was not supplied, then it hasn't changed. Use the last\n        // state\n        if(pressing === null)\n            pressing = state.pressing;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, pressing > 0))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        if(pressing !== state.pressing) {\n            // Get how many bits in the bitmask you need to check\n            const bits = Math.floor(Math.log2(Math.max(pressing, state.pressing)));\n\n            // Check which buttons changed and generate an event for each\n            for(let bit = 0; bit <= bits; bit++) {\n                const wasPressed = ((state.pressing >> bit) & 0x1) === 1;\n                const isPressed = ((pressing >> bit) & 0x1) === 1;\n\n                if(wasPressed === isPressed)\n                    continue;\n\n                if(isPressed)\n                    state.eventQueue.push(new PointerPress(x, y, bit, shift, ctrl, alt));\n                else\n                    state.eventQueue.push(new PointerRelease(x, y, bit, shift, ctrl, alt));\n            }\n\n            state.pressing = pressing;\n        }\n        else\n            state.eventQueue.push(new PointerMove(x, y, shift, ctrl, alt));\n\n        // Update pointer's hint\n        if(state.pressing > 0)\n            this.setPointerHint(pointer, PointerHint.Pressing);\n        else\n            this.setPointerHint(pointer, PointerHint.Hovering);\n    }\n\n    /**\n     * Queue up a {@link Leave} event to a given root. Event will only be queued\n     * if the root was being hovered.\n     *\n     * @param pointer - The registered pointer ID\n     */\n    leavePointer(root: Root, pointer: number): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Queue leave event if this is the assigned pointer and if hovering\n        if(state.hovering && state.pointer == pointer) {\n            state.hovering = false;\n            state.pressing = 0;\n            state.dragLast = null;\n            state.eventQueue.push(\n                new Leave(root.getFocusCapturer(FocusType.Pointer))\n            );\n            this.setPointerHint(pointer, PointerHint.None);\n        }\n    }\n\n    /**\n     * Queue up a {@link Leave} event to any root with the given pointer\n     * assigned. Event will only be queued if the root was being hovered.\n     * Pointer will also be unassigned from root.\n     *\n     * @param pointer - The registered pointer ID\n     */\n    leaveAnyPointer(pointer: number): void {\n        for(const root of this.states.keys())\n            this.leavePointer(root, pointer);\n    }\n\n    /**\n     * Queue up a mouse wheel event in a given 2D direction. Event will only be\n     * queued if the root was being hovered.\n     *\n     * @param pointer - The registered pointer ID\n     * @param xNorm - The normalised (non-integer range from 0 to 1) X coordinate of the pointer event. 0 is the left edge of the root, while 1 is the right edge of the root.\n     * @param yNorm - The normalised (non-integer range from 0 to 1) Y coordinate of the pointer event. 0 is the top edge of the root, while 1 is the bottom edge of the root.\n     * @param deltaX - How much was scrolled horizontally, in pixels\n     * @param deltaY - How much was scrolled vertically, in pixels\n     * @param deltaZ - How much was scrolled in the Z axis, in pixels. Rarely used\n     * @param deltaMode - How the delta values should be interpreted\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    wheelPointer(root: Root, pointer: number, xNorm: number, yNorm: number, deltaX: number, deltaY: number, deltaZ: number, deltaMode: PointerWheelMode, shift: boolean, ctrl: boolean, alt: boolean): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Abort if this pointer can't queue an event to the target root\n        if(!this.canQueueEvent(root, pointer, state, true))\n            return;\n\n        // Update state and queue up event\n        state.hovering = true;\n        const [x, y] = this.denormaliseCoords(root, xNorm, yNorm);\n        state.eventQueue.push(new PointerWheel(x, y, deltaX, deltaY, deltaZ, deltaMode, false, shift, ctrl, alt));\n    }\n\n    /**\n     * Set a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer - The registered pointer ID\n     * @param hint - The new pointer hint\n     * @returns Returns true if the pointer hint changed, else, false\n     */\n    protected setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const oldHint = this.hints.get(pointer);\n\n        if(oldHint !== hint) {\n            this.hints.set(pointer, hint);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Get a pointer's {@link PointerHint | hint}.\n     *\n     * @param pointer - The registered pointer ID\n     *\n     * @returns Returns the given pointer ID's hint. If the pointer ID is not registered, {@link PointerHint.None} is returned.\n     */\n    getPointerHint(pointer: number): PointerHint {\n        return this.hints.get(pointer) ?? PointerHint.None;\n    }\n\n    /**\n     * Creates a state for the enabled root in {@link PointerDriver#states}.\n     */\n    onEnable(root: Root): void {\n        // Create new state for UI that just got enabled\n        this.states.set(root, <PointerDriverState>{\n            eventQueue: [],\n            pointer: null,\n            pressing: 0,\n            hovering: false,\n            dragLast: null,\n            dragOrigin: [0, 0],\n        });\n    }\n\n    /**\n     * Dispatches a leave event for the disabled root and deletes the state of\n     * the disabled root from {@link PointerDriver#states}.\n     */\n    onDisable(root: Root): void {\n        // Dispatch leave event\n        root.dispatchEvent(new Leave());\n\n        // Reset hint for assigned pointer and stop dragging\n        const state = this.states.get(root);\n        if(typeof state !== 'undefined' && state.pointer !== null) {\n            this.setPointerHint(state.pointer, PointerHint.None);\n            state.dragLast = null;\n        }\n\n        // Delete state for UI thats about to get disabled\n        this.states.delete(root);\n    }\n\n    /**\n     * Dispatches all queued events (found in {@link PointerDriver#states}) for\n     * the root and clears its event queue\n     */\n    update(root: Root): void {\n        const state = this.states.get(root);\n        if(typeof state === 'undefined')\n            return;\n\n        // Check if drag to scroll is enabled for this root\n        const dragToScroll = state.pointer === null\n                                ? false\n                                : this.dragToScroll.get(state.pointer);\n\n        // Dispatch all queued events for this root\n        for(const event of state.eventQueue) {\n            // If this is a pointer event and pointer is dragging, continue\n            // doing dragging logic\n            if(event instanceof PointerEvent && state.dragLast !== null) {\n                const [startX, startY] = state.dragLast;\n                root.dispatchEvent(new PointerWheel(\n                    ...state.dragOrigin,\n                    startX - event.x, startY - event.y, 0,\n                    PointerWheelMode.Pixel, false, false, false, true,\n                ));\n\n                if(event instanceof PointerRelease)\n                    state.dragLast = null;\n                else {\n                    state.dragLast[0] = event.x;\n                    state.dragLast[1] = event.y;\n                }\n\n                continue;\n            }\n\n            // Dispatch event. If nobody captures the event, dragToScroll is\n            // enabled and this is a pointer press, then start dragging\n            if(root.dispatchEvent(event))\n                state.dragLast = null;\n            else if(dragToScroll && event instanceof PointerPress) {\n                state.dragLast = [event.x, event.y];\n                state.dragOrigin[0] = event.x;\n                state.dragOrigin[1] = event.y;\n            }\n        }\n\n        // Clear queue\n        state.eventQueue.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusChanged(_root: Root, _focusType: FocusType, _newFocus: Widget | null): void {}\n\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    onFocusCapturerChanged(_root: Root, _focusType: FocusType, _oldCapturer: Widget | null, _newCapturer: Widget | null): void {}\n}\n", "import { getPointerEventNormPos } from '../helpers/getPointerEventNormPos';\nimport { parseDOMDeltaMode } from '../events/PointerWheel';\nimport { PointerDriver } from './PointerDriver';\nimport type { Root } from '../core/Root';\nimport { Msg } from '../core/Strings';\n\n/**\n * A container which has all the event listeners for a {@link Root} DOM bind to\n * a {@link DOMPointerDriver}; a link between a DOM element and an existing\n * Root.\n *\n * @category Driver\n */\nexport interface DOMPointerDriverBind {\n    domElem: HTMLElement,\n    pointerListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    pointerleaveListen: ((this: HTMLElement, event: PointerEvent) => void) | null,\n    wheelListen: ((this: HTMLElement, event: WheelEvent) => void) | null,\n    contextMenuListen: ((this: HTMLElement, event: MouseEvent) => void) | null\n}\n\n/**\n * Unpack a MouseEvent into a 3-tuple containing the event's modifier key state.\n * The 3-tuple contains, respectively, whether shift is being held, whether ctrl\n * is being held, and whether alt is being held.\n *\n * @category Driver\n */\nfunction unpackModifiers(event: MouseEvent): [shift: boolean, ctrl: boolean, alt: boolean] {\n    return [event.shiftKey, event.ctrlKey, event.altKey];\n}\n\n/**\n * A {@link PointerDriver} which listens for pointer events from HTML DOM\n * elements. Each HTML DOM element is bound to a specific root, which synergizes\n * well with DOMRoot.\n *\n * @category Driver\n */\nexport class DOMPointerDriver extends PointerDriver {\n    /** The HTML DOM element and listeners that each root is bound to */\n    private domElems: WeakMap<Root, DOMPointerDriverBind> = new WeakMap();\n    /** The mapping between each DOM pointer ID and canvas-ui pointer ID */\n    private pointers: Map<number, number> = new Map();\n    /**\n     * The pointer ID of the mouse. Registered in constructor. This is needed\n     * due to wheel events not being part of the DOM PointerEvent interface and\n     * therefore not having a pointerID field. This is also safe because there\n     * can only be one mouse.\n     */\n    private mousePointerID: number;\n\n    /**\n     * Create a new DOMPointerDriver.\n     *\n     * Automatically registers a pointer to be used by the mouse.\n     */\n    constructor() {\n        super();\n\n        this.mousePointerID = this.registerPointer(false);\n    }\n\n    /**\n     * Bind an HTML DOM element to a specific root.\n     *\n     * If the root was already bound,\n     * {@link DOMPointerDriver#removeListeners} is called, replacing the old\n     * listeners. Populates {@link DOMPointerDriver#domElems} with the new bind.\n     * Calls {@link DOMPointerDriver#addListeners} if root is enabled.\n     */\n    bindDOMElem(root: Root, domElem: HTMLElement): void {\n        let rootBind = this.domElems.get(root);\n        if(rootBind !== undefined) {\n            console.warn(Msg.DOM_DRIVER_REBIND);\n            this.removeListeners(rootBind);\n        }\n        else {\n            rootBind = <DOMPointerDriverBind>{\n                domElem,\n                pointerListen: null,\n                pointerleaveListen: null,\n                wheelListen: null,\n                contextMenuListen: null,\n            };\n            this.domElems.set(root, rootBind);\n            domElem.style.touchAction = 'none';\n        }\n\n        if(root.enabled)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Unbind a HTML DOM element from this pointer driver that is bound to a\n     * given Root. Removes all used listeners.\n     */\n    unbindDOMElem(root: Root): void {\n        const rootBind = this.domElems.get(root);\n        if(rootBind === undefined)\n            return;\n\n        this.removeListeners(rootBind);\n        this.domElems.delete(root);\n    }\n\n    /**\n     * Get the canvas-ui pointer ID of a given event. If the event has a pointer\n     * which hasn't been registered yet, then it is registered automatically\n     */\n    private getPointerID(event: PointerEvent): number {\n        let pointerID = this.pointers.get(event.pointerId);\n\n        if(pointerID === undefined) {\n            const isMouse = event.pointerType === 'mouse';\n            if(isMouse)\n                pointerID = this.mousePointerID;\n            else\n                pointerID = this.registerPointer(true);\n\n            this.pointers.set(event.pointerId, pointerID);\n        }\n\n        return pointerID;\n    }\n\n    /** Add pointer event listeners to root's DOM element. */\n    private addListeners(root: Root, rootBind: DOMPointerDriverBind): void {\n        // Make listeners for mouse events, queueing events. Add them to the\n        // root DOM bind so they can be removed later when needed\n        const domElem = rootBind.domElem;\n        if(rootBind.pointerListen === null) {\n            rootBind.pointerListen = (event: PointerEvent) => {\n                this.movePointer(\n                    root, this.getPointerID(event),\n                    ...getPointerEventNormPos(event, domElem),\n                    event.buttons,\n                    ...unpackModifiers(event),\n                );\n            }\n\n            domElem.addEventListener('pointermove', rootBind.pointerListen);\n            domElem.addEventListener('pointerdown', rootBind.pointerListen);\n            domElem.addEventListener('pointerup', rootBind.pointerListen);\n        }\n\n        if(rootBind.pointerleaveListen === null) {\n            rootBind.pointerleaveListen = (event: PointerEvent) => {\n                this.leavePointer(root, this.getPointerID(event));\n            }\n\n            domElem.addEventListener('pointerleave', rootBind.pointerleaveListen);\n        }\n\n        if(rootBind.wheelListen === null) {\n            rootBind.wheelListen = (event: WheelEvent) => {\n                const deltaMode = parseDOMDeltaMode(event.deltaMode);\n                if(deltaMode === null)\n                    return;\n\n                this.wheelPointer(\n                    root, this.mousePointerID,\n                    ...getPointerEventNormPos(event, domElem),\n                    event.deltaX, event.deltaY, event.deltaZ, deltaMode,\n                    ...unpackModifiers(event),\n                );\n\n                event.preventDefault();\n            }\n\n            domElem.addEventListener('wheel', rootBind.wheelListen, { passive: false });\n        }\n\n        if(rootBind.contextMenuListen === null) {\n            rootBind.contextMenuListen = (event: MouseEvent) => {\n                // Prevent right-click from opening context menu\n                event.preventDefault();\n            }\n\n            domElem.addEventListener('contextmenu', rootBind.contextMenuListen);\n        }\n    }\n\n    /**\n     * Remove pointer event listeners from root's DOM element and unset tracked\n     * listeners in root's bind.\n     */\n    private removeListeners(rootBind: DOMPointerDriverBind): void {\n        if(rootBind.pointerListen !== null) {\n            rootBind.domElem.removeEventListener('pointermove', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerdown', rootBind.pointerListen);\n            rootBind.domElem.removeEventListener('pointerup', rootBind.pointerListen);\n            rootBind.pointerListen = null;\n        }\n        if(rootBind.pointerleaveListen !== null) {\n            rootBind.domElem.removeEventListener('pointerleave', rootBind.pointerleaveListen);\n            rootBind.pointerleaveListen = null;\n        }\n        if(rootBind.wheelListen !== null) {\n            rootBind.domElem.removeEventListener('wheel', rootBind.wheelListen);\n            rootBind.wheelListen = null;\n        }\n        if(rootBind.contextMenuListen !== null) {\n            rootBind.domElem.removeEventListener('contextmenu', rootBind.contextMenuListen);\n            rootBind.contextMenuListen = null;\n        }\n    }\n\n    /**\n     * Calls {@link PointerDriver#onEnable} and\n     * {@link DOMPointerDriver#addListeners} to each bound root.\n     */\n    override onEnable(root: Root): void {\n        super.onEnable(root);\n\n        // Add event listeners for pointer when root is enabled, if the root is\n        // bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(rootBind !== undefined)\n            this.addListeners(root, rootBind);\n    }\n\n    /**\n     * Calls {@link PointerDriver#onDisable} and\n     * {@link DOMPointerDriver#removeListeners} to each bound root.\n     */\n    override onDisable(root: Root): void {\n        super.onDisable(root);\n\n        // Remove event listeners for pointer when root is disabled, if the root\n        // is bound to a DOM element\n        const rootBind = this.domElems.get(root);\n        if(rootBind !== undefined)\n            this.removeListeners(rootBind);\n    }\n}", "import type { RayPointerSource } from './RayPointerSource';\nimport type { PointerHint } from './PointerHint';\nimport { PointerDriver } from './PointerDriver';\nimport { Root } from '../core/Root';\n\n/**\n * A {@link PointerDriver} which gets pointer events from raycasts in a 3D\n * engine's world. This is an abstract class and must be implemented. For an\n * example, see\n * [canvas-ui-three](https://github.com/rafern/canvas-ui-three)'s\n * ThreeRayPointerDriver implementation.\n *\n * @category Driver\n */\nexport abstract class RayPointerDriver extends PointerDriver {\n    /** The sources which this is assigned to */\n    protected readonly sources: Set<RayPointerSource> = new Set();\n\n    /**\n     * Cast a ray in the world and get which root was intersected and where.\n     *\n     * @param origin - The world position where the ray is starting\n     * @param direction - A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @returns Returns a 3-tuple containing, in this order, the intersected root or null if none intersected, the normalised x axis of the intersection and the normalised y axis of the intersection. If no root was intersected, use bogus values for x and y\n     */\n    abstract castRay(origin: [number, number, number], direction: [number, number, number]): [Root | null, number, number];\n\n    /**\n     * Receive a ray from a {@link RayPointerSource}.\n     *\n     * @param pointer - The source's pointer ID, given when setting the source's sink\n     * @param pressing - Is the pointer pressed? If null, then the last pressing state will be used. A bitmask where each set bit represents a different button being pressed\n     * @param origin - The world position where the ray is starting\n     * @param direction - A normalised vector representing the ray's direction. Not a euler rotation nor a quaternion\n     * @param shift - Is shift being pressed?\n     * @param ctrl - Is control being pressed?\n     * @param alt - Is alt being pressed?\n     */\n    handlePointerRay(pointer: number, pressing: number | null, origin: [number, number, number], direction: [number, number, number], shift: boolean, ctrl: boolean, alt: boolean): void {\n        // Cast a ray and get the root that intersects with the ray and the\n        // intersection coordinates\n        const [root, xNorm, yNorm] = this.castRay(origin, direction);\n\n        // Queue a leave event if no root intersected, else, queue a move event\n        if(root === null)\n            this.leaveAnyPointer(pointer);\n        else\n            this.movePointer(root, pointer, xNorm, yNorm, pressing, shift, ctrl, alt);\n    }\n\n    /** Add a source. Assigns itself to the given source. */\n    addSource(source: RayPointerSource): void {\n        if(!this.sources.has(source)) {\n            source.setRayPointerDriver(this);\n            this.sources.add(source);\n        }\n    }\n\n    protected override setPointerHint(pointer: number, hint: PointerHint): boolean {\n        const changed = super.setPointerHint(pointer, hint);\n\n        // Call onPointerHintChanged handler for each source\n        for(const source of this.sources)\n            source.onPointerHintChanged(pointer, hint);\n\n        return changed;\n\n    }\n}\n", "/**\n * A callback used for when a {@link Variable} has its value changed.\n *\n * @category State Management\n */\nexport type VariableCallback<V> = (value?: V, variable?: Variable<V>) => void;\n\n/**\n * An aggregate helper class for widgets that contain a variable with a\n * specified type which is intended to be controlled by the user.\n *\n * Useful for implementing widgets such as sliders, checkboxes, text input,\n * etc...\n *\n * @typeParam V - The type of {@link Variable#value}.\n * @typeParam C - The type of a callback function. Should not be passed manually.\n *\n * @category State Management\n */\nexport class Variable<V, C extends CallableFunction = VariableCallback<V>> {\n    /** The current value, for internal use. */\n    private _value: V;\n    /** The function callbacks called when the value is changed */\n    private callbacks: Set<C> = new Set();\n\n    /**\n     * Create a new Variable.\n     *\n     * @param initialValue - The initial value of this variable. Sets {@link Variable#_value}.\n     * @param callback - A callback for when the variable changes. Equivalent to calling {@link Variable#watch} after creating the variable, but allows for variables to created inline.\n     * @param callNow - If true, the callback will be called once immediately after it's registered, unless the callback is already registered. Doesn't apply if no callback was passed.\n     */\n    constructor(initialValue: V, callback?: C, callNow = true) {\n        this._value = initialValue;\n\n        if(callback)\n            this.watch(callback, callNow);\n    }\n\n    /**\n     * The current value.\n     *\n     * If setting, {@link Variable#setValue} is called.\n     */\n    get value(): V {\n        return this._value;\n    }\n\n    set value(value: V) {\n        this.setValue(value);\n    }\n\n    /** Check if a callback is registered to this variable. */\n    hasCallback(callback: C): boolean {\n        return this.callbacks.has(callback);\n    }\n\n    /**\n     * Register a callback to this variable. When the value is changed, the\n     * callback will be called.\n     *\n     * @param callNow - If true, the callback will be called once immediately after it's registered, unless the callback is already registered.\n     */\n    watch(callback: C, callNow = true): boolean {\n        if(this.hasCallback(callback))\n            return false;\n\n        this.callbacks.add(callback);\n\n        if(callNow)\n            this.doCallback(callback);\n\n        return true;\n    }\n\n    /** Unregister a previously registered callback from this variable. */\n    unwatch(callback: C): boolean {\n        return this.callbacks.delete(callback);\n    }\n\n    /**\n     * Sets {@link Variable#_value}. Does nothing if the value is already the\n     * one specified.\n     *\n     * @param notify - If true, then the {@link Variable#callbacks} are called.\n     * @returns Returns true if the value was changed, false if not\n     */\n    setValue(value: V, notify = true): boolean {\n        if(this._value === value)\n            return false;\n\n        this._value = value;\n\n        if(notify) {\n            for(const callback of this.callbacks)\n                this.doCallback(callback);\n        }\n\n        return true;\n    }\n\n    protected doCallback(callback: C): void {\n        try {\n            callback(this._value, this);\n        }\n        catch(e) {\n            console.error('Exception in Variable callback:', e);\n        }\n    }\n}\n", "import { Variable } from \"./Variable\";\n\n/**\n * An input validator. A function which checks whether an input is valid and\n * transforms that input.\n *\n * @returns Returns a tuple containing whether the input is valid and the transformed input. Note that if the input is not valid, then the transformed input will be a bogus value.\n * @typeParam U - The type of the input.\n * @typeParam V - The type of the output (the transformed input).\n *\n * @category State Management\n */\nexport type Validator<U, V> = (value: U) => [true, V] | [false, unknown];\n\n/**\n * A callback used for when a {@link ValidatedVariable} has its value changed.\n * Functionally equivalent to {@link VariableCallback}; only used for type\n * correctness.\n *\n * @category State Management\n */\nexport type ValidatedVariableCallback<V, T> = (value?: V, variable?: ValidatedVariable<V, T>) => void;\n\n/**\n * Similar to {@link Variable}, except the variable's value can optionally be\n * validated by a {@link Validator | validator function}.\n *\n * @typeParam V - The type of {@link Variable#value}.\n * @typeParam T - The transformed type of a {@link ValidatedVariable#validValue | valid value}.\n *\n * @category State Management\n */\nexport class ValidatedVariable<V, T = V, C extends CallableFunction = ValidatedVariableCallback<V, T>> extends Variable<V, C> {\n    /** See {@link ValidatedVariable#valid}. For internal use only */\n    private _valid = true;\n    /** See {@link ValidatedVariable#validValue}. For internal use only */\n    private _validValue?: T;\n    /**\n     * The validator/transformer used for this variable's value. If null, then\n     * the value will always be valid and {@link ValidatedVariable#validValue}\n     * will be equal to {@link Variable#value}.\n     */\n    readonly validator: Validator<V, T> | null;\n\n    constructor(initialValue: V, validator: Validator<V, T> | null = null, callback?: C, callNow = true) {\n        super(initialValue, callback, false);\n\n        this.validator = validator;\n        this.validate(initialValue);\n\n        if(callback && callNow)\n            this.doCallback(callback);\n    }\n\n    /** If true, then the current value is valid. */\n    get valid() {\n        return this._valid;\n    }\n\n    /**\n     * The last valid value. If there was never a valid value, `undefined` is\n     * returned.\n     */\n    get validValue(): T {\n        return this._validValue as T;\n    }\n\n    override setValue(value: V, notify = true): boolean {\n        if(this.value === value)\n            return false;\n\n        this.validate(value);\n\n        return super.setValue(value, notify);\n    }\n\n    private validate(value: V): void {\n        if(this.validator) {\n            const [valid, validValueCandidate] = this.validator(value);\n            // XXX _valid is set in two stages so the type system knows whether\n            // valid is true or false\n            this._valid = valid;\n\n            if(valid)\n                this._validValue = validValueCandidate;\n        }\n    }\n}\n", "import { FillStyle } from './FillStyle';\nimport { Theme } from './Theme';\n\n/**\n * A theme which always gives out a random canvas fill colour. Used for\n * debugging when painting occurs. Has no properties but always has a fallback\n * theme.\n *\n * @category Theme\n */\nexport class DebugTheme extends Theme {\n    /**\n     * Create a new DebugTheme instance.\n     *\n     * @param fallback - The actual theme to use. Canvas fill color will be ignored as it is randomly generated. If none supplied, then the default theme found in {@link (Theme:constructor)} is used\n     */\n    constructor(fallback: Theme = new Theme()) {\n        super(undefined, fallback);\n    }\n\n    override get canvasFill(): FillStyle {\n        return '#' + Math.floor(Math.random() * 0xffffff).toString(16);\n    }\n\n    override set canvasFill(value: FillStyle | undefined) {\n        super.canvasFill = value;\n    }\n}\n", "import type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as an alt key; toggles\n * {@link KeyContext#alt} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class AltKey extends VirtualKey {\n    /** Create a new AltKey. */\n    constructor(keyContext: KeyContext, minWidth = 42, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            'Alt',\n            () => {\n                keyContext.alt = !keyContext.alt;\n                this.child.forced = keyContext.alt;\n                keyContext.callback('Alt');\n            },\n            minWidth,\n            minHeight,\n            properties,\n        );\n\n        this.child.forced = keyContext.alt;\n    }\n}\n", "import type { WidgetProperties } from '../Widget';\nimport type { KeyContext } from './KeyContext';\nimport { VirtualKey } from './VirtualKey';\n\n/**\n * A {@link VirtualKey} which acts as a control key; toggles\n * {@link KeyContext#ctrl} on click.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class ControlKey extends VirtualKey {\n    /** Create a new ControlKey. */\n    constructor(keyContext: KeyContext, minWidth = 42, minHeight = 24, properties?: Readonly<WidgetProperties>) {\n        super(\n            'Ctrl',\n            () => {\n                keyContext.ctrl = !keyContext.ctrl;\n                this.child.forced = keyContext.ctrl;\n                keyContext.callback('Control');\n            },\n            minWidth,\n            minHeight,\n            properties,\n        );\n\n        this.child.forced = keyContext.ctrl;\n    }\n}\n", "/**\n * An axis coupling mode is a mode that is applied to a {@link ViewportWidget}\n * on a per-axis basis. The mode controls how a ViewportWidget's axis length\n * relates to a ViewportWidget child's axis length.\n *\n * If two axes are not coupled, then they do not affect each other's length in\n * any way. If two axes are bi-directionally coupled, then they will always have\n * the same length. If two axes are uni-directionally coupled, then one axis\n * will affect the length of another axis, but not the other way around.\n *\n * @category Widget\n */\nexport enum AxisCoupling {\n    /**\n     * Doesn't couple a {@link ViewportWidget}'s axis to its child; the\n     * viewport's axis length is completely separate from the child's axis\n     * length.\n     *\n     * Default axis coupling mode for ViewportWidget.\n     */\n    None,\n    /**\n     * Bi-directional coupling. The {@link ViewportWidget}'s axis will be equal\n     * to its child's axis. Use this if the axis being tied isn't meant to be\n     * scrollable.\n     */\n    Bi,\n    /**\n     * Uni-directional coupling. The {@link ViewportWidget}'s axis will be\n     * resolved as a regular Widget, but the result will be transferred to the\n     * child's minimum axis length constraint.\n     *\n     * Default axis coupling mode for {@link TextArea}.\n     */\n    Uni,\n}\n", "import type { Widget, WidgetProperties } from './Widget';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport type { Padding } from '../theme/Padding';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\n\n/**\n * A {@link Container} with center alignment on both axes and no padding by\n * default.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class Center<W extends Widget = Widget> extends Container<W> {\n    /** Create a new Center. */\n    constructor(child: W, properties?: Readonly<WidgetProperties>) {\n        properties = {\n            containerAlignment: <Alignment2D>{\n                horizontal: Alignment.Center, vertical: Alignment.Center,\n            },\n            containerPadding: <Padding>{\n                left: 0, right: 0, top: 0, bottom: 0,\n            },\n            ...properties\n        };\n\n        super(child, properties);\n    }\n}\n", "import { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport { Widget, WidgetProperties } from './Widget';\nimport { ClickState } from '../helpers/ClickState';\nimport type { FocusType } from '../core/FocusType';\nimport type { Viewport } from '../core/Viewport';\nimport type { Event } from '../events/Event';\nimport { Variable } from '../state/Variable';\nimport type { Root } from '../core/Root';\n\n/**\n * A checkbox widget; can be ticked or unticked.\n *\n * @category Widget\n */\nexport class Checkbox extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /** The helper for keeping track of the checkbox value */\n    readonly variable: Variable<boolean>;\n    /** The callback used for the {@link Checkbox#\"variable\"} */\n    private readonly callback: () => void;\n\n    /**\n     * Create a new Checkbox.\n     *\n     * @param variable - The {@link Variable} where the value will be stored.\n     */\n    constructor(variable: Variable<boolean> = new Variable(false), properties?: Readonly<WidgetProperties>) {\n        // Checkboxes need a clear background, have no children and don't\n        // propagate events\n        super(true, false, properties);\n\n        this.tabFocusable = true;\n        this.variable = variable;\n        this.callback = this.handleChange.bind(this);\n        this.clickHelper = new ButtonClickHelper(this);\n    }\n\n    protected handleChange(): void {\n        this._dirty = true;\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n        this.variable.watch(this.callback);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n        this.variable.unwatch(this.callback);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'checkboxLength') {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundGlowFill' ||\n                property === 'backgroundFill' ||\n                property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'checkboxInnerPadding')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /** Is the checkbox checked? */\n    set checked(checked: boolean) {\n        this.variable.value = checked;\n    }\n\n    get checked(): boolean {\n        return this.variable.value;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(this.clickHelper.onFocusGrabbed(focusType))\n            this._dirty = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(this.clickHelper.onFocusDropped(focusType))\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        const x = this.idealX + this.offsetX;\n        const y = this.idealY + this.offsetY;\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event,\n            this.root,\n            true,\n            [x, x + this.actualLength, y, y + this.actualLength]\n        );\n\n        // Swap value if checkbox was clicked\n        if(wasClick)\n            this.checked = !this.checked;\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect). Toggle value if clicked\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return capture ? this : null;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve width and height\n        const minLength = Math.min(this.checkboxLength, maxWidth, maxHeight);\n        this.idealWidth = minLength;\n        this.idealHeight = minLength;\n\n        if(this.idealWidth < minWidth)\n            this.idealWidth = minWidth;\n        if(this.idealHeight < minHeight)\n            this.idealHeight = minHeight;\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // Center checkbox\n        this.actualLength = Math.min(this.checkboxLength, this.width, this.height);\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of checkbox\n        const ctx = this.viewport.context;\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n\n        const checkboxX = this.offsetX + this.x;\n        const checkboxY = this.offsetY + this.y;\n        ctx.fillRect(\n            checkboxX, checkboxY, this.actualLength, this.actualLength,\n        );\n\n        // Draw checked part of checkbox\n        if(this.checked) {\n            if(useGlow)\n                ctx.fillStyle = this.accentFill;\n            else\n                ctx.fillStyle = this.primaryFill;\n\n            const innerPadding = this.checkboxInnerPadding;\n            const innerLength = this.actualLength - innerPadding * 2;\n\n            // Fall back to filling entire checkbox if there isn't enough space\n            // for padding\n            if(innerLength <= 0) {\n                ctx.fillRect(\n                    checkboxX,\n                    checkboxY,\n                    this.actualLength,\n                    this.actualLength,\n                );\n            }\n            else {\n                ctx.fillRect(\n                    checkboxX + innerPadding,\n                    checkboxY + innerPadding,\n                    innerLength,\n                    innerLength,\n                );\n            }\n        }\n    }\n}\n", "import { paintField, layoutField, paintLayoutArrayField } from '../decorators/FlagFields';\nimport { Widget, WidgetProperties } from './Widget';\nimport { DynMsg, Msg } from '../core/Strings';\nimport type { Rect } from '../helpers/Rect';\n\nconst videoRegex = /^.*\\.(webm|og[gv]|m(p4|4v|ov)|avi|qt)$/i;\n\n/**\n * The image fitting mode for {@link Icon} widgets; describes how an image is\n * transformed if its dimensions don't match the output dimensions.\n */\nexport enum IconFit {\n    /**\n     * The image will be scaled down or up such that at least an axis of the\n     * image has the same dimensions as the widget, and the entire image is\n     * visible, preserving the aspect ratio of the image. The default image\n     * fitting mode.\n     */\n    Contain,\n    /**\n     * Similar to {@link IconFit.Contain}, except parts of the image can be cut\n     * off so that all parts of the widget are covered by the image.\n     */\n    Cover,\n    /**\n     * The image will be forced to have the same size as the widget by\n     * stretching or squishing it.\n     */\n    Fill\n}\n\n/**\n * Optional Icon constructor properties.\n *\n * @category Widget\n */\nexport interface IconProperties extends WidgetProperties {\n    /** Sets {@link Icon#rotation}. */\n    rotation?: number,\n    /** Sets {@link Icon#viewBox}. */\n    viewBox?: Rect | null,\n    /** Sets {@link Icon#width}. */\n    width?: number | null,\n    /** Sets {@link Icon#height}. */\n    height?: number | null,\n    /** Sets {@link Icon#fit}. */\n    fit?: IconFit\n}\n\n/**\n * A widget which displays a given image.\n *\n * @category Widget\n */\nexport class Icon extends Widget {\n    /** The current image/video used by the icon. */\n    private _image: HTMLImageElement | HTMLVideoElement;\n    /**\n     * The last source that the current image was using. Used for tracking if\n     * the image source changed and if the image is fully loaded. Only used if\n     * image is not a video.\n     */\n    private lastSrc: string | null = null;\n    /**\n     * The current image rotation in radians.\n     *\n     * @decorator `@paintField`\n     */\n    @paintField\n    rotation = 0;\n    /**\n     * The view box of this Icon, useful if the image used for the icon is a\n     * spritesheet. If null, the entire image will be used.\n     *\n     * @decorator `@paintLayoutArrayField(true)`\n     */\n    @paintLayoutArrayField(true)\n    viewBox: Rect | null;\n    /**\n     * The wanted width. If null, the image's width will be used, taking\n     * {@link Icon#viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageWidth: number | null = null;\n    /**\n     * The wanted height. If null, the image's height will be used, taking\n     * {@link Icon#viewBox} into account.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    imageHeight: number | null = null;\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual image width. */\n    private actualWidth = 0;\n    /** Actual image height. */\n    private actualHeight = 0;\n    /**\n     * Listener for video loadedmetadata and canplay events. Saved so it can be\n     * removed when needed.\n     */\n    private loadedmetadataListener: ((event: Event) => void) | null = null;\n    /**\n     * Listener for video canplay event. Saved so it can be removed when needed.\n     */\n    private canplayListener: ((event: Event) => void) | null = null;\n    /**\n     * Used for requestVideoFrameCallback. If null, then callback is being done\n     * by setting _dirty to true every frame, which may be wasteful.\n     */\n    private frameCallback: ((now: DOMHighResTimeStamp, metadata: unknown /* VideoFrameMetadata */) => void) | null = null;\n    /**\n     * The {@link IconFit} mode to use when the image dimensions don't match the\n     * widget dimensions.\n     */\n    @paintField\n    fit: IconFit;\n\n    /** Create a new Icon. */\n    constructor(image: HTMLImageElement | HTMLVideoElement | string, properties?: Readonly<IconProperties>) {\n        // Icons need a clear background, have no children and don't propagate\n        // events\n        super(true, false, properties);\n\n        if(typeof image === 'string') {\n            if(videoRegex.test(image)) {\n                const videoElem = document.createElement('video');\n                videoElem.src = image;\n                // So that video poster shows. If you're passing your own video\n                // element then this won't be automatically set\n                videoElem.preload = 'auto';\n                image = videoElem;\n            }\n            else {\n                const imgElem = document.createElement('img');\n                imgElem.src = image;\n                image = imgElem;\n            }\n        }\n\n        this._image = image;\n        this.rotation = properties?.rotation ?? 0;\n        this.viewBox = properties?.viewBox ?? null;\n        this.imageWidth = properties?.width ?? null;\n        this.imageHeight = properties?.height ?? null;\n        this.fit = properties?.fit ?? IconFit.Contain;\n        this.setupVideoEvents();\n    }\n\n    /**\n     * Setup event listeners for video. Has no effect if {@link Icon#image} is\n     * not a video\n     */\n    private setupVideoEvents() {\n        if(this.image instanceof HTMLVideoElement) {\n            // Add event listeners\n            // loadedmetadata is so that we resize the widget when we know the\n            // video dimensions\n            this.loadedmetadataListener = _event => this._layoutDirty = true;\n            this.image.addEventListener('loadedmetadata', this.loadedmetadataListener);\n            // canplay is so that the first video frame is always displayed\n            this.canplayListener = _event => this._dirty = true;\n            this.image.addEventListener('canplay', this.canplayListener);\n\n            if('requestVideoFrameCallback' in this.image) {\n                console.warn(Msg.VIDEO_API_AVAILABLE);\n\n                const originalVideo = this.image;\n                this.frameCallback = (_now, _metadata) => {\n                    // Set dirty flag when a new frame is got so that it is\n                    // painted\n                    this._dirty = true;\n\n                    if(this.image === originalVideo && this.frameCallback !== null) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        (this.image as any).requestVideoFrameCallback(this.frameCallback);\n                    }\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (this.image as any).requestVideoFrameCallback(this.frameCallback)\n            }\n        }\n    }\n\n    /**\n     * The image or video used by this Icon.\n     *\n     * Sets {@link Icon#_image} if changed and sets {@link Icon#lastSrc} to null\n     * to mark the image as loading so that flickers are minimised.\n     *\n     * If getting, returns {@link Icon#_image}.\n     */\n    set image(image: HTMLImageElement | HTMLVideoElement) {\n        if(image !== this._image) {\n            if(this._image instanceof HTMLVideoElement) {\n                // Remove old event listeners in video. null checks aren't\n                // needed, but adding them anyways so that typescript doesn't\n                // complain\n                if(this.loadedmetadataListener !== null)\n                    this._image.removeEventListener('loadedmetadata', this.loadedmetadataListener);\n                if(this.canplayListener !== null)\n                    this._image.removeEventListener('canplay', this.canplayListener);\n            }\n\n            this._image = image;\n            this.lastSrc = null;\n            this.loadedmetadataListener = null;\n            this.canplayListener = null;\n            this.frameCallback = null;\n            this.setupVideoEvents();\n        }\n    }\n\n    get image(): HTMLImageElement | HTMLVideoElement {\n        return this._image;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Icons only needs to be re-drawn if image changed, which is tracked by\n        // the image setter, or if the source changed, but not if the icon isn't\n        // loaded yet. If this is a playing video, icon only needs to be\n        // re-drawn if video is playing\n        if(this._image instanceof HTMLVideoElement) {\n            if(!this._image.paused && this.frameCallback === null)\n                this._dirty = true;\n        }\n        else if(this._image?.src !== this.lastSrc && this._image?.complete) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Find dimensions\n        let wantedWidth = this.imageWidth;\n        if(wantedWidth === null) {\n            if(this.viewBox === null) {\n                if(this._image instanceof HTMLVideoElement)\n                    wantedWidth = this._image.videoWidth;\n                else\n                    wantedWidth = this._image.naturalWidth;\n            }\n            else\n                wantedWidth = this.viewBox[2];\n        }\n\n        this.idealWidth = Math.max(Math.min(wantedWidth, maxWidth), minWidth);\n\n        let wantedHeight = this.imageHeight;\n        if(wantedHeight === null) {\n            if(this.viewBox === null) {\n                if(this._image instanceof HTMLVideoElement)\n                    wantedHeight = this._image.videoHeight;\n                else\n                    wantedHeight = this._image.naturalHeight;\n            }\n            else\n                wantedHeight = this.viewBox[3];\n        }\n\n        this.idealHeight = Math.max(Math.min(wantedHeight, maxHeight), minHeight);\n\n        // Find offset and actual image dimensions (preserving aspect ratio)\n        switch(this.fit) {\n            case IconFit.Contain:\n            case IconFit.Cover:\n            {\n                const widthRatio = this.idealWidth / wantedWidth;\n                const heightRatio = this.idealHeight / wantedHeight;\n                let scale;\n\n                if(this.fit === IconFit.Contain)\n                    scale = Math.min(widthRatio, heightRatio);\n                else\n                    scale = Math.max(widthRatio, heightRatio);\n\n                this.actualWidth = wantedWidth * scale;\n                this.actualHeight = wantedHeight * scale;\n                this.offsetX = (this.idealWidth - this.actualWidth) / 2;\n                this.offsetY = (this.idealHeight - this.actualHeight) / 2;\n                break;\n            }\n            case IconFit.Fill:\n                this.actualWidth = this.idealWidth;\n                this.actualHeight = this.idealHeight;\n                this.offsetX = 0;\n                this.offsetY = 0;\n                break;\n            default:\n                throw new Error(DynMsg.INVALID_ENUM(this.fit, 'IconFit', 'fit'));\n        }\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Abort if icon isn't ready yet\n        if(this._image instanceof HTMLImageElement && !this._image?.complete) {\n            this.lastSrc = null;\n            return;\n        }\n\n        // Mark as not needing to be drawn by setting the source\n        this.lastSrc = this._image.src;\n\n        // Translate, rotate and clip if rotation is not 0\n        let tdx = this.x + this.offsetX, tdy = this.y + this.offsetY;\n        const rotated = this.rotation !== 0;\n        const needsClip = rotated || this.fit === IconFit.Cover;\n        const ctx = this.viewport.context;\n        if(needsClip) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(this.x, this.y, this.width, this.height);\n            ctx.clip();\n\n            if(rotated) {\n                ctx.translate(\n                    this.x + this.offsetX + this.actualWidth / 2,\n                    this.y + this.offsetY + this.actualHeight / 2,\n                );\n                tdx = -this.actualWidth / 2;\n                tdy = -this.actualHeight / 2;\n                ctx.rotate(this.rotation);\n            }\n        }\n\n        // Draw image, with viewBox if it is not null\n        if(this.viewBox === null) {\n            ctx.drawImage(\n                this._image,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n        else {\n            ctx.drawImage(\n                this._image, ...this.viewBox,\n                tdx, tdy, this.actualWidth, this.actualHeight,\n            );\n        }\n\n        // Revert transformation\n        if(needsClip)\n            ctx.restore();\n    }\n\n    override dryPaint(): void {\n        if(this._image instanceof HTMLImageElement && this._image?.complete)\n            this.lastSrc = this._image.src;\n        else\n            this.lastSrc = null;\n\n        super.dryPaint();\n    }\n}\n", "import { Icon, IconProperties } from './Icon';\nimport { Button } from './Button';\n\n/**\n * A {@link Button} with an {@link Icon}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class IconButton extends Button<Icon> {\n    /** Create a new IconButton. */\n    constructor(image: HTMLImageElement, callback: (() => void) | null, properties?: Readonly<IconProperties>) {\n        super(\n            new Icon(image, properties),\n            callback, properties\n        );\n    }\n}\n", "import { Widget, WidgetProperties } from './Widget';\n\n/**\n * Optional TextInput constructor properties.\n *\n * @category Widget\n */\nexport interface SpacingProperties extends WidgetProperties {\n    /** Sets {@link Spacing#minWidth}. */\n    minWidth?: number,\n    /** Sets {@link Spacing#minHeight}. */\n    minHeight?: number\n}\n\n/**\n * A widget with empty space.\n *\n * Will always try to expand if the layout is constrained, so make sure to set\n * flex or pass it along the constructor\n *\n * @category Widget\n */\nexport class Spacing extends Widget {\n    /** The minimum width this will try to expand */\n    minWidth: number;\n    /** The minimum height this will try to expand */\n    minHeight: number;\n\n    /** Create a new Spacing. */\n    constructor(properties?: Readonly<SpacingProperties>) {\n        // default properties\n        properties = {\n            flex: 1,\n            ...properties\n        };\n\n        // Spacing needs clear, never has children and doesn't propagate events\n        super(true, false, properties);\n\n        this.minWidth = properties?.minWidth ?? 0;\n        this.minHeight = properties?.minHeight ?? 0;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Try to expand each axis. If axis is not constrained (can't expand),\n        // then try to use the biggest minimum length\n        if(maxWidth !== Infinity)\n            this.idealWidth = maxWidth;\n        else\n            this.idealWidth = Math.max(minWidth, this.minWidth);\n\n        if(maxHeight !== Infinity)\n            this.idealHeight = maxHeight;\n        else\n            this.idealHeight = Math.max(minHeight, this.minHeight);\n    }\n}\n", "import { Spacing, SpacingProperties } from './Spacing';\nimport type { Variable } from '../state/Variable';\nimport { Label, LabelProperties } from './Label';\nimport { Checkbox } from './Checkbox';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a {@link Checkbox}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class LabelledCheckbox extends Row {\n    constructor(text: string, variable?: Variable<boolean>, properties?: Readonly<LabelProperties & SpacingProperties>) {\n        super(properties);\n\n        this.add([\n            new Label(text, properties),\n            new Spacing(properties),\n            new Checkbox(variable, properties),\n        ]);\n    }\n}\n", "import { ButtonClickHelper } from '../helpers/ButtonClickHelper';\nimport { Widget, WidgetProperties } from './Widget';\nimport { ClickState } from '../helpers/ClickState';\nimport type { FocusType } from '../core/FocusType';\nimport type { Variable } from '../state/Variable';\nimport type { Viewport } from '../core/Viewport';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\n\n/**\n * A radio button widget; used for selecting one of many options. Uses a shared\n * {@link Variable} instance and expects the creation of multiple RadioButton\n * instances.\n *\n * @typeParam V - The type stored in the {@link RadioButton#\"variable\"}; when a radio button is clicked, the value inside the variable has this type.\n *\n * @category Widget\n */\nexport class RadioButton<V> extends Widget {\n    /** Horizontal offset. */\n    private offsetX = 0;\n    /** Vertical offset. */\n    private offsetY = 0;\n    /** Actual length after resolving layout. */\n    private actualLength = 0;\n    /** The helper used for handling pointer clicks and enter presses */\n    protected clickHelper: ButtonClickHelper;\n    /** The shared {@link Variable} where the value is set */\n    readonly variable: Variable<V>;\n    /**\n     * The value that will be used when the {@link RadioButton#\"variable\"} is\n     * set\n     */\n    protected value: V;\n    /** The callback used for the {@link RadioButton#\"variable\"} */\n    private readonly callback: () => void;\n    /** Was the radio button selected in the last paint? */\n    private _wasSelected = false;\n\n    /**\n     * Create a new radio button.\n     *\n     * @param variable - The shared variable that radio buttons will save the value to when selected.\n     * @param value - The value that will be used to set the {@link RadioButton#\"variable\"} when the radio button is clicked\n     */\n    constructor(variable: Variable<V>, value: V, properties?: Readonly<WidgetProperties>) {\n        // Radio buttons need a clear background, have no children and don't\n        // propagate events\n        super(true, false, properties);\n\n        this.tabFocusable = true;\n        this.variable = variable;\n        this.value = value;\n        this.clickHelper = new ButtonClickHelper(this);\n        this.callback = this.handleChange.bind(this);\n        this._wasSelected = this.selected;\n    }\n\n    protected handleChange(): void {\n        if(this.selected !== this._wasSelected)\n            this._dirty = true;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'radioButtonLength') {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundGlowFill' ||\n                property === 'backgroundFill' ||\n                property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'radioButtonInnerPadding')\n        {\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Select this radio button. Sets the value in\n     * {@link RadioButton#\"variable\"} to be {@link RadioButton#value}\n     */\n    select() {\n        this.variable.value = this.value;\n    }\n\n    /**\n     * Is the radio button selected? Equivalent to checking if the value in the\n     * {@link RadioButton#\"variable\"} is strictly equal to the\n     * {@link RadioButton#value}\n     */\n    get selected(): boolean {\n        return this.variable.value === this.value;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(this.clickHelper.onFocusGrabbed(focusType))\n            this._dirty = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(this.clickHelper.onFocusDropped(focusType))\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        const x = this.idealX + this.offsetX;\n        const y = this.idealY + this.offsetY;\n        const [wasClick, capture] = this.clickHelper.handleEvent(\n            event,\n            this.root,\n            true,\n            [x, x + this.actualLength, y, y + this.actualLength]\n        );\n\n        // Select radio button if button was clicked\n        if(wasClick)\n            this.select();\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect). Toggle value if clicked\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return capture ? this : null;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Resolve width and height\n        const minLength = Math.min(this.radioButtonLength, maxWidth, maxHeight);\n        this.idealWidth = minLength;\n        this.idealHeight = minLength;\n\n        if(this.idealWidth < minWidth)\n            this.idealWidth = minWidth;\n        if(this.idealHeight < minHeight)\n            this.idealHeight = minHeight;\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // Center checkbox\n        this.actualLength = Math.min(this.radioButtonLength, this.width, this.height);\n        this.offsetX = (this.width - this.actualLength) / 2;\n        this.offsetY = (this.height - this.actualLength) / 2;\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        this._wasSelected = this.selected;\n\n        // Should we use glow colours? (background glow and accent)\n        const useGlow = this.clickHelper.clickState === ClickState.Hover ||\n                        this.clickHelper.clickState === ClickState.Hold;\n\n        // Draw unchecked part of radio button\n        const ctx = this.viewport.context;\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n\n        const halfLength = this.actualLength / 2;\n        const radioX = this.offsetX + this.x + halfLength;\n        const radioY = this.offsetY + this.y + halfLength;\n        this.paintCircle(radioX, radioY, halfLength);\n\n        // Draw checked part of checkbox\n        if(this.selected) {\n            if(useGlow)\n                ctx.fillStyle = this.accentFill;\n            else\n                ctx.fillStyle = this.primaryFill;\n\n            const innerLength = this.actualLength - this.radioButtonInnerPadding * 2;\n\n            // Fall back to filling entire radio button if there isn't enough\n            // space for padding\n            if(innerLength <= 0)\n                this.paintCircle(radioX, radioY, halfLength);\n            else {\n                const halfInnerLength = innerLength / 2;\n                this.paintCircle(radioX, radioY, halfInnerLength);\n            }\n        }\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n        this.variable.watch(this.callback);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n        this.variable.unwatch(this.callback);\n    }\n}\n", "import { Spacing, SpacingProperties } from './Spacing';\nimport type { Variable } from '../state/Variable';\nimport { Label, LabelProperties } from './Label';\nimport { RadioButton } from './RadioButton';\nimport { Row } from './Row';\n\n/**\n * A {@link Row} with a {@link Label}, {@link Spacing} and a\n * {@link RadioButton}.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class LabelledRadioButton<V> extends Row {\n    constructor(text: string, variable: Variable<V>, value: V, properties?: Readonly<LabelProperties & SpacingProperties>) {\n        super(properties);\n\n        this.add([\n            new Label(text, properties),\n            new Spacing(properties),\n            new RadioButton(variable, value, properties),\n        ]);\n    }\n}\n", "import type { LayoutConstraints } from '../core/LayoutConstraints';\nimport { ClippedViewport } from '../core/ClippedViewport';\nimport { CanvasViewport } from '../core/CanvasViewport';\nimport { layoutField } from '../decorators/FlagFields';\nimport { AxisCoupling } from '../widgets/AxisCoupling';\nimport { Widget, WidgetProperties } from './Widget';\nimport type { Viewport } from '../core/Viewport';\nimport type { Bounds } from '../helpers/Bounds';\nimport { SingleParent } from './SingleParent';\nimport type { Event } from '../events/Event';\nimport type { Root } from '../core/Root';\nimport { DynMsg } from '../core/Strings';\n\n/**\n * Optional ViewportWidget constructor properties.\n *\n * @category Widget\n */\nexport interface ViewportWidgetProperties extends WidgetProperties {\n    /** Sets {@link ViewportWidget#widthCoupling}. */\n    widthCoupling?: AxisCoupling,\n    /** Sets {@link ViewportWidget#heightCoupling}. */\n    heightCoupling?: AxisCoupling,\n    /** Sets {@link ViewportWidget#minWidth}. */\n    minWidth?: number,\n    /** Sets {@link ViewportWidget#minHeight}. */\n    minHeight?: number,\n    /**\n     * If true, then the {@link ViewportWidget} will use a\n     * {@link CanvasViewport} instead of a {@link ClippedViewport}.\n     */\n    useCanvas?: boolean,\n    /** Sets {@link ViewportWidget#offset}. */\n    offset?: [number, number],\n    /** Sets {@link ViewportWidget#constraints}. */\n    constraints?: LayoutConstraints\n}\n\n// TODO finalizeBounds is called multiple times. this has no side-effects other\n// than being less efficient. note that finalizeBounds must be able to be called\n// multiple times, not just once per frame. this is because of canvas scaling\n// triggering a need for re-rounding dimensions and positions\n\n/**\n * A type of container widget which is allowed to be bigger or smaller than its\n * child.\n *\n * Can be constrained to a specific type of children.\n *\n * Allows setting the offset of the child, automatically clips it if neccessary.\n * Otherwise acts like a {@link Container}. Implemented by force re-painting the\n * child and clipping it or, optionally, by using a {@link Viewport} to paint\n * the child widget to a dedicated canvas.\n *\n * @category Widget\n */\nexport class ViewportWidget<W extends Widget = Widget> extends SingleParent<W> {\n    /** See {@link ViewportWidget#widthCoupling}. For internal use only */\n    private _widthCoupling: AxisCoupling;\n    /** See {@link ViewportWidget#heightCoupling}. For internal use only */\n    private _heightCoupling: AxisCoupling;\n    /**\n     * The minimum width that this widget will try to expand to.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minWidth: number;\n    /**\n     * The minimum height that this widget will try to expand to.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    minHeight: number;\n    /**\n     * The actual viewport object. Can be a {@link ClippedViewport} or a\n     * {@link CanvasViewport}.\n     */\n    protected readonly internalViewport: Viewport;\n    /**\n     * Is the internal viewport a {@link CanvasViewport} instance? If true, then\n     * the resolution of the {@link Root} will be inherited automatically.\n     */\n    readonly useCanvas: boolean;\n    /**\n     * Child constraints for resolving layout. May be different than\n     * {@link ViewportWidget#internalViewport}'s constraints. By default, this\n     * is 0 minimum and Infinity maximum per axis.\n     *\n     * Will be automatically scaled depending on the current {@link Root}'s\n     * resolution.\n     */\n    private _constraints: LayoutConstraints = [0, Infinity, 0, Infinity];\n    /** Force child re-paint? Only used when not using a Viewport */\n    protected forceRePaint = true;\n    /**\n     * The amount of horizontal space to reserve. By default, no space is\n     * reserved. Useful for situations where additional parts are needed around\n     * the viewport, such as scrollbars in {@link ScrollableViewportWidget}.\n     *\n     * Note that if scaling is being used, then these values are expected to\n     * already be scaled.\n     *\n     * Should be set before {@link ViewportWidget#handleResolveDimensions} is\n     * called.\n     */\n    protected reservedX = 0;\n    /** Similar to {@link ViewportWidget#reservedX}, but vertical. */\n    protected reservedY = 0;\n\n    /** Create a new ViewportWidget. */\n    constructor(child: W, properties?: Readonly<ViewportWidgetProperties>) {\n        // Viewport clears its own background, has a single child and propagates\n        // events\n        super(child, false, true, properties);\n\n        this.useCanvas = properties?.useCanvas ?? false;\n        if(this.useCanvas)\n            this.internalViewport = new CanvasViewport(child);\n        else\n            this.internalViewport = new ClippedViewport(child);\n\n        this.minWidth = properties?.minWidth ?? 0;\n        this.minHeight = properties?.minHeight ?? 0;\n        this._widthCoupling = properties?.widthCoupling ?? AxisCoupling.None;\n        this._heightCoupling = properties?.heightCoupling ?? AxisCoupling.None;\n        this._constraints = properties?.constraints ?? [0, Infinity, 0, Infinity];\n    }\n\n    /**\n     * Offset of {@link SingleParent#child}. Positional events will take this\n     * into account, as well as rendering. Useful for implementing scrolling.\n     */\n    get offset(): [number, number] {\n        return [...this.internalViewport.offset];\n    }\n\n    set offset(offset: [number, number]) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this.internalViewport.offset[0] !== offset[0] || this.internalViewport.offset[1] !== offset[1]) {\n            this.internalViewport.offset = [offset[0], offset[1]];\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Accessor for {@link ViewportWidget#_constraints}. Will also update the\n     * constraints of the {@link ViewportWidget#internalViewport | Viewport},\n     * but may be different due to {@link ViewportWidget#widthCoupling} or\n     * {@link ViewportWidget#heightCoupling}.\n     */\n    set constraints(constraints: LayoutConstraints) {\n        if (constraints[0] !== this._constraints[0] ||\n            constraints[1] !== this._constraints[1] ||\n            constraints[2] !== this._constraints[2] ||\n            constraints[3] !== this._constraints[3])\n        {\n            // Update own constraints\n            this._constraints[0] = constraints[0];\n            this._constraints[1] = constraints[1];\n            this._constraints[2] = constraints[2];\n            this._constraints[3] = constraints[3];\n\n            // Update viewport's constaints\n            this.internalViewport.constraints = constraints;\n        }\n    }\n\n    get constraints(): LayoutConstraints {\n        return [...this._constraints];\n    }\n\n    /**\n     * Is the width coupled to the child's? If not {@link AxisCoupling.None},\n     * width constraints will be ignored or augmented.\n     */\n    get widthCoupling(): AxisCoupling {\n        return this._widthCoupling;\n    }\n\n    set widthCoupling(widthCoupling: AxisCoupling) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._widthCoupling !== widthCoupling) {\n            this._widthCoupling = widthCoupling;\n            this._layoutDirty = true;\n        }\n    }\n\n    /**\n     * Is the height coupled to the child's? If not {@link AxisCoupling.None},\n     * height constraints will be ignored or augmented.\n     */\n    get heightCoupling(): AxisCoupling {\n        return this._heightCoupling;\n    }\n\n    set heightCoupling(heightCoupling: AxisCoupling) {\n        // Not using @paintArrayField so that accessor can be overridden\n        if(this._heightCoupling !== heightCoupling) {\n            this._heightCoupling = heightCoupling;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'canvasFill')\n            this._dirty = true;\n    }\n\n    protected getBoundsOf(widget: Widget): Bounds {\n        const [width, height] = widget.idealDimensions;\n        const [x, y] = widget.idealPosition;\n        const [childX, childY] = this.child.idealPosition;\n        const left = this.idealX + this.offset[0] + x - childX;\n        const top = this.idealY + this.offset[1] + y - childY;\n        return [ left, left + width, top, top + height ];\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        return this.internalViewport.dispatchEvent(event);\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Pre-layout update child\n        const child = this.child;\n        child.preLayoutUpdate();\n\n        // If child's layout is dirty, set self's layout as dirty\n        if(child.layoutDirty)\n            this._layoutDirty = true;\n\n        // Update viewport resolution if needed\n        if(this.useCanvas)\n            (this.internalViewport as CanvasViewport).resolution = this.root.resolution;\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Update viewport rect\n        this.internalViewport.rect = [this.x, this.y, this.width, this.height];\n\n        // Post-layout update child\n        const child = this.child;\n        child.postLayoutUpdate();\n\n        // If child is dirty, set self as dirty\n        if(child.dirty)\n            this._dirty = true;\n    }\n\n    /**\n     * Resolve the dimensions of the viewport widget, taking coupling modes and\n     * reserved space into account. Note that if space is reserved, then the\n     * resulting {@link ViewportWidget#idealWidth} and\n     * {@link ViewportWidget#idealHeight} will not include the reserved space.\n     * Child classes are expected to add the reserved space to the final\n     * dimensions themselves so that they can also be aware of the final\n     * non-reserved space.\n     */\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // reserve space\n        const rMaxWidth = Math.max(maxWidth - this.reservedX, 0);\n        const rMaxHeight = Math.max(maxHeight - this.reservedY, 0);\n        let effectiveMinWidth = Math.min(Math.max(minWidth, this.minWidth) - this.reservedX, rMaxWidth);\n        let effectiveMinHeight = Math.min(Math.max(minHeight, this.minHeight) - this.reservedY, rMaxHeight);\n\n        // Expand to the needed dimensions\n        if(this._widthCoupling !== AxisCoupling.Bi) {\n            this.idealWidth = effectiveMinWidth;\n\n            if(this._widthCoupling === AxisCoupling.Uni)\n                effectiveMinWidth = this.idealWidth;\n        }\n\n        if(this.idealWidth === 0 && this.minWidth === 0 && this._widthCoupling !== AxisCoupling.Bi)\n            console.warn(DynMsg.MAYBE_DIMENSIONLESS('width'));\n\n        if(this._heightCoupling !== AxisCoupling.Bi) {\n            this.idealHeight = effectiveMinHeight;\n\n            if(this._heightCoupling === AxisCoupling.Uni)\n                effectiveMinHeight = this.idealHeight;\n        }\n\n        if(this.idealHeight === 0 && this.minHeight === 0 && this._heightCoupling !== AxisCoupling.Bi)\n            console.warn(DynMsg.MAYBE_DIMENSIONLESS('height'));\n\n        // Resolve child's layout and handle coupling\n        const constraints: LayoutConstraints = [...this._constraints];\n\n        if(this._widthCoupling !== AxisCoupling.None) {\n            constraints[0] = effectiveMinWidth;\n\n            if(this._widthCoupling === AxisCoupling.Bi)\n                constraints[1] = rMaxWidth;\n        }\n\n        if(this._heightCoupling !== AxisCoupling.None) {\n            constraints[2] = effectiveMinHeight;\n\n            if(this._heightCoupling === AxisCoupling.Bi)\n                constraints[3] = rMaxHeight;\n        }\n\n        const child = this.child;\n        this.internalViewport.constraints = constraints;\n        this.internalViewport.resolveLayout();\n\n        // Bi-couple wanted axes. Do regular layout for non-coupled axes.\n        if(this._widthCoupling === AxisCoupling.Bi)\n            this.idealWidth = Math.max(0, child.idealDimensions[0]);\n\n        if(this._heightCoupling === AxisCoupling.Bi)\n            this.idealHeight = Math.max(0, child.idealDimensions[1]);\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        // HACK Parent#activate activates child widgets with this._viewport, but\n        // we want to use this.internalViewport\n        Widget.prototype.activate.call(this, root, viewport, parent);\n        this.internalViewport.parent = viewport;\n        this.child.activate(root, this.internalViewport, parent);\n    }\n\n    override deactivate(): void {\n        // unset parent viewport of internal viewport. using a clipped viewport\n        // after this will crash; make sure to only use the viewport if the\n        // widget is active\n        this.internalViewport.parent = null;\n        super.deactivate();\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Clear background and paint canvas\n        this.internalViewport.paint(forced || this.forceRePaint, this.canvasFill);\n        this.forceRePaint = false;\n    }\n}", "import { ViewportWidget, ViewportWidgetProperties } from './ViewportWidget';\nimport { AxisCoupling } from '../widgets/AxisCoupling';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { ClickHelper } from '../helpers/ClickHelper';\nimport { ClickState } from '../helpers/ClickState';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { AutoScroll } from '../events/AutoScroll';\nimport type { Bounds } from '../helpers/Bounds';\nimport type { Event } from '../events/Event';\nimport { Leave } from '../events/Leave';\nimport type { Widget } from './Widget';\nimport { Root } from '../core/Root';\n\n/**\n * The mode for how a scrollbar is shown in a {@link ScrollableViewportWidget}.\n *\n * @category Widget\n */\nexport enum ScrollbarMode {\n    /** The scrollbar is an overlay and therefore only shown when needed */\n    Overlay,\n    /** The scrollbar is part of the layout and therefore always shown */\n    Layout,\n    /** The scrollbar is hidden, but the content can still be scrolled */\n    Hidden,\n}\n\n/**\n * Optional ScrollableViewportWidget constructor properties.\n *\n * @category Widget\n */\nexport interface ScrollableViewportWidgetProperties extends ViewportWidgetProperties {\n    /** Sets {@link ScrollableViewportWidget#scrollbarMode}. */\n    scrollbarMode?: ScrollbarMode\n}\n\n/**\n * A wrapper for a {@link ViewportWidget} with scrollbars.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n */\nexport class ScrollableViewportWidget<W extends Widget = Widget> extends ViewportWidget<W> {\n    /**\n     * See {@link ScrollableViewportWidget#scrollbarMode}. For internal use only\n     */\n    private _scrollbarMode: ScrollbarMode;\n    /**\n     * The effective viewport width (ideal width not occupied by a non-overlay\n     * scrollbar), for scrollbar calculations. For internal use only.\n     */\n    private effectiveWidth = 0;\n    /**\n     * The effective viewport height (ideal height not occupied by a non-overlay\n     * scrollbar), for scrollbar calculations. For internal use only.\n     */\n    private effectiveHeight = 0;\n    /**\n     * ClickHelper used for checking if the horizontal scrollbar has been\n     * dragged\n     */\n    private horizontalClickHelper: ClickHelper;\n    /**\n     * ClickHelper used for checking if the vertical scrollbar has been dragged\n     */\n    private verticalClickHelper: ClickHelper;\n    /** Is the vertical scrollbar being dragged? If null, none is */\n    private verticalDragged: boolean | null = null;\n    /** What was the starting scroll value before dragging? */\n    private startingScroll = 0;\n    /** What was the normalised offset when starting drag? */\n    private startingOffset = 0;\n    /** When was the last scroll attempt in milliseconds since Unix epoch? */\n    private lastScroll = 0;\n    /** Was the horizontal scrollbar painted last frame? */\n    private horizWasPainted = false;\n    /** Was the vertical scrollbar painted last frame? */\n    private vertWasPainted = false;\n    /** The line height used for scrolling via wheel events. */\n    private _scrollLineHeight = 0;\n\n    /**\n     * Create a new ScrollableViewportWidget.\n     *\n     * If an axis is bi-coupled, that axis will not have a scrollbar.\n     */\n    constructor(child: W, properties?: Readonly<ScrollableViewportWidgetProperties>) {\n        super(child, properties);\n\n        this._scrollbarMode = properties?.scrollbarMode ?? ScrollbarMode.Overlay;\n        this.horizontalClickHelper = new ClickHelper(this);\n        this.verticalClickHelper = new ClickHelper(this);\n        this.updateScrollLineHeight();\n    }\n\n    /** The mode for how the scrollbar is shown. */\n    get scrollbarMode(): ScrollbarMode {\n        return this._scrollbarMode;\n    }\n\n    set scrollbarMode(scrollbarMode: ScrollbarMode) {\n        if(this._scrollbarMode !== scrollbarMode) {\n            const oldScroll = this.scroll;\n            this._scrollbarMode = scrollbarMode;\n            this.scroll = oldScroll;\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * Offset of {@link SingleParent#child}. Positional events will take this\n     * into account, as well as rendering. Unlike {@link ViewportWidget#offset},\n     * this will clamp to possible scroll values to avoid issues.\n     */\n    override get offset(): [number, number] {\n        return super.offset;\n    }\n\n    override set offset(offset: [number, number]) {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        super.offset = [\n            -Math.max(Math.min(-offset[0], childWidth - this.effectiveWidth), 0),\n            -Math.max(Math.min(-offset[1], childHeight - this.effectiveHeight), 0),\n        ];\n    }\n\n    override get widthCoupling(): AxisCoupling {\n        return super.widthCoupling;\n    }\n\n    override set widthCoupling(widthCoupling: AxisCoupling) {\n        const oldScroll = this.scroll;\n        super.widthCoupling = widthCoupling;\n        this.scroll = oldScroll;\n    }\n\n    override get heightCoupling(): AxisCoupling {\n        return super.heightCoupling;\n    }\n\n    override set heightCoupling(heightCoupling: AxisCoupling) {\n        const oldScroll = this.scroll;\n        super.heightCoupling = heightCoupling;\n        this.scroll = oldScroll;\n    }\n\n    /**\n     * The current scroll values. Similar to\n     * {@link ScrollableViewportWidget#offset}, but with normalised values (from\n     * 0 to 1).\n     */\n    get scroll(): [number, number] {\n        const [offsetX, offsetY] = this.offset;\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const diffX = childWidth - this.effectiveWidth;\n        const diffY = childHeight - this.effectiveHeight;\n        return [\n            diffX === 0 ? 0 : Math.min(Math.max(-offsetX / diffX, 0), 1),\n            diffY === 0 ? 0 : Math.min(Math.max(-offsetY / diffY, 0), 1),\n        ];\n    }\n\n    set scroll(scroll: [number, number]) {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        this.offset = [\n            -scroll[0] * (childWidth - this.effectiveWidth),\n            -scroll[1] * (childHeight - this.effectiveHeight),\n        ];\n    }\n\n    /** Get the ClickHelper of a scrollbar */\n    private getClickHelper(vertical: boolean): ClickHelper {\n        if(vertical)\n            return this.verticalClickHelper;\n        else\n            return this.horizontalClickHelper;\n    }\n\n    /**\n     * Handle a pointer/leave event for a given scrollbar.\n     *\n     * @returns Returns true if the event was captured\n     */\n    private handleEventScrollbar(vertical: boolean, corner: boolean, event: Event, root: Root): boolean {\n        // Abort if the other scrollbar is being dragged\n        if(this.verticalDragged !== null && this.verticalDragged !== vertical)\n            return false;\n\n        // Get click area of scrollbar. If in overlay mode, use the filled part\n        // of the scrollbar as the click area since there is no background\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const clickRect = overlay ? fillRect : bgRect;\n        const clickArea: [number, number, number, number] = [\n            clickRect[0],\n            clickRect[0] + clickRect[2],\n            clickRect[1],\n            clickRect[1] + clickRect[3],\n        ];\n\n        // Handle click event\n        const clickHelper = this.getClickHelper(vertical);\n        clickHelper.handleClickEvent(event, root, clickArea);\n\n        const clickState = clickHelper.clickState;\n        const stateChanged = clickHelper.clickStateChanged;\n        if(stateChanged)\n            this._dirty = true;\n\n        if(clickState === ClickState.Hold) {\n            // Abort if state is not valid, but grab the event\n            if(clickHelper.pointerPos === null || !(event instanceof PointerEvent))\n                return true;\n\n            const axisIndex = vertical ? 1 : 0;\n            const scroll = this.scroll;\n\n            // Skip check if in overlay mode; can only scroll by dragging in\n            // this mode\n            let inFilledArea = overlay;\n            if(!inFilledArea) {\n                inFilledArea = clickHelper.isPointInRect(\n                    event.x,\n                    event.y,\n                    fillRect[0],\n                    fillRect[0] + fillRect[2],\n                    fillRect[1],\n                    fillRect[1] + fillRect[3],\n                );\n            }\n\n            // Find offset along scrollbar. Necessary for overlay mode since\n            // pointerPos is relative to the fillRect in that case, not bgRect\n            let thisOffset;\n            if(overlay) {\n                thisOffset = clickHelper.getNormalInRect(\n                    event.x,\n                    event.y,\n                    bgRect[0],\n                    bgRect[0] + bgRect[2],\n                    bgRect[1],\n                    bgRect[1] + bgRect[3],\n                )[axisIndex];\n            }\n            else\n                thisOffset = clickHelper.pointerPos[axisIndex];\n\n            if(stateChanged) {\n                // If this was outside the filled area, snap scrollbar\n                if(!inFilledArea) {\n                    const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                    const childLength = this.child.idealDimensions[axisIndex];\n                    const barLength = viewportLength / childLength;\n                    scroll[axisIndex] = (thisOffset - barLength / 2) / (1 - barLength);\n                    this.scroll = scroll;\n                }\n\n                // Drag start, save current scroll and set this scrollbar as\n                // being dragged\n                this.startingOffset = thisOffset;\n                this.startingScroll = scroll[axisIndex];\n                this.verticalDragged = vertical;\n            }\n            else {\n                // Drag continue, scroll\n                const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n                const childLength = this.child.idealDimensions[axisIndex];\n                const barLength = viewportLength / childLength;\n                const dragDiff = thisOffset - this.startingOffset;\n                scroll[axisIndex] = this.startingScroll + dragDiff / (1 - barLength);\n                this.scroll = scroll;\n            }\n\n            return true;\n        }\n        else if(clickState === ClickState.Hover)\n            return true;\n        else if(stateChanged) {\n            // Release this scrollbar\n            this.verticalDragged = null;\n            return true;\n        }\n\n        return false;\n    }\n\n    /** Clamp offset in-place to valid scroll values. For internal use only. */\n    private clampOffset(offset: [number, number]): void {\n        const [childWidth, childHeight] = this.child.idealDimensions;\n\n        const minX = -(childWidth - this.effectiveWidth);\n        if(minX >= 0)\n            offset[0] = 0;\n        else if(offset[0] < minX)\n            offset[0] = minX;\n\n        const minY = -(childHeight - this.effectiveHeight);\n        if(minY >= 0)\n            offset[1] = 0;\n        else if(offset[1] < minY)\n            offset[1] = minY;\n    }\n\n    /**\n     * Handle a wheel scroll event. If scrolling fails due to being at the\n     * limit, this returns true if the last scroll attempt happened less than\n     * 200 milliseconds ago. This behaviour is disabled if\n     * {@link PointerWheel#fromDrag} is true.\n     *\n     * @returns Returns true if this changed scroll was successful\n     */\n    private handleWheelEvent(event: PointerWheel): boolean {\n        const offset = this.offset;\n        const [oldX, oldY] = offset;\n        const [dx, dy] = event.getDeltaPixels(true, this._scrollLineHeight, this.idealWidth, this.idealHeight);\n        offset[0] -= event.shift ? dy : dx;\n        offset[1] -= event.shift ? dx : dy;\n        this.clampOffset(offset);\n        this.offset = offset;\n        const [newX, newY] = this.offset;\n\n        const success = newX !== oldX || newY !== oldY;\n        const last = this.lastScroll;\n        const now = (new Date()).getTime();\n        this.lastScroll = now;\n\n        if(success)\n            return true;\n\n        if(event.fromDrag)\n            return false;\n\n        const elapsed = now - last;\n        return elapsed < 200;\n    }\n\n    protected updateScrollLineHeight(): void {\n        const textHelper = new TextHelper();\n        textHelper.font = this.bodyTextFont;\n        textHelper.lineHeight = this.bodyTextHeight;\n        textHelper.lineSpacing = this.bodyTextSpacing;\n        this._scrollLineHeight = textHelper.fullLineHeight;\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'bodyTextFont' ||\n                property === 'bodyTextHeight' ||\n                property === 'bodyTextSpacing')\n            this.updateScrollLineHeight();\n        else if(property === 'scrollBarThickness')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'backgroundFill' ||\n                property === 'scrollBarMinPercent' ||\n                property === 'scrollBarMinPixels' ||\n                property === 'primaryFill' ||\n                property === 'accentFill' ||\n                property === 'backgroundGlowFill')\n            this._dirty = true;\n    }\n\n    protected override handleEvent(event: Event): Widget | null {\n        // Try to drag a scrollbar if this is a pointer or leave event with no\n        // target or target on this. Don't do this if the scrollbars are hidden\n        const widthBiCoupled = this.widthCoupling === AxisCoupling.Bi;\n        const heightBiCoupled = this.heightCoupling === AxisCoupling.Bi;\n\n        if(this._scrollbarMode !== ScrollbarMode.Hidden &&\n           (event instanceof Leave || event instanceof PointerEvent) &&\n           (event.target === null || event.target === this)) {\n            const [childWidth, childHeight] = this.child.idealDimensions;\n            const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n            const forceCorner = !overlay && (!widthBiCoupled && !heightBiCoupled);\n            const xNeeded = childWidth > this.idealWidth;\n            const yNeeded = childHeight > this.idealHeight;\n\n            let grabbedEvent = false;\n\n            // Only handle event in scrollbar if the scrollbar is shown and\n            // needed (layout mode shows unneeded scrollbars)\n            if(!widthBiCoupled && (xNeeded || !overlay) &&\n               this.handleEventScrollbar(false, yNeeded || forceCorner, event, this.root))\n                grabbedEvent = true;\n\n            if(!heightBiCoupled && (yNeeded || !overlay) &&\n               this.handleEventScrollbar(true, xNeeded || forceCorner, event, this.root))\n                grabbedEvent = true;\n\n            // If the event was grabbed by either scrollbar, capture it\n            if(grabbedEvent) {\n                // If this is a wheel event, handle it\n                if(event instanceof PointerWheel)\n                    this.handleWheelEvent(event);\n\n                return this;\n            }\n        }\n\n        // Pass event along\n        const capturer = super.handleEvent(event);\n\n        // If this is an auto-scroll event and it's been captured, then scroll\n        // to the capturer's wanted bounds, make the event relative to this\n        // scrollable viewport and re-capture it\n        if(capturer !== null && event instanceof AutoScroll) {\n            const reserve = this._scrollbarMode === ScrollbarMode.Layout;\n            const reserveX = reserve && !heightBiCoupled;\n            const reserveY = reserve && !widthBiCoupled;\n            let clearWidth = this.effectiveWidth;\n            let clearHeight = this.effectiveHeight;\n\n            if(!reserveX || !reserveY) {\n                const thickness = this.scrollBarThickness;\n                const [childWidth, childHeight] = this.child.idealDimensions;\n                const xNeeded = childWidth > this.idealWidth;\n                const yNeeded = childHeight > this.idealHeight;\n                const paintX = this.scrollbarNeedsPaint(false, xNeeded);\n                const paintY = this.scrollbarNeedsPaint(true, yNeeded);\n\n                // XXX don't trim clear space if scrollbars are hidden\n                if(this._scrollbarMode !== ScrollbarMode.Hidden) {\n                    if(!reserveX && paintY)\n                        clearWidth = Math.max(0, clearWidth - thickness);\n                    if(!reserveY && paintX)\n                        clearHeight = Math.max(0, clearHeight - thickness);\n                }\n            }\n\n            let [cx, cy] = capturer.idealPosition;\n\n            // XXX if a viewport is being used, then the child's coordinates are\n            // relative to the viewport widget. convert coordinates so that they\n            // are relative to the viewport widget's parent viewport\n            let [offsetX, offsetY] = this.offset;\n            const oldOffX = offsetX, oldOffY = offsetY;\n            if(this.internalViewport.relativeCoordinates) {\n                cx += this.idealX + offsetX;\n                cy += this.idealY + offsetY;\n            }\n\n            let [cl, cr, ct, cb] = event.bounds;\n            cl += cx;\n            cr += cx;\n            ct += cy;\n            cb += cy;\n            const vpr = this.idealX + clearWidth;\n            const vpb = this.idealY + clearHeight;\n\n            // If a tab-selection event occurred, scroll so that widget that got\n            // selected is visible. Don't scroll if viewport is smaller than\n            // capturer and viewport is inside capturer. Don't scroll if\n            // capturer is smaller than viewport and capturer is inside viewport\n            const moveX = !widthBiCoupled && !(cl >= this.idealX && cr <= vpr) && !(this.idealX >= cl && vpr <= cr);\n            if(moveX) {\n                // If child rect is bigger than viewport, then align nearest\n                // child rect edge to farthest border of viewport\n                // If child rect is smaller than viewport, then align farthest\n                // child rect edge to nearest border of viewport\n                const rectBiggerThanViewport = cr - cl > clearWidth;\n                const rectBeforeViewport = cl < this.idealX;\n                const alignLeft = rectBiggerThanViewport !== rectBeforeViewport;\n                if(alignLeft)\n                    offsetX += this.idealX - cl;\n                else\n                    offsetX += vpr - cr;\n            }\n\n            const moveY = !heightBiCoupled && !(ct >= this.idealY && cb <= vpb) && !(this.idealY >= ct && vpb <= cb);\n            if(moveY) {\n                const rectBiggerThanViewport = cb - ct > clearHeight;\n                const rectBeforeViewport = ct < this.idealY;\n                const alignTop = rectBiggerThanViewport !== rectBeforeViewport;\n                if(alignTop)\n                    offsetY += this.idealY - ct;\n                else\n                    offsetY += vpb - cb;\n            }\n\n            if(moveX || moveY)\n                this.offset = [offsetX, offsetY];\n\n            // Correct event bounds to new offset\n            // XXX need to use getter instead of [offsetX, offsetY] because the\n            // setter clamps the values and therefore the offset may have\n            // changed\n            const [newOffX, newOffY] = this.offset;\n            const offDiffX = newOffX - oldOffX + cx - this.idealX;\n            const offDiffY = newOffY - oldOffY + cy - this.idealY;\n            event.bounds[0] += offDiffX;\n            event.bounds[1] += offDiffX;\n            event.bounds[2] += offDiffY;\n            event.bounds[3] += offDiffY;\n\n            return this;\n        }\n\n        // If this is a wheel event and nobody captured the event, try\n        // scrolling. If scrolling did indeed occur, then capture the event.\n        if(capturer === null && event instanceof PointerWheel && this.handleWheelEvent(event))\n            return this;\n\n        return capturer;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Reserve space for scrollbars if needed\n        const thickness = this.scrollBarThickness;\n        const reserve = this._scrollbarMode === ScrollbarMode.Layout;\n\n        this.reservedX = reserve && this.heightCoupling !== AxisCoupling.Bi ? thickness : 0;\n        this.reservedY = reserve && this.widthCoupling !== AxisCoupling.Bi ? thickness : 0;\n\n        // Resolve dimensions\n        super.handleResolveDimensions(minWidth, maxWidth, minHeight, maxHeight);\n\n        // Save dimensions to effective dimensions\n        this.effectiveWidth = this.idealWidth;\n        this.effectiveHeight = this.idealHeight;\n\n        // Expand dimensions to fit scrollbars\n        this.idealWidth = Math.min(Math.max(this.idealWidth + this.reservedX, minWidth), maxWidth);\n        this.idealHeight = Math.min(Math.max(this.idealHeight + this.reservedY, minHeight), maxHeight);\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        super.handlePostLayoutUpdate();\n\n        // Keep scroll in bounds\n        const offset = this.offset;\n        this.clampOffset(offset);\n        this.offset = offset;\n    }\n\n    protected override handlePainting(forced: boolean): void {\n        // Check which scrollbars need painting and update forceRePaint flag\n        const [childWidth, childHeight] = this.child.idealDimensions;\n        const xNeeded = childWidth > this.effectiveWidth;\n        const yNeeded = childHeight > this.effectiveHeight;\n        const paintX = this.scrollbarNeedsPaint(false, xNeeded);\n        const paintY = this.scrollbarNeedsPaint(true, yNeeded);\n\n        if(this.horizWasPainted !== paintX || this.vertWasPainted !== paintY) {\n            this.horizWasPainted = paintX;\n            this.vertWasPainted = paintY;\n            this.forceRePaint = true;\n        }\n        else if(this.scrollbarMode === ScrollbarMode.Overlay) {\n            // XXX overlay mode always needs the child widget to be repainted\n            // because the scrollbar could be semi-transparent. if the scrollbar\n            // is semi-transparent and the child is painted, then the scrollbar\n            // will also be painted, but it will be overpainted, resulting in\n            // accumulation of alpha, getting rid of the transparency over time\n            this.forceRePaint = true;\n        }\n\n        // Paint viewport\n        super.handlePainting(forced);\n\n        // Paint scrollbars\n        const forceCorner = this._scrollbarMode === ScrollbarMode.Layout &&\n                            (this.widthCoupling !== AxisCoupling.Bi\n                                && this.heightCoupling !== AxisCoupling.Bi);\n\n        if(paintX)\n            this.paintScrollbar(false, xNeeded, yNeeded || forceCorner);\n        if(paintY)\n            this.paintScrollbar(true, yNeeded, xNeeded || forceCorner);\n\n        // Paint corner if it is forced\n        if(forceCorner) {\n            const thickness = this.scrollBarThickness;\n            const ctx = this.viewport.context;\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(\n                this.x + this.width - thickness,\n                this.y + this.height - thickness,\n                thickness,\n                thickness,\n            );\n        }\n    }\n\n    /**\n     * Get the rectangles (filled and background) of a scrollbar\n     *\n     * @returns Returns a 2-tuple with 2 4-tuples. The first one is the scrollbar fill rectangle and the second one is the background fill rectangle. Each rectangle 4-tuple contains, respectively, horizontal offset, vertical offset, width and height\n     */\n    private getScrollbarRects(vertical: boolean, corner: boolean): [Bounds, Bounds] {\n        // Calculate basic scrollbar properties\n        const overlay = this._scrollbarMode === ScrollbarMode.Overlay;\n        const axisIndex = vertical ? 1 : 0;\n        const percent = this.scroll[axisIndex];\n        const childLength = this.child.idealDimensions[axisIndex];\n        const viewportLength = vertical ? this.effectiveHeight : this.effectiveWidth;\n        const thickness = Math.min(this.scrollBarThickness, this.width / 2, this.height / 2);\n        const minPercent = this.scrollBarMinPercent;\n        const minPixels = this.scrollBarMinPixels;\n\n        let viewportLengthCorner = viewportLength;\n        if(overlay)\n            viewportLengthCorner -= (corner ? thickness : 0);\n\n        const length = Math.min(\n            // Make sure scrollbar fill isn't bigger than viewport\n            Math.max(\n                // Make sure that scrollbar respects the minimum pixel length\n                minPixels,\n                Math.max(\n                    // Make sure that scrollbar respects the minimum percent\n                    viewportLength / childLength,\n                    minPercent,\n                ) * viewportLengthCorner,\n            ),\n            viewportLength,\n        );\n\n        const offset = (viewportLengthCorner - length) * percent;\n\n        // Find rectangle where filled part of scrollbar will be painted\n        let sX, sY, sWidth, sHeight;\n        if(vertical) {\n            sX = this.idealX + this.idealWidth - thickness;\n            sY = this.idealY + offset;\n            sWidth = thickness;\n            sHeight = length;\n        }\n        else {\n            sX = this.idealX + offset;\n            sY = this.idealY + this.idealHeight - thickness;\n            sWidth = length;\n            sHeight = thickness;\n        }\n\n        // Find rectangle where background of scrollbar will be painted\n        let bgX, bgY, bgWidth, bgHeight;\n        if(vertical) {\n            bgX = sX;\n            bgY = this.idealY;\n            bgWidth = thickness;\n            bgHeight = viewportLengthCorner;\n        }\n        else {\n            bgX = this.idealX;\n            bgY = sY;\n            bgWidth = viewportLengthCorner;\n            bgHeight = thickness;\n        }\n\n        return [\n            [sX, sY, sWidth, sHeight],\n            [bgX, bgY, bgWidth, bgHeight],\n        ];\n    }\n\n    /** Check if a scrollbar needs to be painted */\n    private scrollbarNeedsPaint(vertical: boolean, needed: boolean): boolean {\n        if(this._scrollbarMode === ScrollbarMode.Hidden)\n            return false;\n\n        if(!needed && this._scrollbarMode === ScrollbarMode.Overlay)\n            return false;\n\n        if(vertical)\n            return this.heightCoupling !== AxisCoupling.Bi;\n        else\n            return this.widthCoupling !== AxisCoupling.Bi;\n    }\n\n    /** Paint a scrollbar. For internal use only */\n    private paintScrollbar(vertical: boolean, needed: boolean, corner: boolean): void {\n        // Get rectangles\n        const [fillRect, bgRect] = this.getScrollbarRects(vertical, corner);\n\n        // Paint background if not in overlay mode\n        const ctx = this.viewport.context;\n        if(this._scrollbarMode !== ScrollbarMode.Overlay) {\n            ctx.fillStyle = this.backgroundFill;\n            ctx.fillRect(...bgRect);\n        }\n\n        // Paint filled part of scrollbar\n        if(needed) {\n            const clickHelper = this.getClickHelper(vertical);\n            switch(clickHelper.clickState) {\n                case ClickState.Released:\n                    ctx.fillStyle = this.primaryFill;\n                    break;\n                case ClickState.Hover:\n                case ClickState.Hold:\n                    ctx.fillStyle = this.accentFill;\n                    break;\n            }\n        }\n        else\n            ctx.fillStyle = this.backgroundGlowFill;\n\n        ctx.fillRect(...fillRect);\n    }\n}", "import { PointerPress } from '../events/PointerPress';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { paintField } from '../decorators/FlagFields';\nimport { ClickHelper } from '../helpers/ClickHelper';\nimport { Widget, WidgetProperties } from './Widget';\nimport { ClickState } from '../helpers/ClickState';\nimport type { Viewport } from '../core/Viewport';\nimport type { Bounds } from '../helpers/Bounds';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport { KeyEvent } from '../events/KeyEvent';\nimport type { Event } from '../events/Event';\nimport { Variable } from '../state/Variable';\nimport type { Root } from '../core/Root';\nimport { DynMsg } from '../core/Strings';\nimport { Leave } from '../events/Leave';\n\n/**\n * Optional Slider constructor properties.\n *\n * @category Widget\n */\nexport interface SliderProperties extends WidgetProperties {\n    /** Sets {@link Slider#snapIncrement}. */\n    snapIncrement?: number,\n    /** Sets {@link Slider#vertical}. */\n    vertical?: boolean\n}\n\n/**\n * A slider flexbox widget; can slide a numeric value from an inclusive minimum\n * value to an inclusive maximum value, with optional snapping along set\n * increments.\n *\n * Note that sliders can only be horizontal.\n *\n * @category Widget\n */\nexport class Slider extends Widget {\n    /** The slider's minimum value. */\n    private minValue: number;\n    /** The slider's maximum value. */\n    private maxValue: number;\n    /**\n     * The increments in which the slider changes value. If 0, there are no\n     * fixed increments.\n     */\n    private snapIncrement: number;\n    /** The helper for handling pointer clicks/drags */\n    protected clickHelper: ClickHelper;\n    /** Is this a vertical slider? */\n    protected readonly vertical: boolean;\n    /** The horizontal offset of the slider */\n    private offsetX = 0;\n    /** The vertical offset of the slider */\n    private offsetY = 0;\n    /** The actual width of the slider */\n    private actualWidth = 0;\n    /** The actual height of the slider */\n    private actualHeight = 0;\n    /** Is the keyboard focusing this widget? */\n    @paintField\n    private keyboardFocused = false;\n    /** The helper for keeping track of the slider value */\n    readonly variable: Variable<number>;\n    /** The callback used for the {@link Slider#\"variable\"} */\n    private readonly callback: () => void;\n    /**\n     * The rectangle of the slider when the dragging started. Used to prevent\n     * glitchy behaviour when the slider is being used while the layout is\n     * changing. For internal use only.\n     */\n    private dragBounds: Bounds = [0, 0, 0, 0];\n\n    /** Create a new Slider */\n    constructor(variable: Variable<number> = new Variable(0), minValue = 0, maxValue = 1, properties?: Readonly<SliderProperties>) {\n        // Sliders need a clear background, have no children and don't propagate\n        // events\n        super(true, false, properties);\n\n        if(maxValue < minValue)\n            throw new Error(DynMsg.SWAPPED_MIN_MAX(minValue, maxValue));\n        if(!isFinite(minValue) || isNaN(minValue))\n            throw new Error(DynMsg.INVALID_MIN(minValue));\n        if(!isFinite(maxValue) || isNaN(maxValue))\n            throw new Error(DynMsg.INVALID_MAX(maxValue));\n\n        const snapIncrement = properties?.snapIncrement ?? 0;\n        if(!isFinite(snapIncrement) || isNaN(snapIncrement))\n            throw new Error(DynMsg.INVALID_INC(maxValue));\n        if(snapIncrement < 0)\n            throw new Error(DynMsg.NEGATIVE_INC(maxValue));\n\n        this.clickHelper = new ClickHelper(this);\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n        this.snapIncrement = snapIncrement;\n        this.vertical = properties?.vertical ?? false;\n        this.tabFocusable = true;\n        this.variable = variable;\n        this.callback = this.handleChange.bind(this);\n    }\n\n    protected handleChange(): void {\n        this._dirty = true;\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n        this.variable.watch(this.callback);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n        this.variable.unwatch(this.callback);\n    }\n\n    /** The slider's value */\n    set value(value: number) {\n        this.setValue(value);\n    }\n\n    get value(): number {\n        return this.variable.value;\n    }\n\n    /** Clamp a value to this slider's min and max values */\n    protected clamp(value: number): number {\n        if(value < this.minValue)\n            value = this.minValue;\n        else if(value > this.maxValue)\n            value = this.maxValue;\n\n        return value;\n    }\n\n    /** Set the slider's value, optionally disabling callback */\n    setValue(value: number, doCallback = true): void {\n        // Snap to increments if needed\n        if(this.snapIncrement > 0)\n            value = Math.round(value / this.snapIncrement) * this.snapIncrement;\n\n        // Update value in variable\n        this.variable.setValue(this.clamp(value), doCallback);\n    }\n\n    protected stepValue(add: boolean, incMul: number): void {\n        // Get snap increment. If the increment is not set, default to 1% of the\n        // value range\n        let effectiveIncrement = this.snapIncrement;\n        if(effectiveIncrement === 0)\n            effectiveIncrement = 0.01 * (this.maxValue - this.minValue);\n\n        // Multiply increment (for holding shift)\n        effectiveIncrement *= incMul;\n\n        // Step value in increment\n        const delta = add ? 1 : -1;\n        this.value = this.clamp((Math.round(this.value / effectiveIncrement) + delta) * effectiveIncrement);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'sliderThickness' ||\n                property === 'sliderMinLength')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'accentFill' ||\n                property === 'primaryFill' ||\n                property === 'backgroundFill')\n            this._dirty = true;\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        if(focusType === FocusType.Keyboard)\n            this.keyboardFocused = true;\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        if(focusType === FocusType.Keyboard)\n            this.keyboardFocused = false;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        // Ignore unhandled events\n        if(event instanceof PointerWheel || !(event instanceof PointerEvent || event instanceof KeyEvent || event instanceof Leave))\n            return null;\n\n        // Ignore tab key presses so tab selection works, and escape so widget\n        // unfocusing works\n        if(event instanceof KeyPress && (event.key === 'Tab' || event.key === 'Escape'))\n            return null;\n\n        // Handle key presses\n        if(event instanceof KeyEvent) {\n            if(event instanceof KeyPress) {\n                const incMul = event.shift ? 10 : 1;\n                if(event.key === 'ArrowLeft' || event.key === 'ArrowDown')\n                    this.stepValue(false, incMul);\n                else if(event.key === 'ArrowRight' || event.key === 'ArrowUp')\n                    this.stepValue(true, incMul);\n            }\n\n            return this;\n        }\n\n        // Save slider bounds so that the slider doesn't glitch out if dragged\n        // while the layout changes. To handle hovering properly, also update if\n        // moving pointer, but drag hasn't been initiated\n        if(event instanceof PointerPress || this.clickHelper.clickState !== ClickState.Hold) {\n            const x = this.idealX + this.offsetX;\n            const y = this.idealY + this.offsetY;\n            this.dragBounds = [ x, x + this.actualWidth, y, y + this.actualHeight ];\n        }\n\n        // Handle click event\n        this.clickHelper.handleClickEvent(event, this.root, this.dragBounds);\n\n        // If this was a click or the slider is currently being held, update\n        // value\n        if(((this.clickHelper.clickStateChanged && this.clickHelper.wasClick) || this.clickHelper.clickState === ClickState.Hold)\n            && this.clickHelper.pointerPos !== null) {\n            // Interpolate value\n            const percent = this.clickHelper.pointerPos[0];\n            this.value = this.minValue + percent * (this.maxValue - this.minValue);\n        }\n\n        // Always flag as dirty if the click state changed (so glow colour takes\n        // effect)\n        if(this.clickHelper.clickStateChanged)\n            this._dirty = true;\n\n        return this;\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Get theme properties\n        const thickness = this.sliderThickness;\n        const minLength = this.sliderMinLength;\n\n        // Fully expand along main axis if constrained and center along cross\n        // axis\n        if(this.vertical) {\n            // Main axis\n            if(maxHeight != Infinity)\n                this.idealHeight = maxHeight;\n            else\n                this.idealHeight = Math.max(minLength, minHeight);\n\n            // Cross axis\n            this.idealWidth = Math.min(Math.max(thickness, minWidth), maxWidth);\n\n        }\n        else {\n            // Main axis\n            if(maxWidth != Infinity)\n                this.idealWidth = maxWidth;\n            else\n                this.idealWidth = Math.max(minLength, minWidth);\n\n            // Cross axis\n            this.idealHeight = Math.min(Math.max(thickness, minHeight), maxHeight);\n        }\n    }\n\n    override finalizeBounds() {\n        super.finalizeBounds();\n\n        // cache centered position and dimensions\n        if(this.vertical) {\n            this.actualWidth = Math.min(this.width, this.sliderThickness);\n            this.actualHeight = this.height;\n            this.offsetX = (this.width - this.actualWidth) / 2;\n            this.offsetY = 0;\n        }\n        else {\n            this.actualWidth = this.width;\n            this.actualHeight = Math.min(this.height, this.sliderThickness);\n            this.offsetX = 0;\n            this.offsetY = (this.height - this.actualHeight) / 2;\n        }\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Correct position with offset\n        const x = this.x + this.offsetX;\n        const y = this.y + this.offsetY;\n\n        // Draw filled part of slider. Use accent colour if hovering or holding\n        const ctx = this.viewport.context;\n        const useGlow = this.keyboardFocused || this.clickHelper.clickState === ClickState.Hover || this.clickHelper.clickState === ClickState.Hold;\n        if(useGlow)\n            ctx.fillStyle = this.accentFill;\n        else\n            ctx.fillStyle = this.primaryFill;\n        const fullWidth = this.actualWidth * (this.value - this.minValue) / (this.maxValue - this.minValue);\n        ctx.fillRect(x, y, fullWidth, this.actualHeight);\n\n        // Draw empty part of slider\n        if(useGlow)\n            ctx.fillStyle = this.backgroundGlowFill;\n        else\n            ctx.fillStyle = this.backgroundFill;\n        const emptyWidth = this.actualWidth - fullWidth;\n        ctx.fillRect(x + fullWidth, y, emptyWidth, this.actualHeight);\n    }\n}\n", "import { layoutField, multiFlagField, paintArrayField } from '../decorators/FlagFields';\nimport { ValidatedVariable } from '../state/ValidatedVariable';\nimport { PointerRelease } from '../events/PointerRelease';\nimport { TextPasteEvent } from '../events/TextPasteEvent';\nimport { PointerEvent } from '../events/PointerEvent';\nimport { PointerPress } from '../events/PointerPress';\nimport { PointerWheel } from '../events/PointerWheel';\nimport { Widget, WidgetProperties } from './Widget';\nimport { PointerMove } from '../events/PointerMove';\nimport { TextHelper } from '../helpers/TextHelper';\nimport { AutoScroll } from '../events/AutoScroll';\nimport type { Viewport } from '../core/Viewport';\nimport { TabSelect } from '../events/TabSelect';\nimport type { Bounds } from '../helpers/Bounds';\nimport { KeyPress } from '../events/KeyPress';\nimport { FocusType } from '../core/FocusType';\nimport type { Event } from '../events/Event';\nimport type { Rect } from '../helpers/Rect';\nimport type { Root } from '../core/Root';\nimport { Leave } from '../events/Leave';\n\n/**\n * Optional TextInput constructor properties.\n *\n * @category Widget\n */\nexport interface TextInputProperties extends WidgetProperties {\n    /** Sets {@link TextInput#hideText}. */\n    hideText?: boolean,\n    /** Sets {@link TextInput#wrapText}. */\n    wrapText?: boolean,\n    /** Sets {@link TextInput#inputFilter}. */\n    inputFilter?: ((input: string) => boolean) | null,\n    /** Sets {@link TextInput#typeableTab}. */\n    typeableTab?: boolean,\n    /** Sets {@link TextInput#editingEnabled}. */\n    editingEnabled?: boolean\n}\n\n/**\n * A flexbox widget that allows for a single line of text input.\n *\n * Supports obscuring the text with {@link TextInput#hideText}, which shows all\n * characters as black circles like in password fields, text validation and\n * toggling editing.\n *\n * If a {@link TextInputHandler} is set, then that will be used instead of\n * keyboard input for mobile compatibility.\n *\n * @category Widget\n */\nexport class TextInput extends Widget {\n    /**\n     * At what timestamp did the blinking start. If 0, then the text cursor is\n     * not blinking.\n     */\n    private blinkStart = 0;\n    /**\n     * Was the cursor shown last frame due to blinking? If null, then the text\n     * cursor is not blinking.\n     */\n    private blinkWasOn: boolean | null = null;\n    /** Current cursor position (index, not offset). */\n    private cursorPos = 0;\n    /** Current cursor offset in pixels. */\n    private cursorOffset: [number, number] = [0, 0];\n    /** Current cursor selection start position (index, not offset). */\n    private selectPos = 0;\n    /** Current cursor selection start offset in pixels. */\n    private selectOffset: [number, number] = [0, 0];\n    /** Does the cursor offset need to be updated? */\n    private cursorOffsetDirty = false;\n    /** Is editing enabled? */\n    private _editingEnabled: boolean;\n    /**\n     * Is the text hidden?\n     *\n     * @decorator `@multiFlagField(['cursorOffsetDirty', '_dirty'])`\n     */\n    @multiFlagField(['cursorOffsetDirty', '_dirty'])\n    hideText: boolean;\n    /** The helper for measuring/painting text */\n    protected textHelper: TextHelper;\n    /**\n     * Current offset of the text in the text box. Used on overflow.\n     *\n     * @decorator `@paintArrayField()`\n     */\n    @paintArrayField()\n    private offset = [0, 0];\n    /**\n     * Is text wrapping enabled? If not, text will be panned if needed\n     *\n     * @decorator `@layoutField`\n     */\n    @layoutField\n    wrapText: boolean;\n    /**\n     * An input filter; a function which dictates whether a certain input can be\n     * inserted in the text. If the function returns false given the input,\n     * then the input will not be inserted in the text. Useful for preventing\n     * newlines or forcing numeric input. Note that the input is not\n     * neccessarily a character; it can be a whole sentence.\n     */\n    inputFilter: ((input: string) => boolean) | null;\n    /** Is the pointer dragging? */\n    private dragging = false;\n    /** When was the last pointer click? For detecting double/triple-clicks */\n    private lastClick = 0;\n    /**\n     * The cursor position when dragging was started. Used for\n     * double/triple-click dragging.\n     */\n    private dragStart = -1;\n    /**\n     * How many clicks have there been after a first click where the time\n     * between each click is less than 500 ms. Used for detecting double/triple\n     * clicks\n     */\n    private successiveClickCount: 0 | 1 | 2 = 0;\n    /**\n     * Can tab characters be typed in this input widget? If true, then pressing\n     * tab will not move the focus to the next widget, unless tab is a filtered\n     * character.\n     *\n     * If tab is not a filtered character and this is true, holding shift will\n     * move to the next widget instead of typing the character, not move to the\n     * previous focusable widget.\n     */\n    typeableTab: boolean;\n    /**\n     * Should the caret position be {@link AutoScroll | auto-scrolled} after the\n     * layout is finalized?\n     */\n    private needsAutoScroll = false;\n    /** The helper for keeping track of the checkbox value */\n    readonly variable: ValidatedVariable<string, unknown>;\n    /** The callback used for the {@link TextInput#\"variable\"} */\n    private readonly callback: () => void;\n\n    /** Create a new TextInput. */\n    constructor(variable: ValidatedVariable<string, unknown> = new ValidatedVariable(''), properties?: Readonly<TextInputProperties>) {\n        // TextInputs clear their own background, have no children and don't\n        // propagate events\n        super(false, false, properties);\n\n        this.tabFocusable = true;\n        this.textHelper = new TextHelper();\n        this.variable = variable;\n        this.callback = this.handleChange.bind(this);\n\n        this.hideText = properties?.hideText ?? false;\n        this.wrapText = properties?.wrapText ?? true;\n        this.inputFilter = properties?.inputFilter ?? null;\n        this.typeableTab = properties?.typeableTab ?? false;\n        this._editingEnabled = properties?.editingEnabled ?? true;\n    }\n\n    protected handleChange(): void {\n        this._dirty = true;\n    }\n\n    override activate(root: Root, viewport: Viewport, parent: Widget | null): void {\n        super.activate(root, viewport, parent);\n        this.variable.watch(this.callback);\n    }\n\n    override deactivate(): void {\n        super.deactivate();\n        this.variable.unwatch(this.callback);\n    }\n\n    protected override onThemeUpdated(property: string | null = null): void {\n        super.onThemeUpdated(property);\n\n        if(property === null) {\n            this._layoutDirty = true;\n            this._dirty = true;\n            this.cursorOffsetDirty = true;\n        }\n        else if(property === 'inputTextInnerPadding' ||\n                property === 'inputTextFont' ||\n                property === 'inputTextHeight' ||\n                property === 'inputTextSpacing')\n        {\n            this._layoutDirty = true;\n            this._dirty = true;\n        }\n        else if(property === 'inputBackgroundFill' ||\n                property === 'inputTextFill' ||\n                property === 'inputTextFillInvalid' ||\n                property === 'inputTextFillDisabled' ||\n                property === 'cursorThickness')\n        {\n            this._dirty = true;\n        }\n        else if(property === 'inputTextAlign')\n            this.cursorOffsetDirty = true;\n    }\n\n    /**\n     * Is the text cursor shown?\n     *\n     * @returns Returns true if the text cursor is shown, false if not shown but the text input is in use, or null if the text cursor is not shown due to the text input not being in use.\n     */\n    get blinkOn(): boolean | null {\n        if(this.blinkStart === 0)\n            return null;\n\n        const blinkRate = this.blinkRate;\n        return Math.trunc(((Date.now() - this.blinkStart) / (500 * blinkRate)) % 2) === 0;\n    }\n\n    /**\n     * Is editing enabled?\n     *\n     * Tied to {@link TextInput#_editingEnabled}. If changed,\n     * {@link Widget#_dirty} is set to true. If disabled, blinking stops and the\n     * cursor position is reset to the beginning.\n     */\n    get editingEnabled(): boolean {\n        return this._editingEnabled;\n    }\n\n    set editingEnabled(editingEnabled: boolean) {\n        if(this._editingEnabled !== editingEnabled) {\n            this._editingEnabled = editingEnabled;\n\n            // Disable blinking and reset cursor position if disabled\n            if(!editingEnabled) {\n                this.blinkStart = 0;\n                this.moveCursorTo(0, false);\n            }\n\n            // Mark as dirty; the text color changes\n            this._dirty = true;\n        }\n    }\n\n    /**\n     * The current text value.\n     *\n     * Should not be used internally as a setter (but using it as a getter is\n     * fine); if you are extending TextInput, use this.variable.value instead.\n     */\n    set text(text: string) {\n        this.variable.value = text;\n\n        // clamp cursor positions if the new text has a smaller length\n        // than the old text\n        const textLength = this.variable.value.length;\n        if(this.cursorPos > textLength) {\n            this.cursorPos = textLength;\n            this.cursorOffsetDirty = true;\n        }\n        if(this.selectPos > textLength) {\n            this.selectPos = textLength;\n            this.cursorOffsetDirty = true;\n        }\n    }\n\n    get text(): string {\n        return this.variable.value;\n    }\n\n    /**\n     * Get the text as it is shown. If the text is hidden, all characters are\n     * replaced with a black circle.\n     */\n    get displayedText(): string {\n        if(this.hideText)\n            return '\u25CF'.repeat(this.variable.value.length);\n        else\n            return this.variable.value;\n    }\n\n    /** The current line number, starting from 0. */\n    get line(): number {\n        return this.textHelper.getLine(this.cursorPos);\n    }\n\n    /** Auto-scroll to the caret if the {@link blinkStart | caret is shown}. */\n    private autoScrollCaret(): void {\n        // Auto-scroll if caret is shown\n        if(this.blinkStart !== 0)\n            this.needsAutoScroll = true;\n    }\n\n    /**\n     * Move the cursor to a given index.\n     *\n     * Sets {@link Widget#_dirty} and {@link TextInput#cursorOffsetDirty} to\n     * true.\n     *\n     * @param select - Should this do text selection?\n     */\n    moveCursorTo(index: number, select: boolean): void {\n        // Update cursor position, checking for boundaries\n        this.cursorPos = Math.min(Math.max(index, 0), this.text.length);\n\n        if(!select)\n            this.selectPos = this.cursorPos;\n\n        // Update cursor offset\n        this.cursorOffsetDirty = true;\n        this._dirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Move the cursor by a given index delta. Calls\n     * {@link TextInput#moveCursorTo}\n     *\n     * @param delta - The change in index; if a positive number, the cursor will be moved right by that amount, else, the cursor will be moved left by that amount.\n     */\n    moveCursor(delta: number, select: boolean): void {\n        this.moveCursorTo(this.cursorPos + delta, select);\n    }\n\n    /**\n     * Move the cursor given a given pointer offset.\n     *\n     * @param offsetX - The horizontal offset in pixels, relative to the text area with padding removed\n     * @param offsetY - The vertical offset in pixels, relative to the text area with padding removed\n     * @param select - Should this do text selection?\n     */\n    moveCursorFromOffset(offsetX: number, offsetY: number, select: boolean): void {\n        [this.cursorPos, this.cursorOffset] = this.textHelper.findIndexOffsetFromOffset(\n            [ offsetX, offsetY ],\n        );\n\n        if(!select) {\n            this.selectPos = this.cursorPos;\n            this.selectOffset = this.cursorOffset;\n        }\n\n        // Start blinking cursor and mark component as dirty, to\n        // make sure that cursor blink always resets for better\n        // feedback\n        this.blinkStart = Date.now();\n        this._dirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Move the cursor by a given line delta. Calls\n     * {@link TextInput#moveCursorFromOffset}\n     *\n     * @param delta - The change in line; if a positive number, the cursor will be moved down by that amount, else, the cursor will be moved up by that amount.\n     */\n    moveCursorLine(delta: number, select: boolean): void {\n        this.moveCursorFromOffset(\n            this.cursorOffset[0],\n            this.cursorOffset[1] + (0.5 + delta) * this.textHelper.fullLineHeight,\n            select,\n        );\n    }\n\n    /**\n     * Move the cursor to the start of the line. Calls\n     * {@link TextInput#moveCursorTo}\n     */\n    moveCursorStart(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineStart(this.line), select);\n    }\n\n    /**\n     * Move the cursor to the end of the line. Calls\n     * {@link TextInput#moveCursorTo}\n     */\n    moveCursorEnd(select: boolean): void {\n        this.moveCursorTo(this.textHelper.getLineEnd(this.line, false), select);\n    }\n\n    /**\n     * Move the cursor by skipping over a number of words. Calls\n     * {@link TextInput#moveCursorTo}\n     *\n     * @param delta - The change in words; if a positive number, the cursor skip this amount of words, else, it will do the same, but backwards.\n     */\n    moveCursorWord(delta: number, select: boolean): void {\n        if(delta == 0)\n            return;\n\n        const wordRegex = /\\w/;\n        const text = this.text;\n        let targetPos = this.cursorPos;\n\n        if(delta > 0) {\n            while(delta > 0) {\n                let insideWord = false;\n                for(; targetPos <= text.length; targetPos++) {\n                    if(targetPos < text.length && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                delta--;\n            }\n        }\n        else {\n            while(delta < 0) {\n                targetPos--;\n                let insideWord = false;\n                for(; targetPos >= 0; targetPos--) {\n                    if(targetPos >= 0 && wordRegex.test(text[targetPos]))\n                        insideWord = true;\n                    else if(insideWord)\n                        break;\n                }\n\n                targetPos++;\n                delta++;\n            }\n        }\n\n        this.moveCursorTo(targetPos, select);\n    }\n\n    /**\n     * Deletes a range of text and moves the cursor to the start of the range.\n     *\n     * @param start - The inclusive index of the start of the text range\n     * @param end - The exclusive index of the end of the text range\n     */\n    deleteRange(start: number, end: number): void {\n        if(start === end)\n            return;\n\n        // Delete text\n        this.variable.value = this.text.substring(0, start) + this.text.substring(end);\n\n        // Update cursor position\n        this.cursorPos = this.selectPos = start;\n        this.cursorOffsetDirty = true;\n        this.autoScrollCaret();\n    }\n\n    /**\n     * Like {@link TextInput#moveCursorWord}, but for deleting words. Calls\n     * {@link TextInput#moveCursorWord} and {@link TextInput#deleteRange}. If\n     * text is being selected, delta is ignored and the selection is deleted\n     * instead. Note that a delta of zero doesn't delete anything.\n     */\n    deleteWord(delta: number): void {\n        if(delta === 0)\n            return;\n\n        // Delete selection\n        if(this.cursorPos !== this.selectPos) {\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n            return;\n        }\n\n        // Move cursor by wanted words\n        const oldPos = this.cursorPos;\n        this.moveCursorWord(delta, false);\n\n        // If cursor position is different, delete\n        if(oldPos !== this.cursorPos) {\n            this.deleteRange(\n                Math.min(oldPos, this.cursorPos),\n                Math.max(oldPos, this.cursorPos),\n            );\n        }\n    }\n\n    /**\n     * Insert text at the current cursor index. Calls\n     * {@link TextInput#moveCursorTo} afterwards.\n     */\n    insertText(str: string): void {\n        // Abort if input can't be inserted\n        if(this.inputFilter !== null && !this.inputFilter(str))\n            return;\n\n        if(this.selectPos === this.cursorPos) {\n            // Insert string in current cursor position\n            this.variable.value = this.text.substring(0, this.cursorPos) + str + this.text.substring(this.cursorPos);\n            // Move cursor neccessary amount forward\n            this.moveCursor(str.length, false);\n        }\n        else {\n            const start = Math.min(this.cursorPos, this.selectPos);\n            const end = Math.max(this.cursorPos, this.selectPos);\n\n            // Replace text in selection with the one being inserted\n            this.variable.value = this.text.substring(0, start) + str + this.text.substring(end);\n            // Move cursor to end of selection after insert\n            this.moveCursorTo(start + str.length, false);\n        }\n    }\n\n    /**\n     * Deletes a certain amount of characters in a given direction from the\n     * current cursor index. Calls {@link TextInput#deleteRange} or\n     * {@link TextInput#moveCursorTo} if neccessary. If text is being selected,\n     * delta is ignored and the selection is deleted instead. Note that a delta\n     * of zero doesn't delete anything.\n     *\n     * @param delta - The amount and direction of the deletion. For example, if 5, then 5 characters are deleted after the cursor. If -5, then 5 characters are deleted before the cursor and the cursor is moved 5 indices left.\n     */\n    deleteText(delta: number): void {\n        if(delta === 0)\n            return;\n\n        if(this.cursorPos !== this.selectPos) {\n            // Delete selection\n            this.deleteRange(\n                Math.min(this.cursorPos, this.selectPos),\n                Math.max(this.cursorPos, this.selectPos),\n            );\n        }\n        else if(delta > 0) {\n            // Delete forwards\n            this.variable.value = this.text.substring(0, this.cursorPos) + this.text.substring(this.cursorPos + delta);\n            // XXX normally, deleting forwards doens't require updating the\n            // cursor offset, but when there is text wrapping, delete can change\n            // the cursor offset (pressing delete on a long word in the next\n            // line, causing text wrapping to move the cursor to the previous\n            // line). because of this edge case, mark the cursor offset as dirty\n            this.cursorOffsetDirty = true;\n            this.autoScrollCaret();\n        }\n        else {\n            // Delete backwards\n            // NOTE, still checking if delta < 0 so that nothing is done if\n            // delta is 0\n            this.variable.value = this.text.substring(0, this.cursorPos + delta) + this.text.substring(this.cursorPos);\n            this.moveCursor(delta, false);\n        }\n    }\n\n    /**\n     * Select a range of text (either word or non-word, but not both) which\n     * includes the given cursor position\n     *\n     * @returns Returns a 2-tuple with, respectively, the start and end of the range\n     */\n    private selectRangeAt(pos: number): [number, number] {\n        const text = this.text;\n        const wordRegex = /\\w/;\n        const isWord = wordRegex.test(text[pos]);\n        const midPos = pos;\n\n        // Grow left\n        for(; pos >= 0; pos--) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        const startPos = pos + 1;\n\n        // Grow right\n        pos = midPos;\n        for(; pos < text.length; pos++) {\n            if(wordRegex.test(text[pos]) !== isWord)\n                break;\n        }\n\n        this.autoScrollCaret();\n\n        return [startPos, pos];\n    }\n\n    override onFocusGrabbed(focusType: FocusType): void {\n        // If keyboard focus is gained and the caret isn't shown yet, select the\n        // last character and start blinking the caret\n        if(focusType === FocusType.Keyboard && this.blinkStart === 0) {\n            this.blinkStart = Date.now();\n            this.selectPos = this.variable.value.length;\n            this.cursorPos = this.selectPos;\n            this.cursorOffsetDirty = true;\n            this.autoScrollCaret();\n        }\n    }\n\n    override onFocusDropped(focusType: FocusType): void {\n        // Stop blinking cursor if keyboard focus lost and stop dragging if\n        // pointer focus is lost\n        if(focusType === FocusType.Keyboard)\n            this.blinkStart = 0;\n    }\n\n    protected override handleEvent(event: Event): this | null {\n        // If editing is disabled, abort\n        if(!this._editingEnabled)\n            return null;\n\n        const root = this.root;\n\n        if(event instanceof Leave) {\n            // Stop dragging if the pointer leaves the text input, since it\n            // won't receive pointer release events outside the widget\n            this.dragging = false;\n            this.lastClick = 0;\n            return this;\n        }\n        else if(event instanceof PointerWheel) {\n            // Don't capture wheel events\n            return null;\n        }\n        else if(event instanceof PointerEvent) {\n            // If this is a pointer event, set pointer style and handle clicks\n            root.pointerStyle = 'text';\n\n            // Request keyboard focus if this is a pointer press with the\n            // primary button\n            if(event instanceof PointerPress || event instanceof PointerMove) {\n                const isPress = event instanceof PointerPress && event.isPrimary;\n                if(isPress) {\n                    this.dragging = true;\n                    const clickTime = (new Date()).getTime();\n\n                    // Count successive clicks. Clicks counts as successive if\n                    // they come after the last click in less than 500 ms\n                    if(clickTime - this.lastClick < 500) {\n                        this.successiveClickCount++;\n                        // Wrap click counter around (there's no action above\n                        // triple click)\n                        if(this.successiveClickCount > 2)\n                            this.successiveClickCount = 0;\n                    }\n                    else\n                        this.successiveClickCount = 0;\n\n                    this.lastClick = clickTime;\n                }\n                else if(!this.dragging)\n                    return this;\n\n                // Update cursor position (and offset) from click position\n                const padding = this.inputTextInnerPadding;\n                this.moveCursorFromOffset(\n                    event.x - this.idealX - padding + this.offset[0],\n                    event.y - this.idealY - padding + this.offset[1],\n                    (!isPress && this.dragging) || (isPress && event.shift),\n                );\n\n                if(isPress) {\n                    // Prevent successive clicks from one cursor position to\n                    // another from counting as successive clicks\n                    if(this.cursorPos !== this.dragStart)\n                        this.successiveClickCount = 0;\n\n                    this.dragStart = this.cursorPos;\n                }\n\n                if(this.successiveClickCount > 0) {\n                    let start, end;\n\n                    if(this.successiveClickCount === 1) {\n                        // If double-click dragging, select ranges of text\n                        // Get the text range at the cursor and at the start of the\n                        // double click drag, then mush them together into a single\n                        // range\n                        const [doubleStart, doubleEnd] = this.selectRangeAt(this.dragStart);\n                        const [curStart, curEnd] = this.selectRangeAt(this.cursorPos);\n                        start = Math.min(doubleStart, curStart);\n                        end = Math.max(doubleEnd, curEnd);\n                    }\n                    else {\n                        // If triple-click dragging, select lines of text\n                        const startPos = Math.min(this.cursorPos, this.dragStart);\n                        const startLine = this.textHelper.getLine(startPos);\n                        start = this.textHelper.getLineStart(startLine);\n\n                        const endPos = Math.max(this.cursorPos, this.dragStart);\n                        const endLine = this.textHelper.getLine(endPos);\n                        // Include newlines so that deleting a triple-click\n                        // selection deletes entire lines\n                        end = this.textHelper.getLineEnd(endLine);\n                    }\n\n                    // Set cursor positions. Get the drag direction and swap\n                    // cursor and select pos depending on the direction\n                    if(this.cursorPos >= this.dragStart) {\n                        this.selectPos = start;\n                        this.cursorPos = end;\n                    }\n                    else {\n                        this.selectPos = end;\n                        this.cursorPos = start;\n                    }\n\n                    this.cursorOffsetDirty = true;\n                }\n\n                // Request focus\n                root.requestFocus(FocusType.Keyboard, this);\n            }\n            else if(event instanceof PointerRelease && event.isPrimary) {\n                // Stop dragging\n                this.dragging = false;\n\n                // Get mobile-friendly text input if available\n                if(root.hasMobileTextInput) {\n                    root.getTextInput(this.text).then((newValue: string | null) => {\n                        if(newValue === null || (this.inputFilter !== null && !this.inputFilter(newValue)))\n                            return;\n\n                        if(this.text !== newValue) {\n                            this.text = newValue;\n                            this.moveCursorTo(newValue.length, false);\n                        }\n                    });\n                }\n            }\n\n            return this;\n        }\n        else if(event instanceof KeyPress) {\n            // Stop dragging\n            this.dragging = false;\n            this.lastClick = 0;\n\n            // Ignore all key presses with alt modifier\n            if(event.alt)\n                return this;\n\n            // Ignore most key presses if control is pressed\n            if(event.ctrl) {\n                if(event.key === 'Backspace')\n                    this.deleteWord(-1); // Delete word backwards\n                else if(event.key === 'Delete')\n                    this.deleteWord(1); // Delete word forwards\n                else if(event.key === 'ArrowLeft')\n                    this.moveCursorWord(-1, event.shift); // Back-skip a word\n                else if(event.key === 'ArrowRight')\n                    this.moveCursorWord(1, event.shift); // Skip a word\n                else if(event.key === 'c' || event.key === 'C') {\n                    // Copy selected text to clipboard, if any\n                    if(this.cursorPos === this.selectPos)\n                        return this;\n\n                    const selectedText = this.text.slice(\n                        Math.min(this.cursorPos, this.selectPos),\n                        Math.max(this.cursorPos, this.selectPos),\n                    );\n\n                    if(navigator.clipboard)\n                        navigator.clipboard.writeText(selectedText);\n                    else\n                        return this;\n                }\n                else if(event.key === 'a' || event.key === 'A') {\n                    this.cursorPos = this.text.length;\n                    this.selectPos = 0;\n                    this.cursorOffsetDirty = true;\n                    this._dirty = true;\n                }\n                else\n                    return this;\n\n                // Reset blink time for better feedback\n                this.blinkStart = Date.now();\n                return this;\n            }\n\n            // Regular key presses:\n            if(event.key.length === 1)\n                this.insertText(event.key); // Insert character\n            else if(event.key === 'Backspace')\n                this.deleteText(-1); // Delete backwards\n            else if(event.key === 'Delete')\n                this.deleteText(1); // Delete forwards\n            else if(event.key === 'ArrowLeft')\n                this.moveCursor(-1, event.shift); // Move cursor left\n            else if(event.key === 'ArrowRight')\n                this.moveCursor(1, event.shift); // Move cursor right\n            else if(event.key === 'ArrowUp')\n                this.moveCursorLine(-1, event.shift); // Move cursor up\n            else if(event.key === 'ArrowDown')\n                this.moveCursorLine(1, event.shift); // Move cursor down\n            else if(event.key === 'PageUp' || event.key === 'PageDown') {\n                // Move cursor up or down by the lines in the viewport height,\n                // or a minimum of 3 lines\n                const mul = event.key === 'PageUp' ? -1 : 1;\n                const [_vpX, _vpY, _vpW, vpH] = this.viewport.rect;\n                const lines = Math.max(Math.floor(vpH / this.textHelper.fullLineHeight), 3);\n                this.moveCursorLine(lines * mul, event.shift);\n            }\n            else if(event.key === 'Home')\n                this.moveCursorStart(event.shift); // Move cursor to beginning\n            else if(event.key === 'End')\n                this.moveCursorEnd(event.shift); // Move cursor to end\n            else if(event.key === 'Escape') {\n                // Return now so that blink time isn't reset.\n                // Don't capture so that focus is dropped\n                return null;\n            }\n            else if(event.key === 'Enter')\n                this.insertText('\\n');\n            else if(event.key === 'Tab') {\n                if(this.typeableTab) {\n                    // HACK if shift if being held, do a tab-selection but don't\n                    // do reverse order. not capturing the event makes its do it\n                    // in normal order, so manually do tab-selection and capture\n                    // the event\n                    if(event.shift) {\n                        root.dispatchEvent(new TabSelect(this, false));\n                        return this;\n                    }\n                    else\n                        this.insertText('\\t');\n                }\n                else\n                    return null; // don't capture, let tab select another widget\n            }\n            else\n                return this; // Ignore key if it is unknown\n\n            // Reset blink time for better feedback\n            this.blinkStart = Date.now();\n        }\n        else if(event instanceof TextPasteEvent) {\n            if(event.target === this) {\n                // Insert pasted text\n                this.insertText(event.text);\n\n                // Reset blink time for better feedback\n                this.blinkStart = Date.now();\n            }\n        }\n        else if(event.target !== this) {\n            // unhandled event type. don't capture\n            return null;\n        }\n\n        return this;\n    }\n\n    protected override handlePreLayoutUpdate(): void {\n        // Drop focus if editing is disabled\n        if(!this.editingEnabled)\n            this.root.dropFocus(FocusType.Keyboard, this);\n\n        // Mark as dirty when a blink needs to occur\n        if(this.blinkOn !== this.blinkWasOn)\n            this._dirty = true;\n\n        // Update TextHelper variables\n        this.textHelper.text = this.displayedText;\n        this.textHelper.font = this.inputTextFont;\n        this.textHelper.lineHeight = this.inputTextHeight;\n        this.textHelper.lineSpacing = this.inputTextSpacing;\n        this.textHelper.alignMode = this.inputTextAlign;\n\n        // Mark as dirty if text helper is dirty\n        if(this.textHelper.dirty) {\n            this._dirty = true;\n            this._layoutDirty = true;\n        }\n    }\n\n    protected override handlePostLayoutUpdate(): void {\n        // Update cursor offset. Needs to be updated post-layout because it is\n        // dependent on maxWidth. Round to nearest integer to avoid\n        // anti-aliasing artifacts (cursor loses sharpness despite being fully\n        // vertical)\n        if(this.cursorOffsetDirty) {\n            this.cursorOffset = this.textHelper.findOffsetFromIndex(this.cursorPos);\n\n            if(this.selectPos === this.cursorPos) {\n                this.selectOffset[0] = this.cursorOffset[0];\n                this.selectOffset[1] = this.cursorOffset[1];\n            }\n            else\n                this.selectOffset = this.textHelper.findOffsetFromIndex(this.selectPos);\n\n            this.cursorOffsetDirty = false;\n        }\n\n        // Check if panning is needed\n        const padding = this.inputTextInnerPadding;\n        const innerWidth = this.textHelper.width;\n        const innerHeight = this.textHelper.height;\n        const usableWidth = this.idealWidth - padding * 2;\n        const usableHeight = this.idealHeight - padding * 2;\n        const candidateOffset = this.offset;\n        const [cursorX, cursorY] = this.cursorOffset;\n\n        if(innerWidth > usableWidth) {\n            // Horizontal panning needed\n            const deadZone = Math.min(20, usableWidth / 2);\n            const left = candidateOffset[0] + deadZone;\n            const right = candidateOffset[0] + usableWidth - deadZone;\n\n            // Pan right\n            if(cursorX > right)\n                candidateOffset[0] += cursorX - right;\n\n            // Pan left\n            if(cursorX < left)\n                candidateOffset[0] -= left - cursorX;\n\n            // Clamp\n            if(candidateOffset[0] + usableWidth > innerWidth)\n                candidateOffset[0] = innerWidth - usableWidth;\n            if(candidateOffset[0] < 0)\n                candidateOffset[0] = 0;\n        }\n        else {\n            // Horizontal panning not needed\n            candidateOffset[0] = 0;\n        }\n\n        if(innerHeight > usableHeight) {\n            // Vertical panning needed\n            const fullLineHeight = this.textHelper.fullLineHeight;\n\n            if(fullLineHeight >= usableHeight) {\n                // Edge case - TextInput is not tall enough for a single line.\n                // Pan so that at least the bottom of the line is visible\n                candidateOffset[1] = cursorY + Math.max(this.textHelper.actualLineHeight - usableHeight, 0);\n            }\n            else {\n                const deadZone = usableHeight < 2 * fullLineHeight ? 0 : fullLineHeight / 2;\n                const top = candidateOffset[1] + deadZone;\n                const bottom = candidateOffset[1] + usableHeight - deadZone - fullLineHeight;\n\n                // Pan up or down\n                if(cursorY < top)\n                    candidateOffset[1] -= top - cursorY;\n                if(cursorY > bottom)\n                    candidateOffset[1] += cursorY - bottom;\n\n                // Clamp\n                if(candidateOffset[1] + usableHeight > innerHeight)\n                    candidateOffset[1] = innerHeight - usableHeight;\n                if(candidateOffset[1] < 0)\n                    candidateOffset[1] = 0;\n            }\n        }\n        else {\n            // Vertical panning not needed\n            candidateOffset[1] = 0;\n        }\n\n        this.offset = candidateOffset;\n\n        if(this.needsAutoScroll) {\n            this.needsAutoScroll = false;\n            this.root.dispatchEvent(new AutoScroll(this, this.caretBounds));\n        }\n    }\n\n    protected override handleResolveDimensions(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): void {\n        // Only expand to the needed dimensions, but take minimum width from\n        // theme into account\n        const padding = 2 * this.inputTextInnerPadding;\n        this.textHelper.maxWidth = this.wrapText ? Math.max(maxWidth - padding, 0) : Infinity;\n        if(this.textHelper.dirty)\n            this._dirty = true;\n\n        const effectiveMinWidth = Math.min(Math.max(this.inputTextMinWidth, minWidth), maxWidth);\n        this.idealWidth = Math.min(Math.max(effectiveMinWidth, this.textHelper.width + padding), maxWidth);\n        this.idealHeight = Math.min(Math.max(minHeight, this.textHelper.height + padding), maxHeight);\n    }\n\n    /**\n     * The rectangle that the caret occupies, relative to the TextInput's\n     * top-left corner.\n     */\n    protected get caretRect(): Rect {\n        const padding = this.inputTextInnerPadding;\n        return [\n            padding + this.cursorOffset[0] - this.offset[0],\n            padding + this.cursorOffset[1] - this.offset[1],\n            this.cursorThickness,\n            this.textHelper.fullLineHeight,\n        ];\n    }\n\n    /** Similar to {@link TextInput#caretRect}, but uses absolute positions. */\n    protected get caretAbsoluteRect(): Rect {\n        const [x, y, w, h] = this.caretRect;\n        return [x + this.idealX, y + this.idealY, w, h];\n    }\n\n    /** Similar to {@link TextInput#caretRect}, but gets bounds instead. */\n    protected get caretBounds(): Bounds {\n        const [x, y, w, h] = this.caretRect;\n        return [x, x + w, y, y + h];\n    }\n\n    protected override handlePainting(_forced: boolean): void {\n        // Paint background\n        const ctx = this.viewport.context;\n        ctx.fillStyle = this.inputBackgroundFill;\n        ctx.fillRect(this.x, this.y, this.width, this.height);\n\n        // Start clipping\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(this.x, this.y, this.width, this.height);\n        ctx.clip();\n\n        // Paint background for selection if there is a selection\n        const padding = this.inputTextInnerPadding;\n        if(this.cursorPos !== this.selectPos) {\n            ctx.fillStyle = this.inputSelectBackgroundFill;\n            if(this.cursorOffset[1] === this.selectOffset[1]) {\n                // Same line\n                const left = Math.min(this.cursorOffset[0], this.selectOffset[0]);\n                const right = Math.max(this.cursorOffset[0], this.selectOffset[0]);\n                ctx.fillRect(\n                    this.idealX + padding + left - this.offset[0],\n                    this.idealY + padding + this.cursorOffset[1] - this.offset[1],\n                    right - left,\n                    this.textHelper.fullLineHeight,\n                );\n            }\n            else {\n                // Spans multiple lines\n                let topOffset: [number, number], bottomOffset: [number, number];\n                if(this.cursorOffset[1] < this.selectOffset[1]) {\n                    topOffset = this.cursorOffset;\n                    bottomOffset = this.selectOffset;\n                }\n                else {\n                    bottomOffset = this.cursorOffset;\n                    topOffset = this.selectOffset;\n                }\n\n                // Top line:\n                const fullLineHeight = this.textHelper.fullLineHeight;\n                const topWidth = this.idealWidth + this.offset[0] - topOffset[0] - padding;\n                if(topWidth > 0) {\n                    ctx.fillRect(\n                        this.idealX + padding + topOffset[0] - this.offset[0],\n                        this.idealY + padding + topOffset[1] - this.offset[1],\n                        topWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Bottom line:\n                const bottomWidth = bottomOffset[0] + padding - this.offset[0];\n                if(bottomWidth > 0) {\n                    ctx.fillRect(\n                        this.idealX,\n                        this.idealY + padding + bottomOffset[1] - this.offset[1],\n                        bottomWidth,\n                        fullLineHeight,\n                    );\n                }\n\n                // Middle lines:\n                const middleYOffset = topOffset[1] + fullLineHeight;\n                const middleHeight = bottomOffset[1] - middleYOffset;\n                if(middleHeight > 0) {\n                    ctx.fillRect(\n                        this.idealX,\n                        this.idealY + padding + middleYOffset - this.offset[1],\n                        this.idealWidth,\n                        middleHeight,\n                    );\n                }\n            }\n        }\n\n        // Paint current text value\n        let fillStyle;\n        if(this._editingEnabled) {\n            if(this.variable.valid)\n                fillStyle = this.inputTextFill;\n            else\n                fillStyle = this.inputTextFillInvalid;\n        }\n        else\n            fillStyle = this.inputTextFillDisabled;\n\n        this.textHelper.paint(\n            ctx, fillStyle,\n            this.idealX + padding - this.offset[0],\n            this.idealY + padding - this.offset[1],\n        );\n\n        // Paint blink\n        const blinkOn = this.blinkOn;\n        this.blinkWasOn = blinkOn;\n        if(blinkOn) {\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(...this.caretAbsoluteRect);\n        }\n\n        // Stop clipping\n        ctx.restore();\n    }\n}\n", "import { ScrollableViewportWidget, ScrollableViewportWidgetProperties, ScrollbarMode } from \"./ScrollableViewportWidget\";\nimport type { ValidatedVariable } from \"../state/ValidatedVariable\";\nimport { TextInput, TextInputProperties } from \"./TextInput\";\nimport { AxisCoupling } from \"../widgets/AxisCoupling\";\n\n/**\n * A {@link ScrollableViewportWidget} with a {@link TextInput}. Meant to be used\n * as an analogue to the HTML textarea. Allows tab typing by default.\n *\n * Using uni-directional coupling with\n * {@link ScrollbarMode.Hidden | hidden scrollbars} (the default) is\n * recommended. However, if the scrollbars need to be visible, then\n * {@link ScrollbarMode.Layout | layout scrollbars} are recommended since\n * {@link ScrollbarMode.Overlay | overlay scrollbars} will hide text near the\n * borders.\n *\n * @category Widget\n * @category Aggregate Widget\n */\nexport class TextArea extends ScrollableViewportWidget<TextInput> {\n    constructor(variable: ValidatedVariable<string, unknown>, properties?: Readonly<ScrollableViewportWidgetProperties & TextInputProperties>) {\n        // default properties\n        properties = {\n            widthCoupling: AxisCoupling.Uni,\n            heightCoupling: AxisCoupling.Uni,\n            scrollbarMode: ScrollbarMode.Hidden,\n            typeableTab: true,\n            ...properties\n        };\n\n        super(new TextInput(variable, properties), properties)\n    }\n\n    /**\n     * Get the {@link TextInput} of this TextArea. Equivalent to\n     * {@link TextArea#child}.\n     */\n    get textInput() {\n        return this.child;\n    }\n}", "import type { Widget, WidgetProperties } from './Widget';\nimport type { Alignment2D } from '../theme/Alignment2D';\nimport { Alignment } from '../theme/Alignment';\nimport { Container } from './Container';\n\n/**\n * A {@link Margin} which stretches on the vertical axis. Useful for\n * horizontally centering labels without making them look weird if they are in\n * a row.\n *\n * Can be constrained to a specific type of children.\n *\n * @category Widget\n * @category Alias Widget\n */\nexport class TextMargin<W extends Widget = Widget> extends Container<W> {\n    /** Create a new TextMargin. */\n    constructor(child: W, properties?: Readonly<WidgetProperties>) {\n        // default properties\n        properties = {\n            containerAlignment: <Alignment2D>{\n                horizontal: Alignment.Center, vertical: Alignment.Stretch,\n            },\n            ...properties\n        };\n\n        super(child, properties);\n    }\n}\n", "import { PassthroughWidget } from './PassthroughWidget';\nimport type { Theme } from '../theme/Theme';\nimport type { Widget } from './Widget';\n\n/**\n * A {@link PassthroughWidget} which changes the theme of its child and\n * completely ignores inherited themes.\n *\n * Can be constrained to a specific type of children.\n *\n * Since the new theme replaces the inherited theme, children of the child will\n * also inherit this theme since inherited themes are propagated down the widget\n * tree.\n *\n * @category Widget\n */\nexport class ThemeScope<W extends Widget = Widget> extends PassthroughWidget<W> {\n    /** The theme used for the child. */\n    private scopeTheme: Theme;\n\n    /** Create a new ThemeScope. */\n    constructor(child: W, themeOverride: Theme) {\n        super(child);\n        this.scopeTheme = themeOverride;\n    }\n\n    override set inheritedTheme(_theme: Theme | undefined) {\n        super.inheritedTheme = this.scopeTheme;\n    }\n\n    override get inheritedTheme(): Theme | undefined {\n        return this.scopeTheme;\n    }\n}"],
  "mappings": "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",
  "names": []
}
